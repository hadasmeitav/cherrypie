/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 320);
/******/ })
/************************************************************************/
/******/ ({

/***/ 0:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (true) {
  module.exports = __webpack_require__(178);
} else {}


/***/ }),

/***/ 1:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ../node_modules/react/index.js
var react = __webpack_require__(0);

// CONCATENATED MODULE: ../node_modules/@emotion/sheet/dist/sheet.browser.esm.js
/*

Based off glamor's StyleSheet, thanks Sunil ❤️

high performance StyleSheet for css-in-js systems

- uses multiple style tags behind the scenes for millions of rules
- uses `insertRule` for appending in production for *much* faster performance

// usage

import { StyleSheet } from '@emotion/sheet'

let styleSheet = new StyleSheet({ key: '', container: document.head })

styleSheet.insert('#box { border: 1px solid red; }')
- appends a css rule into the stylesheet

styleSheet.flush()
- empties the stylesheet of all its contents

*/
// $FlowFixMe
function sheetForTag(tag) {
  if (tag.sheet) {
    // $FlowFixMe
    return tag.sheet;
  } // this weirdness brought to you by firefox

  /* istanbul ignore next */


  for (var i = 0; i < document.styleSheets.length; i++) {
    if (document.styleSheets[i].ownerNode === tag) {
      // $FlowFixMe
      return document.styleSheets[i];
    }
  }
}

function createStyleElement(options) {
  var tag = document.createElement('style');
  tag.setAttribute('data-emotion', options.key);

  if (options.nonce !== undefined) {
    tag.setAttribute('nonce', options.nonce);
  }

  tag.appendChild(document.createTextNode(''));
  return tag;
}

var StyleSheet =
/*#__PURE__*/
function () {
  function StyleSheet(options) {
    this.isSpeedy = options.speedy === undefined ? "production" === 'production' : options.speedy;
    this.tags = [];
    this.ctr = 0;
    this.nonce = options.nonce; // key is the value of the data-emotion attribute, it's used to identify different sheets

    this.key = options.key;
    this.container = options.container;
    this.before = null;
  }

  var _proto = StyleSheet.prototype;

  _proto.insert = function insert(rule) {
    // the max length is how many rules we have per style tag, it's 65000 in speedy mode
    // it's 1 in dev because we insert source maps that map a single rule to a location
    // and you can only have one source map per style tag
    if (this.ctr % (this.isSpeedy ? 65000 : 1) === 0) {
      var _tag = createStyleElement(this);

      var before;

      if (this.tags.length === 0) {
        before = this.before;
      } else {
        before = this.tags[this.tags.length - 1].nextSibling;
      }

      this.container.insertBefore(_tag, before);
      this.tags.push(_tag);
    }

    var tag = this.tags[this.tags.length - 1];

    if (this.isSpeedy) {
      var sheet = sheetForTag(tag);

      try {
        // this is a really hot path
        // we check the second character first because having "i"
        // as the second character will happen less often than
        // having "@" as the first character
        var isImportRule = rule.charCodeAt(1) === 105 && rule.charCodeAt(0) === 64; // this is the ultrafast version, works across browsers
        // the big drawback is that the css won't be editable in devtools

        sheet.insertRule(rule, // we need to insert @import rules before anything else
        // otherwise there will be an error
        // technically this means that the @import rules will
        // _usually_(not always since there could be multiple style tags)
        // be the first ones in prod and generally later in dev
        // this shouldn't really matter in the real world though
        // @import is generally only used for font faces from google fonts and etc.
        // so while this could be technically correct then it would be slower and larger
        // for a tiny bit of correctness that won't matter in the real world
        isImportRule ? 0 : sheet.cssRules.length);
      } catch (e) {
        if (false) {}
      }
    } else {
      tag.appendChild(document.createTextNode(rule));
    }

    this.ctr++;
  };

  _proto.flush = function flush() {
    // $FlowFixMe
    this.tags.forEach(function (tag) {
      return tag.parentNode.removeChild(tag);
    });
    this.tags = [];
    this.ctr = 0;
  };

  return StyleSheet;
}();



// CONCATENATED MODULE: ../node_modules/@emotion/stylis/dist/stylis.browser.esm.js
function stylis_min (W) {
  function M(d, c, e, h, a) {
    for (var m = 0, b = 0, v = 0, n = 0, q, g, x = 0, K = 0, k, u = k = q = 0, l = 0, r = 0, I = 0, t = 0, B = e.length, J = B - 1, y, f = '', p = '', F = '', G = '', C; l < B;) {
      g = e.charCodeAt(l);
      l === J && 0 !== b + n + v + m && (0 !== b && (g = 47 === b ? 10 : 47), n = v = m = 0, B++, J++);

      if (0 === b + n + v + m) {
        if (l === J && (0 < r && (f = f.replace(N, '')), 0 < f.trim().length)) {
          switch (g) {
            case 32:
            case 9:
            case 59:
            case 13:
            case 10:
              break;

            default:
              f += e.charAt(l);
          }

          g = 59;
        }

        switch (g) {
          case 123:
            f = f.trim();
            q = f.charCodeAt(0);
            k = 1;

            for (t = ++l; l < B;) {
              switch (g = e.charCodeAt(l)) {
                case 123:
                  k++;
                  break;

                case 125:
                  k--;
                  break;

                case 47:
                  switch (g = e.charCodeAt(l + 1)) {
                    case 42:
                    case 47:
                      a: {
                        for (u = l + 1; u < J; ++u) {
                          switch (e.charCodeAt(u)) {
                            case 47:
                              if (42 === g && 42 === e.charCodeAt(u - 1) && l + 2 !== u) {
                                l = u + 1;
                                break a;
                              }

                              break;

                            case 10:
                              if (47 === g) {
                                l = u + 1;
                                break a;
                              }

                          }
                        }

                        l = u;
                      }

                  }

                  break;

                case 91:
                  g++;

                case 40:
                  g++;

                case 34:
                case 39:
                  for (; l++ < J && e.charCodeAt(l) !== g;) {
                  }

              }

              if (0 === k) break;
              l++;
            }

            k = e.substring(t, l);
            0 === q && (q = (f = f.replace(ca, '').trim()).charCodeAt(0));

            switch (q) {
              case 64:
                0 < r && (f = f.replace(N, ''));
                g = f.charCodeAt(1);

                switch (g) {
                  case 100:
                  case 109:
                  case 115:
                  case 45:
                    r = c;
                    break;

                  default:
                    r = O;
                }

                k = M(c, r, k, g, a + 1);
                t = k.length;
                0 < A && (r = X(O, f, I), C = H(3, k, r, c, D, z, t, g, a, h), f = r.join(''), void 0 !== C && 0 === (t = (k = C.trim()).length) && (g = 0, k = ''));
                if (0 < t) switch (g) {
                  case 115:
                    f = f.replace(da, ea);

                  case 100:
                  case 109:
                  case 45:
                    k = f + '{' + k + '}';
                    break;

                  case 107:
                    f = f.replace(fa, '$1 $2');
                    k = f + '{' + k + '}';
                    k = 1 === w || 2 === w && L('@' + k, 3) ? '@-webkit-' + k + '@' + k : '@' + k;
                    break;

                  default:
                    k = f + k, 112 === h && (k = (p += k, ''));
                } else k = '';
                break;

              default:
                k = M(c, X(c, f, I), k, h, a + 1);
            }

            F += k;
            k = I = r = u = q = 0;
            f = '';
            g = e.charCodeAt(++l);
            break;

          case 125:
          case 59:
            f = (0 < r ? f.replace(N, '') : f).trim();
            if (1 < (t = f.length)) switch (0 === u && (q = f.charCodeAt(0), 45 === q || 96 < q && 123 > q) && (t = (f = f.replace(' ', ':')).length), 0 < A && void 0 !== (C = H(1, f, c, d, D, z, p.length, h, a, h)) && 0 === (t = (f = C.trim()).length) && (f = '\x00\x00'), q = f.charCodeAt(0), g = f.charCodeAt(1), q) {
              case 0:
                break;

              case 64:
                if (105 === g || 99 === g) {
                  G += f + e.charAt(l);
                  break;
                }

              default:
                58 !== f.charCodeAt(t - 1) && (p += P(f, q, g, f.charCodeAt(2)));
            }
            I = r = u = q = 0;
            f = '';
            g = e.charCodeAt(++l);
        }
      }

      switch (g) {
        case 13:
        case 10:
          47 === b ? b = 0 : 0 === 1 + q && 107 !== h && 0 < f.length && (r = 1, f += '\x00');
          0 < A * Y && H(0, f, c, d, D, z, p.length, h, a, h);
          z = 1;
          D++;
          break;

        case 59:
        case 125:
          if (0 === b + n + v + m) {
            z++;
            break;
          }

        default:
          z++;
          y = e.charAt(l);

          switch (g) {
            case 9:
            case 32:
              if (0 === n + m + b) switch (x) {
                case 44:
                case 58:
                case 9:
                case 32:
                  y = '';
                  break;

                default:
                  32 !== g && (y = ' ');
              }
              break;

            case 0:
              y = '\\0';
              break;

            case 12:
              y = '\\f';
              break;

            case 11:
              y = '\\v';
              break;

            case 38:
              0 === n + b + m && (r = I = 1, y = '\f' + y);
              break;

            case 108:
              if (0 === n + b + m + E && 0 < u) switch (l - u) {
                case 2:
                  112 === x && 58 === e.charCodeAt(l - 3) && (E = x);

                case 8:
                  111 === K && (E = K);
              }
              break;

            case 58:
              0 === n + b + m && (u = l);
              break;

            case 44:
              0 === b + v + n + m && (r = 1, y += '\r');
              break;

            case 34:
            case 39:
              0 === b && (n = n === g ? 0 : 0 === n ? g : n);
              break;

            case 91:
              0 === n + b + v && m++;
              break;

            case 93:
              0 === n + b + v && m--;
              break;

            case 41:
              0 === n + b + m && v--;
              break;

            case 40:
              if (0 === n + b + m) {
                if (0 === q) switch (2 * x + 3 * K) {
                  case 533:
                    break;

                  default:
                    q = 1;
                }
                v++;
              }

              break;

            case 64:
              0 === b + v + n + m + u + k && (k = 1);
              break;

            case 42:
            case 47:
              if (!(0 < n + m + v)) switch (b) {
                case 0:
                  switch (2 * g + 3 * e.charCodeAt(l + 1)) {
                    case 235:
                      b = 47;
                      break;

                    case 220:
                      t = l, b = 42;
                  }

                  break;

                case 42:
                  47 === g && 42 === x && t + 2 !== l && (33 === e.charCodeAt(t + 2) && (p += e.substring(t, l + 1)), y = '', b = 0);
              }
          }

          0 === b && (f += y);
      }

      K = x;
      x = g;
      l++;
    }

    t = p.length;

    if (0 < t) {
      r = c;
      if (0 < A && (C = H(2, p, r, d, D, z, t, h, a, h), void 0 !== C && 0 === (p = C).length)) return G + p + F;
      p = r.join(',') + '{' + p + '}';

      if (0 !== w * E) {
        2 !== w || L(p, 2) || (E = 0);

        switch (E) {
          case 111:
            p = p.replace(ha, ':-moz-$1') + p;
            break;

          case 112:
            p = p.replace(Q, '::-webkit-input-$1') + p.replace(Q, '::-moz-$1') + p.replace(Q, ':-ms-input-$1') + p;
        }

        E = 0;
      }
    }

    return G + p + F;
  }

  function X(d, c, e) {
    var h = c.trim().split(ia);
    c = h;
    var a = h.length,
        m = d.length;

    switch (m) {
      case 0:
      case 1:
        var b = 0;

        for (d = 0 === m ? '' : d[0] + ' '; b < a; ++b) {
          c[b] = Z(d, c[b], e, m).trim();
        }

        break;

      default:
        var v = b = 0;

        for (c = []; b < a; ++b) {
          for (var n = 0; n < m; ++n) {
            c[v++] = Z(d[n] + ' ', h[b], e, m).trim();
          }
        }

    }

    return c;
  }

  function Z(d, c, e) {
    var h = c.charCodeAt(0);
    33 > h && (h = (c = c.trim()).charCodeAt(0));

    switch (h) {
      case 38:
        return c.replace(F, '$1' + d.trim());

      case 58:
        return d.trim() + c.replace(F, '$1' + d.trim());

      default:
        if (0 < 1 * e && 0 < c.indexOf('\f')) return c.replace(F, (58 === d.charCodeAt(0) ? '' : '$1') + d.trim());
    }

    return d + c;
  }

  function P(d, c, e, h) {
    var a = d + ';',
        m = 2 * c + 3 * e + 4 * h;

    if (944 === m) {
      d = a.indexOf(':', 9) + 1;
      var b = a.substring(d, a.length - 1).trim();
      b = a.substring(0, d).trim() + b + ';';
      return 1 === w || 2 === w && L(b, 1) ? '-webkit-' + b + b : b;
    }

    if (0 === w || 2 === w && !L(a, 1)) return a;

    switch (m) {
      case 1015:
        return 97 === a.charCodeAt(10) ? '-webkit-' + a + a : a;

      case 951:
        return 116 === a.charCodeAt(3) ? '-webkit-' + a + a : a;

      case 963:
        return 110 === a.charCodeAt(5) ? '-webkit-' + a + a : a;

      case 1009:
        if (100 !== a.charCodeAt(4)) break;

      case 969:
      case 942:
        return '-webkit-' + a + a;

      case 978:
        return '-webkit-' + a + '-moz-' + a + a;

      case 1019:
      case 983:
        return '-webkit-' + a + '-moz-' + a + '-ms-' + a + a;

      case 883:
        if (45 === a.charCodeAt(8)) return '-webkit-' + a + a;
        if (0 < a.indexOf('image-set(', 11)) return a.replace(ja, '$1-webkit-$2') + a;
        break;

      case 932:
        if (45 === a.charCodeAt(4)) switch (a.charCodeAt(5)) {
          case 103:
            return '-webkit-box-' + a.replace('-grow', '') + '-webkit-' + a + '-ms-' + a.replace('grow', 'positive') + a;

          case 115:
            return '-webkit-' + a + '-ms-' + a.replace('shrink', 'negative') + a;

          case 98:
            return '-webkit-' + a + '-ms-' + a.replace('basis', 'preferred-size') + a;
        }
        return '-webkit-' + a + '-ms-' + a + a;

      case 964:
        return '-webkit-' + a + '-ms-flex-' + a + a;

      case 1023:
        if (99 !== a.charCodeAt(8)) break;
        b = a.substring(a.indexOf(':', 15)).replace('flex-', '').replace('space-between', 'justify');
        return '-webkit-box-pack' + b + '-webkit-' + a + '-ms-flex-pack' + b + a;

      case 1005:
        return ka.test(a) ? a.replace(aa, ':-webkit-') + a.replace(aa, ':-moz-') + a : a;

      case 1e3:
        b = a.substring(13).trim();
        c = b.indexOf('-') + 1;

        switch (b.charCodeAt(0) + b.charCodeAt(c)) {
          case 226:
            b = a.replace(G, 'tb');
            break;

          case 232:
            b = a.replace(G, 'tb-rl');
            break;

          case 220:
            b = a.replace(G, 'lr');
            break;

          default:
            return a;
        }

        return '-webkit-' + a + '-ms-' + b + a;

      case 1017:
        if (-1 === a.indexOf('sticky', 9)) break;

      case 975:
        c = (a = d).length - 10;
        b = (33 === a.charCodeAt(c) ? a.substring(0, c) : a).substring(d.indexOf(':', 7) + 1).trim();

        switch (m = b.charCodeAt(0) + (b.charCodeAt(7) | 0)) {
          case 203:
            if (111 > b.charCodeAt(8)) break;

          case 115:
            a = a.replace(b, '-webkit-' + b) + ';' + a;
            break;

          case 207:
          case 102:
            a = a.replace(b, '-webkit-' + (102 < m ? 'inline-' : '') + 'box') + ';' + a.replace(b, '-webkit-' + b) + ';' + a.replace(b, '-ms-' + b + 'box') + ';' + a;
        }

        return a + ';';

      case 938:
        if (45 === a.charCodeAt(5)) switch (a.charCodeAt(6)) {
          case 105:
            return b = a.replace('-items', ''), '-webkit-' + a + '-webkit-box-' + b + '-ms-flex-' + b + a;

          case 115:
            return '-webkit-' + a + '-ms-flex-item-' + a.replace(ba, '') + a;

          default:
            return '-webkit-' + a + '-ms-flex-line-pack' + a.replace('align-content', '').replace(ba, '') + a;
        }
        break;

      case 973:
      case 989:
        if (45 !== a.charCodeAt(3) || 122 === a.charCodeAt(4)) break;

      case 931:
      case 953:
        if (!0 === la.test(d)) return 115 === (b = d.substring(d.indexOf(':') + 1)).charCodeAt(0) ? P(d.replace('stretch', 'fill-available'), c, e, h).replace(':fill-available', ':stretch') : a.replace(b, '-webkit-' + b) + a.replace(b, '-moz-' + b.replace('fill-', '')) + a;
        break;

      case 962:
        if (a = '-webkit-' + a + (102 === a.charCodeAt(5) ? '-ms-' + a : '') + a, 211 === e + h && 105 === a.charCodeAt(13) && 0 < a.indexOf('transform', 10)) return a.substring(0, a.indexOf(';', 27) + 1).replace(ma, '$1-webkit-$2') + a;
    }

    return a;
  }

  function L(d, c) {
    var e = d.indexOf(1 === c ? ':' : '{'),
        h = d.substring(0, 3 !== c ? e : 10);
    e = d.substring(e + 1, d.length - 1);
    return R(2 !== c ? h : h.replace(na, '$1'), e, c);
  }

  function ea(d, c) {
    var e = P(c, c.charCodeAt(0), c.charCodeAt(1), c.charCodeAt(2));
    return e !== c + ';' ? e.replace(oa, ' or ($1)').substring(4) : '(' + c + ')';
  }

  function H(d, c, e, h, a, m, b, v, n, q) {
    for (var g = 0, x = c, w; g < A; ++g) {
      switch (w = S[g].call(B, d, x, e, h, a, m, b, v, n, q)) {
        case void 0:
        case !1:
        case !0:
        case null:
          break;

        default:
          x = w;
      }
    }

    if (x !== c) return x;
  }

  function T(d) {
    switch (d) {
      case void 0:
      case null:
        A = S.length = 0;
        break;

      default:
        if ('function' === typeof d) S[A++] = d;else if ('object' === typeof d) for (var c = 0, e = d.length; c < e; ++c) {
          T(d[c]);
        } else Y = !!d | 0;
    }

    return T;
  }

  function U(d) {
    d = d.prefix;
    void 0 !== d && (R = null, d ? 'function' !== typeof d ? w = 1 : (w = 2, R = d) : w = 0);
    return U;
  }

  function B(d, c) {
    var e = d;
    33 > e.charCodeAt(0) && (e = e.trim());
    V = e;
    e = [V];

    if (0 < A) {
      var h = H(-1, c, e, e, D, z, 0, 0, 0, 0);
      void 0 !== h && 'string' === typeof h && (c = h);
    }

    var a = M(O, e, c, 0, 0);
    0 < A && (h = H(-2, a, e, e, D, z, a.length, 0, 0, 0), void 0 !== h && (a = h));
    V = '';
    E = 0;
    z = D = 1;
    return a;
  }

  var ca = /^\0+/g,
      N = /[\0\r\f]/g,
      aa = /: */g,
      ka = /zoo|gra/,
      ma = /([,: ])(transform)/g,
      ia = /,\r+?/g,
      F = /([\t\r\n ])*\f?&/g,
      fa = /@(k\w+)\s*(\S*)\s*/,
      Q = /::(place)/g,
      ha = /:(read-only)/g,
      G = /[svh]\w+-[tblr]{2}/,
      da = /\(\s*(.*)\s*\)/g,
      oa = /([\s\S]*?);/g,
      ba = /-self|flex-/g,
      na = /[^]*?(:[rp][el]a[\w-]+)[^]*/,
      la = /stretch|:\s*\w+\-(?:conte|avail)/,
      ja = /([^-])(image-set\()/,
      z = 1,
      D = 1,
      E = 0,
      w = 1,
      O = [],
      S = [],
      A = 0,
      R = null,
      Y = 0,
      V = '';
  B.use = T;
  B.set = U;
  void 0 !== W && U(W);
  return B;
}

/* harmony default export */ var stylis_browser_esm = (stylis_min);

// CONCATENATED MODULE: ../node_modules/@emotion/weak-memoize/dist/weak-memoize.browser.esm.js
var weakMemoize = function weakMemoize(func) {
  // $FlowFixMe flow doesn't include all non-primitive types as allowed for weakmaps
  var cache = new WeakMap();
  return function (arg) {
    if (cache.has(arg)) {
      // $FlowFixMe
      return cache.get(arg);
    }

    var ret = func(arg);
    cache.set(arg, ret);
    return ret;
  };
};

/* harmony default export */ var weak_memoize_browser_esm = (weakMemoize);

// CONCATENATED MODULE: ../node_modules/@emotion/cache/dist/cache.browser.esm.js




// https://github.com/thysultan/stylis.js/tree/master/plugins/rule-sheet
// inlined to avoid umd wrapper and peerDep warnings/installing stylis
// since we use stylis after closure compiler
var delimiter = '/*|*/';
var needle = delimiter + '}';

function toSheet(block) {
  if (block) {
    Sheet.current.insert(block + '}');
  }
}

var Sheet = {
  current: null
};
var ruleSheet = function ruleSheet(context, content, selectors, parents, line, column, length, ns, depth, at) {
  switch (context) {
    // property
    case 1:
      {
        switch (content.charCodeAt(0)) {
          case 64:
            {
              // @import
              Sheet.current.insert(content + ';');
              return '';
            }
          // charcode for l

          case 108:
            {
              // charcode for b
              // this ignores label
              if (content.charCodeAt(2) === 98) {
                return '';
              }
            }
        }

        break;
      }
    // selector

    case 2:
      {
        if (ns === 0) return content + delimiter;
        break;
      }
    // at-rule

    case 3:
      {
        switch (ns) {
          // @font-face, @page
          case 102:
          case 112:
            {
              Sheet.current.insert(selectors[0] + content);
              return '';
            }

          default:
            {
              return content + (at === 0 ? delimiter : '');
            }
        }
      }

    case -2:
      {
        content.split(needle).forEach(toSheet);
      }
  }
};

var cache_browser_esm_createCache = function createCache(options) {
  if (options === undefined) options = {};
  var key = options.key || 'css';
  var stylisOptions;

  if (options.prefix !== undefined) {
    stylisOptions = {
      prefix: options.prefix
    };
  }

  var stylis = new stylis_browser_esm(stylisOptions);

  if (false) {}

  var inserted = {}; // $FlowFixMe

  var container;

  {
    container = options.container || document.head;
    var nodes = document.querySelectorAll("style[data-emotion-" + key + "]");
    Array.prototype.forEach.call(nodes, function (node) {
      var attrib = node.getAttribute("data-emotion-" + key); // $FlowFixMe

      attrib.split(' ').forEach(function (id) {
        inserted[id] = true;
      });

      if (node.parentNode !== container) {
        container.appendChild(node);
      }
    });
  }

  var _insert;

  {
    stylis.use(options.stylisPlugins)(ruleSheet);

    _insert = function insert(selector, serialized, sheet, shouldCache) {
      var name = serialized.name;
      Sheet.current = sheet;

      if (false) { var map; }

      stylis(selector, serialized.styles);

      if (shouldCache) {
        cache.inserted[name] = true;
      }
    };
  }

  if (false) { var commentEnd, commentStart; }

  var cache = {
    key: key,
    sheet: new StyleSheet({
      key: key,
      container: container,
      nonce: options.nonce,
      speedy: options.speedy
    }),
    nonce: options.nonce,
    inserted: inserted,
    registered: {},
    insert: _insert
  };
  return cache;
};

/* harmony default export */ var cache_browser_esm = (cache_browser_esm_createCache);

// CONCATENATED MODULE: ../node_modules/@emotion/utils/dist/utils.browser.esm.js
var isBrowser = "object" !== 'undefined';
function getRegisteredStyles(registered, registeredStyles, classNames) {
  var rawClassName = '';
  classNames.split(' ').forEach(function (className) {
    if (registered[className] !== undefined) {
      registeredStyles.push(registered[className]);
    } else {
      rawClassName += className + " ";
    }
  });
  return rawClassName;
}
var insertStyles = function insertStyles(cache, serialized, isStringTag) {
  var className = cache.key + "-" + serialized.name;

  if ( // we only need to add the styles to the registered cache if the
  // class name could be used further down
  // the tree but if it's a string tag, we know it won't
  // so we don't have to add it to registered cache.
  // this improves memory usage since we can avoid storing the whole style string
  (isStringTag === false || // we need to always store it if we're in compat mode and
  // in node since emotion-server relies on whether a style is in
  // the registered cache to know whether a style is global or not
  // also, note that this check will be dead code eliminated in the browser
  isBrowser === false && cache.compat !== undefined) && cache.registered[className] === undefined) {
    cache.registered[className] = serialized.styles;
  }

  if (cache.inserted[serialized.name] === undefined) {
    var current = serialized;

    do {
      var maybeStyles = cache.insert("." + className, current, cache.sheet, true);

      current = current.next;
    } while (current !== undefined);
  }
};



// CONCATENATED MODULE: ../node_modules/@emotion/hash/dist/hash.browser.esm.js
/* eslint-disable */
// murmurhash2 via https://github.com/garycourt/murmurhash-js/blob/master/murmurhash2_gc.js
function murmurhash2_32_gc(str) {
  var l = str.length,
      h = l ^ l,
      i = 0,
      k;

  while (l >= 4) {
    k = str.charCodeAt(i) & 0xff | (str.charCodeAt(++i) & 0xff) << 8 | (str.charCodeAt(++i) & 0xff) << 16 | (str.charCodeAt(++i) & 0xff) << 24;
    k = (k & 0xffff) * 0x5bd1e995 + (((k >>> 16) * 0x5bd1e995 & 0xffff) << 16);
    k ^= k >>> 24;
    k = (k & 0xffff) * 0x5bd1e995 + (((k >>> 16) * 0x5bd1e995 & 0xffff) << 16);
    h = (h & 0xffff) * 0x5bd1e995 + (((h >>> 16) * 0x5bd1e995 & 0xffff) << 16) ^ k;
    l -= 4;
    ++i;
  }

  switch (l) {
    case 3:
      h ^= (str.charCodeAt(i + 2) & 0xff) << 16;

    case 2:
      h ^= (str.charCodeAt(i + 1) & 0xff) << 8;

    case 1:
      h ^= str.charCodeAt(i) & 0xff;
      h = (h & 0xffff) * 0x5bd1e995 + (((h >>> 16) * 0x5bd1e995 & 0xffff) << 16);
  }

  h ^= h >>> 13;
  h = (h & 0xffff) * 0x5bd1e995 + (((h >>> 16) * 0x5bd1e995 & 0xffff) << 16);
  h ^= h >>> 15;
  return (h >>> 0).toString(36);
}

/* harmony default export */ var hash_browser_esm = (murmurhash2_32_gc);

// CONCATENATED MODULE: ../node_modules/@emotion/unitless/dist/unitless.browser.esm.js
var unitlessKeys = {
  animationIterationCount: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};

/* harmony default export */ var unitless_browser_esm = (unitlessKeys);

// CONCATENATED MODULE: ../node_modules/@emotion/memoize/dist/memoize.browser.esm.js
function memoize(fn) {
  var cache = {};
  return function (arg) {
    if (cache[arg] === undefined) cache[arg] = fn(arg);
    return cache[arg];
  };
}

/* harmony default export */ var memoize_browser_esm = (memoize);

// CONCATENATED MODULE: ../node_modules/@emotion/serialize/dist/serialize.browser.esm.js




var hyphenateRegex = /[A-Z]|^ms/g;
var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;
var processStyleName = memoize_browser_esm(function (styleName) {
  return styleName.replace(hyphenateRegex, '-$&').toLowerCase();
});

var serialize_browser_esm_processStyleValue = function processStyleValue(key, value) {
  if (value == null || typeof value === 'boolean') {
    return '';
  }

  switch (key) {
    case 'animation':
    case 'animationName':
      {
        if (typeof value === 'string') {
          value = value.replace(animationRegex, function (match, p1, p2) {
            cursor = {
              name: p1,
              styles: p2,
              next: cursor
            };
            return p1;
          });
        }
      }
  }

  if (unitless_browser_esm[key] !== 1 && key.charCodeAt(1) !== 45 && // custom properties
  typeof value === 'number' && value !== 0) {
    return value + 'px';
  }

  return value;
};

if (false) { var hyphenatedCache, hyphenPattern, msPattern, oldProcessStyleValue, contentValues, contentValuePattern; }

var shouldWarnAboutInterpolatingClassNameFromCss = true;

function handleInterpolation(mergedProps, registered, interpolation, couldBeSelectorInterpolation) {
  if (interpolation == null) {
    return '';
  }

  if (interpolation.__emotion_styles !== undefined) {
    if (false) {}

    return interpolation;
  }

  switch (typeof interpolation) {
    case 'boolean':
      {
        return '';
      }

    case 'object':
      {
        if (interpolation.anim === 1) {
          cursor = {
            name: interpolation.name,
            styles: interpolation.styles,
            next: cursor
          };
          return interpolation.name;
        }

        if (interpolation.styles !== undefined) {
          var next = interpolation.next;

          if (next !== undefined) {
            // not the most efficient thing ever but this is a pretty rare case
            // and there will be very few iterations of this generally
            while (next !== undefined) {
              cursor = {
                name: next.name,
                styles: next.styles,
                next: cursor
              };
              next = next.next;
            }
          }

          var styles = interpolation.styles;

          if (false) {}

          return styles;
        }

        return createStringFromObject(mergedProps, registered, interpolation);
      }

    case 'function':
      {
        if (mergedProps !== undefined) {
          var previousCursor = cursor;
          var result = interpolation(mergedProps);
          cursor = previousCursor;
          return handleInterpolation(mergedProps, registered, result, couldBeSelectorInterpolation);
        } else if (false) {}
      }
    // eslint-disable-next-line no-fallthrough

    default:
      {
        if (registered == null) {
          return interpolation;
        }

        var cached = registered[interpolation];

        if (false) {}

        return cached !== undefined && !couldBeSelectorInterpolation ? cached : interpolation;
      }
  }
}

function createStringFromObject(mergedProps, registered, obj) {
  var string = '';

  if (Array.isArray(obj)) {
    for (var i = 0; i < obj.length; i++) {
      string += handleInterpolation(mergedProps, registered, obj[i], false);
    }
  } else {
    for (var _key in obj) {
      var value = obj[_key];

      if (typeof value !== 'object') {
        if (registered != null && registered[value] !== undefined) {
          string += _key + "{" + registered[value] + "}";
        } else {
          string += processStyleName(_key) + ":" + serialize_browser_esm_processStyleValue(_key, value) + ";";
        }
      } else {
        if (_key === 'NO_COMPONENT_SELECTOR' && "production" !== 'production') {
          throw new Error('Component selectors can only be used in conjunction with babel-plugin-emotion.');
        }

        if (Array.isArray(value) && typeof value[0] === 'string' && (registered == null || registered[value[0]] === undefined)) {
          for (var _i = 0; _i < value.length; _i++) {
            string += processStyleName(_key) + ":" + serialize_browser_esm_processStyleValue(_key, value[_i]) + ";";
          }
        } else {
          string += _key + "{" + handleInterpolation(mergedProps, registered, value, false) + "}";
        }
      }
    }
  }

  return string;
}

var labelPattern = /label:\s*([^\s;\n{]+)\s*;/g;
var sourceMapPattern;

if (false) {} // this is the cursor for keyframes
// keyframes are stored on the SerializedStyles object as a linked list


var cursor;
var serialize_browser_esm_serializeStyles = function serializeStyles(args, registered, mergedProps) {
  if (args.length === 1 && typeof args[0] === 'object' && args[0] !== null && args[0].styles !== undefined) {
    return args[0];
  }

  var stringMode = true;
  var styles = '';
  cursor = undefined;
  var strings = args[0];

  if (strings == null || strings.raw === undefined) {
    stringMode = false;
    styles += handleInterpolation(mergedProps, registered, strings, false);
  } else {
    styles += strings[0];
  } // we start at 1 since we've already handled the first arg


  for (var i = 1; i < args.length; i++) {
    styles += handleInterpolation(mergedProps, registered, args[i], styles.charCodeAt(styles.length - 1) === 46);

    if (stringMode) {
      styles += strings[i];
    }
  }

  var sourceMap;

  if (false) {} // using a global regex with .exec is stateful so lastIndex has to be reset each time


  labelPattern.lastIndex = 0;
  var identifierName = '';
  var match; // https://esbench.com/bench/5b809c2cf2949800a0f61fb5

  while ((match = labelPattern.exec(styles)) !== null) {
    identifierName += '-' + // $FlowFixMe we know it's not null
    match[1];
  }

  var name = hash_browser_esm(styles) + identifierName;

  if (false) {}

  return {
    name: name,
    styles: styles,
    next: cursor
  };
};



// CONCATENATED MODULE: ../node_modules/@emotion/css/dist/css.browser.esm.js


function css() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return serialize_browser_esm_serializeStyles(args);
}

/* harmony default export */ var css_browser_esm = (css);

// CONCATENATED MODULE: ../node_modules/@emotion/core/dist/core.browser.esm.js
/* unused harmony export withEmotionCache */
/* unused harmony export CacheProvider */
/* unused harmony export ThemeContext */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return core_browser_esm_jsx; });
/* unused harmony export Global */
/* unused harmony export keyframes */
/* unused harmony export ClassNames */
/* unused concated harmony import css */








function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

var EmotionCacheContext = Object(react["createContext"])(cache_browser_esm());
var ThemeContext = Object(react["createContext"])({});
var CacheProvider = // $FlowFixMe
EmotionCacheContext.Provider;

var core_browser_esm_withEmotionCache = function withEmotionCache(func) {
  var render = function render(props, ref) {
    return Object(react["createElement"])(EmotionCacheContext.Consumer, null, function ( // $FlowFixMe we know it won't be null
    cache) {
      return func(props, cache, ref);
    });
  }; // $FlowFixMe


  return Object(react["forwardRef"])(render);
};

var typePropName = '__EMOTION_TYPE_PLEASE_DO_NOT_USE__';
var labelPropName = '__EMOTION_LABEL_PLEASE_DO_NOT_USE__';
var core_browser_esm_hasOwnProperty = Object.prototype.hasOwnProperty;

var core_browser_esm_render = function render(cache, props, theme, ref) {
  var type = props[typePropName];
  var registeredStyles = [];
  var className = '';
  var cssProp = theme === null ? props.css : props.css(theme); // so that using `css` from `emotion` and passing the result to the css prop works
  // not passing the registered cache to serializeStyles because it would
  // make certain babel optimisations not possible

  if (typeof cssProp === 'string' && cache.registered[cssProp] !== undefined) {
    cssProp = cache.registered[cssProp];
  }

  registeredStyles.push(cssProp);

  if (props.className !== undefined) {
    className = getRegisteredStyles(cache.registered, registeredStyles, props.className);
  }

  var serialized = serialize_browser_esm_serializeStyles(registeredStyles);

  if (false) { var labelFromStack; }

  var rules = insertStyles(cache, serialized, typeof type === 'string');
  className += cache.key + "-" + serialized.name;
  var newProps = {};

  for (var key in props) {
    if (core_browser_esm_hasOwnProperty.call(props, key) && key !== 'css' && key !== typePropName && ( true || false)) {
      newProps[key] = props[key];
    }
  }

  newProps.ref = ref;
  newProps.className = className;
  var ele = Object(react["createElement"])(type, newProps);

  return ele;
};

var Emotion = core_browser_esm_withEmotionCache(function (props, cache, ref) {
  // use Context.read for the theme when it's stable
  if (typeof props.css === 'function') {
    return Object(react["createElement"])(ThemeContext.Consumer, null, function (theme) {
      return core_browser_esm_render(cache, props, theme, ref);
    });
  }

  return core_browser_esm_render(cache, props, null, ref);
}); // $FlowFixMe

var core_browser_esm_jsx = function jsx(type, props) {
  var args = arguments;

  if (props == null || props.css == null) {
    // $FlowFixMe
    return react["createElement"].apply(undefined, args);
  }

  if (false) {}

  var argsLength = args.length;
  var createElementArgArray = new Array(argsLength);
  createElementArgArray[0] = Emotion;
  var newProps = {};

  for (var key in props) {
    if (core_browser_esm_hasOwnProperty.call(props, key)) {
      newProps[key] = props[key];
    }
  }

  newProps[typePropName] = type;

  if (false) { var match, error; }

  createElementArgArray[1] = newProps;

  for (var i = 2; i < argsLength; i++) {
    createElementArgArray[i] = args[i];
  } // $FlowFixMe


  return react["createElement"].apply(null, createElementArgArray);
};

var warnedAboutCssPropForGlobal = false;
var Global =
/* #__PURE__ */
core_browser_esm_withEmotionCache(function (props, cache) {
  if (false) {}

  var styles = props.styles;

  if (typeof styles === 'function') {
    return Object(react["createElement"])(ThemeContext.Consumer, null, function (theme) {
      var serialized = serialize_browser_esm_serializeStyles([styles(theme)]);
      return Object(react["createElement"])(core_browser_esm_InnerGlobal, {
        serialized: serialized,
        cache: cache
      });
    });
  }

  var serialized = serialize_browser_esm_serializeStyles([styles]);
  return Object(react["createElement"])(core_browser_esm_InnerGlobal, {
    serialized: serialized,
    cache: cache
  });
});

// maintain place over rerenders.
// initial render from browser, insertBefore context.sheet.tags[0] or if a style hasn't been inserted there yet, appendChild
// initial client-side render from SSR, use place of hydrating tag
var core_browser_esm_InnerGlobal =
/*#__PURE__*/
function (_React$Component) {
  _inheritsLoose(InnerGlobal, _React$Component);

  function InnerGlobal(props, context, updater) {
    return _React$Component.call(this, props, context, updater) || this;
  }

  var _proto = InnerGlobal.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this.sheet = new StyleSheet({
      key: this.props.cache.key + "-global",
      nonce: this.props.cache.sheet.nonce,
      container: this.props.cache.sheet.container
    }); // $FlowFixMe

    var node = document.querySelector("style[data-emotion-" + this.props.cache.key + "=\"" + this.props.serialized.name + "\"]");

    if (node !== null) {
      this.sheet.tags.push(node);
    }

    if (this.props.cache.sheet.tags.length) {
      this.sheet.before = this.props.cache.sheet.tags[0];
    }

    this.insertStyles();
  };

  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    if (prevProps.serialized.name !== this.props.serialized.name) {
      this.insertStyles();
    }
  };

  _proto.insertStyles = function insertStyles$$1() {
    if (this.props.serialized.next !== undefined) {
      // insert keyframes
      insertStyles(this.props.cache, this.props.serialized.next, true);
    }

    if (this.sheet.tags.length) {
      // if this doesn't exist then it will be null so the style element will be appended
      var element = this.sheet.tags[0].nextElementSibling;
      this.sheet.before = element;
      this.sheet.flush();
    }

    this.props.cache.insert("", this.props.serialized, this.sheet, false);
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.sheet.flush();
  };

  _proto.render = function render() {

    return null;
  };

  return InnerGlobal;
}(react["Component"]);

var core_browser_esm_keyframes = function keyframes() {
  var insertable = css_browser_esm.apply(void 0, arguments);
  var name = "animation-" + insertable.name; // $FlowFixMe

  return {
    name: name,
    styles: "@keyframes " + name + "{" + insertable.styles + "}",
    anim: 1,
    toString: function toString() {
      return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
    }
  };
};

var classnames = function classnames(args) {
  var len = args.length;
  var i = 0;
  var cls = '';

  for (; i < len; i++) {
    var arg = args[i];
    if (arg == null) continue;
    var toAdd = void 0;

    switch (typeof arg) {
      case 'boolean':
        break;

      case 'object':
        {
          if (Array.isArray(arg)) {
            toAdd = classnames(arg);
          } else {
            toAdd = '';

            for (var k in arg) {
              if (arg[k] && k) {
                toAdd && (toAdd += ' ');
                toAdd += k;
              }
            }
          }

          break;
        }

      default:
        {
          toAdd = arg;
        }
    }

    if (toAdd) {
      cls && (cls += ' ');
      cls += toAdd;
    }
  }

  return cls;
};

function merge(registered, css$$1, className) {
  var registeredStyles = [];
  var rawClassName = getRegisteredStyles(registered, registeredStyles, className);

  if (registeredStyles.length < 2) {
    return className;
  }

  return rawClassName + css$$1(registeredStyles);
}

var ClassNames = core_browser_esm_withEmotionCache(function (props, context) {
  return Object(react["createElement"])(ThemeContext.Consumer, null, function (theme) {
    var hasRendered = false;

    var css$$1 = function css$$1() {
      if (hasRendered && "production" !== 'production') {
        throw new Error('css can only be used during render');
      }

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      var serialized = serialize_browser_esm_serializeStyles(args, context.registered);

      {
        insertStyles(context, serialized, false);
      }

      return context.key + "-" + serialized.name;
    };

    var cx = function cx() {
      if (hasRendered && "production" !== 'production') {
        throw new Error('cx can only be used during render');
      }

      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      return merge(context.registered, css$$1, classnames(args));
    };

    var content = {
      css: css$$1,
      cx: cx,
      theme: theme
    };
    var ele = props.children(content);
    hasRendered = true;

    return ele;
  });
});




/***/ }),

/***/ 102:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function checkDCE() {
  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
  if (
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' ||
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function'
  ) {
    return;
  }
  if (false) {}
  try {
    // Verify that the code above has been dead code eliminated (DCE'd).
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    // DevTools shouldn't crash React, no matter what.
    // We should still report in case we break this code.
    console.error(err);
  }
}

if (true) {
  // DCE check should happen before ReactDOM bundle executes so that
  // DevTools can report bad minification during injection.
  checkDCE();
  module.exports = __webpack_require__(180);
} else {}


/***/ }),

/***/ 103:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};


/***/ }),

/***/ 178:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v16.7.0-alpha.0
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var k=__webpack_require__(103),l="function"===typeof Symbol&&Symbol.for,p=l?Symbol.for("react.element"):60103,q=l?Symbol.for("react.portal"):60106,r=l?Symbol.for("react.fragment"):60107,t=l?Symbol.for("react.strict_mode"):60108,u=l?Symbol.for("react.profiler"):60114,v=l?Symbol.for("react.provider"):60109,w=l?Symbol.for("react.context"):60110,x=l?Symbol.for("react.concurrent_mode"):60111,y=l?Symbol.for("react.forward_ref"):60112,z=l?Symbol.for("react.suspense"):60113,A=l?Symbol.for("react.memo"):
60115,aa=l?Symbol.for("react.lazy"):60116,B="function"===typeof Symbol&&Symbol.iterator;function ba(a,b,d,c,e,g,h,f){if(!a){a=void 0;if(void 0===b)a=Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");else{var m=[d,c,e,g,h,f],n=0;a=Error(b.replace(/%s/g,function(){return m[n++]}));a.name="Invariant Violation"}a.framesToPop=1;throw a;}}
function C(a){for(var b=arguments.length-1,d="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=0;c<b;c++)d+="&args[]="+encodeURIComponent(arguments[c+1]);ba(!1,"Minified React error #"+a+"; visit %s for the full message or use the non-minified dev environment for full errors and additional helpful warnings. ",d)}var D={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},E={};
function F(a,b,d){this.props=a;this.context=b;this.refs=E;this.updater=d||D}F.prototype.isReactComponent={};F.prototype.setState=function(a,b){"object"!==typeof a&&"function"!==typeof a&&null!=a?C("85"):void 0;this.updater.enqueueSetState(this,a,b,"setState")};F.prototype.forceUpdate=function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};function G(){}G.prototype=F.prototype;function H(a,b,d){this.props=a;this.context=b;this.refs=E;this.updater=d||D}var I=H.prototype=new G;
I.constructor=H;k(I,F.prototype);I.isPureReactComponent=!0;var J={current:null,currentDispatcher:null},K=Object.prototype.hasOwnProperty,L={key:!0,ref:!0,__self:!0,__source:!0};
function M(a,b,d){var c=void 0,e={},g=null,h=null;if(null!=b)for(c in void 0!==b.ref&&(h=b.ref),void 0!==b.key&&(g=""+b.key),b)K.call(b,c)&&!L.hasOwnProperty(c)&&(e[c]=b[c]);var f=arguments.length-2;if(1===f)e.children=d;else if(1<f){for(var m=Array(f),n=0;n<f;n++)m[n]=arguments[n+2];e.children=m}if(a&&a.defaultProps)for(c in f=a.defaultProps,f)void 0===e[c]&&(e[c]=f[c]);return{$$typeof:p,type:a,key:g,ref:h,props:e,_owner:J.current}}
function ca(a,b){return{$$typeof:p,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===p}function escape(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}var O=/\/+/g,P=[];function Q(a,b,d,c){if(P.length){var e=P.pop();e.result=a;e.keyPrefix=b;e.func=d;e.context=c;e.count=0;return e}return{result:a,keyPrefix:b,func:d,context:c,count:0}}
function R(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>P.length&&P.push(a)}
function S(a,b,d,c){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var g=!1;if(null===a)g=!0;else switch(e){case "string":case "number":g=!0;break;case "object":switch(a.$$typeof){case p:case q:g=!0}}if(g)return d(c,a,""===b?"."+T(a,0):b),1;g=0;b=""===b?".":b+":";if(Array.isArray(a))for(var h=0;h<a.length;h++){e=a[h];var f=b+T(e,h);g+=S(e,f,d,c)}else if(null===a||"object"!==typeof a?f=null:(f=B&&a[B]||a["@@iterator"],f="function"===typeof f?f:null),"function"===typeof f)for(a=f.call(a),h=
0;!(e=a.next()).done;)e=e.value,f=b+T(e,h++),g+=S(e,f,d,c);else"object"===e&&(d=""+a,C("31","[object Object]"===d?"object with keys {"+Object.keys(a).join(", ")+"}":d,""));return g}function U(a,b,d){return null==a?0:S(a,"",b,d)}function T(a,b){return"object"===typeof a&&null!==a&&null!=a.key?escape(a.key):b.toString(36)}function da(a,b){a.func.call(a.context,b,a.count++)}
function ea(a,b,d){var c=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?V(a,c,d,function(a){return a}):null!=a&&(N(a)&&(a=ca(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(O,"$&/")+"/")+d)),c.push(a))}function V(a,b,d,c,e){var g="";null!=d&&(g=(""+d).replace(O,"$&/")+"/");b=Q(b,g,c,e);U(a,ea,b);R(b)}function W(){var a=J.currentDispatcher;null===a?C("298"):void 0;return a}
var X={Children:{map:function(a,b,d){if(null==a)return a;var c=[];V(a,c,null,b,d);return c},forEach:function(a,b,d){if(null==a)return a;b=Q(null,null,b,d);U(a,da,b);R(b)},count:function(a){return U(a,function(){return null},null)},toArray:function(a){var b=[];V(a,b,null,function(a){return a});return b},only:function(a){N(a)?void 0:C("143");return a}},createRef:function(){return{current:null}},Component:F,PureComponent:H,createContext:function(a,b){void 0===b&&(b=null);a={$$typeof:w,_calculateChangedBits:b,
_currentValue:a,_currentValue2:a,Provider:null,Consumer:null};a.Provider={$$typeof:v,_context:a};return a.Consumer=a},forwardRef:function(a){return{$$typeof:y,render:a}},lazy:function(a){return{$$typeof:aa,_ctor:a,_status:-1,_result:null}},memo:function(a,b){return{$$typeof:A,type:a,compare:void 0===b?null:b}},Fragment:r,StrictMode:t,Suspense:z,createElement:M,cloneElement:function(a,b,d){null===a||void 0===a?C("267",a):void 0;var c=void 0,e=k({},a.props),g=a.key,h=a.ref,f=a._owner;if(null!=b){void 0!==
b.ref&&(h=b.ref,f=J.current);void 0!==b.key&&(g=""+b.key);var m=void 0;a.type&&a.type.defaultProps&&(m=a.type.defaultProps);for(c in b)K.call(b,c)&&!L.hasOwnProperty(c)&&(e[c]=void 0===b[c]&&void 0!==m?m[c]:b[c])}c=arguments.length-2;if(1===c)e.children=d;else if(1<c){m=Array(c);for(var n=0;n<c;n++)m[n]=arguments[n+2];e.children=m}return{$$typeof:p,type:a.type,key:g,ref:h,props:e,_owner:f}},createFactory:function(a){var b=M.bind(null,a);b.type=a;return b},isValidElement:N,version:"16.7.0-alpha.0",
__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED:{ReactCurrentOwner:J,assign:k}};X.ConcurrentMode=x;X.Profiler=u;X.useCallback=function(a,b){return W().useCallback(a,b)};X.useContext=function(a,b){return W().useContext(a,b)};X.useEffect=function(a,b){return W().useEffect(a,b)};X.useImperativeMethods=function(a,b,d){return W().useImperativeMethods(a,b,d)};X.useLayoutEffect=function(a,b){return W().useLayoutEffect(a,b)};X.useMemo=function(a,b){return W().useMemo(a,b)};
X.useMutationEffect=function(a,b){return W().useMutationEffect(a,b)};X.useReducer=function(a,b,d){return W().useReducer(a,b,d)};X.useRef=function(a){return W().useRef(a)};X.useState=function(a){return W().useState(a)};var Y={default:X},Z=Y&&X||Y;module.exports=Z.default||Z;


/***/ }),

/***/ 179:
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process, global) {/*! *****************************************************************************
Copyright (C) Microsoft. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var Reflect;
(function (Reflect) {
    // Metadata Proposal
    // https://rbuckton.github.io/reflect-metadata/
    (function (factory) {
        var root = typeof global === "object" ? global :
            typeof self === "object" ? self :
                typeof this === "object" ? this :
                    Function("return this;")();
        var exporter = makeExporter(Reflect);
        if (typeof root.Reflect === "undefined") {
            root.Reflect = Reflect;
        }
        else {
            exporter = makeExporter(root.Reflect, exporter);
        }
        factory(exporter);
        function makeExporter(target, previous) {
            return function (key, value) {
                if (typeof target[key] !== "function") {
                    Object.defineProperty(target, key, { configurable: true, writable: true, value: value });
                }
                if (previous)
                    previous(key, value);
            };
        }
    })(function (exporter) {
        var hasOwn = Object.prototype.hasOwnProperty;
        // feature test for Symbol support
        var supportsSymbol = typeof Symbol === "function";
        var toPrimitiveSymbol = supportsSymbol && typeof Symbol.toPrimitive !== "undefined" ? Symbol.toPrimitive : "@@toPrimitive";
        var iteratorSymbol = supportsSymbol && typeof Symbol.iterator !== "undefined" ? Symbol.iterator : "@@iterator";
        var supportsCreate = typeof Object.create === "function"; // feature test for Object.create support
        var supportsProto = { __proto__: [] } instanceof Array; // feature test for __proto__ support
        var downLevel = !supportsCreate && !supportsProto;
        var HashMap = {
            // create an object in dictionary mode (a.k.a. "slow" mode in v8)
            create: supportsCreate
                ? function () { return MakeDictionary(Object.create(null)); }
                : supportsProto
                    ? function () { return MakeDictionary({ __proto__: null }); }
                    : function () { return MakeDictionary({}); },
            has: downLevel
                ? function (map, key) { return hasOwn.call(map, key); }
                : function (map, key) { return key in map; },
            get: downLevel
                ? function (map, key) { return hasOwn.call(map, key) ? map[key] : undefined; }
                : function (map, key) { return map[key]; },
        };
        // Load global or shim versions of Map, Set, and WeakMap
        var functionPrototype = Object.getPrototypeOf(Function);
        var usePolyfill = typeof process === "object" && process.env && process.env["REFLECT_METADATA_USE_MAP_POLYFILL"] === "true";
        var _Map = !usePolyfill && typeof Map === "function" && typeof Map.prototype.entries === "function" ? Map : CreateMapPolyfill();
        var _Set = !usePolyfill && typeof Set === "function" && typeof Set.prototype.entries === "function" ? Set : CreateSetPolyfill();
        var _WeakMap = !usePolyfill && typeof WeakMap === "function" ? WeakMap : CreateWeakMapPolyfill();
        // [[Metadata]] internal slot
        // https://rbuckton.github.io/reflect-metadata/#ordinary-object-internal-methods-and-internal-slots
        var Metadata = new _WeakMap();
        /**
         * Applies a set of decorators to a property of a target object.
         * @param decorators An array of decorators.
         * @param target The target object.
         * @param propertyKey (Optional) The property key to decorate.
         * @param attributes (Optional) The property descriptor for the target key.
         * @remarks Decorators are applied in reverse order.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     Example = Reflect.decorate(decoratorsArray, Example);
         *
         *     // property (on constructor)
         *     Reflect.decorate(decoratorsArray, Example, "staticProperty");
         *
         *     // property (on prototype)
         *     Reflect.decorate(decoratorsArray, Example.prototype, "property");
         *
         *     // method (on constructor)
         *     Object.defineProperty(Example, "staticMethod",
         *         Reflect.decorate(decoratorsArray, Example, "staticMethod",
         *             Object.getOwnPropertyDescriptor(Example, "staticMethod")));
         *
         *     // method (on prototype)
         *     Object.defineProperty(Example.prototype, "method",
         *         Reflect.decorate(decoratorsArray, Example.prototype, "method",
         *             Object.getOwnPropertyDescriptor(Example.prototype, "method")));
         *
         */
        function decorate(decorators, target, propertyKey, attributes) {
            if (!IsUndefined(propertyKey)) {
                if (!IsArray(decorators))
                    throw new TypeError();
                if (!IsObject(target))
                    throw new TypeError();
                if (!IsObject(attributes) && !IsUndefined(attributes) && !IsNull(attributes))
                    throw new TypeError();
                if (IsNull(attributes))
                    attributes = undefined;
                propertyKey = ToPropertyKey(propertyKey);
                return DecorateProperty(decorators, target, propertyKey, attributes);
            }
            else {
                if (!IsArray(decorators))
                    throw new TypeError();
                if (!IsConstructor(target))
                    throw new TypeError();
                return DecorateConstructor(decorators, target);
            }
        }
        exporter("decorate", decorate);
        // 4.1.2 Reflect.metadata(metadataKey, metadataValue)
        // https://rbuckton.github.io/reflect-metadata/#reflect.metadata
        /**
         * A default metadata decorator factory that can be used on a class, class member, or parameter.
         * @param metadataKey The key for the metadata entry.
         * @param metadataValue The value for the metadata entry.
         * @returns A decorator function.
         * @remarks
         * If `metadataKey` is already defined for the target and target key, the
         * metadataValue for that key will be overwritten.
         * @example
         *
         *     // constructor
         *     @Reflect.metadata(key, value)
         *     class Example {
         *     }
         *
         *     // property (on constructor, TypeScript only)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         static staticProperty;
         *     }
         *
         *     // property (on prototype, TypeScript only)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         property;
         *     }
         *
         *     // method (on constructor)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         static staticMethod() { }
         *     }
         *
         *     // method (on prototype)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         method() { }
         *     }
         *
         */
        function metadata(metadataKey, metadataValue) {
            function decorator(target, propertyKey) {
                if (!IsObject(target))
                    throw new TypeError();
                if (!IsUndefined(propertyKey) && !IsPropertyKey(propertyKey))
                    throw new TypeError();
                OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
            }
            return decorator;
        }
        exporter("metadata", metadata);
        /**
         * Define a unique metadata entry on the target.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param metadataValue A value that contains attached metadata.
         * @param target The target object on which to define metadata.
         * @param propertyKey (Optional) The property key for the target.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     Reflect.defineMetadata("custom:annotation", options, Example);
         *
         *     // property (on constructor)
         *     Reflect.defineMetadata("custom:annotation", options, Example, "staticProperty");
         *
         *     // property (on prototype)
         *     Reflect.defineMetadata("custom:annotation", options, Example.prototype, "property");
         *
         *     // method (on constructor)
         *     Reflect.defineMetadata("custom:annotation", options, Example, "staticMethod");
         *
         *     // method (on prototype)
         *     Reflect.defineMetadata("custom:annotation", options, Example.prototype, "method");
         *
         *     // decorator factory as metadata-producing annotation.
         *     function MyAnnotation(options): Decorator {
         *         return (target, key?) => Reflect.defineMetadata("custom:annotation", options, target, key);
         *     }
         *
         */
        function defineMetadata(metadataKey, metadataValue, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
        }
        exporter("defineMetadata", defineMetadata);
        /**
         * Gets a value indicating whether the target object or its prototype chain has the provided metadata key defined.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns `true` if the metadata key was defined on the target object or its prototype chain; otherwise, `false`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.hasMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.hasMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.hasMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.hasMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.hasMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function hasMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryHasMetadata(metadataKey, target, propertyKey);
        }
        exporter("hasMetadata", hasMetadata);
        /**
         * Gets a value indicating whether the target object has the provided metadata key defined.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns `true` if the metadata key was defined on the target object; otherwise, `false`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function hasOwnMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);
        }
        exporter("hasOwnMetadata", hasOwnMetadata);
        /**
         * Gets the metadata value for the provided metadata key on the target object or its prototype chain.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function getMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryGetMetadata(metadataKey, target, propertyKey);
        }
        exporter("getMetadata", getMetadata);
        /**
         * Gets the metadata value for the provided metadata key on the target object.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getOwnMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function getOwnMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryGetOwnMetadata(metadataKey, target, propertyKey);
        }
        exporter("getOwnMetadata", getOwnMetadata);
        /**
         * Gets the metadata keys defined on the target object or its prototype chain.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns An array of unique metadata keys.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getMetadataKeys(Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getMetadataKeys(Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getMetadataKeys(Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getMetadataKeys(Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getMetadataKeys(Example.prototype, "method");
         *
         */
        function getMetadataKeys(target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryMetadataKeys(target, propertyKey);
        }
        exporter("getMetadataKeys", getMetadataKeys);
        /**
         * Gets the unique metadata keys defined on the target object.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns An array of unique metadata keys.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getOwnMetadataKeys(Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getOwnMetadataKeys(Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getOwnMetadataKeys(Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getOwnMetadataKeys(Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getOwnMetadataKeys(Example.prototype, "method");
         *
         */
        function getOwnMetadataKeys(target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryOwnMetadataKeys(target, propertyKey);
        }
        exporter("getOwnMetadataKeys", getOwnMetadataKeys);
        /**
         * Deletes the metadata entry from the target object with the provided key.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns `true` if the metadata entry was found and deleted; otherwise, false.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.deleteMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.deleteMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.deleteMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.deleteMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.deleteMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function deleteMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            var metadataMap = GetOrCreateMetadataMap(target, propertyKey, /*Create*/ false);
            if (IsUndefined(metadataMap))
                return false;
            if (!metadataMap.delete(metadataKey))
                return false;
            if (metadataMap.size > 0)
                return true;
            var targetMetadata = Metadata.get(target);
            targetMetadata.delete(propertyKey);
            if (targetMetadata.size > 0)
                return true;
            Metadata.delete(target);
            return true;
        }
        exporter("deleteMetadata", deleteMetadata);
        function DecorateConstructor(decorators, target) {
            for (var i = decorators.length - 1; i >= 0; --i) {
                var decorator = decorators[i];
                var decorated = decorator(target);
                if (!IsUndefined(decorated) && !IsNull(decorated)) {
                    if (!IsConstructor(decorated))
                        throw new TypeError();
                    target = decorated;
                }
            }
            return target;
        }
        function DecorateProperty(decorators, target, propertyKey, descriptor) {
            for (var i = decorators.length - 1; i >= 0; --i) {
                var decorator = decorators[i];
                var decorated = decorator(target, propertyKey, descriptor);
                if (!IsUndefined(decorated) && !IsNull(decorated)) {
                    if (!IsObject(decorated))
                        throw new TypeError();
                    descriptor = decorated;
                }
            }
            return descriptor;
        }
        function GetOrCreateMetadataMap(O, P, Create) {
            var targetMetadata = Metadata.get(O);
            if (IsUndefined(targetMetadata)) {
                if (!Create)
                    return undefined;
                targetMetadata = new _Map();
                Metadata.set(O, targetMetadata);
            }
            var metadataMap = targetMetadata.get(P);
            if (IsUndefined(metadataMap)) {
                if (!Create)
                    return undefined;
                metadataMap = new _Map();
                targetMetadata.set(P, metadataMap);
            }
            return metadataMap;
        }
        // 3.1.1.1 OrdinaryHasMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinaryhasmetadata
        function OrdinaryHasMetadata(MetadataKey, O, P) {
            var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
            if (hasOwn)
                return true;
            var parent = OrdinaryGetPrototypeOf(O);
            if (!IsNull(parent))
                return OrdinaryHasMetadata(MetadataKey, parent, P);
            return false;
        }
        // 3.1.2.1 OrdinaryHasOwnMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinaryhasownmetadata
        function OrdinaryHasOwnMetadata(MetadataKey, O, P) {
            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
            if (IsUndefined(metadataMap))
                return false;
            return ToBoolean(metadataMap.has(MetadataKey));
        }
        // 3.1.3.1 OrdinaryGetMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarygetmetadata
        function OrdinaryGetMetadata(MetadataKey, O, P) {
            var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
            if (hasOwn)
                return OrdinaryGetOwnMetadata(MetadataKey, O, P);
            var parent = OrdinaryGetPrototypeOf(O);
            if (!IsNull(parent))
                return OrdinaryGetMetadata(MetadataKey, parent, P);
            return undefined;
        }
        // 3.1.4.1 OrdinaryGetOwnMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarygetownmetadata
        function OrdinaryGetOwnMetadata(MetadataKey, O, P) {
            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
            if (IsUndefined(metadataMap))
                return undefined;
            return metadataMap.get(MetadataKey);
        }
        // 3.1.5.1 OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarydefineownmetadata
        function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ true);
            metadataMap.set(MetadataKey, MetadataValue);
        }
        // 3.1.6.1 OrdinaryMetadataKeys(O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarymetadatakeys
        function OrdinaryMetadataKeys(O, P) {
            var ownKeys = OrdinaryOwnMetadataKeys(O, P);
            var parent = OrdinaryGetPrototypeOf(O);
            if (parent === null)
                return ownKeys;
            var parentKeys = OrdinaryMetadataKeys(parent, P);
            if (parentKeys.length <= 0)
                return ownKeys;
            if (ownKeys.length <= 0)
                return parentKeys;
            var set = new _Set();
            var keys = [];
            for (var _i = 0, ownKeys_1 = ownKeys; _i < ownKeys_1.length; _i++) {
                var key = ownKeys_1[_i];
                var hasKey = set.has(key);
                if (!hasKey) {
                    set.add(key);
                    keys.push(key);
                }
            }
            for (var _a = 0, parentKeys_1 = parentKeys; _a < parentKeys_1.length; _a++) {
                var key = parentKeys_1[_a];
                var hasKey = set.has(key);
                if (!hasKey) {
                    set.add(key);
                    keys.push(key);
                }
            }
            return keys;
        }
        // 3.1.7.1 OrdinaryOwnMetadataKeys(O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinaryownmetadatakeys
        function OrdinaryOwnMetadataKeys(O, P) {
            var keys = [];
            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
            if (IsUndefined(metadataMap))
                return keys;
            var keysObj = metadataMap.keys();
            var iterator = GetIterator(keysObj);
            var k = 0;
            while (true) {
                var next = IteratorStep(iterator);
                if (!next) {
                    keys.length = k;
                    return keys;
                }
                var nextValue = IteratorValue(next);
                try {
                    keys[k] = nextValue;
                }
                catch (e) {
                    try {
                        IteratorClose(iterator);
                    }
                    finally {
                        throw e;
                    }
                }
                k++;
            }
        }
        // 6 ECMAScript Data Typ0es and Values
        // https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values
        function Type(x) {
            if (x === null)
                return 1 /* Null */;
            switch (typeof x) {
                case "undefined": return 0 /* Undefined */;
                case "boolean": return 2 /* Boolean */;
                case "string": return 3 /* String */;
                case "symbol": return 4 /* Symbol */;
                case "number": return 5 /* Number */;
                case "object": return x === null ? 1 /* Null */ : 6 /* Object */;
                default: return 6 /* Object */;
            }
        }
        // 6.1.1 The Undefined Type
        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-undefined-type
        function IsUndefined(x) {
            return x === undefined;
        }
        // 6.1.2 The Null Type
        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-null-type
        function IsNull(x) {
            return x === null;
        }
        // 6.1.5 The Symbol Type
        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-symbol-type
        function IsSymbol(x) {
            return typeof x === "symbol";
        }
        // 6.1.7 The Object Type
        // https://tc39.github.io/ecma262/#sec-object-type
        function IsObject(x) {
            return typeof x === "object" ? x !== null : typeof x === "function";
        }
        // 7.1 Type Conversion
        // https://tc39.github.io/ecma262/#sec-type-conversion
        // 7.1.1 ToPrimitive(input [, PreferredType])
        // https://tc39.github.io/ecma262/#sec-toprimitive
        function ToPrimitive(input, PreferredType) {
            switch (Type(input)) {
                case 0 /* Undefined */: return input;
                case 1 /* Null */: return input;
                case 2 /* Boolean */: return input;
                case 3 /* String */: return input;
                case 4 /* Symbol */: return input;
                case 5 /* Number */: return input;
            }
            var hint = PreferredType === 3 /* String */ ? "string" : PreferredType === 5 /* Number */ ? "number" : "default";
            var exoticToPrim = GetMethod(input, toPrimitiveSymbol);
            if (exoticToPrim !== undefined) {
                var result = exoticToPrim.call(input, hint);
                if (IsObject(result))
                    throw new TypeError();
                return result;
            }
            return OrdinaryToPrimitive(input, hint === "default" ? "number" : hint);
        }
        // 7.1.1.1 OrdinaryToPrimitive(O, hint)
        // https://tc39.github.io/ecma262/#sec-ordinarytoprimitive
        function OrdinaryToPrimitive(O, hint) {
            if (hint === "string") {
                var toString_1 = O.toString;
                if (IsCallable(toString_1)) {
                    var result = toString_1.call(O);
                    if (!IsObject(result))
                        return result;
                }
                var valueOf = O.valueOf;
                if (IsCallable(valueOf)) {
                    var result = valueOf.call(O);
                    if (!IsObject(result))
                        return result;
                }
            }
            else {
                var valueOf = O.valueOf;
                if (IsCallable(valueOf)) {
                    var result = valueOf.call(O);
                    if (!IsObject(result))
                        return result;
                }
                var toString_2 = O.toString;
                if (IsCallable(toString_2)) {
                    var result = toString_2.call(O);
                    if (!IsObject(result))
                        return result;
                }
            }
            throw new TypeError();
        }
        // 7.1.2 ToBoolean(argument)
        // https://tc39.github.io/ecma262/2016/#sec-toboolean
        function ToBoolean(argument) {
            return !!argument;
        }
        // 7.1.12 ToString(argument)
        // https://tc39.github.io/ecma262/#sec-tostring
        function ToString(argument) {
            return "" + argument;
        }
        // 7.1.14 ToPropertyKey(argument)
        // https://tc39.github.io/ecma262/#sec-topropertykey
        function ToPropertyKey(argument) {
            var key = ToPrimitive(argument, 3 /* String */);
            if (IsSymbol(key))
                return key;
            return ToString(key);
        }
        // 7.2 Testing and Comparison Operations
        // https://tc39.github.io/ecma262/#sec-testing-and-comparison-operations
        // 7.2.2 IsArray(argument)
        // https://tc39.github.io/ecma262/#sec-isarray
        function IsArray(argument) {
            return Array.isArray
                ? Array.isArray(argument)
                : argument instanceof Object
                    ? argument instanceof Array
                    : Object.prototype.toString.call(argument) === "[object Array]";
        }
        // 7.2.3 IsCallable(argument)
        // https://tc39.github.io/ecma262/#sec-iscallable
        function IsCallable(argument) {
            // NOTE: This is an approximation as we cannot check for [[Call]] internal method.
            return typeof argument === "function";
        }
        // 7.2.4 IsConstructor(argument)
        // https://tc39.github.io/ecma262/#sec-isconstructor
        function IsConstructor(argument) {
            // NOTE: This is an approximation as we cannot check for [[Construct]] internal method.
            return typeof argument === "function";
        }
        // 7.2.7 IsPropertyKey(argument)
        // https://tc39.github.io/ecma262/#sec-ispropertykey
        function IsPropertyKey(argument) {
            switch (Type(argument)) {
                case 3 /* String */: return true;
                case 4 /* Symbol */: return true;
                default: return false;
            }
        }
        // 7.3 Operations on Objects
        // https://tc39.github.io/ecma262/#sec-operations-on-objects
        // 7.3.9 GetMethod(V, P)
        // https://tc39.github.io/ecma262/#sec-getmethod
        function GetMethod(V, P) {
            var func = V[P];
            if (func === undefined || func === null)
                return undefined;
            if (!IsCallable(func))
                throw new TypeError();
            return func;
        }
        // 7.4 Operations on Iterator Objects
        // https://tc39.github.io/ecma262/#sec-operations-on-iterator-objects
        function GetIterator(obj) {
            var method = GetMethod(obj, iteratorSymbol);
            if (!IsCallable(method))
                throw new TypeError(); // from Call
            var iterator = method.call(obj);
            if (!IsObject(iterator))
                throw new TypeError();
            return iterator;
        }
        // 7.4.4 IteratorValue(iterResult)
        // https://tc39.github.io/ecma262/2016/#sec-iteratorvalue
        function IteratorValue(iterResult) {
            return iterResult.value;
        }
        // 7.4.5 IteratorStep(iterator)
        // https://tc39.github.io/ecma262/#sec-iteratorstep
        function IteratorStep(iterator) {
            var result = iterator.next();
            return result.done ? false : result;
        }
        // 7.4.6 IteratorClose(iterator, completion)
        // https://tc39.github.io/ecma262/#sec-iteratorclose
        function IteratorClose(iterator) {
            var f = iterator["return"];
            if (f)
                f.call(iterator);
        }
        // 9.1 Ordinary Object Internal Methods and Internal Slots
        // https://tc39.github.io/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots
        // 9.1.1.1 OrdinaryGetPrototypeOf(O)
        // https://tc39.github.io/ecma262/#sec-ordinarygetprototypeof
        function OrdinaryGetPrototypeOf(O) {
            var proto = Object.getPrototypeOf(O);
            if (typeof O !== "function" || O === functionPrototype)
                return proto;
            // TypeScript doesn't set __proto__ in ES5, as it's non-standard.
            // Try to determine the superclass constructor. Compatible implementations
            // must either set __proto__ on a subclass constructor to the superclass constructor,
            // or ensure each class has a valid `constructor` property on its prototype that
            // points back to the constructor.
            // If this is not the same as Function.[[Prototype]], then this is definately inherited.
            // This is the case when in ES6 or when using __proto__ in a compatible browser.
            if (proto !== functionPrototype)
                return proto;
            // If the super prototype is Object.prototype, null, or undefined, then we cannot determine the heritage.
            var prototype = O.prototype;
            var prototypeProto = prototype && Object.getPrototypeOf(prototype);
            if (prototypeProto == null || prototypeProto === Object.prototype)
                return proto;
            // If the constructor was not a function, then we cannot determine the heritage.
            var constructor = prototypeProto.constructor;
            if (typeof constructor !== "function")
                return proto;
            // If we have some kind of self-reference, then we cannot determine the heritage.
            if (constructor === O)
                return proto;
            // we have a pretty good guess at the heritage.
            return constructor;
        }
        // naive Map shim
        function CreateMapPolyfill() {
            var cacheSentinel = {};
            var arraySentinel = [];
            var MapIterator = (function () {
                function MapIterator(keys, values, selector) {
                    this._index = 0;
                    this._keys = keys;
                    this._values = values;
                    this._selector = selector;
                }
                MapIterator.prototype["@@iterator"] = function () { return this; };
                MapIterator.prototype[iteratorSymbol] = function () { return this; };
                MapIterator.prototype.next = function () {
                    var index = this._index;
                    if (index >= 0 && index < this._keys.length) {
                        var result = this._selector(this._keys[index], this._values[index]);
                        if (index + 1 >= this._keys.length) {
                            this._index = -1;
                            this._keys = arraySentinel;
                            this._values = arraySentinel;
                        }
                        else {
                            this._index++;
                        }
                        return { value: result, done: false };
                    }
                    return { value: undefined, done: true };
                };
                MapIterator.prototype.throw = function (error) {
                    if (this._index >= 0) {
                        this._index = -1;
                        this._keys = arraySentinel;
                        this._values = arraySentinel;
                    }
                    throw error;
                };
                MapIterator.prototype.return = function (value) {
                    if (this._index >= 0) {
                        this._index = -1;
                        this._keys = arraySentinel;
                        this._values = arraySentinel;
                    }
                    return { value: value, done: true };
                };
                return MapIterator;
            }());
            return (function () {
                function Map() {
                    this._keys = [];
                    this._values = [];
                    this._cacheKey = cacheSentinel;
                    this._cacheIndex = -2;
                }
                Object.defineProperty(Map.prototype, "size", {
                    get: function () { return this._keys.length; },
                    enumerable: true,
                    configurable: true
                });
                Map.prototype.has = function (key) { return this._find(key, /*insert*/ false) >= 0; };
                Map.prototype.get = function (key) {
                    var index = this._find(key, /*insert*/ false);
                    return index >= 0 ? this._values[index] : undefined;
                };
                Map.prototype.set = function (key, value) {
                    var index = this._find(key, /*insert*/ true);
                    this._values[index] = value;
                    return this;
                };
                Map.prototype.delete = function (key) {
                    var index = this._find(key, /*insert*/ false);
                    if (index >= 0) {
                        var size = this._keys.length;
                        for (var i = index + 1; i < size; i++) {
                            this._keys[i - 1] = this._keys[i];
                            this._values[i - 1] = this._values[i];
                        }
                        this._keys.length--;
                        this._values.length--;
                        if (key === this._cacheKey) {
                            this._cacheKey = cacheSentinel;
                            this._cacheIndex = -2;
                        }
                        return true;
                    }
                    return false;
                };
                Map.prototype.clear = function () {
                    this._keys.length = 0;
                    this._values.length = 0;
                    this._cacheKey = cacheSentinel;
                    this._cacheIndex = -2;
                };
                Map.prototype.keys = function () { return new MapIterator(this._keys, this._values, getKey); };
                Map.prototype.values = function () { return new MapIterator(this._keys, this._values, getValue); };
                Map.prototype.entries = function () { return new MapIterator(this._keys, this._values, getEntry); };
                Map.prototype["@@iterator"] = function () { return this.entries(); };
                Map.prototype[iteratorSymbol] = function () { return this.entries(); };
                Map.prototype._find = function (key, insert) {
                    if (this._cacheKey !== key) {
                        this._cacheIndex = this._keys.indexOf(this._cacheKey = key);
                    }
                    if (this._cacheIndex < 0 && insert) {
                        this._cacheIndex = this._keys.length;
                        this._keys.push(key);
                        this._values.push(undefined);
                    }
                    return this._cacheIndex;
                };
                return Map;
            }());
            function getKey(key, _) {
                return key;
            }
            function getValue(_, value) {
                return value;
            }
            function getEntry(key, value) {
                return [key, value];
            }
        }
        // naive Set shim
        function CreateSetPolyfill() {
            return (function () {
                function Set() {
                    this._map = new _Map();
                }
                Object.defineProperty(Set.prototype, "size", {
                    get: function () { return this._map.size; },
                    enumerable: true,
                    configurable: true
                });
                Set.prototype.has = function (value) { return this._map.has(value); };
                Set.prototype.add = function (value) { return this._map.set(value, value), this; };
                Set.prototype.delete = function (value) { return this._map.delete(value); };
                Set.prototype.clear = function () { this._map.clear(); };
                Set.prototype.keys = function () { return this._map.keys(); };
                Set.prototype.values = function () { return this._map.values(); };
                Set.prototype.entries = function () { return this._map.entries(); };
                Set.prototype["@@iterator"] = function () { return this.keys(); };
                Set.prototype[iteratorSymbol] = function () { return this.keys(); };
                return Set;
            }());
        }
        // naive WeakMap shim
        function CreateWeakMapPolyfill() {
            var UUID_SIZE = 16;
            var keys = HashMap.create();
            var rootKey = CreateUniqueKey();
            return (function () {
                function WeakMap() {
                    this._key = CreateUniqueKey();
                }
                WeakMap.prototype.has = function (target) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/ false);
                    return table !== undefined ? HashMap.has(table, this._key) : false;
                };
                WeakMap.prototype.get = function (target) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/ false);
                    return table !== undefined ? HashMap.get(table, this._key) : undefined;
                };
                WeakMap.prototype.set = function (target, value) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/ true);
                    table[this._key] = value;
                    return this;
                };
                WeakMap.prototype.delete = function (target) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/ false);
                    return table !== undefined ? delete table[this._key] : false;
                };
                WeakMap.prototype.clear = function () {
                    // NOTE: not a real clear, just makes the previous data unreachable
                    this._key = CreateUniqueKey();
                };
                return WeakMap;
            }());
            function CreateUniqueKey() {
                var key;
                do
                    key = "@@WeakMap@@" + CreateUUID();
                while (HashMap.has(keys, key));
                keys[key] = true;
                return key;
            }
            function GetOrCreateWeakMapTable(target, create) {
                if (!hasOwn.call(target, rootKey)) {
                    if (!create)
                        return undefined;
                    Object.defineProperty(target, rootKey, { value: HashMap.create() });
                }
                return target[rootKey];
            }
            function FillRandomBytes(buffer, size) {
                for (var i = 0; i < size; ++i)
                    buffer[i] = Math.random() * 0xff | 0;
                return buffer;
            }
            function GenRandomBytes(size) {
                if (typeof Uint8Array === "function") {
                    if (typeof crypto !== "undefined")
                        return crypto.getRandomValues(new Uint8Array(size));
                    if (typeof msCrypto !== "undefined")
                        return msCrypto.getRandomValues(new Uint8Array(size));
                    return FillRandomBytes(new Uint8Array(size), size);
                }
                return FillRandomBytes(new Array(size), size);
            }
            function CreateUUID() {
                var data = GenRandomBytes(UUID_SIZE);
                // mark as random - RFC 4122 § 4.4
                data[6] = data[6] & 0x4f | 0x40;
                data[8] = data[8] & 0xbf | 0x80;
                var result = "";
                for (var offset = 0; offset < UUID_SIZE; ++offset) {
                    var byte = data[offset];
                    if (offset === 4 || offset === 6 || offset === 8)
                        result += "-";
                    if (byte < 16)
                        result += "0";
                    result += byte.toString(16).toLowerCase();
                }
                return result;
            }
        }
        // uses a heuristic used by v8 and chakra to force an object into dictionary mode.
        function MakeDictionary(obj) {
            obj.__ = undefined;
            delete obj.__;
            return obj;
        }
    });
})(Reflect || (Reflect = {}));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(3), __webpack_require__(5)))

/***/ }),

/***/ 180:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v16.7.0-alpha.0
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
var aa=__webpack_require__(0),n=__webpack_require__(103),ba=__webpack_require__(181);function ca(a,b,c,d,e,f,g,h){if(!a){a=void 0;if(void 0===b)a=Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");else{var k=[c,d,e,f,g,h],l=0;a=Error(b.replace(/%s/g,function(){return k[l++]}));a.name="Invariant Violation"}a.framesToPop=1;throw a;}}
function r(a){for(var b=arguments.length-1,c="https://reactjs.org/docs/error-decoder.html?invariant="+a,d=0;d<b;d++)c+="&args[]="+encodeURIComponent(arguments[d+1]);ca(!1,"Minified React error #"+a+"; visit %s for the full message or use the non-minified dev environment for full errors and additional helpful warnings. ",c)}aa?void 0:r("227");function da(a,b,c,d,e,f,g,h,k){var l=Array.prototype.slice.call(arguments,3);try{b.apply(c,l)}catch(m){this.onError(m)}}
var ea=!1,ia=null,ja=!1,ka=null,la={onError:function(a){ea=!0;ia=a}};function ma(a,b,c,d,e,f,g,h,k){ea=!1;ia=null;da.apply(la,arguments)}function na(a,b,c,d,e,f,g,h,k){ma.apply(this,arguments);if(ea){if(ea){var l=ia;ea=!1;ia=null}else r("198"),l=void 0;ja||(ja=!0,ka=l)}}var oa=null,pa={};
function qa(){if(oa)for(var a in pa){var b=pa[a],c=oa.indexOf(a);-1<c?void 0:r("96",a);if(!ra[c]){b.extractEvents?void 0:r("97",a);ra[c]=b;c=b.eventTypes;for(var d in c){var e=void 0;var f=c[d],g=b,h=d;sa.hasOwnProperty(h)?r("99",h):void 0;sa[h]=f;var k=f.phasedRegistrationNames;if(k){for(e in k)k.hasOwnProperty(e)&&ta(k[e],g,h);e=!0}else f.registrationName?(ta(f.registrationName,g,h),e=!0):e=!1;e?void 0:r("98",d,a)}}}}
function ta(a,b,c){ua[a]?r("100",a):void 0;ua[a]=b;va[a]=b.eventTypes[c].dependencies}var ra=[],sa={},ua={},va={},wa=null,xa=null,ya=null;function za(a,b,c,d){b=a.type||"unknown-event";a.currentTarget=ya(d);na(b,c,void 0,a);a.currentTarget=null}function Aa(a,b){null==b?r("30"):void 0;if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}
function Ba(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}var Ca=null;function Da(a,b){if(a){var c=a._dispatchListeners,d=a._dispatchInstances;if(Array.isArray(c))for(var e=0;e<c.length&&!a.isPropagationStopped();e++)za(a,b,c[e],d[e]);else c&&za(a,b,c,d);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}}function Ea(a){return Da(a,!0)}function Fa(a){return Da(a,!1)}
var Ga={injectEventPluginOrder:function(a){oa?r("101"):void 0;oa=Array.prototype.slice.call(a);qa()},injectEventPluginsByName:function(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];pa.hasOwnProperty(c)&&pa[c]===d||(pa[c]?r("102",c):void 0,pa[c]=d,b=!0)}b&&qa()}};
function Ha(a,b){var c=a.stateNode;if(!c)return null;var d=wa(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":(d=!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;c&&"function"!==typeof c?r("231",b,typeof c):void 0;
return c}function Ia(a,b){null!==a&&(Ca=Aa(Ca,a));a=Ca;Ca=null;if(a&&(b?Ba(a,Ea):Ba(a,Fa),Ca?r("95"):void 0,ja))throw b=ka,ja=!1,ka=null,b;}var Ja=Math.random().toString(36).slice(2),Ka="__reactInternalInstance$"+Ja,La="__reactEventHandlers$"+Ja;function Ma(a){if(a[Ka])return a[Ka];for(;!a[Ka];)if(a.parentNode)a=a.parentNode;else return null;a=a[Ka];return 5===a.tag||6===a.tag?a:null}function Na(a){a=a[Ka];return!a||5!==a.tag&&6!==a.tag?null:a}
function Oa(a){if(5===a.tag||6===a.tag)return a.stateNode;r("33")}function Pa(a){return a[La]||null}function Qa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function Ra(a,b,c){if(b=Ha(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=Aa(c._dispatchListeners,b),c._dispatchInstances=Aa(c._dispatchInstances,a)}
function Sa(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=Qa(b);for(b=c.length;0<b--;)Ra(c[b],"captured",a);for(b=0;b<c.length;b++)Ra(c[b],"bubbled",a)}}function Ta(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=Ha(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=Aa(c._dispatchListeners,b),c._dispatchInstances=Aa(c._dispatchInstances,a))}function Va(a){a&&a.dispatchConfig.registrationName&&Ta(a._targetInst,null,a)}
function Wa(a){Ba(a,Sa)}var Xa=!("undefined"===typeof window||!window.document||!window.document.createElement);function Ya(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}var Za={animationend:Ya("Animation","AnimationEnd"),animationiteration:Ya("Animation","AnimationIteration"),animationstart:Ya("Animation","AnimationStart"),transitionend:Ya("Transition","TransitionEnd")},$a={},ab={};
Xa&&(ab=document.createElement("div").style,"AnimationEvent"in window||(delete Za.animationend.animation,delete Za.animationiteration.animation,delete Za.animationstart.animation),"TransitionEvent"in window||delete Za.transitionend.transition);function bb(a){if($a[a])return $a[a];if(!Za[a])return a;var b=Za[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in ab)return $a[a]=b[c];return a}
var cb=bb("animationend"),db=bb("animationiteration"),eb=bb("animationstart"),fb=bb("transitionend"),gb="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),hb=null,ib=null,jb=null;
function kb(){if(jb)return jb;var a,b=ib,c=b.length,d,e="value"in hb?hb.value:hb.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return jb=e.slice(a,1<d?1-d:void 0)}function lb(){return!0}function mb(){return!1}
function u(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?lb:mb;this.isPropagationStopped=mb;return this}
n(u.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=lb)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=lb)},persist:function(){this.isPersistent=lb},isPersistent:mb,destructor:function(){var a=this.constructor.Interface,
b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=mb;this._dispatchInstances=this._dispatchListeners=null}});u.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||Date.now()},defaultPrevented:null,isTrusted:null};
u.extend=function(a){function b(){}function c(){return d.apply(this,arguments)}var d=this;b.prototype=d.prototype;var e=new b;n(e,c.prototype);c.prototype=e;c.prototype.constructor=c;c.Interface=n({},d.Interface,a);c.extend=d.extend;nb(c);return c};nb(u);function ob(a,b,c,d){if(this.eventPool.length){var e=this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function pb(a){a instanceof this?void 0:r("279");a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}
function nb(a){a.eventPool=[];a.getPooled=ob;a.release=pb}var qb=u.extend({data:null}),rb=u.extend({data:null}),yb=[9,13,27,32],zb=Xa&&"CompositionEvent"in window,Ab=null;Xa&&"documentMode"in document&&(Ab=document.documentMode);
var Bb=Xa&&"TextEvent"in window&&!Ab,Cb=Xa&&(!zb||Ab&&8<Ab&&11>=Ab),Db=String.fromCharCode(32),Eb={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",
captured:"onCompositionStartCapture"},dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},Fb=!1;
function Gb(a,b){switch(a){case "keyup":return-1!==yb.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function Hb(a){a=a.detail;return"object"===typeof a&&"data"in a?a.data:null}var Ib=!1;function Jb(a,b){switch(a){case "compositionend":return Hb(b);case "keypress":if(32!==b.which)return null;Fb=!0;return Db;case "textInput":return a=b.data,a===Db&&Fb?null:a;default:return null}}
function Kb(a,b){if(Ib)return"compositionend"===a||!zb&&Gb(a,b)?(a=kb(),jb=ib=hb=null,Ib=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;case "compositionend":return Cb&&"ko"!==b.locale?null:b.data;default:return null}}
var Lb={eventTypes:Eb,extractEvents:function(a,b,c,d){var e=void 0;var f=void 0;if(zb)b:{switch(a){case "compositionstart":e=Eb.compositionStart;break b;case "compositionend":e=Eb.compositionEnd;break b;case "compositionupdate":e=Eb.compositionUpdate;break b}e=void 0}else Ib?Gb(a,c)&&(e=Eb.compositionEnd):"keydown"===a&&229===c.keyCode&&(e=Eb.compositionStart);e?(Cb&&"ko"!==c.locale&&(Ib||e!==Eb.compositionStart?e===Eb.compositionEnd&&Ib&&(f=kb()):(hb=d,ib="value"in hb?hb.value:hb.textContent,Ib=
!0)),e=qb.getPooled(e,b,c,d),f?e.data=f:(f=Hb(c),null!==f&&(e.data=f)),Wa(e),f=e):f=null;(a=Bb?Jb(a,c):Kb(a,c))?(b=rb.getPooled(Eb.beforeInput,b,c,d),b.data=a,Wa(b)):b=null;return null===f?b:null===b?f:[f,b]}},Mb=null,Nb=null,Ob=null;function Pb(a){if(a=xa(a)){"function"!==typeof Mb?r("280"):void 0;var b=wa(a.stateNode);Mb(a.stateNode,a.type,b)}}function Qb(a){Nb?Ob?Ob.push(a):Ob=[a]:Nb=a}function Rb(){if(Nb){var a=Nb,b=Ob;Ob=Nb=null;Pb(a);if(b)for(a=0;a<b.length;a++)Pb(b[a])}}
function Sb(a,b){return a(b)}function Tb(a,b,c){return a(b,c)}function Ub(){}var Vb=!1;function Wb(a,b){if(Vb)return a(b);Vb=!0;try{return Sb(a,b)}finally{if(Vb=!1,null!==Nb||null!==Ob)Ub(),Rb()}}var Xb={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function Yb(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Xb[a.type]:"textarea"===b?!0:!1}
function ac(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:a}function bc(a){if(!Xa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function cc(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}
function dc(a){var b=cc(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=
null;delete a[b]}}}}function ec(a){a._valueTracker||(a._valueTracker=dc(a))}function jc(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=cc(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}
var kc=aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,lc=/^(.*)[\\\/]/,z="function"===typeof Symbol&&Symbol.for,mc=z?Symbol.for("react.element"):60103,nc=z?Symbol.for("react.portal"):60106,oc=z?Symbol.for("react.fragment"):60107,pc=z?Symbol.for("react.strict_mode"):60108,qc=z?Symbol.for("react.profiler"):60114,rc=z?Symbol.for("react.provider"):60109,sc=z?Symbol.for("react.context"):60110,tc=z?Symbol.for("react.concurrent_mode"):60111,uc=z?Symbol.for("react.forward_ref"):60112,vc=z?Symbol.for("react.suspense"):
60113,wc=z?Symbol.for("react.memo"):60115,xc=z?Symbol.for("react.lazy"):60116,yc="function"===typeof Symbol&&Symbol.iterator;function zc(a){if(null===a||"object"!==typeof a)return null;a=yc&&a[yc]||a["@@iterator"];return"function"===typeof a?a:null}
function Ac(a){if(null==a)return null;if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case tc:return"ConcurrentMode";case oc:return"Fragment";case nc:return"Portal";case qc:return"Profiler";case pc:return"StrictMode";case vc:return"Suspense"}if("object"===typeof a)switch(a.$$typeof){case sc:return"Context.Consumer";case rc:return"Context.Provider";case uc:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+
")":"ForwardRef");case wc:return Ac(a.type);case xc:if(a=1===a._status?a._result:null)return Ac(a)}return null}function Bc(a){var b="";do{a:switch(a.tag){case 2:case 16:case 0:case 1:case 5:case 8:var c=a._debugOwner,d=a._debugSource,e=Ac(a.type);var f=null;c&&(f=Ac(c.type));c=e;e="";d?e=" (at "+d.fileName.replace(lc,"")+":"+d.lineNumber+")":f&&(e=" (created by "+f+")");f="\n    in "+(c||"Unknown")+e;break a;default:f=""}b+=f;a=a.return}while(a);return b}
var Cc=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,Dc=Object.prototype.hasOwnProperty,Ec={},Fc={};
function Gc(a){if(Dc.call(Fc,a))return!0;if(Dc.call(Ec,a))return!1;if(Cc.test(a))return Fc[a]=!0;Ec[a]=!0;return!1}function Hc(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}
function Ic(a,b,c,d){if(null===b||"undefined"===typeof b||Hc(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function C(a,b,c,d,e){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b}var D={};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){D[a]=new C(a,0,!1,a,null)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];D[b]=new C(b,1,!1,a[1],null)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){D[a]=new C(a,2,!1,a.toLowerCase(),null)});
["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){D[a]=new C(a,2,!1,a,null)});"allowFullScreen async autoFocus autoPlay controls default defer disabled formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){D[a]=new C(a,3,!1,a.toLowerCase(),null)});["checked","multiple","muted","selected"].forEach(function(a){D[a]=new C(a,3,!0,a,null)});
["capture","download"].forEach(function(a){D[a]=new C(a,4,!1,a,null)});["cols","rows","size","span"].forEach(function(a){D[a]=new C(a,6,!1,a,null)});["rowSpan","start"].forEach(function(a){D[a]=new C(a,5,!1,a.toLowerCase(),null)});var Jc=/[\-:]([a-z])/g;function Kc(a){return a[1].toUpperCase()}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=a.replace(Jc,
Kc);D[b]=new C(b,1,!1,a,null)});"xlink:actuate xlink:arcrole xlink:href xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(Jc,Kc);D[b]=new C(b,1,!1,a,"http://www.w3.org/1999/xlink")});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(Jc,Kc);D[b]=new C(b,1,!1,a,"http://www.w3.org/XML/1998/namespace")});D.tabIndex=new C("tabIndex",1,!1,"tabindex",null);
function Lc(a,b,c,d){var e=D.hasOwnProperty(b)?D[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(Ic(b,c,e,d)&&(c=null),d||null===e?Gc(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}
function Mc(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;default:return""}}function Nc(a,b){var c=b.checked;return n({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=c?c:a._wrapperState.initialChecked})}
function Oc(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=Mc(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function Pc(a,b){b=b.checked;null!=b&&Lc(a,"checked",b,!1)}
function Qc(a,b){Pc(a,b);var c=Mc(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Rc(a,b.type,c):b.hasOwnProperty("defaultValue")&&Rc(a,b.type,Mc(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}
function Sc(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!a.defaultChecked;a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}
function Rc(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}var Tc={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}};function Uc(a,b,c){a=u.getPooled(Tc.change,a,b,c);a.type="change";Qb(c);Wa(a);return a}var Vc=null,Wc=null;function Xc(a){Ia(a,!1)}
function Yc(a){var b=Oa(a);if(jc(b))return a}function bd(a,b){if("change"===a)return b}var cd=!1;Xa&&(cd=bc("input")&&(!document.documentMode||9<document.documentMode));function dd(){Vc&&(Vc.detachEvent("onpropertychange",ed),Wc=Vc=null)}function ed(a){"value"===a.propertyName&&Yc(Wc)&&(a=Uc(Wc,a,ac(a)),Wb(Xc,a))}function fd(a,b,c){"focus"===a?(dd(),Vc=b,Wc=c,Vc.attachEvent("onpropertychange",ed)):"blur"===a&&dd()}function gd(a){if("selectionchange"===a||"keyup"===a||"keydown"===a)return Yc(Wc)}
function hd(a,b){if("click"===a)return Yc(b)}function id(a,b){if("input"===a||"change"===a)return Yc(b)}
var jd={eventTypes:Tc,_isInputEventSupported:cd,extractEvents:function(a,b,c,d){var e=b?Oa(b):window,f=void 0,g=void 0,h=e.nodeName&&e.nodeName.toLowerCase();"select"===h||"input"===h&&"file"===e.type?f=bd:Yb(e)?cd?f=id:(f=gd,g=fd):(h=e.nodeName)&&"input"===h.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(f=hd);if(f&&(f=f(a,b)))return Uc(f,c,d);g&&g(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Rc(e,"number",e.value)}},kd=u.extend({view:null,detail:null}),ld={Alt:"altKey",
Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function td(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=ld[a])?!!b[a]:!1}function ud(){return td}
var vd=0,wd=0,xd=!1,yd=!1,zd=kd.extend({screenX:null,screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:ud,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=vd;vd=a.screenX;return xd?"mousemove"===a.type?a.screenX-b:0:(xd=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;
var b=wd;wd=a.screenY;return yd?"mousemove"===a.type?a.screenY-b:0:(yd=!0,0)}}),Ad=zd.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),Bd={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",
dependencies:["pointerout","pointerover"]}},Cd={eventTypes:Bd,extractEvents:function(a,b,c,d){var e="mouseover"===a||"pointerover"===a,f="mouseout"===a||"pointerout"===a;if(e&&(c.relatedTarget||c.fromElement)||!f&&!e)return null;e=d.window===d?d:(e=d.ownerDocument)?e.defaultView||e.parentWindow:window;f?(f=b,b=(b=c.relatedTarget||c.toElement)?Ma(b):null):f=null;if(f===b)return null;var g=void 0,h=void 0,k=void 0,l=void 0;if("mouseout"===a||"mouseover"===a)g=zd,h=Bd.mouseLeave,k=Bd.mouseEnter,l="mouse";
else if("pointerout"===a||"pointerover"===a)g=Ad,h=Bd.pointerLeave,k=Bd.pointerEnter,l="pointer";var m=null==f?e:Oa(f);e=null==b?e:Oa(b);a=g.getPooled(h,f,c,d);a.type=l+"leave";a.target=m;a.relatedTarget=e;c=g.getPooled(k,b,c,d);c.type=l+"enter";c.target=e;c.relatedTarget=m;d=b;if(f&&d)a:{b=f;e=d;l=0;for(g=b;g;g=Qa(g))l++;g=0;for(k=e;k;k=Qa(k))g++;for(;0<l-g;)b=Qa(b),l--;for(;0<g-l;)e=Qa(e),g--;for(;l--;){if(b===e||b===e.alternate)break a;b=Qa(b);e=Qa(e)}b=null}else b=null;e=b;for(b=[];f&&f!==e;){l=
f.alternate;if(null!==l&&l===e)break;b.push(f);f=Qa(f)}for(f=[];d&&d!==e;){l=d.alternate;if(null!==l&&l===e)break;f.push(d);d=Qa(d)}for(d=0;d<b.length;d++)Ta(b[d],"bubbled",a);for(d=f.length;0<d--;)Ta(f[d],"captured",c);return[a,c]}},Dd=Object.prototype.hasOwnProperty;function Ed(a,b){return a===b?0!==a||0!==b||1/a===1/b:a!==a&&b!==b}
function Fd(a,b){if(Ed(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!Dd.call(b,c[d])||!Ed(a[c[d]],b[c[d]]))return!1;return!0}function Gd(a){var b=a;if(a.alternate)for(;b.return;)b=b.return;else{if(0!==(b.effectTag&2))return 1;for(;b.return;)if(b=b.return,0!==(b.effectTag&2))return 1}return 3===b.tag?2:3}function Hd(a){2!==Gd(a)?r("188"):void 0}
function Id(a){var b=a.alternate;if(!b)return b=Gd(a),3===b?r("188"):void 0,1===b?null:a;for(var c=a,d=b;;){var e=c.return,f=e?e.alternate:null;if(!e||!f)break;if(e.child===f.child){for(var g=e.child;g;){if(g===c)return Hd(e),a;if(g===d)return Hd(e),b;g=g.sibling}r("188")}if(c.return!==d.return)c=e,d=f;else{g=!1;for(var h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}g?
void 0:r("189")}}c.alternate!==d?r("190"):void 0}3!==c.tag?r("188"):void 0;return c.stateNode.current===c?a:b}function Jd(a){a=Id(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}
var Kd=u.extend({animationName:null,elapsedTime:null,pseudoElement:null}),Ld=u.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),Md=kd.extend({relatedTarget:null});function Nd(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}
var Od={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},Pd={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",
116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},Qd=kd.extend({key:function(a){if(a.key){var b=Od[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Nd(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?Pd[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:ud,charCode:function(a){return"keypress"===
a.type?Nd(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===a.type?Nd(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),Rd=zd.extend({dataTransfer:null}),Sd=kd.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:ud}),Td=u.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),Ud=zd.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in
a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?-a.wheelDelta:0},deltaZ:null,deltaMode:null}),Vd=[["abort","abort"],[cb,"animationEnd"],[db,"animationIteration"],[eb,"animationStart"],["canplay","canPlay"],["canplaythrough","canPlayThrough"],["drag","drag"],["dragenter","dragEnter"],["dragexit","dragExit"],["dragleave","dragLeave"],["dragover","dragOver"],["durationchange","durationChange"],["emptied","emptied"],["encrypted","encrypted"],
["ended","ended"],["error","error"],["gotpointercapture","gotPointerCapture"],["load","load"],["loadeddata","loadedData"],["loadedmetadata","loadedMetadata"],["loadstart","loadStart"],["lostpointercapture","lostPointerCapture"],["mousemove","mouseMove"],["mouseout","mouseOut"],["mouseover","mouseOver"],["playing","playing"],["pointermove","pointerMove"],["pointerout","pointerOut"],["pointerover","pointerOver"],["progress","progress"],["scroll","scroll"],["seeking","seeking"],["stalled","stalled"],
["suspend","suspend"],["timeupdate","timeUpdate"],["toggle","toggle"],["touchmove","touchMove"],[fb,"transitionEnd"],["waiting","waiting"],["wheel","wheel"]],Wd={},Xd={};function Yd(a,b){var c=a[0];a=a[1];var d="on"+(a[0].toUpperCase()+a.slice(1));b={phasedRegistrationNames:{bubbled:d,captured:d+"Capture"},dependencies:[c],isInteractive:b};Wd[a]=b;Xd[c]=b}
[["blur","blur"],["cancel","cancel"],["click","click"],["close","close"],["contextmenu","contextMenu"],["copy","copy"],["cut","cut"],["auxclick","auxClick"],["dblclick","doubleClick"],["dragend","dragEnd"],["dragstart","dragStart"],["drop","drop"],["focus","focus"],["input","input"],["invalid","invalid"],["keydown","keyDown"],["keypress","keyPress"],["keyup","keyUp"],["mousedown","mouseDown"],["mouseup","mouseUp"],["paste","paste"],["pause","pause"],["play","play"],["pointercancel","pointerCancel"],
["pointerdown","pointerDown"],["pointerup","pointerUp"],["ratechange","rateChange"],["reset","reset"],["seeked","seeked"],["submit","submit"],["touchcancel","touchCancel"],["touchend","touchEnd"],["touchstart","touchStart"],["volumechange","volumeChange"]].forEach(function(a){Yd(a,!0)});Vd.forEach(function(a){Yd(a,!1)});
var Zd={eventTypes:Wd,isInteractiveTopLevelEventType:function(a){a=Xd[a];return void 0!==a&&!0===a.isInteractive},extractEvents:function(a,b,c,d){var e=Xd[a];if(!e)return null;switch(a){case "keypress":if(0===Nd(c))return null;case "keydown":case "keyup":a=Qd;break;case "blur":case "focus":a=Md;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=zd;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
Rd;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=Sd;break;case cb:case db:case eb:a=Kd;break;case fb:a=Td;break;case "scroll":a=kd;break;case "wheel":a=Ud;break;case "copy":case "cut":case "paste":a=Ld;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=Ad;break;default:a=u}b=a.getPooled(e,b,c,d);Wa(b);return b}},$d=Zd.isInteractiveTopLevelEventType,
ae=[];function be(a){var b=a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d;for(d=c;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo;if(!d)break;a.ancestors.push(c);c=Ma(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=ac(a.nativeEvent);d=a.topLevelType;for(var f=a.nativeEvent,g=null,h=0;h<ra.length;h++){var k=ra[h];k&&(k=k.extractEvents(d,b,f,e))&&(g=Aa(g,k))}Ia(g,!1)}}var ce=!0;
function G(a,b){if(!b)return null;var c=($d(a)?de:ee).bind(null,a);b.addEventListener(a,c,!1)}function fe(a,b){if(!b)return null;var c=($d(a)?de:ee).bind(null,a);b.addEventListener(a,c,!0)}function de(a,b){Tb(ee,a,b)}
function ee(a,b){if(ce){var c=ac(b);c=Ma(c);null===c||"number"!==typeof c.tag||2===Gd(c)||(c=null);if(ae.length){var d=ae.pop();d.topLevelType=a;d.nativeEvent=b;d.targetInst=c;a=d}else a={topLevelType:a,nativeEvent:b,targetInst:c,ancestors:[]};try{Wb(be,a)}finally{a.topLevelType=null,a.nativeEvent=null,a.targetInst=null,a.ancestors.length=0,10>ae.length&&ae.push(a)}}}var ge={},he=0,ie="_reactListenersID"+(""+Math.random()).slice(2);
function je(a){Object.prototype.hasOwnProperty.call(a,ie)||(a[ie]=he++,ge[a[ie]]={});return ge[a[ie]]}function ke(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function le(a){for(;a&&a.firstChild;)a=a.firstChild;return a}
function me(a,b){var c=le(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=le(c)}}function ne(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?ne(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}
function oe(){for(var a=window,b=ke();b instanceof a.HTMLIFrameElement;){try{a=b.contentDocument.defaultView}catch(c){break}b=ke(a.document)}return b}function pe(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}
var qe=Xa&&"documentMode"in document&&11>=document.documentMode,re={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},se=null,te=null,ue=null,ve=!1;
function we(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ve||null==se||se!==ke(c))return null;c=se;"selectionStart"in c&&pe(c)?c={start:c.selectionStart,end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return ue&&Fd(ue,c)?null:(ue=c,a=u.getPooled(re.select,te,a,b),a.type="select",a.target=se,Wa(a),a)}
var xe={eventTypes:re,extractEvents:function(a,b,c,d){var e=d.window===d?d.document:9===d.nodeType?d:d.ownerDocument,f;if(!(f=!e)){a:{e=je(e);f=va.onSelect;for(var g=0;g<f.length;g++){var h=f[g];if(!e.hasOwnProperty(h)||!e[h]){e=!1;break a}}e=!0}f=!e}if(f)return null;e=b?Oa(b):window;switch(a){case "focus":if(Yb(e)||"true"===e.contentEditable)se=e,te=b,ue=null;break;case "blur":ue=te=se=null;break;case "mousedown":ve=!0;break;case "contextmenu":case "mouseup":case "dragend":return ve=!1,we(c,d);case "selectionchange":if(qe)break;
case "keydown":case "keyup":return we(c,d)}return null}};Ga.injectEventPluginOrder("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));wa=Pa;xa=Na;ya=Oa;Ga.injectEventPluginsByName({SimpleEventPlugin:Zd,EnterLeaveEventPlugin:Cd,ChangeEventPlugin:jd,SelectEventPlugin:xe,BeforeInputEventPlugin:Lb});function ye(a){var b="";aa.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}
function ze(a,b){a=n({children:void 0},b);if(b=ye(b.children))a.children=b;return a}function Ae(a,b,c,d){a=a.options;if(b){b={};for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+Mc(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}
function Be(a,b){null!=b.dangerouslySetInnerHTML?r("91"):void 0;return n({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}function De(a,b){var c=b.value;null==c&&(c=b.defaultValue,b=b.children,null!=b&&(null!=c?r("92"):void 0,Array.isArray(b)&&(1>=b.length?void 0:r("93"),b=b[0]),c=b),null==c&&(c=""));a._wrapperState={initialValue:Mc(c)}}
function Ee(a,b){var c=Mc(b.value),d=Mc(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Fe(a){var b=a.textContent;b===a._wrapperState.initialValue&&(a.value=b)}var Ge={html:"http://www.w3.org/1999/xhtml",mathml:"http://www.w3.org/1998/Math/MathML",svg:"http://www.w3.org/2000/svg"};
function He(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Ie(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?He(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}
var Je=void 0,Ke=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if(a.namespaceURI!==Ge.svg||"innerHTML"in a)a.innerHTML=b;else{Je=Je||document.createElement("div");Je.innerHTML="<svg>"+b+"</svg>";for(b=Je.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}});
function Le(a,b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b}
var Me={animationIterationCount:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,
floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Ne=["Webkit","ms","Moz","O"];Object.keys(Me).forEach(function(a){Ne.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Me[b]=Me[a]})});
function Oe(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--");var e=c;var f=b[c];e=null==f||"boolean"===typeof f||""===f?"":d||"number"!==typeof f||0===f||Me.hasOwnProperty(e)&&Me[e]?(""+f).trim():f+"px";"float"===c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}var Pe=n({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});
function Qe(a,b){b&&(Pe[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML?r("137",a,""):void 0),null!=b.dangerouslySetInnerHTML&&(null!=b.children?r("60"):void 0,"object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML?void 0:r("61")),null!=b.style&&"object"!==typeof b.style?r("62",""):void 0)}
function Re(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;default:return!0}}
function Se(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=je(a);b=va[b];for(var d=0;d<b.length;d++){var e=b[d];if(!c.hasOwnProperty(e)||!c[e]){switch(e){case "scroll":fe("scroll",a);break;case "focus":case "blur":fe("focus",a);fe("blur",a);c.blur=!0;c.focus=!0;break;case "cancel":case "close":bc(e)&&fe(e,a);break;case "invalid":case "submit":case "reset":break;default:-1===gb.indexOf(e)&&G(e,a)}c[e]=!0}}}function Te(){}var Ue=null,lf=null;
function mf(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function nf(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}var of=setTimeout,pf=clearTimeout;function qf(a){for(a=a.nextSibling;a&&1!==a.nodeType&&3!==a.nodeType;)a=a.nextSibling;return a}
function rf(a){for(a=a.firstChild;a&&1!==a.nodeType&&3!==a.nodeType;)a=a.nextSibling;return a}new Set;var sf=[],tf=-1;function I(a){0>tf||(a.current=sf[tf],sf[tf]=null,tf--)}function J(a,b){tf++;sf[tf]=a.current;a.current=b}var uf={},K={current:uf},L={current:!1},vf=uf;
function wf(a,b){var c=a.type.contextTypes;if(!c)return uf;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function M(a){a=a.childContextTypes;return null!==a&&void 0!==a}function xf(a){I(L,a);I(K,a)}function yf(a){I(L,a);I(K,a)}
function zf(a,b,c){K.current!==uf?r("168"):void 0;J(K,b,a);J(L,c,a)}function Af(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)e in a?void 0:r("108",Ac(b)||"Unknown",e);return n({},c,d)}function Bf(a){var b=a.stateNode;b=b&&b.__reactInternalMemoizedMergedChildContext||uf;vf=K.current;J(K,b,a);J(L,L.current,a);return!0}
function Cf(a,b,c){var d=a.stateNode;d?void 0:r("169");c?(b=Af(a,b,vf),d.__reactInternalMemoizedMergedChildContext=b,I(L,a),I(K,a),J(K,b,a)):I(L,a);J(L,c,a)}var Df=null,Ef=null;function Ff(a){return function(b){try{return a(b)}catch(c){}}}
function Gf(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=b.inject(a);Df=Ff(function(a){return b.onCommitFiberRoot(c,a)});Ef=Ff(function(a){return b.onCommitFiberUnmount(c,a)})}catch(d){}return!0}
function Hf(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.firstContextDependency=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function N(a,b,c,d){return new Hf(a,b,c,d)}
function If(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Jf(a){if("function"===typeof a)return If(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===uc)return 11;if(a===wc)return 14}return 2}
function Kf(a,b){var c=a.alternate;null===c?(c=N(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;c.firstContextDependency=a.firstContextDependency;c.sibling=a.sibling;
c.index=a.index;c.ref=a.ref;return c}
function Lf(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)If(a)&&(g=1);else if("string"===typeof a)g=5;else a:switch(a){case oc:return Mf(c.children,e,f,b);case tc:return Nf(c,e|3,f,b);case pc:return Nf(c,e|2,f,b);case qc:return a=N(12,c,b,e|4),a.elementType=qc,a.type=qc,a.expirationTime=f,a;case vc:return a=N(13,c,b,e),a.elementType=vc,a.type=vc,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case rc:g=10;break a;case sc:g=9;break a;case uc:g=11;break a;case wc:g=
14;break a;case xc:g=16;d=null;break a}r("130",null==a?a:typeof a,"")}b=N(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Mf(a,b,c,d){a=N(7,a,d,b);a.expirationTime=c;return a}function Nf(a,b,c,d){a=N(8,a,d,b);b=0===(b&1)?pc:tc;a.elementType=b;a.type=b;a.expirationTime=c;return a}function Of(a,b,c){a=N(6,a,null,b);a.expirationTime=c;return a}
function Pf(a,b,c){b=N(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Qf(a,b){a.didError=!1;var c=a.earliestPendingTime;0===c?a.earliestPendingTime=a.latestPendingTime=b:c>b?a.earliestPendingTime=b:a.latestPendingTime<b&&(a.latestPendingTime=b);Rf(b,a)}
function Sf(a,b){a.didError=!1;var c=a.latestPingedTime;0!==c&&c<=b&&(a.latestPingedTime=0);c=a.earliestPendingTime;var d=a.latestPendingTime;c===b?a.earliestPendingTime=d===b?a.latestPendingTime=0:d:d===b&&(a.latestPendingTime=c);c=a.earliestSuspendedTime;d=a.latestSuspendedTime;0===c?a.earliestSuspendedTime=a.latestSuspendedTime=b:c>b?a.earliestSuspendedTime=b:d<b&&(a.latestSuspendedTime=b);Rf(b,a)}
function Tf(a,b){var c=a.earliestPendingTime;a=a.earliestSuspendedTime;if(0===b||0!==c&&c<b)b=c;if(0===b||0!==a&&a<b)b=a;return b}function Rf(a,b){var c=b.earliestSuspendedTime,d=b.latestSuspendedTime,e=b.earliestPendingTime,f=b.latestPingedTime;e=0!==e?e:f;0===e&&(0===a||d>a)&&(e=d);a=e;0!==a&&0!==c&&c<a&&(a=c);b.nextExpirationTimeToWorkOn=e;b.expirationTime=a}var Uf=!1;
function Vf(a){return{baseState:a,firstUpdate:null,lastUpdate:null,firstCapturedUpdate:null,lastCapturedUpdate:null,firstEffect:null,lastEffect:null,firstCapturedEffect:null,lastCapturedEffect:null}}function Wf(a){return{baseState:a.baseState,firstUpdate:a.firstUpdate,lastUpdate:a.lastUpdate,firstCapturedUpdate:null,lastCapturedUpdate:null,firstEffect:null,lastEffect:null,firstCapturedEffect:null,lastCapturedEffect:null}}
function Xf(a){return{expirationTime:a,tag:0,payload:null,callback:null,next:null,nextEffect:null}}function Yf(a,b){null===a.lastUpdate?a.firstUpdate=a.lastUpdate=b:(a.lastUpdate.next=b,a.lastUpdate=b)}
function Zf(a,b){var c=a.alternate;if(null===c){var d=a.updateQueue;var e=null;null===d&&(d=a.updateQueue=Vf(a.memoizedState))}else d=a.updateQueue,e=c.updateQueue,null===d?null===e?(d=a.updateQueue=Vf(a.memoizedState),e=c.updateQueue=Vf(c.memoizedState)):d=a.updateQueue=Wf(e):null===e&&(e=c.updateQueue=Wf(d));null===e||d===e?Yf(d,b):null===d.lastUpdate||null===e.lastUpdate?(Yf(d,b),Yf(e,b)):(Yf(d,b),e.lastUpdate=b)}
function $f(a,b){var c=a.updateQueue;c=null===c?a.updateQueue=Vf(a.memoizedState):ag(a,c);null===c.lastCapturedUpdate?c.firstCapturedUpdate=c.lastCapturedUpdate=b:(c.lastCapturedUpdate.next=b,c.lastCapturedUpdate=b)}function ag(a,b){var c=a.alternate;null!==c&&b===c.updateQueue&&(b=a.updateQueue=Wf(b));return b}
function bg(a,b,c,d,e,f){switch(c.tag){case 1:return a=c.payload,"function"===typeof a?a.call(f,d,e):a;case 3:a.effectTag=a.effectTag&-2049|64;case 0:a=c.payload;e="function"===typeof a?a.call(f,d,e):a;if(null===e||void 0===e)break;return n({},d,e);case 2:Uf=!0}return d}
function cg(a,b,c,d,e){Uf=!1;b=ag(a,b);for(var f=b.baseState,g=null,h=0,k=b.firstUpdate,l=f;null!==k;){var m=k.expirationTime;if(m>e){if(null===g&&(g=k,f=l),0===h||h>m)h=m}else l=bg(a,b,k,l,c,d),null!==k.callback&&(a.effectTag|=32,k.nextEffect=null,null===b.lastEffect?b.firstEffect=b.lastEffect=k:(b.lastEffect.nextEffect=k,b.lastEffect=k));k=k.next}m=null;for(k=b.firstCapturedUpdate;null!==k;){var p=k.expirationTime;if(p>e){if(null===m&&(m=k,null===g&&(f=l)),0===h||h>p)h=p}else l=bg(a,b,k,l,c,d),
null!==k.callback&&(a.effectTag|=32,k.nextEffect=null,null===b.lastCapturedEffect?b.firstCapturedEffect=b.lastCapturedEffect=k:(b.lastCapturedEffect.nextEffect=k,b.lastCapturedEffect=k));k=k.next}null===g&&(b.lastUpdate=null);null===m?b.lastCapturedUpdate=null:a.effectTag|=32;null===g&&null===m&&(f=l);b.baseState=f;b.firstUpdate=g;b.firstCapturedUpdate=m;a.expirationTime=h;a.memoizedState=l}
function dg(a,b,c){null!==b.firstCapturedUpdate&&(null!==b.lastUpdate&&(b.lastUpdate.next=b.firstCapturedUpdate,b.lastUpdate=b.lastCapturedUpdate),b.firstCapturedUpdate=b.lastCapturedUpdate=null);eg(b.firstEffect,c);b.firstEffect=b.lastEffect=null;eg(b.firstCapturedEffect,c);b.firstCapturedEffect=b.lastCapturedEffect=null}function eg(a,b){for(;null!==a;){var c=a.callback;if(null!==c){a.callback=null;var d=b;"function"!==typeof c?r("191",c):void 0;c.call(d)}a=a.nextEffect}}
function fg(a,b){return{value:a,source:b,stack:Bc(b)}}var gg={current:null},hg=null,ig=null,jg=null;function kg(a,b){var c=a.type._context;J(gg,c._currentValue,a);c._currentValue=b}function lg(a){var b=gg.current;I(gg,a);a.type._context._currentValue=b}function mg(a){hg=a;jg=ig=null;a.firstContextDependency=null}
function ng(a,b){if(jg!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)jg=a,b=1073741823;b={context:a,observedBits:b,next:null};null===ig?(null===hg?r("293"):void 0,hg.firstContextDependency=ig=b):ig=ig.next=b}return a._currentValue}var og=0,O=null,pg=null,P=null,qg=null,Q=null,rg=0,R=null,sg=!1,tg=!1,ug=null,vg=0;function wg(){null===O?r("298"):void 0;return O}
function xg(a,b,c,d){for(;tg;)tg=!1,vg+=1,R=Q=P=null,c=a(b,d);ug=null;vg=0;a=O;a.memoizedState=qg;a.expirationTime=rg;a.updateQueue=R;a=null!==P&&null!==P.next;og=0;Q=qg=P=pg=O=null;rg=0;R=null;a?r("299"):void 0;return c}function yg(){og=0;Q=qg=P=pg=O=null;rg=0;R=null;tg=!1;ug=null;vg=0}function zg(){return{memoizedState:null,baseState:null,queue:null,baseUpdate:null,next:null}}
function Ag(a){return{memoizedState:a.memoizedState,baseState:a.memoizedState,queue:a.queue,baseUpdate:a.baseUpdate,next:null}}function Bg(){if(null===Q)null===qg?(sg=!1,P=pg,qg=Q=null===P?zg():Ag(P)):(sg=!0,P=pg,Q=qg);else if(null===Q.next){sg=!1;if(null===P)var a=zg();else P=P.next,a=null===P?zg():Ag(P);Q=Q.next=a}else sg=!0,Q=Q.next,P=null!==P?P.next:null;return Q}function Cg(a,b){return"function"===typeof b?b(a):b}
function Dg(a,b,c){O=wg();Q=Bg();var d=Q.queue;if(null!==d){if(sg){b=d.dispatch;if(null!==ug){var e=ug.get(d);if(void 0!==e){ug.delete(d);c=Q.memoizedState;do c=a(c,e.action),null!==e.callback&&Eg(O,e),e=e.next;while(null!==e);Q.memoizedState=c;Q.baseUpdate===d.last&&(Q.baseState=c);return[c,b]}}return[Q.memoizedState,b]}b=d.last;var f=Q.baseUpdate;null!==f?(null!==b&&(b.next=null),b=f.next):b=null!==b?b.next:null;if(null!==b){c=Q.baseState;var g=e=null,h=b,k=!1;do{var l=h.expirationTime;if(l>og){if(k||
(k=!0,g=f,e=c),0===rg||l<rg)rg=l}else c=a(c,h.action),null!==h.callback&&Eg(O,h);f=h;h=h.next}while(null!==h&&h!==b);k||(g=f,e=c);Q.memoizedState=c;Q.baseUpdate=g;Q.baseState=e}return[Q.memoizedState,d.dispatch]}a===Cg?"function"===typeof b&&(b=b()):void 0!==c&&null!==c&&(b=a(b,c));Q.memoizedState=Q.baseState=b;d=Q.queue={last:null,dispatch:null};a=d.dispatch=Fg.bind(null,O,d);return[Q.memoizedState,a]}
function Eg(a,b){if(null===R)R={callbackList:null,lastEffect:null},R.callbackList=[b];else{var c=R.callbackList;null===c?R.callbackList=[b]:c.push(b)}a.effectTag|=32}function Gg(a,b,c,d){a={tag:a,create:b,destroy:c,inputs:d,next:null};null===R?(R={callbackList:null,lastEffect:null},R.lastEffect=a.next=a):(b=R.lastEffect,null===b?R.lastEffect=a.next=a:(c=b.next,b.next=a,a.next=c,R.lastEffect=a));return a}
function Hg(a,b,c,d){O=wg();Q=Bg();d=void 0!==d&&null!==d?d:[c];var e=null;if(null!==P){var f=P.memoizedState;e=f.destroy;if(Ig(d,f.inputs)){Gg(0,c,e,d);return}}O.effectTag|=a;Q.memoizedState=Gg(b,c,e,d)}
function Fg(a,b,c,d){d=null;25>vg?void 0:r("300");var e=a.alternate;if(a===O||null!==e&&e===O)if(tg=!0,a={expirationTime:og,action:c,callback:void 0!==d?d:null,next:null},null===ug&&(ug=new Map),e=ug.get(b),void 0===e)ug.set(b,a);else{for(b=e;null!==b.next;)b=b.next;b.next=a}else{e=Jg();e=Kg(e,a);c={expirationTime:e,action:c,callback:void 0!==d?d:null,next:null};Lg();d=b.last;if(null===d)c.next=c;else{var f=d.next;null!==f&&(c.next=f);d.next=c}b.last=c;Mg(a,e)}}
function Ig(a,b){for(var c=0;c<a.length;c++){var d=a[c],e=b[c];if((d!==e||0===d&&1/d!==1/e)&&(d===d||e===e))return!1}return!0}var Ng={},Og={current:Ng},Pg={current:Ng},Qg={current:Ng};function Rg(a){a===Ng?r("174"):void 0;return a}function Sg(a,b){J(Qg,b,a);J(Pg,a,a);J(Og,Ng,a);var c=b.nodeType;switch(c){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Ie(null,"");break;default:c=8===c?b.parentNode:b,b=c.namespaceURI||null,c=c.tagName,b=Ie(b,c)}I(Og,a);J(Og,b,a)}
function Tg(a){I(Og,a);I(Pg,a);I(Qg,a)}function Ug(a){Rg(Qg.current);var b=Rg(Og.current);var c=Ie(b,a.type);b!==c&&(J(Pg,a,a),J(Og,c,a))}function Vg(a){Pg.current===a&&(I(Og,a),I(Pg,a))}var Wg=kc.ReactCurrentOwner,Xg=(new aa.Component).refs;function Yg(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:n({},b,c);a.memoizedState=c;d=a.updateQueue;null!==d&&0===a.expirationTime&&(d.baseState=c)}
var Zg={isMounted:function(a){return(a=a._reactInternalFiber)?2===Gd(a):!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=Jg();d=Kg(d,a);var e=Xf(d);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Lg();Zf(a,e);Mg(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=Jg();d=Kg(d,a);var e=Xf(d);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Lg();Zf(a,e);Mg(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=Jg();c=Kg(c,a);var d=Xf(c);d.tag=
2;void 0!==b&&null!==b&&(d.callback=b);Lg();Zf(a,d);Mg(a,c)}};function $g(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,f,g):b.prototype&&b.prototype.isPureReactComponent?!Fd(c,d)||!Fd(e,f):!0}
function ah(a,b,c){var d=!1,e=uf;var f=b.contextType;"object"===typeof f&&null!==f?f=Wg.currentDispatcher.readContext(f):(e=M(b)?vf:K.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?wf(a,e):uf);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Zg;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}
function bh(a,b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Zg.enqueueReplaceState(b,b.state,null)}
function ch(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=Xg;var f=b.contextType;"object"===typeof f&&null!==f?e.context=Wg.currentDispatcher.readContext(f):(f=M(b)?vf:K.current,e.context=wf(a,f));f=a.updateQueue;null!==f&&(cg(a,f,c,e,d),e.state=a.memoizedState);f=b.getDerivedStateFromProps;"function"===typeof f&&(Yg(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&
"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Zg.enqueueReplaceState(e,e.state,null),f=a.updateQueue,null!==f&&(cg(a,f,c,e,d),e.state=a.memoizedState));"function"===typeof e.componentDidMount&&(a.effectTag|=4)}var dh=Array.isArray;
function eh(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;var d=void 0;c&&(1!==c.tag?r("289"):void 0,d=c.stateNode);d?void 0:r("147",a);var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===Xg&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}"string"!==typeof a?r("284"):void 0;c._owner?void 0:r("290",a)}return a}
function fh(a,b){"textarea"!==a.type&&r("31","[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,"")}
function gh(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,b),b=b.sibling;return a}function e(a,b,c){a=Kf(a,b,c);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=
2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=Of(c,a.mode,d),b.return=a,b;b=e(b,c,d);b.return=a;return b}function k(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props,d),d.ref=eh(a,b,c),d.return=a,d;d=Lf(c.type,c.key,c.props,null,a.mode,d);d.ref=eh(a,b,c);d.return=a;return d}function l(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==
c.implementation)return b=Pf(c,a.mode,d),b.return=a,b;b=e(b,c.children||[],d);b.return=a;return b}function m(a,b,c,d,f){if(null===b||7!==b.tag)return b=Mf(c,a.mode,d,f),b.return=a,b;b=e(b,c,d);b.return=a;return b}function p(a,b,c){if("string"===typeof b||"number"===typeof b)return b=Of(""+b,a.mode,c),b.return=a,b;if("object"===typeof b&&null!==b){switch(b.$$typeof){case mc:return c=Lf(b.type,b.key,b.props,null,a.mode,c),c.ref=eh(a,null,b),c.return=a,c;case nc:return b=Pf(b,a.mode,c),b.return=a,b}if(dh(b)||
zc(b))return b=Mf(b,a.mode,c,null),b.return=a,b;fh(a,b)}return null}function w(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case mc:return c.key===e?c.type===oc?m(a,b,c.props.children,d,e):k(a,b,c,d):null;case nc:return c.key===e?l(a,b,c,d):null}if(dh(c)||zc(c))return null!==e?null:m(a,b,c,d,null);fh(a,c)}return null}function E(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=
a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case mc:return a=a.get(null===d.key?c:d.key)||null,d.type===oc?m(b,a,d.props.children,e,d.key):k(b,a,d,e);case nc:return a=a.get(null===d.key?c:d.key)||null,l(b,a,d,e)}if(dh(d)||zc(d))return a=a.get(c)||null,m(b,a,d,e,null);fh(b,d)}return null}function x(e,g,h,k){for(var l=null,m=null,q=g,v=g=0,B=null;null!==q&&v<h.length;v++){q.index>v?(B=q,q=null):B=q.sibling;var t=w(e,q,h[v],k);if(null===t){null===q&&(q=B);break}a&&
q&&null===t.alternate&&b(e,q);g=f(t,g,v);null===m?l=t:m.sibling=t;m=t;q=B}if(v===h.length)return c(e,q),l;if(null===q){for(;v<h.length;v++)if(q=p(e,h[v],k))g=f(q,g,v),null===m?l=q:m.sibling=q,m=q;return l}for(q=d(e,q);v<h.length;v++)if(B=E(q,e,v,h[v],k))a&&null!==B.alternate&&q.delete(null===B.key?v:B.key),g=f(B,g,v),null===m?l=B:m.sibling=B,m=B;a&&q.forEach(function(a){return b(e,a)});return l}function F(e,g,h,k){var l=zc(h);"function"!==typeof l?r("150"):void 0;h=l.call(h);null==h?r("151"):void 0;
for(var m=l=null,q=g,v=g=0,B=null,t=h.next();null!==q&&!t.done;v++,t=h.next()){q.index>v?(B=q,q=null):B=q.sibling;var x=w(e,q,t.value,k);if(null===x){q||(q=B);break}a&&q&&null===x.alternate&&b(e,q);g=f(x,g,v);null===m?l=x:m.sibling=x;m=x;q=B}if(t.done)return c(e,q),l;if(null===q){for(;!t.done;v++,t=h.next())t=p(e,t.value,k),null!==t&&(g=f(t,g,v),null===m?l=t:m.sibling=t,m=t);return l}for(q=d(e,q);!t.done;v++,t=h.next())t=E(q,e,v,t.value,k),null!==t&&(a&&null!==t.alternate&&q.delete(null===t.key?v:
t.key),g=f(t,g,v),null===m?l=t:m.sibling=t,m=t);a&&q.forEach(function(a){return b(e,a)});return l}return function(a,d,f,h){var k="object"===typeof f&&null!==f&&f.type===oc&&null===f.key;k&&(f=f.props.children);var l="object"===typeof f&&null!==f;if(l)switch(f.$$typeof){case mc:a:{l=f.key;for(k=d;null!==k;){if(k.key===l)if(7===k.tag?f.type===oc:k.elementType===f.type){c(a,k.sibling);d=e(k,f.type===oc?f.props.children:f.props,h);d.ref=eh(a,k,f);d.return=a;a=d;break a}else{c(a,k);break}else b(a,k);k=
k.sibling}f.type===oc?(d=Mf(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Lf(f.type,f.key,f.props,null,a.mode,h),h.ref=eh(a,d,f),h.return=a,a=h)}return g(a);case nc:a:{for(k=f.key;null!==d;){if(d.key===k)if(4===d.tag&&d.stateNode.containerInfo===f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[],h);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=Pf(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=
""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f,h),d.return=a,a=d):(c(a,d),d=Of(f,a.mode,h),d.return=a,a=d),g(a);if(dh(f))return x(a,d,f,h);if(zc(f))return F(a,d,f,h);l&&fh(a,f);if("undefined"===typeof f&&!k)switch(a.tag){case 1:case 0:h=a.type,r("152",h.displayName||h.name||"Component")}return c(a,d)}}var hh=gh(!0),ih=gh(!1),jh=null,kh=null,lh=!1;
function mh(a,b){var c=N(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function nh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?null:b,null!==b?(a.stateNode=b,!0):!1;default:return!1}}
function oh(a){if(lh){var b=kh;if(b){var c=b;if(!nh(a,b)){b=qf(c);if(!b||!nh(a,b)){a.effectTag|=2;lh=!1;jh=a;return}mh(jh,c)}jh=a;kh=rf(b)}else a.effectTag|=2,lh=!1,jh=a}}function ph(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag;)a=a.return;jh=a}function qh(a){if(a!==jh)return!1;if(!lh)return ph(a),lh=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==b&&!nf(b,a.memoizedProps))for(b=kh;b;)mh(a,b),b=qf(b);ph(a);kh=jh?qf(a.stateNode):null;return!0}function rh(){kh=jh=null;lh=!1}
function sh(a){var b=a._result;switch(a._status){case 1:return b;case 2:throw b;case 0:throw b;default:throw a._status=0,b=a._ctor,b=b(),b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)}),a._result=b,b;}}var th=kc.ReactCurrentOwner;function S(a,b,c,d){b.child=null===a?ih(b,null,c,d):hh(b,a.child,c,d)}
function uh(a,b,c,d,e){c=c.render;var f=b.ref;mg(b,e);og=e;O=b;pg=null!==a?a.memoizedState:null;var g=c(d,f);g=xg(c,d,g,f);b.effectTag|=1;S(a,b,g,e);return b.child}
function vh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!If(g)&&void 0===g.defaultProps&&null===c.compare)return b.tag=15,b.type=g,wh(a,b,g,d,e,f);a=Lf(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(0===e||e>f)if(e=g.memoizedProps,c=c.compare,c=null!==c?c:Fd,c(e,d)&&a.ref===b.ref)return xh(a,b,f);a=Kf(g,d,f);a.ref=b.ref;a.return=b;return b.child=a}
function wh(a,b,c,d,e,f){return null!==a&&(0===e||e>f)&&Fd(a.memoizedProps,d)&&a.ref===b.ref?xh(a,b,f):yh(a,b,c,d,f)}function zh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function yh(a,b,c,d,e){var f=M(c)?vf:K.current;f=wf(b,f);mg(b,e);og=e;O=b;pg=null!==a?a.memoizedState:null;var g=c(d,f);g=xg(c,d,g,f);b.effectTag|=1;S(a,b,g,e);return b.child}
function Ah(a,b,c,d,e){if(M(c)){var f=!0;Bf(b)}else f=!1;mg(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),ah(b,c,d,e),ch(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var k=g.context,l=c.contextType;"object"===typeof l&&null!==l?l=Wg.currentDispatcher.readContext(l):(l=M(c)?vf:K.current,l=wf(b,l));var m=c.getDerivedStateFromProps,p="function"===typeof m||"function"===typeof g.getSnapshotBeforeUpdate;p||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&
"function"!==typeof g.componentWillReceiveProps||(h!==d||k!==l)&&bh(b,g,d,l);Uf=!1;var w=b.memoizedState;k=g.state=w;var E=b.updateQueue;null!==E&&(cg(b,E,d,g,e),k=b.memoizedState);h!==d||w!==k||L.current||Uf?("function"===typeof m&&(Yg(b,c,m,d),k=b.memoizedState),(h=Uf||$g(b,c,h,d,w,k,l))?(p||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&
g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=k),g.props=d,g.state=k,g.context=l,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,h=b.memoizedProps,g.props=h,k=g.context,l=c.contextType,"object"===typeof l&&null!==l?l=Wg.currentDispatcher.readContext(l):(l=M(c)?vf:K.current,l=wf(b,l)),m=c.getDerivedStateFromProps,(p="function"===
typeof m||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||k!==l)&&bh(b,g,d,l),Uf=!1,k=b.memoizedState,w=g.state=k,E=b.updateQueue,null!==E&&(cg(b,E,d,g,e),w=b.memoizedState),h!==d||k!==w||L.current||Uf?("function"===typeof m&&(Yg(b,c,m,d),w=b.memoizedState),(m=Uf||$g(b,c,h,d,k,w,l))?(p||"function"!==typeof g.UNSAFE_componentWillUpdate&&"function"!==typeof g.componentWillUpdate||("function"===
typeof g.componentWillUpdate&&g.componentWillUpdate(d,w,l),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,w,l)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&k===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&k===a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=
w),g.props=d,g.state=w,g.context=l,d=m):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&k===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&k===a.memoizedState||(b.effectTag|=256),d=!1);return Bh(a,b,c,d,f,e)}
function Bh(a,b,c,d,e,f){zh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Cf(b,c,!1),xh(a,b,f);d=b.stateNode;th.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?null:d.render();b.effectTag|=1;null!==a&&g?(b.child=hh(b,a.child,null,f),b.child=hh(b,null,h,f)):S(a,b,h,f);b.memoizedState=d.state;e&&Cf(b,c,!0);return b.child}function Ch(a){var b=a.stateNode;b.pendingContext?zf(a,b.pendingContext,b.pendingContext!==b.context):b.context&&zf(a,b.context,!1);Sg(a,b.containerInfo)}
function Dh(a,b){if(a&&a.defaultProps){b=n({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}
function Eh(a,b,c){var d=b.mode,e=b.pendingProps,f=b.memoizedState;null!==f&&(f.alreadyCaptured?null!==a&&f===a.memoizedState?f={alreadyCaptured:!0,didTimeout:!0,timedOutAt:f.timedOutAt}:(f.alreadyCaptured=!0,f.didTimeout=!0):f=null);var g=null!==f&&f.didTimeout;if(null===a)g?(g=e.fallback,e=Mf(null,d,0,null),d=Mf(g,d,c,null),e.sibling=d,c=e,c.return=d.return=b):c=d=ih(b,null,e.children,c);else{var h=a.memoizedState;null!==h&&h.didTimeout?(d=a.child,a=d.sibling,g?(c=e.fallback,d=Kf(d,d.pendingProps,
0),d.effectTag|=2,e=d.sibling=Kf(a,c,a.expirationTime),e.effectTag|=2,c=d,d.childExpirationTime=0,d=e,c.return=d.return=b):(g=a.child,d=hh(b,d.child,e.children,c),hh(b,g,null,c),c=d)):(a=a.child,g?(g=e.fallback,e=Mf(null,d,0,null),e.effectTag|=2,e.child=a,a.return=e,d=e.sibling=Mf(g,d,c,null),d.effectTag|=2,c=e,e.childExpirationTime=0,c.return=d.return=b):d=c=hh(b,a,e.children,c))}b.memoizedState=f;b.child=c;return d}
function xh(a,b,c){null!==a&&(b.firstContextDependency=a.firstContextDependency);var d=b.childExpirationTime;if(0===d||d>c)return null;null!==a&&b.child!==a.child?r("153"):void 0;if(null!==b.child){a=b.child;c=Kf(a,a.pendingProps,a.expirationTime);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Kf(a,a.pendingProps,a.expirationTime),c.return=b;c.sibling=null}return b.child}
function Fh(a,b,c){var d=b.expirationTime;if(null!==a&&a.memoizedProps===b.pendingProps&&!L.current&&(0===d||d>c)){switch(b.tag){case 3:Ch(b);rh();break;case 5:Ug(b);break;case 1:M(b.type)&&Bf(b);break;case 4:Sg(b,b.stateNode.containerInfo);break;case 10:kg(b,b.memoizedProps.value);break;case 13:if(d=b.memoizedState,null!==d&&d.didTimeout){d=b.child.childExpirationTime;if(0!==d&&d<=c)return Eh(a,b,c);b=xh(a,b,c);return null!==b?b.sibling:null}}return xh(a,b,c)}b.expirationTime=0;switch(b.tag){case 2:d=
b.elementType;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;var e=wf(b,K.current);mg(b,c);og=c;O=b;pg=null;var f=d(a,e);b.effectTag|=1;if("object"===typeof f&&null!==f&&"function"===typeof f.render&&void 0===f.$$typeof){b.tag=1;yg();M(d)?(e=!0,Bf(b)):e=!1;b.memoizedState=null!==f.state&&void 0!==f.state?f.state:null;var g=d.getDerivedStateFromProps;"function"===typeof g&&Yg(b,d,g,a);f.updater=Zg;b.stateNode=f;f._reactInternalFiber=b;ch(b,d,a,c);b=Bh(null,b,d,!0,e,c)}else b.tag=
0,f=xg(d,a,f,e),S(null,b,f,c),b=b.child;return b;case 16:f=b.elementType;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);e=b.pendingProps;a=sh(f);b.type=a;f=b.tag=Jf(a);e=Dh(a,e);g=void 0;switch(f){case 0:g=yh(null,b,a,e,c);break;case 1:g=Ah(null,b,a,e,c);break;case 11:g=uh(null,b,a,e,c);break;case 14:g=vh(null,b,a,Dh(a.type,e),d,c);break;default:r("283",a)}return g;case 0:return d=b.type,f=b.pendingProps,f=b.elementType===d?f:Dh(d,f),yh(a,b,d,f,c);case 1:return d=b.type,f=b.pendingProps,
f=b.elementType===d?f:Dh(d,f),Ah(a,b,d,f,c);case 3:Ch(b);d=b.updateQueue;null===d?r("282"):void 0;f=b.memoizedState;f=null!==f?f.element:null;cg(b,d,b.pendingProps,null,c);d=b.memoizedState.element;if(d===f)rh(),b=xh(a,b,c);else{f=b.stateNode;if(f=(null===a||null===a.child)&&f.hydrate)kh=rf(b.stateNode.containerInfo),jh=b,f=lh=!0;f?(b.effectTag|=2,b.child=ih(b,null,d,c)):(S(a,b,d,c),rh());b=b.child}return b;case 5:return Ug(b),null===a&&oh(b),d=b.type,f=b.pendingProps,e=null!==a?a.memoizedProps:null,
g=f.children,nf(d,f)?g=null:null!==e&&nf(d,e)&&(b.effectTag|=16),zh(a,b),1073741823!==c&&b.mode&1&&f.hidden?(b.expirationTime=1073741823,b=null):(S(a,b,g,c),b=b.child),b;case 6:return null===a&&oh(b),null;case 13:return Eh(a,b,c);case 4:return Sg(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=hh(b,null,d,c):S(a,b,d,c),b.child;case 11:return d=b.type,f=b.pendingProps,f=b.elementType===d?f:Dh(d,f),uh(a,b,d,f,c);case 7:return S(a,b,b.pendingProps,c),b.child;case 8:return S(a,b,b.pendingProps.children,
c),b.child;case 12:return S(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;f=b.pendingProps;g=b.memoizedProps;e=f.value;kg(b,e);if(null!==g){var h=g.value;e=h===e&&(0!==h||1/h===1/e)||h!==h&&e!==e?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,e):1073741823)|0;if(0===e){if(g.children===f.children&&!L.current){b=xh(a,b,c);break a}}else for(g=b.child,null!==g&&(g.return=b);null!==g;){h=g.firstContextDependency;if(null!==h){do{if(h.context===d&&0!==(h.observedBits&
e)){if(1===g.tag){var k=Xf(c);k.tag=2;Zf(g,k)}if(0===g.expirationTime||g.expirationTime>c)g.expirationTime=c;k=g.alternate;null!==k&&(0===k.expirationTime||k.expirationTime>c)&&(k.expirationTime=c);for(var l=g.return;null!==l;){k=l.alternate;if(0===l.childExpirationTime||l.childExpirationTime>c)l.childExpirationTime=c,null!==k&&(0===k.childExpirationTime||k.childExpirationTime>c)&&(k.childExpirationTime=c);else if(null!==k&&(0===k.childExpirationTime||k.childExpirationTime>c))k.childExpirationTime=
c;else break;l=l.return}}k=g.child;h=h.next}while(null!==h)}else k=10===g.tag?g.type===b.type?null:g.child:g.child;if(null!==k)k.return=g;else for(k=g;null!==k;){if(k===b){k=null;break}g=k.sibling;if(null!==g){g.return=k.return;k=g;break}k=k.return}g=k}}S(a,b,f.children,c);b=b.child}return b;case 9:return f=b.type,e=b.pendingProps,d=e.children,mg(b,c),f=ng(f,e.unstable_observedBits),d=d(f),b.effectTag|=1,S(a,b,d,c),b.child;case 14:return f=b.type,e=Dh(f.type,b.pendingProps),vh(a,b,f,e,d,c);case 15:return wh(a,
b,b.type,b.pendingProps,d,c);case 17:return d=b.type,f=b.pendingProps,f=b.elementType===d?f:Dh(d,f),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,M(d)?(a=!0,Bf(b)):a=!1,mg(b,c),ah(b,d,f,c),ch(b,d,f,c),Bh(null,b,d,!0,a,c);default:r("156")}}function Gh(a){a.effectTag|=4}var Hh=void 0,Ih=void 0,Jh=void 0,Kh=void 0;
Hh=function(a,b){for(var c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};Ih=function(){};
Jh=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Rg(Og.current);a=null;switch(c){case "input":f=Nc(g,f);d=Nc(g,d);a=[];break;case "option":f=ze(g,f);d=ze(g,d);a=[];break;case "select":f=n({},f,{value:void 0});d=n({},d,{value:void 0});a=[];break;case "textarea":f=Be(g,f);d=Be(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=Te)}Qe(c,d);g=c=void 0;var h=null;for(c in f)if(!d.hasOwnProperty(c)&&f.hasOwnProperty(c)&&null!=f[c])if("style"===
c){var k=f[c];for(g in k)k.hasOwnProperty(g)&&(h||(h={}),h[g]="")}else"dangerouslySetInnerHTML"!==c&&"children"!==c&&"suppressContentEditableWarning"!==c&&"suppressHydrationWarning"!==c&&"autoFocus"!==c&&(ua.hasOwnProperty(c)?a||(a=[]):(a=a||[]).push(c,null));for(c in d){var l=d[c];k=null!=f?f[c]:void 0;if(d.hasOwnProperty(c)&&l!==k&&(null!=l||null!=k))if("style"===c)if(k){for(g in k)!k.hasOwnProperty(g)||l&&l.hasOwnProperty(g)||(h||(h={}),h[g]="");for(g in l)l.hasOwnProperty(g)&&k[g]!==l[g]&&(h||
(h={}),h[g]=l[g])}else h||(a||(a=[]),a.push(c,h)),h=l;else"dangerouslySetInnerHTML"===c?(l=l?l.__html:void 0,k=k?k.__html:void 0,null!=l&&k!==l&&(a=a||[]).push(c,""+l)):"children"===c?k===l||"string"!==typeof l&&"number"!==typeof l||(a=a||[]).push(c,""+l):"suppressContentEditableWarning"!==c&&"suppressHydrationWarning"!==c&&(ua.hasOwnProperty(c)?(null!=l&&Se(e,c),a||k===l||(a=[])):(a=a||[]).push(c,l))}h&&(a=a||[]).push("style",h);e=a;(b.updateQueue=e)&&Gh(b)}};Kh=function(a,b,c,d){c!==d&&Gh(b)};
function Lh(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bc(c));null!==c&&Ac(c.type);b=b.value;null!==a&&1===a.tag&&Ac(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function gi(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){hi(a,c)}else b.current=null}
function ii(a,b,c){c=c.updateQueue;c=null!==c?c.lastEffect:null;if(null!==c){var d=c=c.next;do{if(0!==(d.tag&a)){var e=d.destroy;d.destroy=null;null!==e&&e()}0!==(d.tag&b)&&(e=d.create,e=e(),d.destroy="function"===typeof e?e:null);d=d.next}while(d!==c)}}
function ji(a){"function"===typeof Ef&&Ef(a);switch(a.tag){case 0:case 11:case 14:case 15:var b=a.updateQueue;if(null!==b&&(b=b.lastEffect,null!==b)){var c=b=b.next;do{var d=c.destroy;if(null!==d){var e=a;try{d()}catch(f){hi(e,f)}}c=c.next}while(c!==b)}break;case 1:gi(a);b=a.stateNode;if("function"===typeof b.componentWillUnmount)try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(f){hi(a,f)}break;case 5:gi(a);break;case 4:ki(a)}}
function li(a){return 5===a.tag||3===a.tag||4===a.tag}
function mi(a){a:{for(var b=a.return;null!==b;){if(li(b)){var c=b;break a}b=b.return}r("160");c=void 0}var d=b=void 0;switch(c.tag){case 5:b=c.stateNode;d=!1;break;case 3:b=c.stateNode.containerInfo;d=!0;break;case 4:b=c.stateNode.containerInfo;d=!0;break;default:r("161")}c.effectTag&16&&(Le(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||li(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag;){if(c.effectTag&2)continue b;
if(null===c.child||4===c.tag)continue b;else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}for(var e=a;;){if(5===e.tag||6===e.tag)if(c)if(d){var f=b,g=e.stateNode,h=c;8===f.nodeType?f.parentNode.insertBefore(g,h):f.insertBefore(g,h)}else b.insertBefore(e.stateNode,c);else d?(g=b,h=e.stateNode,8===g.nodeType?(f=g.parentNode,f.insertBefore(h,g)):(f=g,f.appendChild(h)),g=g._reactRootContainer,null!==g&&void 0!==g||null!==f.onclick||(f.onclick=Te)):b.appendChild(e.stateNode);
else if(4!==e.tag&&null!==e.child){e.child.return=e;e=e.child;continue}if(e===a)break;for(;null===e.sibling;){if(null===e.return||e.return===a)return;e=e.return}e.sibling.return=e.return;e=e.sibling}}
function ki(a){for(var b=a,c=!1,d=void 0,e=void 0;;){if(!c){c=b.return;a:for(;;){null===c?r("160"):void 0;switch(c.tag){case 5:d=c.stateNode;e=!1;break a;case 3:d=c.stateNode.containerInfo;e=!0;break a;case 4:d=c.stateNode.containerInfo;e=!0;break a}c=c.return}c=!0}if(5===b.tag||6===b.tag){a:for(var f=b,g=f;;)if(ji(g),null!==g.child&&4!==g.tag)g.child.return=g,g=g.child;else{if(g===f)break;for(;null===g.sibling;){if(null===g.return||g.return===f)break a;g=g.return}g.sibling.return=g.return;g=g.sibling}e?
(f=d,g=b.stateNode,8===f.nodeType?f.parentNode.removeChild(g):f.removeChild(g)):d.removeChild(b.stateNode)}else if(4===b.tag?(d=b.stateNode.containerInfo,e=!0):ji(b),null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return;b=b.return;4===b.tag&&(c=!1)}b.sibling.return=b.return;b=b.sibling}}
function ni(a,b){switch(b.tag){case 0:case 11:case 14:case 15:ii(4,8,b);break;case 1:break;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[La]=d;"input"===a&&"radio"===d.type&&null!=d.name&&Pc(c,d);Re(a,e);b=Re(a,d);for(e=0;e<f.length;e+=2){var g=f[e],h=f[e+1];"style"===g?Oe(c,h):"dangerouslySetInnerHTML"===g?Ke(c,h):"children"===g?Le(c,h):Lc(c,g,h,b)}switch(a){case "input":Qc(c,d);break;case "textarea":Ee(c,
d);break;case "select":a=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,f=d.value,null!=f?Ae(c,!!d.multiple,f,!1):a!==!!d.multiple&&(null!=d.defaultValue?Ae(c,!!d.multiple,d.defaultValue,!0):Ae(c,!!d.multiple,d.multiple?[]:"",!1))}}}break;case 6:null===b.stateNode?r("162"):void 0;b.stateNode.nodeValue=b.memoizedProps;break;case 3:break;case 12:break;case 13:break;case 17:break;default:r("163")}}
function oi(a,b,c){c=Xf(c);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){pi(d);Lh(a,b)};return c}
function qi(a,b,c){c=Xf(c);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&(null===ri?ri=new Set([this]):ri.add(this));var c=b.value,e=b.stack;Lh(a,b);this.componentDidCatch(c,{componentStack:null!==e?e:""})});return c}
function si(a){switch(a.tag){case 1:M(a.type)&&xf(a);var b=a.effectTag;return b&2048?(a.effectTag=b&-2049|64,a):null;case 3:return Tg(a),yf(a),b=a.effectTag,0!==(b&64)?r("285"):void 0,a.effectTag=b&-2049|64,a;case 5:return Vg(a),null;case 13:b=a.effectTag;if(b&2048){a.effectTag=b&-2049|64;b=a.alternate;b=null!==b?b.memoizedState:null;var c=a.memoizedState;null===c?c={alreadyCaptured:!0,didTimeout:!1,timedOutAt:0}:b===c?c={alreadyCaptured:!0,didTimeout:c.didTimeout,timedOutAt:c.timedOutAt}:c.alreadyCaptured=
!0;a.memoizedState=c;return a}return null;case 4:return Tg(a),null;case 10:return lg(a),null;default:return null}}
var ti={readContext:ng,useCallback:function(a,b){O=wg();Q=Bg();b=void 0!==b&&null!==b?b:[a];var c=Q.memoizedState;if(null!==c&&Ig(b,c[1]))return c[0];Q.memoizedState=[a,b];return a},useContext:function(a,b){wg();return ng(a,b)},useEffect:function(a,b){Hg(516,192,a,b)},useImperativeMethods:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):[a,b];Hg(4,36,function(){if("function"===typeof a){var c=b();a(c);return function(){return a(null)}}if(null!==a&&void 0!==a)return c=b(),a.current=c,function(){a.current=
null}},c)},useLayoutEffect:function(a,b){Hg(4,36,a,b)},useMemo:function(a,b){O=wg();Q=Bg();b=void 0!==b&&null!==b?b:[a];var c=Q.memoizedState;if(null!==c&&Ig(b,c[1]))return c[0];a=a();Q.memoizedState=[a,b];return a},useMutationEffect:function(a,b){Hg(260,10,a,b)},useReducer:Dg,useRef:function(a){O=wg();Q=Bg();null===Q.memoizedState?(a={current:a},Q.memoizedState=a):a=Q.memoizedState;return a},useState:function(a){return Dg(Cg,a)}},ui=kc.ReactCurrentOwner,vi=0,wi=0,xi=!1,T=null,yi=null,U=0,zi=-1,Ai=
!1,V=null,Bi=!1,Ci=null,Di=null,Ei=null,ri=null;function Fi(){if(null!==T)for(var a=T.return;null!==a;){var b=a;switch(b.tag){case 1:var c=b.type.childContextTypes;null!==c&&void 0!==c&&xf(b);break;case 3:Tg(b);yf(b);break;case 5:Vg(b);break;case 4:Tg(b);break;case 10:lg(b)}a=a.return}yi=null;U=0;zi=-1;Ai=!1;T=null}
function Gi(a,b){Ei=Di=Ci=null;var c=W;W=!0;do{if(b.effectTag&512){var d=!1,e=void 0;try{var f=b;ii(128,0,f);ii(0,64,f)}catch(g){d=!0,e=g}d&&hi(b,e)}b=b.nextEffect}while(null!==b);W=c;c=a.expirationTime;0!==c&&Hi(a,c)}function Lg(){null!==Ei&&(ba.unstable_cancelCallback(Di),Ei())}
function Ii(a){for(;;){var b=a.alternate,c=a.return,d=a.sibling;if(0===(a.effectTag&1024)){var e=b;b=a;var f=b.pendingProps;switch(b.tag){case 2:break;case 16:break;case 15:case 0:break;case 1:M(b.type)&&xf(b);break;case 3:Tg(b);yf(b);f=b.stateNode;f.pendingContext&&(f.context=f.pendingContext,f.pendingContext=null);if(null===e||null===e.child)qh(b),b.effectTag&=-3;Ih(b);break;case 5:Vg(b);var g=Rg(Qg.current),h=b.type;if(null!==e&&null!=b.stateNode)Jh(e,b,h,f,g),e.ref!==b.ref&&(b.effectTag|=128);
else if(f){var k=Rg(Og.current);if(qh(b)){f=b;e=f.stateNode;var l=f.type,m=f.memoizedProps,p=g;e[Ka]=f;e[La]=m;h=void 0;g=l;switch(g){case "iframe":case "object":G("load",e);break;case "video":case "audio":for(l=0;l<gb.length;l++)G(gb[l],e);break;case "source":G("error",e);break;case "img":case "image":case "link":G("error",e);G("load",e);break;case "form":G("reset",e);G("submit",e);break;case "details":G("toggle",e);break;case "input":Oc(e,m);G("invalid",e);Se(p,"onChange");break;case "select":e._wrapperState=
{wasMultiple:!!m.multiple};G("invalid",e);Se(p,"onChange");break;case "textarea":De(e,m),G("invalid",e),Se(p,"onChange")}Qe(g,m);l=null;for(h in m)m.hasOwnProperty(h)&&(k=m[h],"children"===h?"string"===typeof k?e.textContent!==k&&(l=["children",k]):"number"===typeof k&&e.textContent!==""+k&&(l=["children",""+k]):ua.hasOwnProperty(h)&&null!=k&&Se(p,h));switch(g){case "input":ec(e);Sc(e,m,!0);break;case "textarea":ec(e);Fe(e,m);break;case "select":case "option":break;default:"function"===typeof m.onClick&&
(e.onclick=Te)}h=l;f.updateQueue=h;f=null!==h?!0:!1;f&&Gh(b)}else{m=b;e=h;p=f;l=9===g.nodeType?g:g.ownerDocument;k===Ge.html&&(k=He(e));k===Ge.html?"script"===e?(e=l.createElement("div"),e.innerHTML="<script>\x3c/script>",l=e.removeChild(e.firstChild)):"string"===typeof p.is?l=l.createElement(e,{is:p.is}):(l=l.createElement(e),"select"===e&&p.multiple&&(l.multiple=!0)):l=l.createElementNS(k,e);e=l;e[Ka]=m;e[La]=f;Hh(e,b,!1,!1);p=e;l=h;m=f;var w=g,E=Re(l,m);switch(l){case "iframe":case "object":G("load",
p);g=m;break;case "video":case "audio":for(g=0;g<gb.length;g++)G(gb[g],p);g=m;break;case "source":G("error",p);g=m;break;case "img":case "image":case "link":G("error",p);G("load",p);g=m;break;case "form":G("reset",p);G("submit",p);g=m;break;case "details":G("toggle",p);g=m;break;case "input":Oc(p,m);g=Nc(p,m);G("invalid",p);Se(w,"onChange");break;case "option":g=ze(p,m);break;case "select":p._wrapperState={wasMultiple:!!m.multiple};g=n({},m,{value:void 0});G("invalid",p);Se(w,"onChange");break;case "textarea":De(p,
m);g=Be(p,m);G("invalid",p);Se(w,"onChange");break;default:g=m}Qe(l,g);k=void 0;var x=l,F=p,v=g;for(k in v)if(v.hasOwnProperty(k)){var q=v[k];"style"===k?Oe(F,q):"dangerouslySetInnerHTML"===k?(q=q?q.__html:void 0,null!=q&&Ke(F,q)):"children"===k?"string"===typeof q?("textarea"!==x||""!==q)&&Le(F,q):"number"===typeof q&&Le(F,""+q):"suppressContentEditableWarning"!==k&&"suppressHydrationWarning"!==k&&"autoFocus"!==k&&(ua.hasOwnProperty(k)?null!=q&&Se(w,k):null!=q&&Lc(F,k,q,E))}switch(l){case "input":ec(p);
Sc(p,m,!1);break;case "textarea":ec(p);Fe(p,m);break;case "option":null!=m.value&&p.setAttribute("value",""+Mc(m.value));break;case "select":g=p;g.multiple=!!m.multiple;p=m.value;null!=p?Ae(g,!!m.multiple,p,!1):null!=m.defaultValue&&Ae(g,!!m.multiple,m.defaultValue,!0);break;default:"function"===typeof g.onClick&&(p.onclick=Te)}(f=mf(h,f))&&Gh(b);b.stateNode=e}null!==b.ref&&(b.effectTag|=128)}else null===b.stateNode?r("166"):void 0;break;case 6:e&&null!=b.stateNode?Kh(e,b,e.memoizedProps,f):("string"!==
typeof f&&(null===b.stateNode?r("166"):void 0),e=Rg(Qg.current),Rg(Og.current),qh(b)?(f=b,h=f.stateNode,e=f.memoizedProps,h[Ka]=f,(f=h.nodeValue!==e)&&Gh(b)):(h=b,f=(9===e.nodeType?e:e.ownerDocument).createTextNode(f),f[Ka]=b,h.stateNode=f));break;case 11:break;case 13:f=b.memoizedState;h=null!==e?e.memoizedState:null;(null!==f&&f.didTimeout)!==(null!==h&&h.didTimeout)&&(b.effectTag|=4);break;case 7:break;case 8:break;case 12:break;case 4:Tg(b);Ih(b);break;case 10:lg(b);break;case 9:break;case 14:break;
case 17:M(b.type)&&xf(b);break;default:r("156")}T=null;b=a;if(1073741823===U||1073741823!==b.childExpirationTime){f=0;for(h=b.child;null!==h;){e=h.expirationTime;g=h.childExpirationTime;if(0===f||0!==e&&e<f)f=e;if(0===f||0!==g&&g<f)f=g;h=h.sibling}b.childExpirationTime=f}null!==c&&0===(c.effectTag&1024)&&(null===c.firstEffect&&(c.firstEffect=a.firstEffect),null!==a.lastEffect&&(null!==c.lastEffect&&(c.lastEffect.nextEffect=a.firstEffect),c.lastEffect=a.lastEffect),1<a.effectTag&&(null!==c.lastEffect?
c.lastEffect.nextEffect=a:c.firstEffect=a,c.lastEffect=a))}else{a=si(a,U);if(null!==a)return a.effectTag&=1023,a;null!==c&&(c.firstEffect=c.lastEffect=null,c.effectTag|=1024)}if(null!==d)return d;if(null!==c)a=c;else break}return null}function Ji(a){var b=Fh(a.alternate,a,U);a.memoizedProps=a.pendingProps;null===b&&(b=Ii(a));ui.current=null;return b}
function Ki(a,b,c){xi?r("243"):void 0;Lg();xi=!0;ui.currentDispatcher=ti;var d=a.nextExpirationTimeToWorkOn;if(d!==U||a!==yi||null===T)Fi(),yi=a,U=d,T=Kf(yi.current,null,U),a.pendingCommitExpirationTime=0;var e=!1;do{try{if(b)for(;null!==T&&!Li();)T=Ji(T);else for(;null!==T;)T=Ji(T)}catch(F){if(jg=ig=hg=null,yg(),null===T)e=!0,pi(F);else{null===T?r("271"):void 0;var f=T,g=f.return;if(null===g)e=!0,pi(F);else{a:{var h=a,k=g,l=f,m=F;g=U;l.effectTag|=1024;l.firstEffect=l.lastEffect=null;if(null!==m&&
"object"===typeof m&&"function"===typeof m.then){var p=m;m=k;var w=-1,E=-1;do{if(13===m.tag){var x=m.alternate;if(null!==x&&(x=x.memoizedState,null!==x&&x.didTimeout)){E=10*(x.timedOutAt-2);break}x=m.pendingProps.maxDuration;if("number"===typeof x)if(0>=x)w=0;else if(-1===w||x<w)w=x}m=m.return}while(null!==m);m=k;do{if(x=13===m.tag)void 0===m.memoizedProps.fallback?x=!1:(x=m.memoizedState,x=null===x||!x.didTimeout);if(x){k=Mi.bind(null,h,m,l,0===(m.mode&1)?1:g);p.then(k,k);if(0===(m.mode&1)){m.effectTag|=
32;S(l.alternate,l,null,g);l.effectTag&=-1025;l.effectTag&=-933;1===l.tag&&null===l.alternate&&(l.tag=17);break a}-1===w?h=1073741823:(-1===E&&(E=10*(Tf(h,g)-2)-5E3),h=E+w);0<=h&&zi<h&&(zi=h);m.effectTag|=2048;m.expirationTime=g;break a}m=m.return}while(null!==m);m=Error("An update was suspended, but no placeholder UI was provided.")}Ai=!0;m=fg(m,l);h=k;do{switch(h.tag){case 3:l=m;h.effectTag|=2048;h.expirationTime=g;g=oi(h,l,g);$f(h,g);break a;case 1:if(l=m,k=h.type,p=h.stateNode,0===(h.effectTag&
64)&&("function"===typeof k.getDerivedStateFromError||null!==p&&"function"===typeof p.componentDidCatch&&(null===ri||!ri.has(p)))){h.effectTag|=2048;h.expirationTime=g;g=qi(h,l,g);$f(h,g);break a}}h=h.return}while(null!==h)}T=Ii(f);continue}}}break}while(1);xi=!1;jg=ig=hg=ui.currentDispatcher=null;yg();if(e)yi=null,a.finishedWork=null;else if(null!==T)a.finishedWork=null;else{b=a.current.alternate;null===b?r("281"):void 0;yi=null;if(Ai){e=a.latestPendingTime;f=a.latestSuspendedTime;g=a.latestPingedTime;
if(0!==e&&e>d||0!==f&&f>d||0!==g&&g>d){Sf(a,d);Ni(a,b,d,a.expirationTime,-1);return}if(!a.didError&&!c){a.didError=!0;d=a.nextExpirationTimeToWorkOn=d;c=a.expirationTime=1;Ni(a,b,d,c,-1);return}}c||-1===zi?(a.pendingCommitExpirationTime=d,a.finishedWork=b):(Sf(a,d),c=10*(Tf(a,d)-2),c<zi&&(zi=c),c=10*(Jg()-2),c=zi-c,Ni(a,b,d,a.expirationTime,0>c?0:c))}}
function hi(a,b){for(var c=a.return;null!==c;){switch(c.tag){case 1:var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===ri||!ri.has(d))){a=fg(b,a);a=qi(c,a,1);Zf(c,a);Mg(c,1);return}break;case 3:a=fg(b,a);a=oi(c,a,1);Zf(c,a);Mg(c,1);return}c=c.return}3===a.tag&&(c=fg(b,a),c=oi(a,c,1),Zf(a,c),Mg(a,1))}
function Kg(a,b){0!==wi?a=wi:xi?a=Bi?1:U:b.mode&1?(a=Oi?2+10*(((a-2+15)/10|0)+1):2+25*(((a-2+500)/25|0)+1),null!==yi&&a===U&&(a+=1)):a=1;Oi&&a>Pi&&(Pi=a);return a}
function Mi(a,b,c,d){var e=a.earliestSuspendedTime;var f=a.latestSuspendedTime;if(0!==e&&d>=e&&d<=f){f=e=d;a.didError=!1;var g=a.latestPingedTime;if(0===g||g<f)a.latestPingedTime=f;Rf(f,a)}else e=Jg(),e=Kg(e,b),Qf(a,e);0!==(b.mode&1)&&a===yi&&U===d&&(yi=null);Qi(b,e);0===(b.mode&1)&&(Qi(c,e),1===c.tag&&null!==c.stateNode&&(b=Xf(e),b.tag=2,Zf(c,b)));c=a.expirationTime;0!==c&&Hi(a,c)}
function Qi(a,b){if(0===a.expirationTime||a.expirationTime>b)a.expirationTime=b;var c=a.alternate;null!==c&&(0===c.expirationTime||c.expirationTime>b)&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;if(0===d.childExpirationTime||d.childExpirationTime>b)d.childExpirationTime=b;null!==c&&(0===c.childExpirationTime||c.childExpirationTime>b)&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}return null===
e?null:e}function Mg(a,b){a=Qi(a,b);null!==a&&(!xi&&0!==U&&b<U&&Fi(),Qf(a,b),xi&&!Bi&&yi===a||Hi(a,a.expirationTime),Ri>Si&&(Ri=0,r("185")))}function Ti(a,b,c,d,e){var f=wi;wi=1;try{return a(b,c,d,e)}finally{wi=f}}var Ui=null,X=null,Vi=0,Wi=void 0,W=!1,Xi=null,Y=0,Pi=0,Yi=!1,Zi=!1,$i=null,aj=null,Z=!1,bj=!1,Oi=!1,cj=null,dj=ba.unstable_now(),ej=(dj/10|0)+2,fj=ej,Si=50,Ri=0,gj=null,hj=1;function ij(){ej=((ba.unstable_now()-dj)/10|0)+2}
function jj(a,b){if(0!==Vi){if(b>Vi)return;null!==Wi&&ba.unstable_cancelCallback(Wi)}Vi=b;a=ba.unstable_now()-dj;Wi=ba.unstable_scheduleCallback(kj,{timeout:10*(b-2)-a})}function Ni(a,b,c,d,e){a.expirationTime=d;0!==e||Li()?0<e&&(a.timeoutHandle=of(lj.bind(null,a,b,c),e)):(a.pendingCommitExpirationTime=c,a.finishedWork=b)}function lj(a,b,c){a.pendingCommitExpirationTime=c;a.finishedWork=b;ij();fj=ej;mj(a,c)}function Jg(){if(W)return fj;nj();if(0===Y||1073741823===Y)ij(),fj=ej;return fj}
function Hi(a,b){if(null===a.nextScheduledRoot)a.expirationTime=b,null===X?(Ui=X=a,a.nextScheduledRoot=a):(X=X.nextScheduledRoot=a,X.nextScheduledRoot=Ui);else{var c=a.expirationTime;if(0===c||b<c)a.expirationTime=b}W||(Z?bj&&(Xi=a,Y=1,oj(a,1,!0)):1===b?pj(1,null):jj(a,b))}
function nj(){var a=0,b=null;if(null!==X)for(var c=X,d=Ui;null!==d;){var e=d.expirationTime;if(0===e){null===c||null===X?r("244"):void 0;if(d===d.nextScheduledRoot){Ui=X=d.nextScheduledRoot=null;break}else if(d===Ui)Ui=e=d.nextScheduledRoot,X.nextScheduledRoot=e,d.nextScheduledRoot=null;else if(d===X){X=c;X.nextScheduledRoot=Ui;d.nextScheduledRoot=null;break}else c.nextScheduledRoot=d.nextScheduledRoot,d.nextScheduledRoot=null;d=c.nextScheduledRoot}else{if(0===a||e<a)a=e,b=d;if(d===X)break;if(1===
a)break;c=d;d=d.nextScheduledRoot}}Xi=b;Y=a}function kj(a){if(a.didTimeout&&null!==Ui){ij();var b=Ui;do{var c=b.expirationTime;0!==c&&ej>=c&&(b.nextExpirationTimeToWorkOn=ej);b=b.nextScheduledRoot}while(b!==Ui)}pj(0,a)}
function pj(a,b){aj=b;nj();if(null!==aj)for(ij(),fj=ej;null!==Xi&&0!==Y&&(0===a||a>=Y)&&(!Yi||ej>=Y);)oj(Xi,Y,ej>=Y),nj(),ij(),fj=ej;else for(;null!==Xi&&0!==Y&&(0===a||a>=Y);)oj(Xi,Y,!0),nj();null!==aj&&(Vi=0,Wi=null);0!==Y&&jj(Xi,Y);aj=null;Yi=!1;Ri=0;gj=null;if(null!==cj)for(a=cj,cj=null,b=0;b<a.length;b++){var c=a[b];try{c._onComplete()}catch(d){Zi||(Zi=!0,$i=d)}}if(Zi)throw a=$i,$i=null,Zi=!1,a;}function mj(a,b){W?r("253"):void 0;Xi=a;Y=b;oj(a,b,!0);pj(1,null)}
function oj(a,b,c){W?r("245"):void 0;W=!0;if(null===aj||c){var d=a.finishedWork;null!==d?qj(a,d,b):(a.finishedWork=null,d=a.timeoutHandle,-1!==d&&(a.timeoutHandle=-1,pf(d)),Ki(a,!1,c),d=a.finishedWork,null!==d&&qj(a,d,b))}else d=a.finishedWork,null!==d?qj(a,d,b):(a.finishedWork=null,d=a.timeoutHandle,-1!==d&&(a.timeoutHandle=-1,pf(d)),Ki(a,!0,c),d=a.finishedWork,null!==d&&(Li()?a.finishedWork=d:qj(a,d,b)));W=!1}
function qj(a,b,c){var d=a.firstBatch;if(null!==d&&d._expirationTime<=c&&(null===cj?cj=[d]:cj.push(d),d._defer)){a.finishedWork=b;a.expirationTime=0;return}a.finishedWork=null;a===gj?Ri++:(gj=a,Ri=0);Bi=xi=!0;a.current===b?r("177"):void 0;var e=a.pendingCommitExpirationTime;0===e?r("261"):void 0;a.pendingCommitExpirationTime=0;var f=b.expirationTime,g=b.childExpirationTime,h=0===f||0!==g&&g<f?g:f;a.didError=!1;if(0===h)a.earliestPendingTime=0,a.latestPendingTime=0,a.earliestSuspendedTime=0,a.latestSuspendedTime=
0,a.latestPingedTime=0;else{var k=a.latestPendingTime;0!==k&&(k<h?a.earliestPendingTime=a.latestPendingTime=0:a.earliestPendingTime<h&&(a.earliestPendingTime=a.latestPendingTime));var l=a.earliestSuspendedTime;0===l?Qf(a,h):h>a.latestSuspendedTime?(a.earliestSuspendedTime=0,a.latestSuspendedTime=0,a.latestPingedTime=0,Qf(a,h)):h<l&&Qf(a,h)}Rf(0,a);ui.current=null;if(1<b.effectTag)if(null!==b.lastEffect){b.lastEffect.nextEffect=b;var m=b.firstEffect}else m=b;else m=b.firstEffect;Ue=ce;var p=oe();if(pe(p)){if("selectionStart"in
p)var w={start:p.selectionStart,end:p.selectionEnd};else a:{var E=p.ownerDocument,x=E&&E.defaultView||window,F=x.getSelection&&x.getSelection();if(F&&0!==F.rangeCount){var v=F.anchorNode,q=F.anchorOffset,B=F.focusNode,Ce=F.focusOffset;try{v.nodeType,B.nodeType}catch(sb){w=null;break a}var Zb=0,Zc=-1,$c=-1,vj=0,wj=0,t=p,$b=null;b:for(;;){for(var ad;;){t!==v||0!==q&&3!==t.nodeType||(Zc=Zb+q);t!==B||0!==Ce&&3!==t.nodeType||($c=Zb+Ce);3===t.nodeType&&(Zb+=t.nodeValue.length);if(null===(ad=t.firstChild))break;
$b=t;t=ad}for(;;){if(t===p)break b;$b===v&&++vj===q&&(Zc=Zb);$b===B&&++wj===Ce&&($c=Zb);if(null!==(ad=t.nextSibling))break;t=$b;$b=t.parentNode}t=ad}w=-1===Zc||-1===$c?null:{start:Zc,end:$c}}else w=null}var Mh=w||{start:0,end:0}}else Mh=null;lf={focusedElem:p,selectionRange:Mh};ce=!1;for(V=m;null!==V;){var Nh=!1,Oh=void 0;try{for(;null!==V;){if(V.effectTag&256)a:{var Ve=V.alternate,tb=V;switch(tb.tag){case 0:case 11:case 15:ii(2,0,tb);break a;case 1:if(tb.effectTag&256&&null!==Ve){var Ij=Ve.memoizedProps,
Jj=Ve.memoizedState,md=tb.stateNode;md.props=tb.memoizedProps;md.state=tb.memoizedState;var Kj=md.getSnapshotBeforeUpdate(Ij,Jj);md.__reactInternalSnapshotBeforeUpdate=Kj}break a;case 3:case 5:case 6:case 4:case 17:break a;default:r("163")}}V=V.nextEffect}}catch(sb){Nh=!0,Oh=sb}Nh&&(null===V?r("178"):void 0,hi(V,Oh),null!==V&&(V=V.nextEffect))}for(V=m;null!==V;){var Ph=!1,Qh=void 0;try{for(;null!==V;){var We=V.effectTag;We&16&&Le(V.stateNode,"");if(We&128){var Rh=V.alternate;if(null!==Rh){var nd=
Rh.ref;null!==nd&&("function"===typeof nd?nd(null):nd.current=null)}}switch(We&14){case 2:mi(V);V.effectTag&=-3;break;case 6:mi(V);V.effectTag&=-3;ni(V.alternate,V);break;case 4:ni(V.alternate,V);break;case 8:var Sh=V;ki(Sh);var fc=Sh;fc.return=null;fc.child=null;fc.alternate&&(fc.alternate.child=null,fc.alternate.return=null)}V=V.nextEffect}}catch(sb){Ph=!0,Qh=sb}Ph&&(null===V?r("178"):void 0,hi(V,Qh),null!==V&&(V=V.nextEffect))}var Th=lf,Lj=oe(),H=Th.focusedElem,ub=Th.selectionRange;if(Lj!==H&&
H&&H.ownerDocument&&ne(H.ownerDocument.documentElement,H)){if(null!==ub&&pe(H)){var Uh=ub.start,Xe=ub.end;void 0===Xe&&(Xe=Uh);if("selectionStart"in H)H.selectionStart=Uh,H.selectionEnd=Math.min(Xe,H.value.length);else{var Ye=H.ownerDocument||document,fa=(Ye&&Ye.defaultView||window).getSelection(),Vh=H.textContent.length,vb=Math.min(ub.start,Vh),gc=void 0===ub.end?vb:Math.min(ub.end,Vh);if(!fa.extend&&vb>gc){var Mj=gc;gc=vb;vb=Mj}var hc=me(H,vb),Ua=me(H,gc);if(hc&&Ua&&(1!==fa.rangeCount||fa.anchorNode!==
hc.node||fa.anchorOffset!==hc.offset||fa.focusNode!==Ua.node||fa.focusOffset!==Ua.offset)){var od=Ye.createRange();od.setStart(hc.node,hc.offset);fa.removeAllRanges();vb>gc?(fa.addRange(od),fa.extend(Ua.node,Ua.offset)):(od.setEnd(Ua.node,Ua.offset),fa.addRange(od))}}}for(var Ze=[],wb=H;wb=wb.parentNode;)1===wb.nodeType&&Ze.push({element:wb,left:wb.scrollLeft,top:wb.scrollTop});"function"===typeof H.focus&&H.focus();for(var $e=0;$e<Ze.length;$e++){var pd=Ze[$e];pd.element.scrollLeft=pd.left;pd.element.scrollTop=
pd.top}}lf=null;ce=!!Ue;Ue=null;a.current=b;for(V=m;null!==V;){var Wh=!1,Xh=void 0;try{for(var Nj=a,Oj=e;null!==V;){var af=V.effectTag;if(af&36){var qd=void 0,xb=V.alternate,y=V,Yh=Oj;switch(y.tag){case 0:case 11:case 15:ii(16,32,y);var bf=y.updateQueue;if(null!==bf){var cf=bf.callbackList;if(null!==cf){bf.callbackList=null;for(var df=0;df<cf.length;df++){var Zh=cf[df],Pj=Zh.callback;Zh.callback=null;Pj()}}}break;case 1:var ha=y.stateNode;if(y.effectTag&4)if(null===xb)ha.props=y.memoizedProps,ha.state=
y.memoizedState,ha.componentDidMount();else{var Qj=xb.memoizedProps,Rj=xb.memoizedState;ha.props=y.memoizedProps;ha.state=y.memoizedState;ha.componentDidUpdate(Qj,Rj,ha.__reactInternalSnapshotBeforeUpdate)}var $h=y.updateQueue;null!==$h&&(ha.props=y.memoizedProps,ha.state=y.memoizedState,dg(y,$h,ha,Yh));break;case 3:var ai=y.updateQueue;if(null!==ai){var ef=null;if(null!==y.child)switch(y.child.tag){case 5:ef=y.child.stateNode;break;case 1:ef=y.child.stateNode}dg(y,ai,ef,Yh)}break;case 5:var Sj=y.stateNode;
null===xb&&y.effectTag&4&&mf(y.type,y.memoizedProps)&&Sj.focus();break;case 6:break;case 4:break;case 12:break;case 13:if(y.effectTag&32){y.memoizedState={alreadyCaptured:!0,didTimeout:!1,timedOutAt:0};Lg();Mg(y,1);break}var bi=null!==xb?xb.memoizedState:null,ic=y.memoizedState,Tj=null!==bi?bi.didTimeout:!1,ff=y;if(null===ic)qd=!1;else if(qd=ic.didTimeout)ff=y.child,ic.alreadyCaptured=!1,0===ic.timedOutAt&&(ic.timedOutAt=Jg());if(qd!==Tj&&null!==ff)a:for(var gf=ff,ci=qd,A=gf;;){if(5===A.tag){var Uj=
A.stateNode;if(ci)Uj.style.display="none";else{var Vj=A.stateNode,rd=A.memoizedProps.style,Wj=void 0!==rd&&null!==rd&&rd.hasOwnProperty("display")?rd.display:null;Vj.style.display=Wj}}else if(6===A.tag)A.stateNode.nodeValue=ci?"":A.memoizedProps;else if(null!==A.child){A.child.return=A;A=A.child;continue}if(A===gf)break a;for(;null===A.sibling;){if(null===A.return||A.return===gf)break a;A=A.return}A.sibling.return=A.return;A=A.sibling}break;case 17:break;default:r("163")}}if(af&128){var sd=V.ref;
if(null!==sd){var di=V.stateNode;switch(V.tag){case 5:var hf=di;break;default:hf=di}"function"===typeof sd?sd(hf):sd.current=hf}}af&512&&(Ci=Nj);V=V.nextEffect}}catch(sb){Wh=!0,Xh=sb}Wh&&(null===V?r("178"):void 0,hi(V,Xh),null!==V&&(V=V.nextEffect))}if(null!==m&&null!==Ci){var ei=Gi.bind(null,a,m);Di=ba.unstable_scheduleCallback(ei);Ei=ei}xi=Bi=!1;"function"===typeof Df&&Df(b.stateNode);var jf=b.expirationTime,kf=b.childExpirationTime,fi=0===jf||0!==kf&&kf<jf?kf:jf;0===fi&&(ri=null);a.expirationTime=
fi;a.finishedWork=null}function Li(){return Yi?!0:null===aj||aj.timeRemaining()>hj?!1:Yi=!0}function pi(a){null===Xi?r("246"):void 0;Xi.expirationTime=0;Zi||(Zi=!0,$i=a)}function rj(a,b){var c=Z;Z=!0;try{return a(b)}finally{(Z=c)||W||pj(1,null)}}function sj(a,b){if(Z&&!bj){bj=!0;try{return a(b)}finally{bj=!1}}return a(b)}function tj(a,b,c){if(Oi)return a(b,c);Z||W||0===Pi||(pj(Pi,null),Pi=0);var d=Oi,e=Z;Z=Oi=!0;try{return a(b,c)}finally{Oi=d,(Z=e)||W||pj(1,null)}}
function uj(a,b,c,d,e){var f=b.current;a:if(c){c=c._reactInternalFiber;b:{2===Gd(c)&&1===c.tag?void 0:r("170");var g=c;do{switch(g.tag){case 3:g=g.stateNode.context;break b;case 1:if(M(g.type)){g=g.stateNode.__reactInternalMemoizedMergedChildContext;break b}}g=g.return}while(null!==g);r("171");g=void 0}if(1===c.tag){var h=c.type;if(M(h)){c=Af(c,h,g);break a}}c=g}else c=uf;null===b.context?b.context=c:b.pendingContext=c;b=e;e=Xf(d);e.payload={element:a};b=void 0===b?null:b;null!==b&&(e.callback=b);
Lg();Zf(f,e);Mg(f,d);return d}function xj(a,b,c,d){var e=b.current,f=Jg();e=Kg(f,e);return uj(a,b,c,e,d)}function yj(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function zj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:nc,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}
Mb=function(a,b,c){switch(b){case "input":Qc(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=Pa(d);e?void 0:r("90");jc(d);Qc(d,e)}}}break;case "textarea":Ee(a,c);break;case "select":b=c.value,null!=b&&Ae(a,!!c.multiple,b,!1)}};
function Aj(a){var b=2+25*(((Jg()-2+500)/25|0)+1);b<=vi&&(b=vi+1);this._expirationTime=vi=b;this._root=a;this._callbacks=this._next=null;this._hasChildren=this._didComplete=!1;this._children=null;this._defer=!0}Aj.prototype.render=function(a){this._defer?void 0:r("250");this._hasChildren=!0;this._children=a;var b=this._root._internalRoot,c=this._expirationTime,d=new Bj;uj(a,b,null,c,d._onCommit);return d};
Aj.prototype.then=function(a){if(this._didComplete)a();else{var b=this._callbacks;null===b&&(b=this._callbacks=[]);b.push(a)}};
Aj.prototype.commit=function(){var a=this._root._internalRoot,b=a.firstBatch;this._defer&&null!==b?void 0:r("251");if(this._hasChildren){var c=this._expirationTime;if(b!==this){this._hasChildren&&(c=this._expirationTime=b._expirationTime,this.render(this._children));for(var d=null,e=b;e!==this;)d=e,e=e._next;null===d?r("251"):void 0;d._next=e._next;this._next=b;a.firstBatch=this}this._defer=!1;mj(a,c);b=this._next;this._next=null;b=a.firstBatch=b;null!==b&&b._hasChildren&&b.render(b._children)}else this._next=
null,this._defer=!1};Aj.prototype._onComplete=function(){if(!this._didComplete){this._didComplete=!0;var a=this._callbacks;if(null!==a)for(var b=0;b<a.length;b++)(0,a[b])()}};function Bj(){this._callbacks=null;this._didCommit=!1;this._onCommit=this._onCommit.bind(this)}Bj.prototype.then=function(a){if(this._didCommit)a();else{var b=this._callbacks;null===b&&(b=this._callbacks=[]);b.push(a)}};
Bj.prototype._onCommit=function(){if(!this._didCommit){this._didCommit=!0;var a=this._callbacks;if(null!==a)for(var b=0;b<a.length;b++){var c=a[b];"function"!==typeof c?r("191",c):void 0;c()}}};
function Cj(a,b,c){b=N(3,null,null,b?3:0);a={current:b,containerInfo:a,pendingChildren:null,earliestPendingTime:0,latestPendingTime:0,earliestSuspendedTime:0,latestSuspendedTime:0,latestPingedTime:0,didError:!1,pendingCommitExpirationTime:0,finishedWork:null,timeoutHandle:-1,context:null,pendingContext:null,hydrate:c,nextExpirationTimeToWorkOn:0,expirationTime:0,firstBatch:null,nextScheduledRoot:null};this._internalRoot=b.stateNode=a}
Cj.prototype.render=function(a,b){var c=this._internalRoot,d=new Bj;b=void 0===b?null:b;null!==b&&d.then(b);xj(a,c,null,d._onCommit);return d};Cj.prototype.unmount=function(a){var b=this._internalRoot,c=new Bj;a=void 0===a?null:a;null!==a&&c.then(a);xj(null,b,null,c._onCommit);return c};Cj.prototype.legacy_renderSubtreeIntoContainer=function(a,b,c){var d=this._internalRoot,e=new Bj;c=void 0===c?null:c;null!==c&&e.then(c);xj(b,d,a,e._onCommit);return e};
Cj.prototype.createBatch=function(){var a=new Aj(this),b=a._expirationTime,c=this._internalRoot,d=c.firstBatch;if(null===d)c.firstBatch=a,a._next=null;else{for(c=null;null!==d&&d._expirationTime<=b;)c=d,d=d._next;a._next=d;null!==c&&(c._next=a)}return a};function Dj(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}Sb=rj;Tb=tj;Ub=function(){W||0===Pi||(pj(Pi,null),Pi=0)};
function Ej(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new Cj(a,!1,b)}
function Fj(a,b,c,d,e){Dj(c)?void 0:r("200");var f=c._reactRootContainer;if(f){if("function"===typeof e){var g=e;e=function(){var a=yj(f._internalRoot);g.call(a)}}null!=a?f.legacy_renderSubtreeIntoContainer(a,b,e):f.render(b,e)}else{f=c._reactRootContainer=Ej(c,d);if("function"===typeof e){var h=e;e=function(){var a=yj(f._internalRoot);h.call(a)}}sj(function(){null!=a?f.legacy_renderSubtreeIntoContainer(a,b,e):f.render(b,e)})}return yj(f._internalRoot)}
function Gj(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;Dj(b)?void 0:r("200");return zj(a,b,null,c)}
var Hj={createPortal:Gj,findDOMNode:function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;void 0===b&&("function"===typeof a.render?r("188"):r("268",Object.keys(a)));a=Jd(b);a=null===a?null:a.stateNode;return a},hydrate:function(a,b,c){return Fj(null,a,b,!0,c)},render:function(a,b,c){return Fj(null,a,b,!1,c)},unstable_renderSubtreeIntoContainer:function(a,b,c,d){null==a||void 0===a._reactInternalFiber?r("38"):void 0;return Fj(a,b,c,!1,d)},unmountComponentAtNode:function(a){Dj(a)?
void 0:r("40");return a._reactRootContainer?(sj(function(){Fj(null,null,a,!1,function(){a._reactRootContainer=null})}),!0):!1},unstable_createPortal:function(){return Gj.apply(void 0,arguments)},unstable_batchedUpdates:rj,unstable_interactiveUpdates:tj,flushSync:function(a,b){W?r("187"):void 0;var c=Z;Z=!0;try{return Ti(a,b)}finally{Z=c,pj(1,null)}},unstable_flushControlled:function(a){var b=Z;Z=!0;try{Ti(a)}finally{(Z=b)||W||pj(1,null)}},__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED:{Events:[Na,
Oa,Pa,Ga.injectEventPluginsByName,sa,Wa,function(a){Ba(a,Va)},Qb,Rb,ee,Ia]},createRoot:function(a,b){Dj(a)?void 0:r("278");return new Cj(a,!0,null!=b&&!0===b.hydrate)}};(function(a){var b=a.findFiberByHostInstance;return Gf(n({},a,{findHostInstanceByFiber:function(a){a=Jd(a);return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null}}))})({findFiberByHostInstance:Ma,bundleType:0,version:"16.7.0-alpha.0",rendererPackageName:"react-dom"});
var Xj={default:Hj},Yj=Xj&&Hj||Xj;module.exports=Yj.default||Yj;


/***/ }),

/***/ 181:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (true) {
  module.exports = __webpack_require__(182);
} else {}


/***/ }),

/***/ 182:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/** @license React v0.11.3
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

Object.defineProperty(exports,"__esModule",{value:!0});var d=null,f=!1,h=3,k=-1,l=-1,m=!1,n=!1;function p(){if(!m){var a=d.expirationTime;n?q():n=!0;r(t,a)}}
function u(){var a=d,b=d.next;if(d===b)d=null;else{var c=d.previous;d=c.next=b;b.previous=c}a.next=a.previous=null;c=a.callback;b=a.expirationTime;a=a.priorityLevel;var e=h,Q=l;h=a;l=b;try{var g=c()}finally{h=e,l=Q}if("function"===typeof g)if(g={callback:g,priorityLevel:a,expirationTime:b,next:null,previous:null},null===d)d=g.next=g.previous=g;else{c=null;a=d;do{if(a.expirationTime>=b){c=a;break}a=a.next}while(a!==d);null===c?c=d:c===d&&(d=g,p());b=c.previous;b.next=c.previous=g;g.next=c;g.previous=
b}}function v(){if(-1===k&&null!==d&&1===d.priorityLevel){m=!0;try{do u();while(null!==d&&1===d.priorityLevel)}finally{m=!1,null!==d?p():n=!1}}}function t(a){m=!0;var b=f;f=a;try{if(a)for(;null!==d;){var c=exports.unstable_now();if(d.expirationTime<=c){do u();while(null!==d&&d.expirationTime<=c)}else break}else if(null!==d){do u();while(null!==d&&!w())}}finally{m=!1,f=b,null!==d?p():n=!1,v()}}
var x=Date,y="function"===typeof setTimeout?setTimeout:void 0,z="function"===typeof clearTimeout?clearTimeout:void 0,A="function"===typeof requestAnimationFrame?requestAnimationFrame:void 0,B="function"===typeof cancelAnimationFrame?cancelAnimationFrame:void 0,C,D;function E(a){C=A(function(b){z(D);a(b)});D=y(function(){B(C);a(exports.unstable_now())},100)}
if("object"===typeof performance&&"function"===typeof performance.now){var F=performance;exports.unstable_now=function(){return F.now()}}else exports.unstable_now=function(){return x.now()};var r,q,w,G=null;"undefined"!==typeof window?G=window:"undefined"!==typeof global&&(G=global);
if(G&&G._schedMock){var H=G._schedMock;r=H[0];q=H[1];w=H[2];exports.unstable_now=H[3]}else if("undefined"===typeof window||"function"!==typeof MessageChannel){var I=null,J=function(a){if(null!==I)try{I(a)}finally{I=null}};r=function(a){null!==I?setTimeout(r,0,a):(I=a,setTimeout(J,0,!1))};q=function(){I=null};w=function(){return!1}}else{"undefined"!==typeof console&&("function"!==typeof A&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof B&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));var K=null,L=!1,M=-1,N=!1,O=!1,P=0,R=33,S=33;w=function(){return P<=exports.unstable_now()};var T=new MessageChannel,U=T.port2;T.port1.onmessage=function(){L=!1;var a=K,b=M;K=null;M=-1;var c=exports.unstable_now(),e=!1;if(0>=P-c)if(-1!==b&&b<=c)e=!0;else{N||(N=!0,E(V));K=a;M=b;return}if(null!==a){O=!0;try{a(e)}finally{O=!1}}};
var V=function(a){if(null!==K){E(V);var b=a-P+S;b<S&&R<S?(8>b&&(b=8),S=b<R?R:b):R=b;P=a+S;L||(L=!0,U.postMessage(void 0))}else N=!1};r=function(a,b){K=a;M=b;O||0>b?U.postMessage(void 0):N||(N=!0,E(V))};q=function(){K=null;L=!1;M=-1}}exports.unstable_ImmediatePriority=1;exports.unstable_UserBlockingPriority=2;exports.unstable_NormalPriority=3;exports.unstable_IdlePriority=5;exports.unstable_LowPriority=4;
exports.unstable_runWithPriority=function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=h,e=k;h=a;k=exports.unstable_now();try{return b()}finally{h=c,k=e,v()}};
exports.unstable_scheduleCallback=function(a,b){var c=-1!==k?k:exports.unstable_now();if("object"===typeof b&&null!==b&&"number"===typeof b.timeout)b=c+b.timeout;else switch(h){case 1:b=c+-1;break;case 2:b=c+250;break;case 5:b=c+1073741823;break;case 4:b=c+1E4;break;default:b=c+5E3}a={callback:a,priorityLevel:h,expirationTime:b,next:null,previous:null};if(null===d)d=a.next=a.previous=a,p();else{c=null;var e=d;do{if(e.expirationTime>b){c=e;break}e=e.next}while(e!==d);null===c?c=d:c===d&&(d=a,p());
b=c.previous;b.next=c.previous=a;a.next=c;a.previous=b}return a};exports.unstable_cancelCallback=function(a){var b=a.next;if(null!==b){if(b===a)d=null;else{a===d&&(d=b);var c=a.previous;c.next=b;b.previous=c}a.next=a.previous=null}};exports.unstable_wrapCallback=function(a){var b=h;return function(){var c=h,e=k;h=b;k=exports.unstable_now();try{return a.apply(this,arguments)}finally{h=c,k=e,v()}}};exports.unstable_getCurrentPriorityLevel=function(){return h};
exports.unstable_shouldYield=function(){return!f&&(null!==d&&d.expirationTime<l||w())};

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(5)))

/***/ }),

/***/ 3:
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(BrowserFS) {module.exports = BrowserFS.BFSRequire('process');

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(30)))

/***/ }),

/***/ 30:
/***/ (function(module, exports) {

(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["BrowserFS"] = factory();
	else
		root["BrowserFS"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer, global, module, process) {'use strict';
	
	Object.defineProperty(exports, '__esModule', { value: true });
	
	var buffer = __webpack_require__(2);
	var path = __webpack_require__(9);
	
	/**
	 * Standard libc error codes. Add more to this enum and ErrorStrings as they are
	 * needed.
	 * @url http://www.gnu.org/software/libc/manual/html_node/Error-Codes.html
	 */
	/**
	 * Standard libc error codes. Add more to this enum and ErrorStrings as they are
	 * needed.
	 * @url http://www.gnu.org/software/libc/manual/html_node/Error-Codes.html
	 */ var ErrorCode;
	(function (ErrorCode) {
	    ErrorCode[ErrorCode["EPERM"] = 1] = "EPERM";
	    ErrorCode[ErrorCode["ENOENT"] = 2] = "ENOENT";
	    ErrorCode[ErrorCode["EIO"] = 5] = "EIO";
	    ErrorCode[ErrorCode["EBADF"] = 9] = "EBADF";
	    ErrorCode[ErrorCode["EACCES"] = 13] = "EACCES";
	    ErrorCode[ErrorCode["EBUSY"] = 16] = "EBUSY";
	    ErrorCode[ErrorCode["EEXIST"] = 17] = "EEXIST";
	    ErrorCode[ErrorCode["ENOTDIR"] = 20] = "ENOTDIR";
	    ErrorCode[ErrorCode["EISDIR"] = 21] = "EISDIR";
	    ErrorCode[ErrorCode["EINVAL"] = 22] = "EINVAL";
	    ErrorCode[ErrorCode["EFBIG"] = 27] = "EFBIG";
	    ErrorCode[ErrorCode["ENOSPC"] = 28] = "ENOSPC";
	    ErrorCode[ErrorCode["EROFS"] = 30] = "EROFS";
	    ErrorCode[ErrorCode["ENOTEMPTY"] = 39] = "ENOTEMPTY";
	    ErrorCode[ErrorCode["ENOTSUP"] = 95] = "ENOTSUP";
	})(ErrorCode || (ErrorCode = {}));
	/* tslint:disable:variable-name */
	/**
	 * Strings associated with each error code.
	 * @hidden
	 */
	var ErrorStrings = {};
	ErrorStrings[ErrorCode.EPERM] = 'Operation not permitted.';
	ErrorStrings[ErrorCode.ENOENT] = 'No such file or directory.';
	ErrorStrings[ErrorCode.EIO] = 'Input/output error.';
	ErrorStrings[ErrorCode.EBADF] = 'Bad file descriptor.';
	ErrorStrings[ErrorCode.EACCES] = 'Permission denied.';
	ErrorStrings[ErrorCode.EBUSY] = 'Resource busy or locked.';
	ErrorStrings[ErrorCode.EEXIST] = 'File exists.';
	ErrorStrings[ErrorCode.ENOTDIR] = 'File is not a directory.';
	ErrorStrings[ErrorCode.EISDIR] = 'File is a directory.';
	ErrorStrings[ErrorCode.EINVAL] = 'Invalid argument.';
	ErrorStrings[ErrorCode.EFBIG] = 'File is too big.';
	ErrorStrings[ErrorCode.ENOSPC] = 'No space left on disk.';
	ErrorStrings[ErrorCode.EROFS] = 'Cannot modify a read-only file system.';
	ErrorStrings[ErrorCode.ENOTEMPTY] = 'Directory is not empty.';
	ErrorStrings[ErrorCode.ENOTSUP] = 'Operation is not supported.';
	/* tslint:enable:variable-name */
	/**
	 * Represents a BrowserFS error. Passed back to applications after a failed
	 * call to the BrowserFS API.
	 */
	var ApiError = (function (Error) {
	     function ApiError(type, message, path$$1) {
	        if ( message === void 0 ) message = ErrorStrings[type];
	
	        Error.call(this, message);
	        // Unsupported.
	        this.syscall = "";
	        this.errno = type;
	        this.code = ErrorCode[type];
	        this.path = path$$1;
	        this.stack = new Error().stack;
	        this.message = "Error: " + (this.code) + ": " + message + (this.path ? (", '" + (this.path) + "'") : '');
	    }
	
	     if ( Error ) ApiError.__proto__ = Error;
	     ApiError.prototype = Object.create( Error && Error.prototype );
	     ApiError.prototype.constructor = ApiError;
	    ApiError.fromJSON = function fromJSON (json) {
	        var err = new ApiError(0);
	        err.errno = json.errno;
	        err.code = json.code;
	        err.path = json.path;
	        err.stack = json.stack;
	        err.message = json.message;
	        return err;
	    };
	    /**
	     * Creates an ApiError object from a buffer.
	     */
	    ApiError.fromBuffer = function fromBuffer (buffer$$1, i) {
	        if ( i === void 0 ) i = 0;
	
	        return ApiError.fromJSON(JSON.parse(buffer$$1.toString('utf8', i + 4, i + 4 + buffer$$1.readUInt32LE(i))));
	    };
	    ApiError.FileError = function FileError (code, p) {
	        return new ApiError(code, ErrorStrings[code], p);
	    };
	    ApiError.ENOENT = function ENOENT (path$$1) {
	        return this.FileError(ErrorCode.ENOENT, path$$1);
	    };
	    ApiError.EEXIST = function EEXIST (path$$1) {
	        return this.FileError(ErrorCode.EEXIST, path$$1);
	    };
	    ApiError.EISDIR = function EISDIR (path$$1) {
	        return this.FileError(ErrorCode.EISDIR, path$$1);
	    };
	    ApiError.ENOTDIR = function ENOTDIR (path$$1) {
	        return this.FileError(ErrorCode.ENOTDIR, path$$1);
	    };
	    ApiError.EPERM = function EPERM (path$$1) {
	        return this.FileError(ErrorCode.EPERM, path$$1);
	    };
	    ApiError.ENOTEMPTY = function ENOTEMPTY (path$$1) {
	        return this.FileError(ErrorCode.ENOTEMPTY, path$$1);
	    };
	    /**
	     * @return A friendly error message.
	     */
	    ApiError.prototype.toString = function toString () {
	        return this.message;
	    };
	    ApiError.prototype.toJSON = function toJSON () {
	        return {
	            errno: this.errno,
	            code: this.code,
	            path: this.path,
	            stack: this.stack,
	            message: this.message
	        };
	    };
	    /**
	     * Writes the API error into a buffer.
	     */
	    ApiError.prototype.writeToBuffer = function writeToBuffer (buffer$$1, i) {
	        if ( buffer$$1 === void 0 ) buffer$$1 = Buffer.alloc(this.bufferSize());
	        if ( i === void 0 ) i = 0;
	
	        var bytesWritten = buffer$$1.write(JSON.stringify(this.toJSON()), i + 4);
	        buffer$$1.writeUInt32LE(bytesWritten, i);
	        return buffer$$1;
	    };
	    /**
	     * The size of the API error in buffer-form in bytes.
	     */
	    ApiError.prototype.bufferSize = function bufferSize () {
	        // 4 bytes for string length.
	        return 4 + Buffer.byteLength(JSON.stringify(this.toJSON()));
	    };
	
	     return ApiError;
	 }(Error));
	
	
	var api_error = Object.freeze({
		get ErrorCode () { return ErrorCode; },
		ErrorStrings: ErrorStrings,
		ApiError: ApiError
	});
	
	var ActionType;
	(function (ActionType) {
	    // Indicates that the code should not do anything.
	    ActionType[ActionType["NOP"] = 0] = "NOP";
	    // Indicates that the code should throw an exception.
	    ActionType[ActionType["THROW_EXCEPTION"] = 1] = "THROW_EXCEPTION";
	    // Indicates that the code should truncate the file, but only if it is a file.
	    ActionType[ActionType["TRUNCATE_FILE"] = 2] = "TRUNCATE_FILE";
	    // Indicates that the code should create the file.
	    ActionType[ActionType["CREATE_FILE"] = 3] = "CREATE_FILE";
	})(ActionType || (ActionType = {}));
	/**
	 * Represents one of the following file flags. A convenience object.
	 *
	 * * `'r'` - Open file for reading. An exception occurs if the file does not exist.
	 * * `'r+'` - Open file for reading and writing. An exception occurs if the file does not exist.
	 * * `'rs'` - Open file for reading in synchronous mode. Instructs the filesystem to not cache writes.
	 * * `'rs+'` - Open file for reading and writing, and opens the file in synchronous mode.
	 * * `'w'` - Open file for writing. The file is created (if it does not exist) or truncated (if it exists).
	 * * `'wx'` - Like 'w' but opens the file in exclusive mode.
	 * * `'w+'` - Open file for reading and writing. The file is created (if it does not exist) or truncated (if it exists).
	 * * `'wx+'` - Like 'w+' but opens the file in exclusive mode.
	 * * `'a'` - Open file for appending. The file is created if it does not exist.
	 * * `'ax'` - Like 'a' but opens the file in exclusive mode.
	 * * `'a+'` - Open file for reading and appending. The file is created if it does not exist.
	 * * `'ax+'` - Like 'a+' but opens the file in exclusive mode.
	 *
	 * Exclusive mode ensures that the file path is newly created.
	 */
	var FileFlag = function FileFlag(flagStr) {
	    this.flagStr = flagStr;
	    if (FileFlag.validFlagStrs.indexOf(flagStr) < 0) {
	        throw new ApiError(ErrorCode.EINVAL, "Invalid flag: " + flagStr);
	    }
	};
	/**
	 * Get an object representing the given file flag.
	 * @param modeStr The string representing the flag
	 * @return The FileFlag object representing the flag
	 * @throw when the flag string is invalid
	 */
	FileFlag.getFileFlag = function getFileFlag (flagStr) {
	    // Check cache first.
	    if (FileFlag.flagCache.hasOwnProperty(flagStr)) {
	        return FileFlag.flagCache[flagStr];
	    }
	    return FileFlag.flagCache[flagStr] = new FileFlag(flagStr);
	};
	/**
	 * Get the underlying flag string for this flag.
	 */
	FileFlag.prototype.getFlagString = function getFlagString () {
	    return this.flagStr;
	};
	/**
	 * Returns true if the file is readable.
	 */
	FileFlag.prototype.isReadable = function isReadable () {
	    return this.flagStr.indexOf('r') !== -1 || this.flagStr.indexOf('+') !== -1;
	};
	/**
	 * Returns true if the file is writeable.
	 */
	FileFlag.prototype.isWriteable = function isWriteable () {
	    return this.flagStr.indexOf('w') !== -1 || this.flagStr.indexOf('a') !== -1 || this.flagStr.indexOf('+') !== -1;
	};
	/**
	 * Returns true if the file mode should truncate.
	 */
	FileFlag.prototype.isTruncating = function isTruncating () {
	    return this.flagStr.indexOf('w') !== -1;
	};
	/**
	 * Returns true if the file is appendable.
	 */
	FileFlag.prototype.isAppendable = function isAppendable () {
	    return this.flagStr.indexOf('a') !== -1;
	};
	/**
	 * Returns true if the file is open in synchronous mode.
	 */
	FileFlag.prototype.isSynchronous = function isSynchronous () {
	    return this.flagStr.indexOf('s') !== -1;
	};
	/**
	 * Returns true if the file is open in exclusive mode.
	 */
	FileFlag.prototype.isExclusive = function isExclusive () {
	    return this.flagStr.indexOf('x') !== -1;
	};
	/**
	 * Returns one of the static fields on this object that indicates the
	 * appropriate response to the path existing.
	 */
	FileFlag.prototype.pathExistsAction = function pathExistsAction () {
	    if (this.isExclusive()) {
	        return ActionType.THROW_EXCEPTION;
	    }
	    else if (this.isTruncating()) {
	        return ActionType.TRUNCATE_FILE;
	    }
	    else {
	        return ActionType.NOP;
	    }
	};
	/**
	 * Returns one of the static fields on this object that indicates the
	 * appropriate response to the path not existing.
	 */
	FileFlag.prototype.pathNotExistsAction = function pathNotExistsAction () {
	    if ((this.isWriteable() || this.isAppendable()) && this.flagStr !== 'r+') {
	        return ActionType.CREATE_FILE;
	    }
	    else {
	        return ActionType.THROW_EXCEPTION;
	    }
	};
	// Contains cached FileMode instances.
	FileFlag.flagCache = {};
	// Array of valid mode strings.
	FileFlag.validFlagStrs = ['r', 'r+', 'rs', 'rs+', 'w', 'wx', 'w+', 'wx+', 'a', 'ax', 'a+', 'ax+'];
	
	/**
	 * Indicates the type of the given file. Applied to 'mode'.
	 */
	var FileType;
	(function (FileType) {
	    FileType[FileType["FILE"] = 32768] = "FILE";
	    FileType[FileType["DIRECTORY"] = 16384] = "DIRECTORY";
	    FileType[FileType["SYMLINK"] = 40960] = "SYMLINK";
	})(FileType || (FileType = {}));
	/**
	 * Emulation of Node's `fs.Stats` object.
	 *
	 * Attribute descriptions are from `man 2 stat'
	 * @see http://nodejs.org/api/fs.html#fs_class_fs_stats
	 * @see http://man7.org/linux/man-pages/man2/stat.2.html
	 */
	var Stats = function Stats(itemType, size, mode, atime, mtime, ctime) {
	    if ( atime === void 0 ) atime = new Date();
	    if ( mtime === void 0 ) mtime = new Date();
	    if ( ctime === void 0 ) ctime = new Date();
	
	    this.size = size;
	    this.atime = atime;
	    this.mtime = mtime;
	    this.ctime = ctime;
	    /**
	     * UNSUPPORTED ATTRIBUTES
	     * I assume no one is going to need these details, although we could fake
	     * appropriate values if need be.
	     */
	    // ID of device containing file
	    this.dev = 0;
	    // inode number
	    this.ino = 0;
	    // device ID (if special file)
	    this.rdev = 0;
	    // number of hard links
	    this.nlink = 1;
	    // blocksize for file system I/O
	    this.blksize = 4096;
	    // @todo Maybe support these? atm, it's a one-user filesystem.
	    // user ID of owner
	    this.uid = 0;
	    // group ID of owner
	    this.gid = 0;
	    // time file was created (currently unsupported)
	    this.birthtime = new Date(0);
	    // XXX: Some file systems stash data on stats objects.
	    this.fileData = null;
	    if (!mode) {
	        switch (itemType) {
	            case FileType.FILE:
	                this.mode = 0x1a4;
	                break;
	            case FileType.DIRECTORY:
	            default:
	                this.mode = 0x1ff;
	        }
	    }
	    else {
	        this.mode = mode;
	    }
	    // number of 512B blocks allocated
	    this.blocks = Math.ceil(size / 512);
	    // Check if mode also includes top-most bits, which indicate the file's
	    // type.
	    if (this.mode < 0x1000) {
	        this.mode |= itemType;
	    }
	};
	Stats.fromBuffer = function fromBuffer (buffer$$1) {
	    var size = buffer$$1.readUInt32LE(0), mode = buffer$$1.readUInt32LE(4), atime = buffer$$1.readDoubleLE(8), mtime = buffer$$1.readDoubleLE(16), ctime = buffer$$1.readDoubleLE(24);
	    return new Stats(mode & 0xF000, size, mode & 0xFFF, new Date(atime), new Date(mtime), new Date(ctime));
	};
	Stats.prototype.toBuffer = function toBuffer () {
	    var buffer$$1 = Buffer.alloc(32);
	    buffer$$1.writeUInt32LE(this.size, 0);
	    buffer$$1.writeUInt32LE(this.mode, 4);
	    buffer$$1.writeDoubleLE(this.atime.getTime(), 8);
	    buffer$$1.writeDoubleLE(this.mtime.getTime(), 16);
	    buffer$$1.writeDoubleLE(this.ctime.getTime(), 24);
	    return buffer$$1;
	};
	/**
	 * **Nonstandard**: Clone the stats object.
	 * @return [BrowserFS.node.fs.Stats]
	 */
	Stats.prototype.clone = function clone () {
	    return new Stats(this.mode & 0xF000, this.size, this.mode & 0xFFF, this.atime, this.mtime, this.ctime);
	};
	/**
	 * @return [Boolean] True if this item is a file.
	 */
	Stats.prototype.isFile = function isFile () {
	    return (this.mode & 0xF000) === FileType.FILE;
	};
	/**
	 * @return [Boolean] True if this item is a directory.
	 */
	Stats.prototype.isDirectory = function isDirectory () {
	    return (this.mode & 0xF000) === FileType.DIRECTORY;
	};
	/**
	 * @return [Boolean] True if this item is a symbolic link (only valid through lstat)
	 */
	Stats.prototype.isSymbolicLink = function isSymbolicLink () {
	    return (this.mode & 0xF000) === FileType.SYMLINK;
	};
	/**
	 * Change the mode of the file. We use this helper function to prevent messing
	 * up the type of the file, which is encoded in mode.
	 */
	Stats.prototype.chmod = function chmod (mode) {
	    this.mode = (this.mode & 0xF000) | mode;
	};
	// We don't support the following types of files.
	Stats.prototype.isSocket = function isSocket () {
	    return false;
	};
	Stats.prototype.isBlockDevice = function isBlockDevice () {
	    return false;
	};
	Stats.prototype.isCharacterDevice = function isCharacterDevice () {
	    return false;
	};
	Stats.prototype.isFIFO = function isFIFO () {
	    return false;
	};
	
	/**
	 * Wraps a callback function. Used for unit testing. Defaults to a NOP.
	 * @hidden
	 */
	var wrapCb = function (cb, numArgs) {
	    return cb;
	};
	/**
	 * @hidden
	 */
	function assertRoot(fs) {
	    if (fs) {
	        return fs;
	    }
	    throw new ApiError(ErrorCode.EIO, "Initialize BrowserFS with a file system using BrowserFS.initialize(filesystem)");
	}
	/**
	 * @hidden
	 */
	function normalizeMode(mode, def) {
	    switch (typeof mode) {
	        case 'number':
	            // (path, flag, mode, cb?)
	            return mode;
	        case 'string':
	            // (path, flag, modeString, cb?)
	            var trueMode = parseInt(mode, 8);
	            if (!isNaN(trueMode)) {
	                return trueMode;
	            }
	            // Invalid string.
	            return def;
	        default:
	            return def;
	    }
	}
	/**
	 * @hidden
	 */
	function normalizeTime(time) {
	    if (time instanceof Date) {
	        return time;
	    }
	    else if (typeof time === 'number') {
	        return new Date(time * 1000);
	    }
	    else {
	        throw new ApiError(ErrorCode.EINVAL, "Invalid time.");
	    }
	}
	/**
	 * @hidden
	 */
	function normalizePath(p) {
	    // Node doesn't allow null characters in paths.
	    if (p.indexOf('\u0000') >= 0) {
	        throw new ApiError(ErrorCode.EINVAL, 'Path must be a string without null bytes.');
	    }
	    else if (p === '') {
	        throw new ApiError(ErrorCode.EINVAL, 'Path must not be empty.');
	    }
	    return path.resolve(p);
	}
	/**
	 * @hidden
	 */
	function normalizeOptions(options, defEnc, defFlag, defMode) {
	    switch (typeof options) {
	        case 'object':
	            return {
	                encoding: typeof options['encoding'] !== 'undefined' ? options['encoding'] : defEnc,
	                flag: typeof options['flag'] !== 'undefined' ? options['flag'] : defFlag,
	                mode: normalizeMode(options['mode'], defMode)
	            };
	        case 'string':
	            return {
	                encoding: options,
	                flag: defFlag,
	                mode: defMode
	            };
	        default:
	            return {
	                encoding: defEnc,
	                flag: defFlag,
	                mode: defMode
	            };
	    }
	}
	/**
	 * The default callback is a NOP.
	 * @hidden
	 * @private
	 */
	function nopCb() {
	    // NOP.
	}
	/**
	 * The node frontend to all filesystems.
	 * This layer handles:
	 *
	 * * Sanity checking inputs.
	 * * Normalizing paths.
	 * * Resetting stack depth for asynchronous operations which may not go through
	 *   the browser by wrapping all input callbacks using `setImmediate`.
	 * * Performing the requested operation through the filesystem or the file
	 *   descriptor, as appropriate.
	 * * Handling optional arguments and setting default arguments.
	 * @see http://nodejs.org/api/fs.html
	 */
	var FS = function FS() {
	    /* tslint:enable:variable-name */
	    this.F_OK = 0;
	    this.R_OK = 4;
	    this.W_OK = 2;
	    this.X_OK = 1;
	    this.root = null;
	    this.fdMap = {};
	    this.nextFd = 100;
	};
	FS.prototype.initialize = function initialize (rootFS) {
	    if (!rootFS.constructor.isAvailable()) {
	        throw new ApiError(ErrorCode.EINVAL, 'Tried to instantiate BrowserFS with an unavailable file system.');
	    }
	    return this.root = rootFS;
	};
	/**
	 * converts Date or number to a fractional UNIX timestamp
	 * Grabbed from NodeJS sources (lib/fs.js)
	 */
	FS.prototype._toUnixTimestamp = function _toUnixTimestamp (time) {
	    if (typeof time === 'number') {
	        return time;
	    }
	    else if (time instanceof Date) {
	        return time.getTime() / 1000;
	    }
	    throw new Error("Cannot parse time: " + time);
	};
	/**
	 * **NONSTANDARD**: Grab the FileSystem instance that backs this API.
	 * @return [BrowserFS.FileSystem | null] Returns null if the file system has
	 *   not been initialized.
	 */
	FS.prototype.getRootFS = function getRootFS () {
	    if (this.root) {
	        return this.root;
	    }
	    else {
	        return null;
	    }
	};
	// FILE OR DIRECTORY METHODS
	/**
	 * Asynchronous rename. No arguments other than a possible exception are given
	 * to the completion callback.
	 * @param oldPath
	 * @param newPath
	 * @param callback
	 */
	FS.prototype.rename = function rename (oldPath, newPath, cb) {
	        if ( cb === void 0 ) cb = nopCb;
	
	    var newCb = wrapCb(cb, 1);
	    try {
	        assertRoot(this.root).rename(normalizePath(oldPath), normalizePath(newPath), newCb);
	    }
	    catch (e) {
	        newCb(e);
	    }
	};
	/**
	 * Synchronous rename.
	 * @param oldPath
	 * @param newPath
	 */
	FS.prototype.renameSync = function renameSync (oldPath, newPath) {
	    assertRoot(this.root).renameSync(normalizePath(oldPath), normalizePath(newPath));
	};
	/**
	 * Test whether or not the given path exists by checking with the file system.
	 * Then call the callback argument with either true or false.
	 * @example Sample invocation
	 *   fs.exists('/etc/passwd', function (exists) {
	 * util.debug(exists ? "it's there" : "no passwd!");
	 *   });
	 * @param path
	 * @param callback
	 */
	FS.prototype.exists = function exists (path$$1, cb) {
	        if ( cb === void 0 ) cb = nopCb;
	
	    var newCb = wrapCb(cb, 1);
	    try {
	        return assertRoot(this.root).exists(normalizePath(path$$1), newCb);
	    }
	    catch (e) {
	        // Doesn't return an error. If something bad happens, we assume it just
	        // doesn't exist.
	        return newCb(false);
	    }
	};
	/**
	 * Test whether or not the given path exists by checking with the file system.
	 * @param path
	 * @return [boolean]
	 */
	FS.prototype.existsSync = function existsSync (path$$1) {
	    try {
	        return assertRoot(this.root).existsSync(normalizePath(path$$1));
	    }
	    catch (e) {
	        // Doesn't return an error. If something bad happens, we assume it just
	        // doesn't exist.
	        return false;
	    }
	};
	/**
	 * Asynchronous `stat`.
	 * @param path
	 * @param callback
	 */
	FS.prototype.stat = function stat (path$$1, cb) {
	        if ( cb === void 0 ) cb = nopCb;
	
	    var newCb = wrapCb(cb, 2);
	    try {
	        return assertRoot(this.root).stat(normalizePath(path$$1), false, newCb);
	    }
	    catch (e) {
	        return newCb(e);
	    }
	};
	/**
	 * Synchronous `stat`.
	 * @param path
	 * @return [BrowserFS.node.fs.Stats]
	 */
	FS.prototype.statSync = function statSync (path$$1) {
	    return assertRoot(this.root).statSync(normalizePath(path$$1), false);
	};
	/**
	 * Asynchronous `lstat`.
	 * `lstat()` is identical to `stat()`, except that if path is a symbolic link,
	 * then the link itself is stat-ed, not the file that it refers to.
	 * @param path
	 * @param callback
	 */
	FS.prototype.lstat = function lstat (path$$1, cb) {
	        if ( cb === void 0 ) cb = nopCb;
	
	    var newCb = wrapCb(cb, 2);
	    try {
	        return assertRoot(this.root).stat(normalizePath(path$$1), true, newCb);
	    }
	    catch (e) {
	        return newCb(e);
	    }
	};
	/**
	 * Synchronous `lstat`.
	 * `lstat()` is identical to `stat()`, except that if path is a symbolic link,
	 * then the link itself is stat-ed, not the file that it refers to.
	 * @param path
	 * @return [BrowserFS.node.fs.Stats]
	 */
	FS.prototype.lstatSync = function lstatSync (path$$1) {
	    return assertRoot(this.root).statSync(normalizePath(path$$1), true);
	};
	FS.prototype.truncate = function truncate (path$$1, arg2, cb) {
	        if ( arg2 === void 0 ) arg2 = 0;
	        if ( cb === void 0 ) cb = nopCb;
	
	    var len = 0;
	    if (typeof arg2 === 'function') {
	        cb = arg2;
	    }
	    else if (typeof arg2 === 'number') {
	        len = arg2;
	    }
	    var newCb = wrapCb(cb, 1);
	    try {
	        if (len < 0) {
	            throw new ApiError(ErrorCode.EINVAL);
	        }
	        return assertRoot(this.root).truncate(normalizePath(path$$1), len, newCb);
	    }
	    catch (e) {
	        return newCb(e);
	    }
	};
	/**
	 * Synchronous `truncate`.
	 * @param path
	 * @param len
	 */
	FS.prototype.truncateSync = function truncateSync (path$$1, len) {
	        if ( len === void 0 ) len = 0;
	
	    if (len < 0) {
	        throw new ApiError(ErrorCode.EINVAL);
	    }
	    return assertRoot(this.root).truncateSync(normalizePath(path$$1), len);
	};
	/**
	 * Asynchronous `unlink`.
	 * @param path
	 * @param callback
	 */
	FS.prototype.unlink = function unlink (path$$1, cb) {
	        if ( cb === void 0 ) cb = nopCb;
	
	    var newCb = wrapCb(cb, 1);
	    try {
	        return assertRoot(this.root).unlink(normalizePath(path$$1), newCb);
	    }
	    catch (e) {
	        return newCb(e);
	    }
	};
	/**
	 * Synchronous `unlink`.
	 * @param path
	 */
	FS.prototype.unlinkSync = function unlinkSync (path$$1) {
	    return assertRoot(this.root).unlinkSync(normalizePath(path$$1));
	};
	FS.prototype.open = function open (path$$1, flag, arg2, cb) {
	        var this$1 = this;
	        if ( cb === void 0 ) cb = nopCb;
	
	    var mode = normalizeMode(arg2, 0x1a4);
	    cb = typeof arg2 === 'function' ? arg2 : cb;
	    var newCb = wrapCb(cb, 2);
	    try {
	        assertRoot(this.root).open(normalizePath(path$$1), FileFlag.getFileFlag(flag), mode, function (e, file) {
	            if (file) {
	                newCb(e, this$1.getFdForFile(file));
	            }
	            else {
	                newCb(e);
	            }
	        });
	    }
	    catch (e) {
	        newCb(e);
	    }
	};
	/**
	 * Synchronous file open.
	 * @see http://www.manpagez.com/man/2/open/
	 * @param path
	 * @param flags
	 * @param mode defaults to `0644`
	 * @return [BrowserFS.File]
	 */
	FS.prototype.openSync = function openSync (path$$1, flag, mode) {
	        if ( mode === void 0 ) mode = 0x1a4;
	
	    return this.getFdForFile(assertRoot(this.root).openSync(normalizePath(path$$1), FileFlag.getFileFlag(flag), normalizeMode(mode, 0x1a4)));
	};
	FS.prototype.readFile = function readFile (filename, arg2, cb) {
	        if ( arg2 === void 0 ) arg2 = {};
	        if ( cb === void 0 ) cb = nopCb;
	
	    var options = normalizeOptions(arg2, null, 'r', null);
	    cb = typeof arg2 === 'function' ? arg2 : cb;
	    var newCb = wrapCb(cb, 2);
	    try {
	        var flag = FileFlag.getFileFlag(options['flag']);
	        if (!flag.isReadable()) {
	            return newCb(new ApiError(ErrorCode.EINVAL, 'Flag passed to readFile must allow for reading.'));
	        }
	        return assertRoot(this.root).readFile(normalizePath(filename), options.encoding, flag, newCb);
	    }
	    catch (e) {
	        return newCb(e);
	    }
	};
	FS.prototype.readFileSync = function readFileSync (filename, arg2) {
	        if ( arg2 === void 0 ) arg2 = {};
	
	    var options = normalizeOptions(arg2, null, 'r', null);
	    var flag = FileFlag.getFileFlag(options.flag);
	    if (!flag.isReadable()) {
	        throw new ApiError(ErrorCode.EINVAL, 'Flag passed to readFile must allow for reading.');
	    }
	    return assertRoot(this.root).readFileSync(normalizePath(filename), options.encoding, flag);
	};
	FS.prototype.writeFile = function writeFile (filename, data, arg3, cb) {
	        if ( arg3 === void 0 ) arg3 = {};
	        if ( cb === void 0 ) cb = nopCb;
	
	    var options = normalizeOptions(arg3, 'utf8', 'w', 0x1a4);
	    cb = typeof arg3 === 'function' ? arg3 : cb;
	    var newCb = wrapCb(cb, 1);
	    try {
	        var flag = FileFlag.getFileFlag(options.flag);
	        if (!flag.isWriteable()) {
	            return newCb(new ApiError(ErrorCode.EINVAL, 'Flag passed to writeFile must allow for writing.'));
	        }
	        return assertRoot(this.root).writeFile(normalizePath(filename), data, options.encoding, flag, options.mode, newCb);
	    }
	    catch (e) {
	        return newCb(e);
	    }
	};
	FS.prototype.writeFileSync = function writeFileSync (filename, data, arg3) {
	    var options = normalizeOptions(arg3, 'utf8', 'w', 0x1a4);
	    var flag = FileFlag.getFileFlag(options.flag);
	    if (!flag.isWriteable()) {
	        throw new ApiError(ErrorCode.EINVAL, 'Flag passed to writeFile must allow for writing.');
	    }
	    return assertRoot(this.root).writeFileSync(normalizePath(filename), data, options.encoding, flag, options.mode);
	};
	FS.prototype.appendFile = function appendFile (filename, data, arg3, cb) {
	        if ( cb === void 0 ) cb = nopCb;
	
	    var options = normalizeOptions(arg3, 'utf8', 'a', 0x1a4);
	    cb = typeof arg3 === 'function' ? arg3 : cb;
	    var newCb = wrapCb(cb, 1);
	    try {
	        var flag = FileFlag.getFileFlag(options.flag);
	        if (!flag.isAppendable()) {
	            return newCb(new ApiError(ErrorCode.EINVAL, 'Flag passed to appendFile must allow for appending.'));
	        }
	        assertRoot(this.root).appendFile(normalizePath(filename), data, options.encoding, flag, options.mode, newCb);
	    }
	    catch (e) {
	        newCb(e);
	    }
	};
	FS.prototype.appendFileSync = function appendFileSync (filename, data, arg3) {
	    var options = normalizeOptions(arg3, 'utf8', 'a', 0x1a4);
	    var flag = FileFlag.getFileFlag(options.flag);
	    if (!flag.isAppendable()) {
	        throw new ApiError(ErrorCode.EINVAL, 'Flag passed to appendFile must allow for appending.');
	    }
	    return assertRoot(this.root).appendFileSync(normalizePath(filename), data, options.encoding, flag, options.mode);
	};
	// FILE DESCRIPTOR METHODS
	/**
	 * Asynchronous `fstat`.
	 * `fstat()` is identical to `stat()`, except that the file to be stat-ed is
	 * specified by the file descriptor `fd`.
	 * @param fd
	 * @param callback
	 */
	FS.prototype.fstat = function fstat (fd, cb) {
	        if ( cb === void 0 ) cb = nopCb;
	
	    var newCb = wrapCb(cb, 2);
	    try {
	        var file = this.fd2file(fd);
	        file.stat(newCb);
	    }
	    catch (e) {
	        newCb(e);
	    }
	};
	/**
	 * Synchronous `fstat`.
	 * `fstat()` is identical to `stat()`, except that the file to be stat-ed is
	 * specified by the file descriptor `fd`.
	 * @param fd
	 * @return [BrowserFS.node.fs.Stats]
	 */
	FS.prototype.fstatSync = function fstatSync (fd) {
	    return this.fd2file(fd).statSync();
	};
	/**
	 * Asynchronous close.
	 * @param fd
	 * @param callback
	 */
	FS.prototype.close = function close (fd, cb) {
	        var this$1 = this;
	        if ( cb === void 0 ) cb = nopCb;
	
	    var newCb = wrapCb(cb, 1);
	    try {
	        this.fd2file(fd).close(function (e) {
	            if (!e) {
	                this$1.closeFd(fd);
	            }
	            newCb(e);
	        });
	    }
	    catch (e) {
	        newCb(e);
	    }
	};
	/**
	 * Synchronous close.
	 * @param fd
	 */
	FS.prototype.closeSync = function closeSync (fd) {
	    this.fd2file(fd).closeSync();
	    this.closeFd(fd);
	};
	FS.prototype.ftruncate = function ftruncate (fd, arg2, cb) {
	        if ( cb === void 0 ) cb = nopCb;
	
	    var length = typeof arg2 === 'number' ? arg2 : 0;
	    cb = typeof arg2 === 'function' ? arg2 : cb;
	    var newCb = wrapCb(cb, 1);
	    try {
	        var file = this.fd2file(fd);
	        if (length < 0) {
	            throw new ApiError(ErrorCode.EINVAL);
	        }
	        file.truncate(length, newCb);
	    }
	    catch (e) {
	        newCb(e);
	    }
	};
	/**
	 * Synchronous ftruncate.
	 * @param fd
	 * @param len
	 */
	FS.prototype.ftruncateSync = function ftruncateSync (fd, len) {
	        if ( len === void 0 ) len = 0;
	
	    var file = this.fd2file(fd);
	    if (len < 0) {
	        throw new ApiError(ErrorCode.EINVAL);
	    }
	    file.truncateSync(len);
	};
	/**
	 * Asynchronous fsync.
	 * @param fd
	 * @param callback
	 */
	FS.prototype.fsync = function fsync (fd, cb) {
	        if ( cb === void 0 ) cb = nopCb;
	
	    var newCb = wrapCb(cb, 1);
	    try {
	        this.fd2file(fd).sync(newCb);
	    }
	    catch (e) {
	        newCb(e);
	    }
	};
	/**
	 * Synchronous fsync.
	 * @param fd
	 */
	FS.prototype.fsyncSync = function fsyncSync (fd) {
	    this.fd2file(fd).syncSync();
	};
	/**
	 * Asynchronous fdatasync.
	 * @param fd
	 * @param callback
	 */
	FS.prototype.fdatasync = function fdatasync (fd, cb) {
	        if ( cb === void 0 ) cb = nopCb;
	
	    var newCb = wrapCb(cb, 1);
	    try {
	        this.fd2file(fd).datasync(newCb);
	    }
	    catch (e) {
	        newCb(e);
	    }
	};
	/**
	 * Synchronous fdatasync.
	 * @param fd
	 */
	FS.prototype.fdatasyncSync = function fdatasyncSync (fd) {
	    this.fd2file(fd).datasyncSync();
	};
	FS.prototype.write = function write (fd, arg2, arg3, arg4, arg5, cb) {
	        if ( cb === void 0 ) cb = nopCb;
	
	    var buffer$$1, offset, length, position = null;
	    if (typeof arg2 === 'string') {
	        // Signature 1: (fd, string, [position?, [encoding?]], cb?)
	        var encoding = 'utf8';
	        switch (typeof arg3) {
	            case 'function':
	                // (fd, string, cb)
	                cb = arg3;
	                break;
	            case 'number':
	                // (fd, string, position, encoding?, cb?)
	                position = arg3;
	                encoding = typeof arg4 === 'string' ? arg4 : 'utf8';
	                cb = typeof arg5 === 'function' ? arg5 : cb;
	                break;
	            default:
	                // ...try to find the callback and get out of here!
	                cb = typeof arg4 === 'function' ? arg4 : typeof arg5 === 'function' ? arg5 : cb;
	                return cb(new ApiError(ErrorCode.EINVAL, 'Invalid arguments.'));
	        }
	        buffer$$1 = Buffer.from(arg2, encoding);
	        offset = 0;
	        length = buffer$$1.length;
	    }
	    else {
	        // Signature 2: (fd, buffer, offset, length, position?, cb?)
	        buffer$$1 = arg2;
	        offset = arg3;
	        length = arg4;
	        position = typeof arg5 === 'number' ? arg5 : null;
	        cb = typeof arg5 === 'function' ? arg5 : cb;
	    }
	    var newCb = wrapCb(cb, 3);
	    try {
	        var file = this.fd2file(fd);
	        if (position === undefined || position === null) {
	            position = file.getPos();
	        }
	        file.write(buffer$$1, offset, length, position, newCb);
	    }
	    catch (e) {
	        newCb(e);
	    }
	};
	FS.prototype.writeSync = function writeSync (fd, arg2, arg3, arg4, arg5) {
	    var buffer$$1, offset = 0, length, position;
	    if (typeof arg2 === 'string') {
	        // Signature 1: (fd, string, [position?, [encoding?]])
	        position = typeof arg3 === 'number' ? arg3 : null;
	        var encoding = typeof arg4 === 'string' ? arg4 : 'utf8';
	        offset = 0;
	        buffer$$1 = Buffer.from(arg2, encoding);
	        length = buffer$$1.length;
	    }
	    else {
	        // Signature 2: (fd, buffer, offset, length, position?)
	        buffer$$1 = arg2;
	        offset = arg3;
	        length = arg4;
	        position = typeof arg5 === 'number' ? arg5 : null;
	    }
	    var file = this.fd2file(fd);
	    if (position === undefined || position === null) {
	        position = file.getPos();
	    }
	    return file.writeSync(buffer$$1, offset, length, position);
	};
	FS.prototype.read = function read (fd, arg2, arg3, arg4, arg5, cb) {
	        if ( cb === void 0 ) cb = nopCb;
	
	    var position, offset, length, buffer$$1, newCb;
	    if (typeof arg2 === 'number') {
	        // legacy interface
	        // (fd, length, position, encoding, callback)
	        length = arg2;
	        position = arg3;
	        var encoding = arg4;
	        cb = typeof arg5 === 'function' ? arg5 : cb;
	        offset = 0;
	        buffer$$1 = Buffer.alloc(length);
	        // XXX: Inefficient.
	        // Wrap the cb so we shelter upper layers of the API from these
	        // shenanigans.
	        newCb = wrapCb(function (err, bytesRead, buf) {
	            if (err) {
	                return cb(err);
	            }
	            cb(err, buf.toString(encoding), bytesRead);
	        }, 3);
	    }
	    else {
	        buffer$$1 = arg2;
	        offset = arg3;
	        length = arg4;
	        position = arg5;
	        newCb = wrapCb(cb, 3);
	    }
	    try {
	        var file = this.fd2file(fd);
	        if (position === undefined || position === null) {
	            position = file.getPos();
	        }
	        file.read(buffer$$1, offset, length, position, newCb);
	    }
	    catch (e) {
	        newCb(e);
	    }
	};
	FS.prototype.readSync = function readSync (fd, arg2, arg3, arg4, arg5) {
	    var shenanigans = false;
	    var buffer$$1, offset, length, position, encoding = 'utf8';
	    if (typeof arg2 === 'number') {
	        length = arg2;
	        position = arg3;
	        encoding = arg4;
	        offset = 0;
	        buffer$$1 = Buffer.alloc(length);
	        shenanigans = true;
	    }
	    else {
	        buffer$$1 = arg2;
	        offset = arg3;
	        length = arg4;
	        position = arg5;
	    }
	    var file = this.fd2file(fd);
	    if (position === undefined || position === null) {
	        position = file.getPos();
	    }
	    var rv = file.readSync(buffer$$1, offset, length, position);
	    if (!shenanigans) {
	        return rv;
	    }
	    else {
	        return [buffer$$1.toString(encoding), rv];
	    }
	};
	/**
	 * Asynchronous `fchown`.
	 * @param fd
	 * @param uid
	 * @param gid
	 * @param callback
	 */
	FS.prototype.fchown = function fchown (fd, uid, gid, callback) {
	        if ( callback === void 0 ) callback = nopCb;
	
	    var newCb = wrapCb(callback, 1);
	    try {
	        this.fd2file(fd).chown(uid, gid, newCb);
	    }
	    catch (e) {
	        newCb(e);
	    }
	};
	/**
	 * Synchronous `fchown`.
	 * @param fd
	 * @param uid
	 * @param gid
	 */
	FS.prototype.fchownSync = function fchownSync (fd, uid, gid) {
	    this.fd2file(fd).chownSync(uid, gid);
	};
	/**
	 * Asynchronous `fchmod`.
	 * @param fd
	 * @param mode
	 * @param callback
	 */
	FS.prototype.fchmod = function fchmod (fd, mode, cb) {
	    var newCb = wrapCb(cb, 1);
	    try {
	        var numMode = typeof mode === 'string' ? parseInt(mode, 8) : mode;
	        this.fd2file(fd).chmod(numMode, newCb);
	    }
	    catch (e) {
	        newCb(e);
	    }
	};
	/**
	 * Synchronous `fchmod`.
	 * @param fd
	 * @param mode
	 */
	FS.prototype.fchmodSync = function fchmodSync (fd, mode) {
	    var numMode = typeof mode === 'string' ? parseInt(mode, 8) : mode;
	    this.fd2file(fd).chmodSync(numMode);
	};
	/**
	 * Change the file timestamps of a file referenced by the supplied file
	 * descriptor.
	 * @param fd
	 * @param atime
	 * @param mtime
	 * @param callback
	 */
	FS.prototype.futimes = function futimes (fd, atime, mtime, cb) {
	        if ( cb === void 0 ) cb = nopCb;
	
	    var newCb = wrapCb(cb, 1);
	    try {
	        var file = this.fd2file(fd);
	        if (typeof atime === 'number') {
	            atime = new Date(atime * 1000);
	        }
	        if (typeof mtime === 'number') {
	            mtime = new Date(mtime * 1000);
	        }
	        file.utimes(atime, mtime, newCb);
	    }
	    catch (e) {
	        newCb(e);
	    }
	};
	/**
	 * Change the file timestamps of a file referenced by the supplied file
	 * descriptor.
	 * @param fd
	 * @param atime
	 * @param mtime
	 */
	FS.prototype.futimesSync = function futimesSync (fd, atime, mtime) {
	    this.fd2file(fd).utimesSync(normalizeTime(atime), normalizeTime(mtime));
	};
	// DIRECTORY-ONLY METHODS
	/**
	 * Asynchronous `rmdir`.
	 * @param path
	 * @param callback
	 */
	FS.prototype.rmdir = function rmdir (path$$1, cb) {
	        if ( cb === void 0 ) cb = nopCb;
	
	    var newCb = wrapCb(cb, 1);
	    try {
	        path$$1 = normalizePath(path$$1);
	        assertRoot(this.root).rmdir(path$$1, newCb);
	    }
	    catch (e) {
	        newCb(e);
	    }
	};
	/**
	 * Synchronous `rmdir`.
	 * @param path
	 */
	FS.prototype.rmdirSync = function rmdirSync (path$$1) {
	    path$$1 = normalizePath(path$$1);
	    return assertRoot(this.root).rmdirSync(path$$1);
	};
	/**
	 * Asynchronous `mkdir`.
	 * @param path
	 * @param mode defaults to `0777`
	 * @param callback
	 */
	FS.prototype.mkdir = function mkdir (path$$1, mode, cb) {
	        if ( cb === void 0 ) cb = nopCb;
	
	    if (typeof mode === 'function') {
	        cb = mode;
	        mode = 0x1ff;
	    }
	    var newCb = wrapCb(cb, 1);
	    try {
	        path$$1 = normalizePath(path$$1);
	        assertRoot(this.root).mkdir(path$$1, mode, newCb);
	    }
	    catch (e) {
	        newCb(e);
	    }
	};
	/**
	 * Synchronous `mkdir`.
	 * @param path
	 * @param mode defaults to `0777`
	 */
	FS.prototype.mkdirSync = function mkdirSync (path$$1, mode) {
	    assertRoot(this.root).mkdirSync(normalizePath(path$$1), normalizeMode(mode, 0x1ff));
	};
	/**
	 * Asynchronous `readdir`. Reads the contents of a directory.
	 * The callback gets two arguments `(err, files)` where `files` is an array of
	 * the names of the files in the directory excluding `'.'` and `'..'`.
	 * @param path
	 * @param callback
	 */
	FS.prototype.readdir = function readdir (path$$1, cb) {
	        if ( cb === void 0 ) cb = nopCb;
	
	    var newCb = wrapCb(cb, 2);
	    try {
	        path$$1 = normalizePath(path$$1);
	        assertRoot(this.root).readdir(path$$1, newCb);
	    }
	    catch (e) {
	        newCb(e);
	    }
	};
	/**
	 * Synchronous `readdir`. Reads the contents of a directory.
	 * @param path
	 * @return [String[]]
	 */
	FS.prototype.readdirSync = function readdirSync (path$$1) {
	    path$$1 = normalizePath(path$$1);
	    return assertRoot(this.root).readdirSync(path$$1);
	};
	// SYMLINK METHODS
	/**
	 * Asynchronous `link`.
	 * @param srcpath
	 * @param dstpath
	 * @param callback
	 */
	FS.prototype.link = function link (srcpath, dstpath, cb) {
	        if ( cb === void 0 ) cb = nopCb;
	
	    var newCb = wrapCb(cb, 1);
	    try {
	        srcpath = normalizePath(srcpath);
	        dstpath = normalizePath(dstpath);
	        assertRoot(this.root).link(srcpath, dstpath, newCb);
	    }
	    catch (e) {
	        newCb(e);
	    }
	};
	/**
	 * Synchronous `link`.
	 * @param srcpath
	 * @param dstpath
	 */
	FS.prototype.linkSync = function linkSync (srcpath, dstpath) {
	    srcpath = normalizePath(srcpath);
	    dstpath = normalizePath(dstpath);
	    return assertRoot(this.root).linkSync(srcpath, dstpath);
	};
	FS.prototype.symlink = function symlink (srcpath, dstpath, arg3, cb) {
	        if ( cb === void 0 ) cb = nopCb;
	
	    var type = typeof arg3 === 'string' ? arg3 : 'file';
	    cb = typeof arg3 === 'function' ? arg3 : cb;
	    var newCb = wrapCb(cb, 1);
	    try {
	        if (type !== 'file' && type !== 'dir') {
	            return newCb(new ApiError(ErrorCode.EINVAL, "Invalid type: " + type));
	        }
	        srcpath = normalizePath(srcpath);
	        dstpath = normalizePath(dstpath);
	        assertRoot(this.root).symlink(srcpath, dstpath, type, newCb);
	    }
	    catch (e) {
	        newCb(e);
	    }
	};
	/**
	 * Synchronous `symlink`.
	 * @param srcpath
	 * @param dstpath
	 * @param type can be either `'dir'` or `'file'` (default is `'file'`)
	 */
	FS.prototype.symlinkSync = function symlinkSync (srcpath, dstpath, type) {
	    if (!type) {
	        type = 'file';
	    }
	    else if (type !== 'file' && type !== 'dir') {
	        throw new ApiError(ErrorCode.EINVAL, "Invalid type: " + type);
	    }
	    srcpath = normalizePath(srcpath);
	    dstpath = normalizePath(dstpath);
	    return assertRoot(this.root).symlinkSync(srcpath, dstpath, type);
	};
	/**
	 * Asynchronous readlink.
	 * @param path
	 * @param callback
	 */
	FS.prototype.readlink = function readlink (path$$1, cb) {
	        if ( cb === void 0 ) cb = nopCb;
	
	    var newCb = wrapCb(cb, 2);
	    try {
	        path$$1 = normalizePath(path$$1);
	        assertRoot(this.root).readlink(path$$1, newCb);
	    }
	    catch (e) {
	        newCb(e);
	    }
	};
	/**
	 * Synchronous readlink.
	 * @param path
	 * @return [String]
	 */
	FS.prototype.readlinkSync = function readlinkSync (path$$1) {
	    path$$1 = normalizePath(path$$1);
	    return assertRoot(this.root).readlinkSync(path$$1);
	};
	// PROPERTY OPERATIONS
	/**
	 * Asynchronous `chown`.
	 * @param path
	 * @param uid
	 * @param gid
	 * @param callback
	 */
	FS.prototype.chown = function chown (path$$1, uid, gid, cb) {
	        if ( cb === void 0 ) cb = nopCb;
	
	    var newCb = wrapCb(cb, 1);
	    try {
	        path$$1 = normalizePath(path$$1);
	        assertRoot(this.root).chown(path$$1, false, uid, gid, newCb);
	    }
	    catch (e) {
	        newCb(e);
	    }
	};
	/**
	 * Synchronous `chown`.
	 * @param path
	 * @param uid
	 * @param gid
	 */
	FS.prototype.chownSync = function chownSync (path$$1, uid, gid) {
	    path$$1 = normalizePath(path$$1);
	    assertRoot(this.root).chownSync(path$$1, false, uid, gid);
	};
	/**
	 * Asynchronous `lchown`.
	 * @param path
	 * @param uid
	 * @param gid
	 * @param callback
	 */
	FS.prototype.lchown = function lchown (path$$1, uid, gid, cb) {
	        if ( cb === void 0 ) cb = nopCb;
	
	    var newCb = wrapCb(cb, 1);
	    try {
	        path$$1 = normalizePath(path$$1);
	        assertRoot(this.root).chown(path$$1, true, uid, gid, newCb);
	    }
	    catch (e) {
	        newCb(e);
	    }
	};
	/**
	 * Synchronous `lchown`.
	 * @param path
	 * @param uid
	 * @param gid
	 */
	FS.prototype.lchownSync = function lchownSync (path$$1, uid, gid) {
	    path$$1 = normalizePath(path$$1);
	    assertRoot(this.root).chownSync(path$$1, true, uid, gid);
	};
	/**
	 * Asynchronous `chmod`.
	 * @param path
	 * @param mode
	 * @param callback
	 */
	FS.prototype.chmod = function chmod (path$$1, mode, cb) {
	        if ( cb === void 0 ) cb = nopCb;
	
	    var newCb = wrapCb(cb, 1);
	    try {
	        var numMode = normalizeMode(mode, -1);
	        if (numMode < 0) {
	            throw new ApiError(ErrorCode.EINVAL, "Invalid mode.");
	        }
	        assertRoot(this.root).chmod(normalizePath(path$$1), false, numMode, newCb);
	    }
	    catch (e) {
	        newCb(e);
	    }
	};
	/**
	 * Synchronous `chmod`.
	 * @param path
	 * @param mode
	 */
	FS.prototype.chmodSync = function chmodSync (path$$1, mode) {
	    var numMode = normalizeMode(mode, -1);
	    if (numMode < 0) {
	        throw new ApiError(ErrorCode.EINVAL, "Invalid mode.");
	    }
	    path$$1 = normalizePath(path$$1);
	    assertRoot(this.root).chmodSync(path$$1, false, numMode);
	};
	/**
	 * Asynchronous `lchmod`.
	 * @param path
	 * @param mode
	 * @param callback
	 */
	FS.prototype.lchmod = function lchmod (path$$1, mode, cb) {
	        if ( cb === void 0 ) cb = nopCb;
	
	    var newCb = wrapCb(cb, 1);
	    try {
	        var numMode = normalizeMode(mode, -1);
	        if (numMode < 0) {
	            throw new ApiError(ErrorCode.EINVAL, "Invalid mode.");
	        }
	        assertRoot(this.root).chmod(normalizePath(path$$1), true, numMode, newCb);
	    }
	    catch (e) {
	        newCb(e);
	    }
	};
	/**
	 * Synchronous `lchmod`.
	 * @param path
	 * @param mode
	 */
	FS.prototype.lchmodSync = function lchmodSync (path$$1, mode) {
	    var numMode = normalizeMode(mode, -1);
	    if (numMode < 1) {
	        throw new ApiError(ErrorCode.EINVAL, "Invalid mode.");
	    }
	    assertRoot(this.root).chmodSync(normalizePath(path$$1), true, numMode);
	};
	/**
	 * Change file timestamps of the file referenced by the supplied path.
	 * @param path
	 * @param atime
	 * @param mtime
	 * @param callback
	 */
	FS.prototype.utimes = function utimes (path$$1, atime, mtime, cb) {
	        if ( cb === void 0 ) cb = nopCb;
	
	    var newCb = wrapCb(cb, 1);
	    try {
	        assertRoot(this.root).utimes(normalizePath(path$$1), normalizeTime(atime), normalizeTime(mtime), newCb);
	    }
	    catch (e) {
	        newCb(e);
	    }
	};
	/**
	 * Change file timestamps of the file referenced by the supplied path.
	 * @param path
	 * @param atime
	 * @param mtime
	 */
	FS.prototype.utimesSync = function utimesSync (path$$1, atime, mtime) {
	    assertRoot(this.root).utimesSync(normalizePath(path$$1), normalizeTime(atime), normalizeTime(mtime));
	};
	FS.prototype.realpath = function realpath (path$$1, arg2, cb) {
	        if ( cb === void 0 ) cb = nopCb;
	
	    var cache = typeof (arg2) === 'object' ? arg2 : {};
	    cb = typeof (arg2) === 'function' ? arg2 : nopCb;
	    var newCb = wrapCb(cb, 2);
	    try {
	        path$$1 = normalizePath(path$$1);
	        assertRoot(this.root).realpath(path$$1, cache, newCb);
	    }
	    catch (e) {
	        newCb(e);
	    }
	};
	/**
	 * Synchronous `realpath`.
	 * @param path
	 * @param cache An object literal of mapped paths that can be used to
	 *   force a specific path resolution or avoid additional `fs.stat` calls for
	 *   known real paths.
	 * @return [String]
	 */
	FS.prototype.realpathSync = function realpathSync (path$$1, cache) {
	        if ( cache === void 0 ) cache = {};
	
	    path$$1 = normalizePath(path$$1);
	    return assertRoot(this.root).realpathSync(path$$1, cache);
	};
	FS.prototype.watchFile = function watchFile (filename, arg2, listener) {
	        if ( listener === void 0 ) listener = nopCb;
	
	    throw new ApiError(ErrorCode.ENOTSUP);
	};
	FS.prototype.unwatchFile = function unwatchFile (filename, listener) {
	        if ( listener === void 0 ) listener = nopCb;
	
	    throw new ApiError(ErrorCode.ENOTSUP);
	};
	FS.prototype.watch = function watch (filename, arg2, listener) {
	        if ( listener === void 0 ) listener = nopCb;
	
	    throw new ApiError(ErrorCode.ENOTSUP);
	};
	FS.prototype.access = function access (path$$1, arg2, cb) {
	        if ( cb === void 0 ) cb = nopCb;
	
	    throw new ApiError(ErrorCode.ENOTSUP);
	};
	FS.prototype.accessSync = function accessSync (path$$1, mode) {
	    throw new ApiError(ErrorCode.ENOTSUP);
	};
	FS.prototype.createReadStream = function createReadStream (path$$1, options) {
	    throw new ApiError(ErrorCode.ENOTSUP);
	};
	FS.prototype.createWriteStream = function createWriteStream (path$$1, options) {
	    throw new ApiError(ErrorCode.ENOTSUP);
	};
	/**
	 * For unit testing. Passes all incoming callbacks to cbWrapper for wrapping.
	 */
	FS.prototype.wrapCallbacks = function wrapCallbacks (cbWrapper) {
	    wrapCb = cbWrapper;
	};
	FS.prototype.getFdForFile = function getFdForFile (file) {
	    var fd = this.nextFd++;
	    this.fdMap[fd] = file;
	    return fd;
	};
	FS.prototype.fd2file = function fd2file (fd) {
	    var rv = this.fdMap[fd];
	    if (rv) {
	        return rv;
	    }
	    else {
	        throw new ApiError(ErrorCode.EBADF, 'Invalid file descriptor.');
	    }
	};
	FS.prototype.closeFd = function closeFd (fd) {
	    delete this.fdMap[fd];
	};
	
	/* tslint:disable:variable-name */
	// Exported fs.Stats.
	FS.Stats = Stats;
	
	// Manually export the individual public functions of fs.
	// Required because some code will invoke functions off of the module.
	// e.g.:
	// let writeFile = fs.writeFile;
	// writeFile(...)
	/**
	 * @hidden
	 */
	var fs = new FS();
	/**
	 * @hidden
	 */
	var _fsMock = {};
	/**
	 * @hidden
	 */
	var fsProto = FS.prototype;
	Object.keys(fsProto).forEach(function (key) {
	    if (typeof fs[key] === 'function') {
	        _fsMock[key] = function () {
	            return fs[key].apply(fs, arguments);
	        };
	    }
	    else {
	        _fsMock[key] = fs[key];
	    }
	});
	_fsMock['changeFSModule'] = function (newFs) {
	    fs = newFs;
	};
	_fsMock['getFSModule'] = function () {
	    return fs;
	};
	_fsMock['FS'] = FS;
	
	/*
	 * Levenshtein distance, from the `js-levenshtein` NPM module.
	 * Copied here to avoid complexity of adding another CommonJS module dependency.
	 */
	function _min(d0, d1, d2, bx, ay) {
	    return d0 < d1 || d2 < d1
	        ? d0 > d2
	            ? d2 + 1
	            : d0 + 1
	        : bx === ay
	            ? d1
	            : d1 + 1;
	}
	/**
	 * Calculates levenshtein distance.
	 * @param a
	 * @param b
	 */
	function levenshtein(a, b) {
	    if (a === b) {
	        return 0;
	    }
	    if (a.length > b.length) {
	        var tmp = a;
	        a = b;
	        b = tmp;
	    }
	    var la = a.length;
	    var lb = b.length;
	    while (la > 0 && (a.charCodeAt(la - 1) === b.charCodeAt(lb - 1))) {
	        la--;
	        lb--;
	    }
	    var offset = 0;
	    while (offset < la && (a.charCodeAt(offset) === b.charCodeAt(offset))) {
	        offset++;
	    }
	    la -= offset;
	    lb -= offset;
	    if (la === 0 || lb === 1) {
	        return lb;
	    }
	    var vector = new Array(la << 1);
	    for (var y = 0; y < la;) {
	        vector[la + y] = a.charCodeAt(offset + y);
	        vector[y] = ++y;
	    }
	    var x;
	    var d0;
	    var d1;
	    var d2;
	    var d3;
	    for (x = 0; (x + 3) < lb;) {
	        var bx0 = b.charCodeAt(offset + (d0 = x));
	        var bx1 = b.charCodeAt(offset + (d1 = x + 1));
	        var bx2 = b.charCodeAt(offset + (d2 = x + 2));
	        var bx3 = b.charCodeAt(offset + (d3 = x + 3));
	        var dd$1 = (x += 4);
	        for (var y$1 = 0; y$1 < la;) {
	            var ay = vector[la + y$1];
	            var dy = vector[y$1];
	            d0 = _min(dy, d0, d1, bx0, ay);
	            d1 = _min(d0, d1, d2, bx1, ay);
	            d2 = _min(d1, d2, d3, bx2, ay);
	            dd$1 = _min(d2, d3, dd$1, bx3, ay);
	            vector[y$1++] = dd$1;
	            d3 = d2;
	            d2 = d1;
	            d1 = d0;
	            d0 = dy;
	        }
	    }
	    var dd = 0;
	    for (; x < lb;) {
	        var bx0$1 = b.charCodeAt(offset + (d0 = x));
	        dd = ++x;
	        for (var y$2 = 0; y$2 < la; y$2++) {
	            var dy$1 = vector[y$2];
	            vector[y$2] = dd = dy$1 < d0 || dd < d0
	                ? dy$1 > dd ? dd + 1 : dy$1 + 1
	                : bx0$1 === vector[la + y$2]
	                    ? d0
	                    : d0 + 1;
	            d0 = dy$1;
	        }
	    }
	    return dd;
	}
	
	function deprecationMessage(print, fsName, opts) {
	    if (print) {
	        console.warn(("[" + fsName + "] Direct file system constructor usage is deprecated for this file system, and will be removed in the next major version. Please use the '" + fsName + ".Create(" + (JSON.stringify(opts)) + ", callback)' method instead. See https://github.com/jvilk/BrowserFS/issues/176 for more details."));
	    }
	}
	/**
	 * Checks for any IE version, including IE11 which removed MSIE from the
	 * userAgent string.
	 * @hidden
	 */
	var isIE = typeof navigator !== "undefined" && !!(/(msie) ([\w.]+)/.exec(navigator.userAgent.toLowerCase()) || navigator.userAgent.indexOf('Trident') !== -1);
	/**
	 * Check if we're in a web worker.
	 * @hidden
	 */
	var isWebWorker = typeof window === "undefined";
	/**
	 * Throws an exception. Called on code paths that should be impossible.
	 * @hidden
	 */
	function fail() {
	    throw new Error("BFS has reached an impossible code path; please file a bug.");
	}
	/**
	 * Synchronous recursive makedir.
	 * @hidden
	 */
	function mkdirpSync(p, mode, fs) {
	    if (!fs.existsSync(p)) {
	        mkdirpSync(path.dirname(p), mode, fs);
	        fs.mkdirSync(p, mode);
	    }
	}
	/**
	 * Converts a buffer into an array buffer. Attempts to do so in a
	 * zero-copy manner, e.g. the array references the same memory.
	 * @hidden
	 */
	function buffer2ArrayBuffer(buff) {
	    var u8 = buffer2Uint8array(buff), u8offset = u8.byteOffset, u8Len = u8.byteLength;
	    if (u8offset === 0 && u8Len === u8.buffer.byteLength) {
	        return u8.buffer;
	    }
	    else {
	        return u8.buffer.slice(u8offset, u8offset + u8Len);
	    }
	}
	/**
	 * Converts a buffer into a Uint8Array. Attempts to do so in a
	 * zero-copy manner, e.g. the array references the same memory.
	 * @hidden
	 */
	function buffer2Uint8array(buff) {
	    if (buff instanceof Uint8Array) {
	        // BFS & Node v4.0 buffers *are* Uint8Arrays.
	        return buff;
	    }
	    else {
	        // Uint8Arrays can be constructed from arrayish numbers.
	        // At this point, we assume this isn't a BFS array.
	        return new Uint8Array(buff);
	    }
	}
	/**
	 * Converts the given arrayish object into a Buffer. Attempts to
	 * be zero-copy.
	 * @hidden
	 */
	function arrayish2Buffer(arr) {
	    if (arr instanceof Buffer) {
	        return arr;
	    }
	    else if (arr instanceof Uint8Array) {
	        return uint8Array2Buffer(arr);
	    }
	    else {
	        return Buffer.from(arr);
	    }
	}
	/**
	 * Converts the given Uint8Array into a Buffer. Attempts to be zero-copy.
	 * @hidden
	 */
	function uint8Array2Buffer(u8) {
	    if (u8 instanceof Buffer) {
	        return u8;
	    }
	    else if (u8.byteOffset === 0 && u8.byteLength === u8.buffer.byteLength) {
	        return arrayBuffer2Buffer(u8.buffer);
	    }
	    else {
	        return Buffer.from(u8.buffer, u8.byteOffset, u8.byteLength);
	    }
	}
	/**
	 * Converts the given array buffer into a Buffer. Attempts to be
	 * zero-copy.
	 * @hidden
	 */
	function arrayBuffer2Buffer(ab) {
	    return Buffer.from(ab);
	}
	/**
	 * Copies a slice of the given buffer
	 * @hidden
	 */
	function copyingSlice(buff, start, end) {
	    if ( start === void 0 ) start = 0;
	    if ( end === void 0 ) end = buff.length;
	
	    if (start < 0 || end < 0 || end > buff.length || start > end) {
	        throw new TypeError(("Invalid slice bounds on buffer of length " + (buff.length) + ": [" + start + ", " + end + "]"));
	    }
	    if (buff.length === 0) {
	        // Avoid s0 corner case in ArrayBuffer case.
	        return emptyBuffer();
	    }
	    else {
	        var u8 = buffer2Uint8array(buff), s0 = buff[0], newS0 = (s0 + 1) % 0xFF;
	        buff[0] = newS0;
	        if (u8[0] === newS0) {
	            // Same memory. Revert & copy.
	            u8[0] = s0;
	            return uint8Array2Buffer(u8.slice(start, end));
	        }
	        else {
	            // Revert.
	            buff[0] = s0;
	            return uint8Array2Buffer(u8.subarray(start, end));
	        }
	    }
	}
	/**
	 * @hidden
	 */
	var emptyBuff = null;
	/**
	 * Returns an empty buffer.
	 * @hidden
	 */
	function emptyBuffer() {
	    if (emptyBuff) {
	        return emptyBuff;
	    }
	    return emptyBuff = Buffer.alloc(0);
	}
	/**
	 * Option validator for a Buffer file system option.
	 * @hidden
	 */
	function bufferValidator(v, cb) {
	    if (Buffer.isBuffer(v)) {
	        cb();
	    }
	    else {
	        cb(new ApiError(ErrorCode.EINVAL, "option must be a Buffer."));
	    }
	}
	/**
	 * Checks that the given options object is valid for the file system options.
	 * @hidden
	 */
	function checkOptions(fsType, opts, cb) {
	    var optsInfo = fsType.Options;
	    var fsName = fsType.Name;
	    var pendingValidators = 0;
	    var callbackCalled = false;
	    var loopEnded = false;
	    function validatorCallback(e) {
	        if (!callbackCalled) {
	            if (e) {
	                callbackCalled = true;
	                cb(e);
	            }
	            pendingValidators--;
	            if (pendingValidators === 0 && loopEnded) {
	                cb();
	            }
	        }
	    }
	    // Check for required options.
	    var loop = function ( optName ) {
	        if (optsInfo.hasOwnProperty(optName)) {
	            var opt = optsInfo[optName];
	            var providedValue = opts[optName];
	            if (providedValue === undefined || providedValue === null) {
	                if (!opt.optional) {
	                    // Required option, not provided.
	                    // Any incorrect options provided? Which ones are close to the provided one?
	                    // (edit distance 5 === close)
	                    var incorrectOptions = Object.keys(opts).filter(function (o) { return !(o in optsInfo); }).map(function (a) {
	                        return { str: a, distance: levenshtein(optName, a) };
	                    }).filter(function (o) { return o.distance < 5; }).sort(function (a, b) { return a.distance - b.distance; });
	                    // Validators may be synchronous.
	                    if (callbackCalled) {
	                        return {};
	                    }
	                    callbackCalled = true;
	                    return { v: cb(new ApiError(ErrorCode.EINVAL, ("[" + fsName + "] Required option '" + optName + "' not provided." + (incorrectOptions.length > 0 ? (" You provided unrecognized option '" + (incorrectOptions[0].str) + "'; perhaps you meant to type '" + optName + "'.") : '') + "\nOption description: " + (opt.description)))) };
	                }
	                // Else: Optional option, not provided. That is OK.
	            }
	            else {
	                // Option provided! Check type.
	                var typeMatches = false;
	                if (Array.isArray(opt.type)) {
	                    typeMatches = opt.type.indexOf(typeof (providedValue)) !== -1;
	                }
	                else {
	                    typeMatches = typeof (providedValue) === opt.type;
	                }
	                if (!typeMatches) {
	                    // Validators may be synchronous.
	                    if (callbackCalled) {
	                        return {};
	                    }
	                    callbackCalled = true;
	                    return { v: cb(new ApiError(ErrorCode.EINVAL, ("[" + fsName + "] Value provided for option " + optName + " is not the proper type. Expected " + (Array.isArray(opt.type) ? ("one of {" + (opt.type.join(", ")) + "}") : opt.type) + ", but received " + (typeof (providedValue)) + "\nOption description: " + (opt.description)))) };
	                }
	                else if (opt.validator) {
	                    pendingValidators++;
	                    opt.validator(providedValue, validatorCallback);
	                }
	                // Otherwise: All good!
	            }
	        }
	    };
	
	    for (var optName in optsInfo) {
	        var returned = loop( optName );
	
	        if ( returned ) return returned.v;
	    }
	    loopEnded = true;
	    if (pendingValidators === 0 && !callbackCalled) {
	        cb();
	    }
	}
	
	
	var BFSUtils = Object.freeze({
		deprecationMessage: deprecationMessage,
		isIE: isIE,
		isWebWorker: isWebWorker,
		fail: fail,
		mkdirpSync: mkdirpSync,
		buffer2ArrayBuffer: buffer2ArrayBuffer,
		buffer2Uint8array: buffer2Uint8array,
		arrayish2Buffer: arrayish2Buffer,
		uint8Array2Buffer: uint8Array2Buffer,
		arrayBuffer2Buffer: arrayBuffer2Buffer,
		copyingSlice: copyingSlice,
		emptyBuffer: emptyBuffer,
		bufferValidator: bufferValidator,
		checkOptions: checkOptions
	});
	
	var BFSEmscriptenStreamOps = function BFSEmscriptenStreamOps(fs) {
	    this.fs = fs;
	    this.nodefs = fs.getNodeFS();
	    this.FS = fs.getFS();
	    this.PATH = fs.getPATH();
	    this.ERRNO_CODES = fs.getERRNO_CODES();
	};
	BFSEmscriptenStreamOps.prototype.open = function open (stream) {
	    var path$$1 = this.fs.realPath(stream.node);
	    var FS = this.FS;
	    try {
	        if (FS.isFile(stream.node.mode)) {
	            stream.nfd = this.nodefs.openSync(path$$1, this.fs.flagsToPermissionString(stream.flags));
	        }
	    }
	    catch (e) {
	        if (!e.code) {
	            throw e;
	        }
	        throw new FS.ErrnoError(this.ERRNO_CODES[e.code]);
	    }
	};
	BFSEmscriptenStreamOps.prototype.close = function close (stream) {
	    var FS = this.FS;
	    try {
	        if (FS.isFile(stream.node.mode) && stream.nfd) {
	            this.nodefs.closeSync(stream.nfd);
	        }
	    }
	    catch (e) {
	        if (!e.code) {
	            throw e;
	        }
	        throw new FS.ErrnoError(this.ERRNO_CODES[e.code]);
	    }
	};
	BFSEmscriptenStreamOps.prototype.read = function read (stream, buffer$$1, offset, length, position) {
	    // Avoid copying overhead by reading directly into buffer.
	    try {
	        return this.nodefs.readSync(stream.nfd, uint8Array2Buffer(buffer$$1), offset, length, position);
	    }
	    catch (e) {
	        throw new this.FS.ErrnoError(this.ERRNO_CODES[e.code]);
	    }
	};
	BFSEmscriptenStreamOps.prototype.write = function write (stream, buffer$$1, offset, length, position) {
	    // Avoid copying overhead.
	    try {
	        return this.nodefs.writeSync(stream.nfd, uint8Array2Buffer(buffer$$1), offset, length, position);
	    }
	    catch (e) {
	        throw new this.FS.ErrnoError(this.ERRNO_CODES[e.code]);
	    }
	};
	BFSEmscriptenStreamOps.prototype.llseek = function llseek (stream, offset, whence) {
	    var position = offset;
	    if (whence === 1) {
	        position += stream.position;
	    }
	    else if (whence === 2) {
	        if (this.FS.isFile(stream.node.mode)) {
	            try {
	                var stat = this.nodefs.fstatSync(stream.nfd);
	                position += stat.size;
	            }
	            catch (e) {
	                throw new this.FS.ErrnoError(this.ERRNO_CODES[e.code]);
	            }
	        }
	    }
	    if (position < 0) {
	        throw new this.FS.ErrnoError(this.ERRNO_CODES.EINVAL);
	    }
	    stream.position = position;
	    return position;
	};
	var BFSEmscriptenNodeOps = function BFSEmscriptenNodeOps(fs) {
	    this.fs = fs;
	    this.nodefs = fs.getNodeFS();
	    this.FS = fs.getFS();
	    this.PATH = fs.getPATH();
	    this.ERRNO_CODES = fs.getERRNO_CODES();
	};
	BFSEmscriptenNodeOps.prototype.getattr = function getattr (node) {
	    var path$$1 = this.fs.realPath(node);
	    var stat;
	    try {
	        stat = this.nodefs.lstatSync(path$$1);
	    }
	    catch (e) {
	        if (!e.code) {
	            throw e;
	        }
	        throw new this.FS.ErrnoError(this.ERRNO_CODES[e.code]);
	    }
	    return {
	        dev: stat.dev,
	        ino: stat.ino,
	        mode: stat.mode,
	        nlink: stat.nlink,
	        uid: stat.uid,
	        gid: stat.gid,
	        rdev: stat.rdev,
	        size: stat.size,
	        atime: stat.atime,
	        mtime: stat.mtime,
	        ctime: stat.ctime,
	        blksize: stat.blksize,
	        blocks: stat.blocks
	    };
	};
	BFSEmscriptenNodeOps.prototype.setattr = function setattr (node, attr) {
	    var path$$1 = this.fs.realPath(node);
	    try {
	        if (attr.mode !== undefined) {
	            this.nodefs.chmodSync(path$$1, attr.mode);
	            // update the common node structure mode as well
	            node.mode = attr.mode;
	        }
	        if (attr.timestamp !== undefined) {
	            var date = new Date(attr.timestamp);
	            this.nodefs.utimesSync(path$$1, date, date);
	        }
	    }
	    catch (e) {
	        if (!e.code) {
	            throw e;
	        }
	        // Ignore not supported errors. Emscripten does utimesSync when it
	        // writes files, but never really requires the value to be set.
	        if (e.code !== "ENOTSUP") {
	            throw new this.FS.ErrnoError(this.ERRNO_CODES[e.code]);
	        }
	    }
	    if (attr.size !== undefined) {
	        try {
	            this.nodefs.truncateSync(path$$1, attr.size);
	        }
	        catch (e) {
	            if (!e.code) {
	                throw e;
	            }
	            throw new this.FS.ErrnoError(this.ERRNO_CODES[e.code]);
	        }
	    }
	};
	BFSEmscriptenNodeOps.prototype.lookup = function lookup (parent, name) {
	    var path$$1 = this.PATH.join2(this.fs.realPath(parent), name);
	    var mode = this.fs.getMode(path$$1);
	    return this.fs.createNode(parent, name, mode);
	};
	BFSEmscriptenNodeOps.prototype.mknod = function mknod (parent, name, mode, dev) {
	    var node = this.fs.createNode(parent, name, mode, dev);
	    // create the backing node for this in the fs root as well
	    var path$$1 = this.fs.realPath(node);
	    try {
	        if (this.FS.isDir(node.mode)) {
	            this.nodefs.mkdirSync(path$$1, node.mode);
	        }
	        else {
	            this.nodefs.writeFileSync(path$$1, '', { mode: node.mode });
	        }
	    }
	    catch (e) {
	        if (!e.code) {
	            throw e;
	        }
	        throw new this.FS.ErrnoError(this.ERRNO_CODES[e.code]);
	    }
	    return node;
	};
	BFSEmscriptenNodeOps.prototype.rename = function rename (oldNode, newDir, newName) {
	    var oldPath = this.fs.realPath(oldNode);
	    var newPath = this.PATH.join2(this.fs.realPath(newDir), newName);
	    try {
	        this.nodefs.renameSync(oldPath, newPath);
	        // This logic is missing from the original NodeFS,
	        // causing Emscripten's filesystem to think that the old file still exists.
	        oldNode.name = newName;
	        oldNode.parent = newDir;
	    }
	    catch (e) {
	        if (!e.code) {
	            throw e;
	        }
	        throw new this.FS.ErrnoError(this.ERRNO_CODES[e.code]);
	    }
	};
	BFSEmscriptenNodeOps.prototype.unlink = function unlink (parent, name) {
	    var path$$1 = this.PATH.join2(this.fs.realPath(parent), name);
	    try {
	        this.nodefs.unlinkSync(path$$1);
	    }
	    catch (e) {
	        if (!e.code) {
	            throw e;
	        }
	        throw new this.FS.ErrnoError(this.ERRNO_CODES[e.code]);
	    }
	};
	BFSEmscriptenNodeOps.prototype.rmdir = function rmdir (parent, name) {
	    var path$$1 = this.PATH.join2(this.fs.realPath(parent), name);
	    try {
	        this.nodefs.rmdirSync(path$$1);
	    }
	    catch (e) {
	        if (!e.code) {
	            throw e;
	        }
	        throw new this.FS.ErrnoError(this.ERRNO_CODES[e.code]);
	    }
	};
	BFSEmscriptenNodeOps.prototype.readdir = function readdir (node) {
	    var path$$1 = this.fs.realPath(node);
	    try {
	        // Node does not list . and .. in directory listings,
	        // but Emscripten expects it.
	        var contents = this.nodefs.readdirSync(path$$1);
	        contents.push('.', '..');
	        return contents;
	    }
	    catch (e) {
	        if (!e.code) {
	            throw e;
	        }
	        throw new this.FS.ErrnoError(this.ERRNO_CODES[e.code]);
	    }
	};
	BFSEmscriptenNodeOps.prototype.symlink = function symlink (parent, newName, oldPath) {
	    var newPath = this.PATH.join2(this.fs.realPath(parent), newName);
	    try {
	        this.nodefs.symlinkSync(oldPath, newPath);
	    }
	    catch (e) {
	        if (!e.code) {
	            throw e;
	        }
	        throw new this.FS.ErrnoError(this.ERRNO_CODES[e.code]);
	    }
	};
	BFSEmscriptenNodeOps.prototype.readlink = function readlink (node) {
	    var path$$1 = this.fs.realPath(node);
	    try {
	        return this.nodefs.readlinkSync(path$$1);
	    }
	    catch (e) {
	        if (!e.code) {
	            throw e;
	        }
	        throw new this.FS.ErrnoError(this.ERRNO_CODES[e.code]);
	    }
	};
	var BFSEmscriptenFS = function BFSEmscriptenFS(_FS, _PATH, _ERRNO_CODES, nodefs) {
	    if ( _FS === void 0 ) _FS = self['FS'];
	    if ( _PATH === void 0 ) _PATH = self['PATH'];
	    if ( _ERRNO_CODES === void 0 ) _ERRNO_CODES = self['ERRNO_CODES'];
	    if ( nodefs === void 0 ) nodefs = _fsMock;
	
	    // This maps the integer permission modes from http://linux.die.net/man/3/open
	    // to node.js-specific file open permission strings at http://nodejs.org/api/fs.html#fs_fs_open_path_flags_mode_callback
	    this.flagsToPermissionStringMap = {
	        0 /*O_RDONLY*/: 'r',
	        1 /*O_WRONLY*/: 'r+',
	        2 /*O_RDWR*/: 'r+',
	        64 /*O_CREAT*/: 'r',
	        65 /*O_WRONLY|O_CREAT*/: 'r+',
	        66 /*O_RDWR|O_CREAT*/: 'r+',
	        129 /*O_WRONLY|O_EXCL*/: 'rx+',
	        193 /*O_WRONLY|O_CREAT|O_EXCL*/: 'rx+',
	        514 /*O_RDWR|O_TRUNC*/: 'w+',
	        577 /*O_WRONLY|O_CREAT|O_TRUNC*/: 'w',
	        578 /*O_CREAT|O_RDWR|O_TRUNC*/: 'w+',
	        705 /*O_WRONLY|O_CREAT|O_EXCL|O_TRUNC*/: 'wx',
	        706 /*O_RDWR|O_CREAT|O_EXCL|O_TRUNC*/: 'wx+',
	        1024 /*O_APPEND*/: 'a',
	        1025 /*O_WRONLY|O_APPEND*/: 'a',
	        1026 /*O_RDWR|O_APPEND*/: 'a+',
	        1089 /*O_WRONLY|O_CREAT|O_APPEND*/: 'a',
	        1090 /*O_RDWR|O_CREAT|O_APPEND*/: 'a+',
	        1153 /*O_WRONLY|O_EXCL|O_APPEND*/: 'ax',
	        1154 /*O_RDWR|O_EXCL|O_APPEND*/: 'ax+',
	        1217 /*O_WRONLY|O_CREAT|O_EXCL|O_APPEND*/: 'ax',
	        1218 /*O_RDWR|O_CREAT|O_EXCL|O_APPEND*/: 'ax+',
	        4096 /*O_RDONLY|O_DSYNC*/: 'rs',
	        4098 /*O_RDWR|O_DSYNC*/: 'rs+'
	    };
	    this.nodefs = nodefs;
	    this.FS = _FS;
	    this.PATH = _PATH;
	    this.ERRNO_CODES = _ERRNO_CODES;
	    this.node_ops = new BFSEmscriptenNodeOps(this);
	    this.stream_ops = new BFSEmscriptenStreamOps(this);
	};
	BFSEmscriptenFS.prototype.mount = function mount (m) {
	    return this.createNode(null, '/', this.getMode(m.opts.root), 0);
	};
	BFSEmscriptenFS.prototype.createNode = function createNode (parent, name, mode, dev) {
	    var FS = this.FS;
	    if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {
	        throw new FS.ErrnoError(this.ERRNO_CODES.EINVAL);
	    }
	    var node = FS.createNode(parent, name, mode);
	    node.node_ops = this.node_ops;
	    node.stream_ops = this.stream_ops;
	    return node;
	};
	BFSEmscriptenFS.prototype.getMode = function getMode (path$$1) {
	    var stat;
	    try {
	        stat = this.nodefs.lstatSync(path$$1);
	    }
	    catch (e) {
	        if (!e.code) {
	            throw e;
	        }
	        throw new this.FS.ErrnoError(this.ERRNO_CODES[e.code]);
	    }
	    return stat.mode;
	};
	BFSEmscriptenFS.prototype.realPath = function realPath (node) {
	    var parts = [];
	    while (node.parent !== node) {
	        parts.push(node.name);
	        node = node.parent;
	    }
	    parts.push(node.mount.opts.root);
	    parts.reverse();
	    return this.PATH.join.apply(null, parts);
	};
	BFSEmscriptenFS.prototype.flagsToPermissionString = function flagsToPermissionString (flags) {
	    var parsedFlags = (typeof flags === "string") ? parseInt(flags, 10) : flags;
	    parsedFlags &= 0x1FFF;
	    if (parsedFlags in this.flagsToPermissionStringMap) {
	        return this.flagsToPermissionStringMap[parsedFlags];
	    }
	    else {
	        return flags;
	    }
	};
	BFSEmscriptenFS.prototype.getNodeFS = function getNodeFS () {
	    return this.nodefs;
	};
	BFSEmscriptenFS.prototype.getFS = function getFS () {
	    return this.FS;
	};
	BFSEmscriptenFS.prototype.getPATH = function getPATH () {
	    return this.PATH;
	};
	BFSEmscriptenFS.prototype.getERRNO_CODES = function getERRNO_CODES () {
	    return this.ERRNO_CODES;
	};
	
	/**
	 * Basic filesystem class. Most filesystems should extend this class, as it
	 * provides default implementations for a handful of methods.
	 */
	var BaseFileSystem = function BaseFileSystem () {};
	
	BaseFileSystem.prototype.supportsLinks = function supportsLinks () {
	    return false;
	};
	BaseFileSystem.prototype.diskSpace = function diskSpace (p, cb) {
	    cb(0, 0);
	};
	/**
	 * Opens the file at path p with the given flag. The file must exist.
	 * @param p The path to open.
	 * @param flag The flag to use when opening the file.
	 */
	BaseFileSystem.prototype.openFile = function openFile (p, flag, cb) {
	    throw new ApiError(ErrorCode.ENOTSUP);
	};
	/**
	 * Create the file at path p with the given mode. Then, open it with the given
	 * flag.
	 */
	BaseFileSystem.prototype.createFile = function createFile (p, flag, mode, cb) {
	    throw new ApiError(ErrorCode.ENOTSUP);
	};
	BaseFileSystem.prototype.open = function open (p, flag, mode, cb) {
	        var this$1 = this;
	
	    var mustBeFile = function (e, stats) {
	        if (e) {
	            // File does not exist.
	            switch (flag.pathNotExistsAction()) {
	                case ActionType.CREATE_FILE:
	                    // Ensure parent exists.
	                    return this$1.stat(path.dirname(p), false, function (e, parentStats) {
	                        if (e) {
	                            cb(e);
	                        }
	                        else if (parentStats && !parentStats.isDirectory()) {
	                            cb(ApiError.ENOTDIR(path.dirname(p)));
	                        }
	                        else {
	                            this$1.createFile(p, flag, mode, cb);
	                        }
	                    });
	                case ActionType.THROW_EXCEPTION:
	                    return cb(ApiError.ENOENT(p));
	                default:
	                    return cb(new ApiError(ErrorCode.EINVAL, 'Invalid FileFlag object.'));
	            }
	        }
	        else {
	            // File exists.
	            if (stats && stats.isDirectory()) {
	                return cb(ApiError.EISDIR(p));
	            }
	            switch (flag.pathExistsAction()) {
	                case ActionType.THROW_EXCEPTION:
	                    return cb(ApiError.EEXIST(p));
	                case ActionType.TRUNCATE_FILE:
	                    // NOTE: In a previous implementation, we deleted the file and
	                    // re-created it. However, this created a race condition if another
	                    // asynchronous request was trying to read the file, as the file
	                    // would not exist for a small period of time.
	                    return this$1.openFile(p, flag, function (e, fd) {
	                        if (e) {
	                            cb(e);
	                        }
	                        else if (fd) {
	                            fd.truncate(0, function () {
	                                fd.sync(function () {
	                                    cb(null, fd);
	                                });
	                            });
	                        }
	                        else {
	                            fail();
	                        }
	                    });
	                case ActionType.NOP:
	                    return this$1.openFile(p, flag, cb);
	                default:
	                    return cb(new ApiError(ErrorCode.EINVAL, 'Invalid FileFlag object.'));
	            }
	        }
	    };
	    this.stat(p, false, mustBeFile);
	};
	BaseFileSystem.prototype.rename = function rename (oldPath, newPath, cb) {
	    cb(new ApiError(ErrorCode.ENOTSUP));
	};
	BaseFileSystem.prototype.renameSync = function renameSync (oldPath, newPath) {
	    throw new ApiError(ErrorCode.ENOTSUP);
	};
	BaseFileSystem.prototype.stat = function stat (p, isLstat, cb) {
	    cb(new ApiError(ErrorCode.ENOTSUP));
	};
	BaseFileSystem.prototype.statSync = function statSync (p, isLstat) {
	    throw new ApiError(ErrorCode.ENOTSUP);
	};
	/**
	 * Opens the file at path p with the given flag. The file must exist.
	 * @param p The path to open.
	 * @param flag The flag to use when opening the file.
	 * @return A File object corresponding to the opened file.
	 */
	BaseFileSystem.prototype.openFileSync = function openFileSync (p, flag, mode) {
	    throw new ApiError(ErrorCode.ENOTSUP);
	};
	/**
	 * Create the file at path p with the given mode. Then, open it with the given
	 * flag.
	 */
	BaseFileSystem.prototype.createFileSync = function createFileSync (p, flag, mode) {
	    throw new ApiError(ErrorCode.ENOTSUP);
	};
	BaseFileSystem.prototype.openSync = function openSync (p, flag, mode) {
	    // Check if the path exists, and is a file.
	    var stats;
	    try {
	        stats = this.statSync(p, false);
	    }
	    catch (e) {
	        // File does not exist.
	        switch (flag.pathNotExistsAction()) {
	            case ActionType.CREATE_FILE:
	                // Ensure parent exists.
	                var parentStats = this.statSync(path.dirname(p), false);
	                if (!parentStats.isDirectory()) {
	                    throw ApiError.ENOTDIR(path.dirname(p));
	                }
	                return this.createFileSync(p, flag, mode);
	            case ActionType.THROW_EXCEPTION:
	                throw ApiError.ENOENT(p);
	            default:
	                throw new ApiError(ErrorCode.EINVAL, 'Invalid FileFlag object.');
	        }
	    }
	    // File exists.
	    if (stats.isDirectory()) {
	        throw ApiError.EISDIR(p);
	    }
	    switch (flag.pathExistsAction()) {
	        case ActionType.THROW_EXCEPTION:
	            throw ApiError.EEXIST(p);
	        case ActionType.TRUNCATE_FILE:
	            // Delete file.
	            this.unlinkSync(p);
	            // Create file. Use the same mode as the old file.
	            // Node itself modifies the ctime when this occurs, so this action
	            // will preserve that behavior if the underlying file system
	            // supports those properties.
	            return this.createFileSync(p, flag, stats.mode);
	        case ActionType.NOP:
	            return this.openFileSync(p, flag, mode);
	        default:
	            throw new ApiError(ErrorCode.EINVAL, 'Invalid FileFlag object.');
	    }
	};
	BaseFileSystem.prototype.unlink = function unlink (p, cb) {
	    cb(new ApiError(ErrorCode.ENOTSUP));
	};
	BaseFileSystem.prototype.unlinkSync = function unlinkSync (p) {
	    throw new ApiError(ErrorCode.ENOTSUP);
	};
	BaseFileSystem.prototype.rmdir = function rmdir (p, cb) {
	    cb(new ApiError(ErrorCode.ENOTSUP));
	};
	BaseFileSystem.prototype.rmdirSync = function rmdirSync (p) {
	    throw new ApiError(ErrorCode.ENOTSUP);
	};
	BaseFileSystem.prototype.mkdir = function mkdir (p, mode, cb) {
	    cb(new ApiError(ErrorCode.ENOTSUP));
	};
	BaseFileSystem.prototype.mkdirSync = function mkdirSync (p, mode) {
	    throw new ApiError(ErrorCode.ENOTSUP);
	};
	BaseFileSystem.prototype.readdir = function readdir (p, cb) {
	    cb(new ApiError(ErrorCode.ENOTSUP));
	};
	BaseFileSystem.prototype.readdirSync = function readdirSync (p) {
	    throw new ApiError(ErrorCode.ENOTSUP);
	};
	BaseFileSystem.prototype.exists = function exists (p, cb) {
	    this.stat(p, null, function (err) {
	        cb(!err);
	    });
	};
	BaseFileSystem.prototype.existsSync = function existsSync (p) {
	    try {
	        this.statSync(p, true);
	        return true;
	    }
	    catch (e) {
	        return false;
	    }
	};
	BaseFileSystem.prototype.realpath = function realpath (p, cache, cb) {
	    if (this.supportsLinks()) {
	        // The path could contain symlinks. Split up the path,
	        // resolve any symlinks, return the resolved string.
	        var splitPath = p.split(path.sep);
	        // TODO: Simpler to just pass through file, find sep and such.
	        for (var i = 0; i < splitPath.length; i++) {
	            var addPaths = splitPath.slice(0, i + 1);
	            splitPath[i] = path.join.apply(null, addPaths);
	        }
	    }
	    else {
	        // No symlinks. We just need to verify that it exists.
	        this.exists(p, function (doesExist) {
	            if (doesExist) {
	                cb(null, p);
	            }
	            else {
	                cb(ApiError.ENOENT(p));
	            }
	        });
	    }
	};
	BaseFileSystem.prototype.realpathSync = function realpathSync (p, cache) {
	    if (this.supportsLinks()) {
	        // The path could contain symlinks. Split up the path,
	        // resolve any symlinks, return the resolved string.
	        var splitPath = p.split(path.sep);
	        // TODO: Simpler to just pass through file, find sep and such.
	        for (var i = 0; i < splitPath.length; i++) {
	            var addPaths = splitPath.slice(0, i + 1);
	            splitPath[i] = path.join.apply(path, addPaths);
	        }
	        return splitPath.join(path.sep);
	    }
	    else {
	        // No symlinks. We just need to verify that it exists.
	        if (this.existsSync(p)) {
	            return p;
	        }
	        else {
	            throw ApiError.ENOENT(p);
	        }
	    }
	};
	BaseFileSystem.prototype.truncate = function truncate (p, len, cb) {
	    this.open(p, FileFlag.getFileFlag('r+'), 0x1a4, (function (er, fd) {
	        if (er) {
	            return cb(er);
	        }
	        fd.truncate(len, (function (er) {
	            fd.close((function (er2) {
	                cb(er || er2);
	            }));
	        }));
	    }));
	};
	BaseFileSystem.prototype.truncateSync = function truncateSync (p, len) {
	    var fd = this.openSync(p, FileFlag.getFileFlag('r+'), 0x1a4);
	    // Need to safely close FD, regardless of whether or not truncate succeeds.
	    try {
	        fd.truncateSync(len);
	    }
	    catch (e) {
	        throw e;
	    }
	    finally {
	        fd.closeSync();
	    }
	};
	BaseFileSystem.prototype.readFile = function readFile (fname, encoding, flag, cb) {
	    // Wrap cb in file closing code.
	    var oldCb = cb;
	    // Get file.
	    this.open(fname, flag, 0x1a4, function (err, fd) {
	        if (err) {
	            return cb(err);
	        }
	        cb = function (err, arg) {
	            fd.close(function (err2) {
	                if (!err) {
	                    err = err2;
	                }
	                return oldCb(err, arg);
	            });
	        };
	        fd.stat(function (err, stat) {
	            if (err) {
	                return cb(err);
	            }
	            // Allocate buffer.
	            var buf = Buffer.alloc(stat.size);
	            fd.read(buf, 0, stat.size, 0, function (err) {
	                if (err) {
	                    return cb(err);
	                }
	                else if (encoding === null) {
	                    return cb(err, buf);
	                }
	                try {
	                    cb(null, buf.toString(encoding));
	                }
	                catch (e) {
	                    cb(e);
	                }
	            });
	        });
	    });
	};
	BaseFileSystem.prototype.readFileSync = function readFileSync (fname, encoding, flag) {
	    // Get file.
	    var fd = this.openSync(fname, flag, 0x1a4);
	    try {
	        var stat = fd.statSync();
	        // Allocate buffer.
	        var buf = Buffer.alloc(stat.size);
	        fd.readSync(buf, 0, stat.size, 0);
	        fd.closeSync();
	        if (encoding === null) {
	            return buf;
	        }
	        return buf.toString(encoding);
	    }
	    finally {
	        fd.closeSync();
	    }
	};
	BaseFileSystem.prototype.writeFile = function writeFile (fname, data, encoding, flag, mode, cb) {
	    // Wrap cb in file closing code.
	    var oldCb = cb;
	    // Get file.
	    this.open(fname, flag, 0x1a4, function (err, fd) {
	        if (err) {
	            return cb(err);
	        }
	        cb = function (err) {
	            fd.close(function (err2) {
	                oldCb(err ? err : err2);
	            });
	        };
	        try {
	            if (typeof data === 'string') {
	                data = Buffer.from(data, encoding);
	            }
	        }
	        catch (e) {
	            return cb(e);
	        }
	        // Write into file.
	        fd.write(data, 0, data.length, 0, cb);
	    });
	};
	BaseFileSystem.prototype.writeFileSync = function writeFileSync (fname, data, encoding, flag, mode) {
	    // Get file.
	    var fd = this.openSync(fname, flag, mode);
	    try {
	        if (typeof data === 'string') {
	            data = Buffer.from(data, encoding);
	        }
	        // Write into file.
	        fd.writeSync(data, 0, data.length, 0);
	    }
	    finally {
	        fd.closeSync();
	    }
	};
	BaseFileSystem.prototype.appendFile = function appendFile (fname, data, encoding, flag, mode, cb) {
	    // Wrap cb in file closing code.
	    var oldCb = cb;
	    this.open(fname, flag, mode, function (err, fd) {
	        if (err) {
	            return cb(err);
	        }
	        cb = function (err) {
	            fd.close(function (err2) {
	                oldCb(err ? err : err2);
	            });
	        };
	        if (typeof data === 'string') {
	            data = Buffer.from(data, encoding);
	        }
	        fd.write(data, 0, data.length, null, cb);
	    });
	};
	BaseFileSystem.prototype.appendFileSync = function appendFileSync (fname, data, encoding, flag, mode) {
	    var fd = this.openSync(fname, flag, mode);
	    try {
	        if (typeof data === 'string') {
	            data = Buffer.from(data, encoding);
	        }
	        fd.writeSync(data, 0, data.length, null);
	    }
	    finally {
	        fd.closeSync();
	    }
	};
	BaseFileSystem.prototype.chmod = function chmod (p, isLchmod, mode, cb) {
	    cb(new ApiError(ErrorCode.ENOTSUP));
	};
	BaseFileSystem.prototype.chmodSync = function chmodSync (p, isLchmod, mode) {
	    throw new ApiError(ErrorCode.ENOTSUP);
	};
	BaseFileSystem.prototype.chown = function chown (p, isLchown, uid, gid, cb) {
	    cb(new ApiError(ErrorCode.ENOTSUP));
	};
	BaseFileSystem.prototype.chownSync = function chownSync (p, isLchown, uid, gid) {
	    throw new ApiError(ErrorCode.ENOTSUP);
	};
	BaseFileSystem.prototype.utimes = function utimes (p, atime, mtime, cb) {
	    cb(new ApiError(ErrorCode.ENOTSUP));
	};
	BaseFileSystem.prototype.utimesSync = function utimesSync (p, atime, mtime) {
	    throw new ApiError(ErrorCode.ENOTSUP);
	};
	BaseFileSystem.prototype.link = function link (srcpath, dstpath, cb) {
	    cb(new ApiError(ErrorCode.ENOTSUP));
	};
	BaseFileSystem.prototype.linkSync = function linkSync (srcpath, dstpath) {
	    throw new ApiError(ErrorCode.ENOTSUP);
	};
	BaseFileSystem.prototype.symlink = function symlink (srcpath, dstpath, type, cb) {
	    cb(new ApiError(ErrorCode.ENOTSUP));
	};
	BaseFileSystem.prototype.symlinkSync = function symlinkSync (srcpath, dstpath, type) {
	    throw new ApiError(ErrorCode.ENOTSUP);
	};
	BaseFileSystem.prototype.readlink = function readlink (p, cb) {
	    cb(new ApiError(ErrorCode.ENOTSUP));
	};
	BaseFileSystem.prototype.readlinkSync = function readlinkSync (p) {
	    throw new ApiError(ErrorCode.ENOTSUP);
	};
	/**
	 * Implements the asynchronous API in terms of the synchronous API.
	 * @class SynchronousFileSystem
	 */
	var SynchronousFileSystem = (function (BaseFileSystem) {
	    function SynchronousFileSystem () {
	        BaseFileSystem.apply(this, arguments);
	    }
	
	    if ( BaseFileSystem ) SynchronousFileSystem.__proto__ = BaseFileSystem;
	    SynchronousFileSystem.prototype = Object.create( BaseFileSystem && BaseFileSystem.prototype );
	    SynchronousFileSystem.prototype.constructor = SynchronousFileSystem;
	
	    SynchronousFileSystem.prototype.supportsSynch = function supportsSynch () {
	        return true;
	    };
	    SynchronousFileSystem.prototype.rename = function rename (oldPath, newPath, cb) {
	        try {
	            this.renameSync(oldPath, newPath);
	            cb();
	        }
	        catch (e) {
	            cb(e);
	        }
	    };
	    SynchronousFileSystem.prototype.stat = function stat (p, isLstat, cb) {
	        try {
	            cb(null, this.statSync(p, isLstat));
	        }
	        catch (e) {
	            cb(e);
	        }
	    };
	    SynchronousFileSystem.prototype.open = function open (p, flags, mode, cb) {
	        try {
	            cb(null, this.openSync(p, flags, mode));
	        }
	        catch (e) {
	            cb(e);
	        }
	    };
	    SynchronousFileSystem.prototype.unlink = function unlink (p, cb) {
	        try {
	            this.unlinkSync(p);
	            cb();
	        }
	        catch (e) {
	            cb(e);
	        }
	    };
	    SynchronousFileSystem.prototype.rmdir = function rmdir (p, cb) {
	        try {
	            this.rmdirSync(p);
	            cb();
	        }
	        catch (e) {
	            cb(e);
	        }
	    };
	    SynchronousFileSystem.prototype.mkdir = function mkdir (p, mode, cb) {
	        try {
	            this.mkdirSync(p, mode);
	            cb();
	        }
	        catch (e) {
	            cb(e);
	        }
	    };
	    SynchronousFileSystem.prototype.readdir = function readdir (p, cb) {
	        try {
	            cb(null, this.readdirSync(p));
	        }
	        catch (e) {
	            cb(e);
	        }
	    };
	    SynchronousFileSystem.prototype.chmod = function chmod (p, isLchmod, mode, cb) {
	        try {
	            this.chmodSync(p, isLchmod, mode);
	            cb();
	        }
	        catch (e) {
	            cb(e);
	        }
	    };
	    SynchronousFileSystem.prototype.chown = function chown (p, isLchown, uid, gid, cb) {
	        try {
	            this.chownSync(p, isLchown, uid, gid);
	            cb();
	        }
	        catch (e) {
	            cb(e);
	        }
	    };
	    SynchronousFileSystem.prototype.utimes = function utimes (p, atime, mtime, cb) {
	        try {
	            this.utimesSync(p, atime, mtime);
	            cb();
	        }
	        catch (e) {
	            cb(e);
	        }
	    };
	    SynchronousFileSystem.prototype.link = function link (srcpath, dstpath, cb) {
	        try {
	            this.linkSync(srcpath, dstpath);
	            cb();
	        }
	        catch (e) {
	            cb(e);
	        }
	    };
	    SynchronousFileSystem.prototype.symlink = function symlink (srcpath, dstpath, type, cb) {
	        try {
	            this.symlinkSync(srcpath, dstpath, type);
	            cb();
	        }
	        catch (e) {
	            cb(e);
	        }
	    };
	    SynchronousFileSystem.prototype.readlink = function readlink (p, cb) {
	        try {
	            cb(null, this.readlinkSync(p));
	        }
	        catch (e) {
	            cb(e);
	        }
	    };
	
	    return SynchronousFileSystem;
	}(BaseFileSystem));
	
	/**
	 * Base class that contains shared implementations of functions for the file
	 * object.
	 */
	var BaseFile = function BaseFile () {};
	
	BaseFile.prototype.sync = function sync (cb) {
	    cb(new ApiError(ErrorCode.ENOTSUP));
	};
	BaseFile.prototype.syncSync = function syncSync () {
	    throw new ApiError(ErrorCode.ENOTSUP);
	};
	BaseFile.prototype.datasync = function datasync (cb) {
	    this.sync(cb);
	};
	BaseFile.prototype.datasyncSync = function datasyncSync () {
	    return this.syncSync();
	};
	BaseFile.prototype.chown = function chown (uid, gid, cb) {
	    cb(new ApiError(ErrorCode.ENOTSUP));
	};
	BaseFile.prototype.chownSync = function chownSync (uid, gid) {
	    throw new ApiError(ErrorCode.ENOTSUP);
	};
	BaseFile.prototype.chmod = function chmod (mode, cb) {
	    cb(new ApiError(ErrorCode.ENOTSUP));
	};
	BaseFile.prototype.chmodSync = function chmodSync (mode) {
	    throw new ApiError(ErrorCode.ENOTSUP);
	};
	BaseFile.prototype.utimes = function utimes (atime, mtime, cb) {
	    cb(new ApiError(ErrorCode.ENOTSUP));
	};
	BaseFile.prototype.utimesSync = function utimesSync (atime, mtime) {
	    throw new ApiError(ErrorCode.ENOTSUP);
	};
	
	/**
	 * An implementation of the File interface that operates on a file that is
	 * completely in-memory. PreloadFiles are backed by a Buffer.
	 *
	 * This is also an abstract class, as it lacks an implementation of 'sync' and
	 * 'close'. Each filesystem that wishes to use this file representation must
	 * extend this class and implement those two methods.
	 * @todo 'close' lever that disables functionality once closed.
	 */
	var PreloadFile = (function (BaseFile$$1) {
	    function PreloadFile(_fs, _path, _flag, _stat, contents) {
	        BaseFile$$1.call(this);
	        this._pos = 0;
	        this._dirty = false;
	        this._fs = _fs;
	        this._path = _path;
	        this._flag = _flag;
	        this._stat = _stat;
	        if (contents) {
	            this._buffer = contents;
	        }
	        else {
	            // Empty buffer. It'll expand once we write stuff to it.
	            this._buffer = emptyBuffer();
	        }
	        // Note: This invariant is *not* maintained once the file starts getting
	        // modified.
	        // Note: Only actually matters if file is readable, as writeable modes may
	        // truncate/append to file.
	        if (this._stat.size !== this._buffer.length && this._flag.isReadable()) {
	            throw new Error(("Invalid buffer: Buffer is " + (this._buffer.length) + " long, yet Stats object specifies that file is " + (this._stat.size) + " long."));
	        }
	    }
	
	    if ( BaseFile$$1 ) PreloadFile.__proto__ = BaseFile$$1;
	    PreloadFile.prototype = Object.create( BaseFile$$1 && BaseFile$$1.prototype );
	    PreloadFile.prototype.constructor = PreloadFile;
	    /**
	     * NONSTANDARD: Get the underlying buffer for this file. !!DO NOT MUTATE!! Will mess up dirty tracking.
	     */
	    PreloadFile.prototype.getBuffer = function getBuffer () {
	        return this._buffer;
	    };
	    /**
	     * NONSTANDARD: Get underlying stats for this file. !!DO NOT MUTATE!!
	     */
	    PreloadFile.prototype.getStats = function getStats () {
	        return this._stat;
	    };
	    PreloadFile.prototype.getFlag = function getFlag () {
	        return this._flag;
	    };
	    /**
	     * Get the path to this file.
	     * @return [String] The path to the file.
	     */
	    PreloadFile.prototype.getPath = function getPath () {
	        return this._path;
	    };
	    /**
	     * Get the current file position.
	     *
	     * We emulate the following bug mentioned in the Node documentation:
	     * > On Linux, positional writes don't work when the file is opened in append
	     *   mode. The kernel ignores the position argument and always appends the data
	     *   to the end of the file.
	     * @return [Number] The current file position.
	     */
	    PreloadFile.prototype.getPos = function getPos () {
	        if (this._flag.isAppendable()) {
	            return this._stat.size;
	        }
	        return this._pos;
	    };
	    /**
	     * Advance the current file position by the indicated number of positions.
	     * @param [Number] delta
	     */
	    PreloadFile.prototype.advancePos = function advancePos (delta) {
	        return this._pos += delta;
	    };
	    /**
	     * Set the file position.
	     * @param [Number] newPos
	     */
	    PreloadFile.prototype.setPos = function setPos (newPos) {
	        return this._pos = newPos;
	    };
	    /**
	     * **Core**: Asynchronous sync. Must be implemented by subclasses of this
	     * class.
	     * @param [Function(BrowserFS.ApiError)] cb
	     */
	    PreloadFile.prototype.sync = function sync (cb) {
	        try {
	            this.syncSync();
	            cb();
	        }
	        catch (e) {
	            cb(e);
	        }
	    };
	    /**
	     * **Core**: Synchronous sync.
	     */
	    PreloadFile.prototype.syncSync = function syncSync () {
	        throw new ApiError(ErrorCode.ENOTSUP);
	    };
	    /**
	     * **Core**: Asynchronous close. Must be implemented by subclasses of this
	     * class.
	     * @param [Function(BrowserFS.ApiError)] cb
	     */
	    PreloadFile.prototype.close = function close (cb) {
	        try {
	            this.closeSync();
	            cb();
	        }
	        catch (e) {
	            cb(e);
	        }
	    };
	    /**
	     * **Core**: Synchronous close.
	     */
	    PreloadFile.prototype.closeSync = function closeSync () {
	        throw new ApiError(ErrorCode.ENOTSUP);
	    };
	    /**
	     * Asynchronous `stat`.
	     * @param [Function(BrowserFS.ApiError, BrowserFS.node.fs.Stats)] cb
	     */
	    PreloadFile.prototype.stat = function stat (cb) {
	        try {
	            cb(null, this._stat.clone());
	        }
	        catch (e) {
	            cb(e);
	        }
	    };
	    /**
	     * Synchronous `stat`.
	     */
	    PreloadFile.prototype.statSync = function statSync () {
	        return this._stat.clone();
	    };
	    /**
	     * Asynchronous truncate.
	     * @param [Number] len
	     * @param [Function(BrowserFS.ApiError)] cb
	     */
	    PreloadFile.prototype.truncate = function truncate (len, cb) {
	        try {
	            this.truncateSync(len);
	            if (this._flag.isSynchronous() && !_fsMock.getRootFS().supportsSynch()) {
	                this.sync(cb);
	            }
	            cb();
	        }
	        catch (e) {
	            return cb(e);
	        }
	    };
	    /**
	     * Synchronous truncate.
	     * @param [Number] len
	     */
	    PreloadFile.prototype.truncateSync = function truncateSync (len) {
	        this._dirty = true;
	        if (!this._flag.isWriteable()) {
	            throw new ApiError(ErrorCode.EPERM, 'File not opened with a writeable mode.');
	        }
	        this._stat.mtime = new Date();
	        if (len > this._buffer.length) {
	            var buf = Buffer.alloc(len - this._buffer.length, 0);
	            // Write will set @_stat.size for us.
	            this.writeSync(buf, 0, buf.length, this._buffer.length);
	            if (this._flag.isSynchronous() && _fsMock.getRootFS().supportsSynch()) {
	                this.syncSync();
	            }
	            return;
	        }
	        this._stat.size = len;
	        // Truncate buffer to 'len'.
	        var newBuff = Buffer.alloc(len);
	        this._buffer.copy(newBuff, 0, 0, len);
	        this._buffer = newBuff;
	        if (this._flag.isSynchronous() && _fsMock.getRootFS().supportsSynch()) {
	            this.syncSync();
	        }
	    };
	    /**
	     * Write buffer to the file.
	     * Note that it is unsafe to use fs.write multiple times on the same file
	     * without waiting for the callback.
	     * @param [BrowserFS.node.Buffer] buffer Buffer containing the data to write to
	     *  the file.
	     * @param [Number] offset Offset in the buffer to start reading data from.
	     * @param [Number] length The amount of bytes to write to the file.
	     * @param [Number] position Offset from the beginning of the file where this
	     *   data should be written. If position is null, the data will be written at
	     *   the current position.
	     * @param [Function(BrowserFS.ApiError, Number, BrowserFS.node.Buffer)]
	     *   cb The number specifies the number of bytes written into the file.
	     */
	    PreloadFile.prototype.write = function write (buffer$$1, offset, length, position, cb) {
	        try {
	            cb(null, this.writeSync(buffer$$1, offset, length, position), buffer$$1);
	        }
	        catch (e) {
	            cb(e);
	        }
	    };
	    /**
	     * Write buffer to the file.
	     * Note that it is unsafe to use fs.writeSync multiple times on the same file
	     * without waiting for the callback.
	     * @param [BrowserFS.node.Buffer] buffer Buffer containing the data to write to
	     *  the file.
	     * @param [Number] offset Offset in the buffer to start reading data from.
	     * @param [Number] length The amount of bytes to write to the file.
	     * @param [Number] position Offset from the beginning of the file where this
	     *   data should be written. If position is null, the data will be written at
	     *   the current position.
	     * @return [Number]
	     */
	    PreloadFile.prototype.writeSync = function writeSync (buffer$$1, offset, length, position) {
	        this._dirty = true;
	        if (position === undefined || position === null) {
	            position = this.getPos();
	        }
	        if (!this._flag.isWriteable()) {
	            throw new ApiError(ErrorCode.EPERM, 'File not opened with a writeable mode.');
	        }
	        var endFp = position + length;
	        if (endFp > this._stat.size) {
	            this._stat.size = endFp;
	            if (endFp > this._buffer.length) {
	                // Extend the buffer!
	                var newBuff = Buffer.alloc(endFp);
	                this._buffer.copy(newBuff);
	                this._buffer = newBuff;
	            }
	        }
	        var len = buffer$$1.copy(this._buffer, position, offset, offset + length);
	        this._stat.mtime = new Date();
	        if (this._flag.isSynchronous()) {
	            this.syncSync();
	            return len;
	        }
	        this.setPos(position + len);
	        return len;
	    };
	    /**
	     * Read data from the file.
	     * @param [BrowserFS.node.Buffer] buffer The buffer that the data will be
	     *   written to.
	     * @param [Number] offset The offset within the buffer where writing will
	     *   start.
	     * @param [Number] length An integer specifying the number of bytes to read.
	     * @param [Number] position An integer specifying where to begin reading from
	     *   in the file. If position is null, data will be read from the current file
	     *   position.
	     * @param [Function(BrowserFS.ApiError, Number, BrowserFS.node.Buffer)] cb The
	     *   number is the number of bytes read
	     */
	    PreloadFile.prototype.read = function read (buffer$$1, offset, length, position, cb) {
	        try {
	            cb(null, this.readSync(buffer$$1, offset, length, position), buffer$$1);
	        }
	        catch (e) {
	            cb(e);
	        }
	    };
	    /**
	     * Read data from the file.
	     * @param [BrowserFS.node.Buffer] buffer The buffer that the data will be
	     *   written to.
	     * @param [Number] offset The offset within the buffer where writing will
	     *   start.
	     * @param [Number] length An integer specifying the number of bytes to read.
	     * @param [Number] position An integer specifying where to begin reading from
	     *   in the file. If position is null, data will be read from the current file
	     *   position.
	     * @return [Number]
	     */
	    PreloadFile.prototype.readSync = function readSync (buffer$$1, offset, length, position) {
	        if (!this._flag.isReadable()) {
	            throw new ApiError(ErrorCode.EPERM, 'File not opened with a readable mode.');
	        }
	        if (position === undefined || position === null) {
	            position = this.getPos();
	        }
	        var endRead = position + length;
	        if (endRead > this._stat.size) {
	            length = this._stat.size - position;
	        }
	        var rv = this._buffer.copy(buffer$$1, offset, position, position + length);
	        this._stat.atime = new Date();
	        this._pos = position + length;
	        return rv;
	    };
	    /**
	     * Asynchronous `fchmod`.
	     * @param [Number|String] mode
	     * @param [Function(BrowserFS.ApiError)] cb
	     */
	    PreloadFile.prototype.chmod = function chmod (mode, cb) {
	        try {
	            this.chmodSync(mode);
	            cb();
	        }
	        catch (e) {
	            cb(e);
	        }
	    };
	    /**
	     * Asynchronous `fchmod`.
	     * @param [Number] mode
	     */
	    PreloadFile.prototype.chmodSync = function chmodSync (mode) {
	        if (!this._fs.supportsProps()) {
	            throw new ApiError(ErrorCode.ENOTSUP);
	        }
	        this._dirty = true;
	        this._stat.chmod(mode);
	        this.syncSync();
	    };
	    PreloadFile.prototype.isDirty = function isDirty () {
	        return this._dirty;
	    };
	    /**
	     * Resets the dirty bit. Should only be called after a sync has completed successfully.
	     */
	    PreloadFile.prototype.resetDirty = function resetDirty () {
	        this._dirty = false;
	    };
	
	    return PreloadFile;
	}(BaseFile));
	
	/**
	 * File class for the InMemory and XHR file systems.
	 * Doesn't sync to anything, so it works nicely for memory-only files.
	 */
	var NoSyncFile = (function (PreloadFile) {
	    function NoSyncFile(_fs, _path, _flag, _stat, contents) {
	        PreloadFile.call(this, _fs, _path, _flag, _stat, contents);
	    }
	
	    if ( PreloadFile ) NoSyncFile.__proto__ = PreloadFile;
	    NoSyncFile.prototype = Object.create( PreloadFile && PreloadFile.prototype );
	    NoSyncFile.prototype.constructor = NoSyncFile;
	    /**
	     * Asynchronous sync. Doesn't do anything, simply calls the cb.
	     * @param [Function(BrowserFS.ApiError)] cb
	     */
	    NoSyncFile.prototype.sync = function sync (cb) {
	        cb();
	    };
	    /**
	     * Synchronous sync. Doesn't do anything.
	     */
	    NoSyncFile.prototype.syncSync = function syncSync () {
	        // NOP.
	    };
	    /**
	     * Asynchronous close. Doesn't do anything, simply calls the cb.
	     * @param [Function(BrowserFS.ApiError)] cb
	     */
	    NoSyncFile.prototype.close = function close (cb) {
	        cb();
	    };
	    /**
	     * Synchronous close. Doesn't do anything.
	     */
	    NoSyncFile.prototype.closeSync = function closeSync () {
	        // NOP.
	    };
	
	    return NoSyncFile;
	}(PreloadFile));
	
	/**
	 * We define our own file to interpose on syncSync() for mirroring purposes.
	 */
	var MirrorFile = (function (PreloadFile$$1) {
	    function MirrorFile(fs, path$$1, flag, stat, data) {
	        PreloadFile$$1.call(this, fs, path$$1, flag, stat, data);
	    }
	
	    if ( PreloadFile$$1 ) MirrorFile.__proto__ = PreloadFile$$1;
	    MirrorFile.prototype = Object.create( PreloadFile$$1 && PreloadFile$$1.prototype );
	    MirrorFile.prototype.constructor = MirrorFile;
	    MirrorFile.prototype.syncSync = function syncSync () {
	        if (this.isDirty()) {
	            this._fs._syncSync(this);
	            this.resetDirty();
	        }
	    };
	    MirrorFile.prototype.closeSync = function closeSync () {
	        this.syncSync();
	    };
	
	    return MirrorFile;
	}(PreloadFile));
	/**
	 * AsyncMirrorFS mirrors a synchronous filesystem into an asynchronous filesystem
	 * by:
	 *
	 * * Performing operations over the in-memory copy, while asynchronously pipelining them
	 *   to the backing store.
	 * * During application loading, the contents of the async file system can be reloaded into
	 *   the synchronous store, if desired.
	 *
	 * The two stores will be kept in sync. The most common use-case is to pair a synchronous
	 * in-memory filesystem with an asynchronous backing store.
	 *
	 * Example: Mirroring an IndexedDB file system to an in memory file system. Now, you can use
	 * IndexedDB synchronously.
	 *
	 * ```javascript
	 * BrowserFS.configure({
	 *   fs: "AsyncMirror",
	 *   options: {
	 *     sync: { fs: "InMemory" },
	 *     async: { fs: "IndexedDB" }
	 *   }
	 * }, function(e) {
	 *   // BrowserFS is initialized and ready-to-use!
	 * });
	 * ```
	 *
	 * Or, alternatively:
	 *
	 * ```javascript
	 * BrowserFS.FileSystem.IndexedDB.Create(function(e, idbfs) {
	 *   BrowserFS.FileSystem.InMemory.Create(function(e, inMemory) {
	 *     BrowserFS.FileSystem.AsyncMirror({
	 *       sync: inMemory, async: idbfs
	 *     }, function(e, mirrored) {
	 *       BrowserFS.initialize(mirrored);
	 *     });
	 *   });
	 * });
	 * ```
	 */
	var AsyncMirror = (function (SynchronousFileSystem$$1) {
	    function AsyncMirror(sync, async, deprecateMsg) {
	        if ( deprecateMsg === void 0 ) deprecateMsg = true;
	
	        SynchronousFileSystem$$1.call(this);
	        /**
	         * Queue of pending asynchronous operations.
	         */
	        this._queue = [];
	        this._queueRunning = false;
	        this._isInitialized = false;
	        this._initializeCallbacks = [];
	        this._sync = sync;
	        this._async = async;
	        if (!sync.supportsSynch()) {
	            throw new Error("The first argument to AsyncMirror needs to be a synchronous file system.");
	        }
	        deprecationMessage(deprecateMsg, AsyncMirror.Name, { sync: "sync file system instance", async: "async file system instance" });
	    }
	
	    if ( SynchronousFileSystem$$1 ) AsyncMirror.__proto__ = SynchronousFileSystem$$1;
	    AsyncMirror.prototype = Object.create( SynchronousFileSystem$$1 && SynchronousFileSystem$$1.prototype );
	    AsyncMirror.prototype.constructor = AsyncMirror;
	    /**
	     * Constructs and initializes an AsyncMirror file system with the given options.
	     */
	    AsyncMirror.Create = function Create (opts, cb) {
	        try {
	            var fs = new AsyncMirror(opts.sync, opts.async, false);
	            fs.initialize(function (e) {
	                if (e) {
	                    cb(e);
	                }
	                else {
	                    cb(null, fs);
	                }
	            }, false);
	        }
	        catch (e) {
	            cb(e);
	        }
	    };
	    AsyncMirror.isAvailable = function isAvailable () {
	        return true;
	    };
	    AsyncMirror.prototype.getName = function getName () {
	        return AsyncMirror.Name;
	    };
	    AsyncMirror.prototype._syncSync = function _syncSync (fd) {
	        this._sync.writeFileSync(fd.getPath(), fd.getBuffer(), null, FileFlag.getFileFlag('w'), fd.getStats().mode);
	        this.enqueueOp({
	            apiMethod: 'writeFile',
	            arguments: [fd.getPath(), fd.getBuffer(), null, fd.getFlag(), fd.getStats().mode]
	        });
	    };
	    /**
	     * Called once to load up files from async storage into sync storage.
	     */
	    AsyncMirror.prototype.initialize = function initialize (userCb, deprecateMsg) {
	        var this$1 = this;
	        if ( deprecateMsg === void 0 ) deprecateMsg = true;
	
	        if (deprecateMsg) {
	            console.warn("[AsyncMirror] AsyncMirror.initialize() is deprecated and will be removed in the next major version. Please use 'AsyncMirror.Create({ sync: (sync file system instance), async: (async file system instance)}, cb)' to create and initialize AsyncMirror instances.");
	        }
	        var callbacks = this._initializeCallbacks;
	        var end = function (e) {
	            this$1._isInitialized = !e;
	            this$1._initializeCallbacks = [];
	            callbacks.forEach(function (cb) { return cb(e); });
	        };
	        if (!this._isInitialized) {
	            // First call triggers initialization, the rest wait.
	            if (callbacks.push(userCb) === 1) {
	                var copyDirectory = function (p, mode, cb) {
	                    if (p !== '/') {
	                        this$1._sync.mkdirSync(p, mode);
	                    }
	                    this$1._async.readdir(p, function (err, files) {
	                        var i = 0;
	                        // NOTE: This function must not be in a lexically nested statement,
	                        // such as an if or while statement. Safari refuses to run the
	                        // script since it is undefined behavior.
	                        function copyNextFile(err) {
	                            if (err) {
	                                cb(err);
	                            }
	                            else if (i < files.length) {
	                                copyItem(path.join(p, files[i]), copyNextFile);
	                                i++;
	                            }
	                            else {
	                                cb();
	                            }
	                        }
	                        if (err) {
	                            cb(err);
	                        }
	                        else {
	                            copyNextFile();
	                        }
	                    });
	                }, copyFile = function (p, mode, cb) {
	                    this$1._async.readFile(p, null, FileFlag.getFileFlag('r'), function (err, data) {
	                        if (err) {
	                            cb(err);
	                        }
	                        else {
	                            try {
	                                this$1._sync.writeFileSync(p, data, null, FileFlag.getFileFlag('w'), mode);
	                            }
	                            catch (e) {
	                                err = e;
	                            }
	                            finally {
	                                cb(err);
	                            }
	                        }
	                    });
	                }, copyItem = function (p, cb) {
	                    this$1._async.stat(p, false, function (err, stats) {
	                        if (err) {
	                            cb(err);
	                        }
	                        else if (stats.isDirectory()) {
	                            copyDirectory(p, stats.mode, cb);
	                        }
	                        else {
	                            copyFile(p, stats.mode, cb);
	                        }
	                    });
	                };
	                copyDirectory('/', 0, end);
	            }
	        }
	        else {
	            userCb();
	        }
	    };
	    AsyncMirror.prototype.isReadOnly = function isReadOnly () { return false; };
	    AsyncMirror.prototype.supportsSynch = function supportsSynch () { return true; };
	    AsyncMirror.prototype.supportsLinks = function supportsLinks () { return false; };
	    AsyncMirror.prototype.supportsProps = function supportsProps () { return this._sync.supportsProps() && this._async.supportsProps(); };
	    AsyncMirror.prototype.renameSync = function renameSync (oldPath, newPath) {
	        this.checkInitialized();
	        this._sync.renameSync(oldPath, newPath);
	        this.enqueueOp({
	            apiMethod: 'rename',
	            arguments: [oldPath, newPath]
	        });
	    };
	    AsyncMirror.prototype.statSync = function statSync (p, isLstat) {
	        this.checkInitialized();
	        return this._sync.statSync(p, isLstat);
	    };
	    AsyncMirror.prototype.openSync = function openSync (p, flag, mode) {
	        this.checkInitialized();
	        // Sanity check: Is this open/close permitted?
	        var fd = this._sync.openSync(p, flag, mode);
	        fd.closeSync();
	        return new MirrorFile(this, p, flag, this._sync.statSync(p, false), this._sync.readFileSync(p, null, FileFlag.getFileFlag('r')));
	    };
	    AsyncMirror.prototype.unlinkSync = function unlinkSync (p) {
	        this.checkInitialized();
	        this._sync.unlinkSync(p);
	        this.enqueueOp({
	            apiMethod: 'unlink',
	            arguments: [p]
	        });
	    };
	    AsyncMirror.prototype.rmdirSync = function rmdirSync (p) {
	        this.checkInitialized();
	        this._sync.rmdirSync(p);
	        this.enqueueOp({
	            apiMethod: 'rmdir',
	            arguments: [p]
	        });
	    };
	    AsyncMirror.prototype.mkdirSync = function mkdirSync (p, mode) {
	        this.checkInitialized();
	        this._sync.mkdirSync(p, mode);
	        this.enqueueOp({
	            apiMethod: 'mkdir',
	            arguments: [p, mode]
	        });
	    };
	    AsyncMirror.prototype.readdirSync = function readdirSync (p) {
	        this.checkInitialized();
	        return this._sync.readdirSync(p);
	    };
	    AsyncMirror.prototype.existsSync = function existsSync (p) {
	        this.checkInitialized();
	        return this._sync.existsSync(p);
	    };
	    AsyncMirror.prototype.chmodSync = function chmodSync (p, isLchmod, mode) {
	        this.checkInitialized();
	        this._sync.chmodSync(p, isLchmod, mode);
	        this.enqueueOp({
	            apiMethod: 'chmod',
	            arguments: [p, isLchmod, mode]
	        });
	    };
	    AsyncMirror.prototype.chownSync = function chownSync (p, isLchown, uid, gid) {
	        this.checkInitialized();
	        this._sync.chownSync(p, isLchown, uid, gid);
	        this.enqueueOp({
	            apiMethod: 'chown',
	            arguments: [p, isLchown, uid, gid]
	        });
	    };
	    AsyncMirror.prototype.utimesSync = function utimesSync (p, atime, mtime) {
	        this.checkInitialized();
	        this._sync.utimesSync(p, atime, mtime);
	        this.enqueueOp({
	            apiMethod: 'utimes',
	            arguments: [p, atime, mtime]
	        });
	    };
	    AsyncMirror.prototype.checkInitialized = function checkInitialized () {
	        if (!this._isInitialized) {
	            throw new ApiError(ErrorCode.EPERM, "AsyncMirrorFS is not initialized. Please initialize AsyncMirrorFS using its initialize() method before using it.");
	        }
	    };
	    AsyncMirror.prototype.enqueueOp = function enqueueOp (op) {
	        var this$1 = this;
	
	        this._queue.push(op);
	        if (!this._queueRunning) {
	            this._queueRunning = true;
	            var doNextOp = function (err) {
	                if (err) {
	                    console.error(("WARNING: File system has desynchronized. Received following error: " + err + "\n$"));
	                }
	                if (this$1._queue.length > 0) {
	                    var op = this$1._queue.shift(), args = op.arguments;
	                    args.push(doNextOp);
	                    this$1._async[op.apiMethod].apply(this$1._async, args);
	                }
	                else {
	                    this$1._queueRunning = false;
	                }
	            };
	            doNextOp();
	        }
	    };
	
	    return AsyncMirror;
	}(SynchronousFileSystem));
	
	AsyncMirror.Name = "AsyncMirror";
	AsyncMirror.Options = {
	    sync: {
	        type: "object",
	        description: "The synchronous file system to mirror the asynchronous file system to."
	    },
	    async: {
	        type: "object",
	        description: "The asynchronous file system to mirror."
	    }
	};
	
	/**
	 * A faster alternative to `Function#apply`, this function invokes `func`
	 * with the `this` binding of `thisArg` and the arguments of `args`.
	 *
	 * @private
	 * @param {Function} func The function to invoke.
	 * @param {*} thisArg The `this` binding of `func`.
	 * @param {Array} args The arguments to invoke `func` with.
	 * @returns {*} Returns the result of `func`.
	 */
	function apply(func, thisArg, args) {
	  switch (args.length) {
	    case 0: return func.call(thisArg);
	    case 1: return func.call(thisArg, args[0]);
	    case 2: return func.call(thisArg, args[0], args[1]);
	    case 3: return func.call(thisArg, args[0], args[1], args[2]);
	  }
	  return func.apply(thisArg, args);
	}
	
	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMax = Math.max;
	
	/**
	 * A specialized version of `baseRest` which transforms the rest array.
	 *
	 * @private
	 * @param {Function} func The function to apply a rest parameter to.
	 * @param {number} [start=func.length-1] The start position of the rest parameter.
	 * @param {Function} transform The rest array transform.
	 * @returns {Function} Returns the new function.
	 */
	function overRest$1(func, start, transform) {
	  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
	  return function() {
	    var args = arguments,
	        index = -1,
	        length = nativeMax(args.length - start, 0),
	        array = Array(length);
	
	    while (++index < length) {
	      array[index] = args[start + index];
	    }
	    index = -1;
	    var otherArgs = Array(start + 1);
	    while (++index < start) {
	      otherArgs[index] = args[index];
	    }
	    otherArgs[start] = transform(array);
	    return apply(func, this, otherArgs);
	  };
	}
	
	/**
	 * This method returns the first argument it receives.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Util
	 * @param {*} value Any value.
	 * @returns {*} Returns `value`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 *
	 * console.log(_.identity(object) === object);
	 * // => true
	 */
	function identity(value) {
	  return value;
	}
	
	// Lodash rest function without function.toString()
	// remappings
	function rest(func, start) {
	    return overRest$1(func, start, identity);
	}
	
	var initialParams = function (fn) {
	    return rest(function (args/*..., callback*/) {
	        var callback = args.pop();
	        fn.call(this, args, callback);
	    });
	};
	
	function applyEach$1(eachfn) {
	    return rest(function(fns, args) {
	        var go = initialParams(function(args, callback) {
	            var that = this;
	            return eachfn(fns, function (fn, cb) {
	                fn.apply(that, args.concat(cb));
	            }, callback);
	        });
	        if (args.length) {
	            return go.apply(this, args);
	        }
	        else {
	            return go;
	        }
	    });
	}
	
	/** Detect free variable `global` from Node.js. */
	var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
	
	/** Detect free variable `self`. */
	var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
	
	/** Used as a reference to the global object. */
	var root = freeGlobal || freeSelf || Function('return this')();
	
	/** Built-in value references. */
	var Symbol$1 = root.Symbol;
	
	/** Used for built-in method references. */
	var objectProto = Object.prototype;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString = objectProto.toString;
	
	/** Built-in value references. */
	var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : undefined;
	
	/**
	 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the raw `toStringTag`.
	 */
	function getRawTag(value) {
	  var isOwn = hasOwnProperty.call(value, symToStringTag$1),
	      tag = value[symToStringTag$1];
	
	  try {
	    value[symToStringTag$1] = undefined;
	    var unmasked = true;
	  } catch (e) {}
	
	  var result = nativeObjectToString.call(value);
	  if (unmasked) {
	    if (isOwn) {
	      value[symToStringTag$1] = tag;
	    } else {
	      delete value[symToStringTag$1];
	    }
	  }
	  return result;
	}
	
	/** Used for built-in method references. */
	var objectProto$1 = Object.prototype;
	
	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString$1 = objectProto$1.toString;
	
	/**
	 * Converts `value` to a string using `Object.prototype.toString`.
	 *
	 * @private
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 */
	function objectToString(value) {
	  return nativeObjectToString$1.call(value);
	}
	
	/** `Object#toString` result references. */
	var nullTag = '[object Null]';
	var undefinedTag = '[object Undefined]';
	
	/** Built-in value references. */
	var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : undefined;
	
	/**
	 * The base implementation of `getTag` without fallbacks for buggy environments.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	function baseGetTag(value) {
	  if (value == null) {
	    return value === undefined ? undefinedTag : nullTag;
	  }
	  return (symToStringTag && symToStringTag in Object(value))
	    ? getRawTag(value)
	    : objectToString(value);
	}
	
	/**
	 * Checks if `value` is the
	 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */
	function isObject(value) {
	  var type = typeof value;
	  return value != null && (type == 'object' || type == 'function');
	}
	
	/** `Object#toString` result references. */
	var asyncTag = '[object AsyncFunction]';
	var funcTag = '[object Function]';
	var genTag = '[object GeneratorFunction]';
	var proxyTag = '[object Proxy]';
	
	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction(value) {
	  if (!isObject(value)) {
	    return false;
	  }
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in Safari 9 which returns 'object' for typed arrays and other constructors.
	  var tag = baseGetTag(value);
	  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
	}
	
	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER = 9007199254740991;
	
	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This method is loosely based on
	 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 * @example
	 *
	 * _.isLength(3);
	 * // => true
	 *
	 * _.isLength(Number.MIN_VALUE);
	 * // => false
	 *
	 * _.isLength(Infinity);
	 * // => false
	 *
	 * _.isLength('3');
	 * // => false
	 */
	function isLength(value) {
	  return typeof value == 'number' &&
	    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}
	
	/**
	 * Checks if `value` is array-like. A value is considered array-like if it's
	 * not a function and has a `value.length` that's an integer greater than or
	 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	 * @example
	 *
	 * _.isArrayLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLike(document.body.children);
	 * // => true
	 *
	 * _.isArrayLike('abc');
	 * // => true
	 *
	 * _.isArrayLike(_.noop);
	 * // => false
	 */
	function isArrayLike(value) {
	  return value != null && isLength(value.length) && !isFunction(value);
	}
	
	// A temporary value used to identify if the loop should be broken.
	// See #1064, #1293
	var breakLoop = {};
	
	/**
	 * This method returns `undefined`.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.3.0
	 * @category Util
	 * @example
	 *
	 * _.times(2, _.noop);
	 * // => [undefined, undefined]
	 */
	function noop() {
	  // No operation performed.
	}
	
	function once(fn) {
	    return function () {
	        if (fn === null) { return; }
	        var callFn = fn;
	        fn = null;
	        callFn.apply(this, arguments);
	    };
	}
	
	var iteratorSymbol = typeof Symbol === 'function' && Symbol.iterator;
	
	var getIterator = function (coll) {
	    return iteratorSymbol && coll[iteratorSymbol] && coll[iteratorSymbol]();
	};
	
	/**
	 * The base implementation of `_.times` without support for iteratee shorthands
	 * or max array length checks.
	 *
	 * @private
	 * @param {number} n The number of times to invoke `iteratee`.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the array of results.
	 */
	function baseTimes(n, iteratee) {
	  var index = -1,
	      result = Array(n);
	
	  while (++index < n) {
	    result[index] = iteratee(index);
	  }
	  return result;
	}
	
	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return value != null && typeof value == 'object';
	}
	
	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]';
	
	/**
	 * The base implementation of `_.isArguments`.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 */
	function baseIsArguments(value) {
	  return isObjectLike(value) && baseGetTag(value) == argsTag;
	}
	
	/** Used for built-in method references. */
	var objectProto$3 = Object.prototype;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty$2 = objectProto$3.hasOwnProperty;
	
	/** Built-in value references. */
	var propertyIsEnumerable = objectProto$3.propertyIsEnumerable;
	
	/**
	 * Checks if `value` is likely an `arguments` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArguments(function() { return arguments; }());
	 * // => true
	 *
	 * _.isArguments([1, 2, 3]);
	 * // => false
	 */
	var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
	  return isObjectLike(value) && hasOwnProperty$2.call(value, 'callee') &&
	    !propertyIsEnumerable.call(value, 'callee');
	};
	
	/**
	 * Checks if `value` is classified as an `Array` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
	 * @example
	 *
	 * _.isArray([1, 2, 3]);
	 * // => true
	 *
	 * _.isArray(document.body.children);
	 * // => false
	 *
	 * _.isArray('abc');
	 * // => false
	 *
	 * _.isArray(_.noop);
	 * // => false
	 */
	var isArray = Array.isArray;
	
	/**
	 * This method returns `false`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.13.0
	 * @category Util
	 * @returns {boolean} Returns `false`.
	 * @example
	 *
	 * _.times(2, _.stubFalse);
	 * // => [false, false]
	 */
	function stubFalse() {
	  return false;
	}
	
	/** Detect free variable `exports`. */
	var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
	
	/** Detect free variable `module`. */
	var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
	
	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports = freeModule && freeModule.exports === freeExports;
	
	/** Built-in value references. */
	var Buffer$1 = moduleExports ? root.Buffer : undefined;
	
	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeIsBuffer = Buffer$1 ? Buffer$1.isBuffer : undefined;
	
	/**
	 * Checks if `value` is a buffer.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.3.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
	 * @example
	 *
	 * _.isBuffer(new Buffer(2));
	 * // => true
	 *
	 * _.isBuffer(new Uint8Array(2));
	 * // => false
	 */
	var isBuffer = nativeIsBuffer || stubFalse;
	
	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER$1 = 9007199254740991;
	
	/** Used to detect unsigned integer values. */
	var reIsUint = /^(?:0|[1-9]\d*)$/;
	
	/**
	 * Checks if `value` is a valid array-like index.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	 */
	function isIndex(value, length) {
	  length = length == null ? MAX_SAFE_INTEGER$1 : length;
	  return !!length &&
	    (typeof value == 'number' || reIsUint.test(value)) &&
	    (value > -1 && value % 1 == 0 && value < length);
	}
	
	/** `Object#toString` result references. */
	var argsTag$1 = '[object Arguments]';
	var arrayTag = '[object Array]';
	var boolTag = '[object Boolean]';
	var dateTag = '[object Date]';
	var errorTag = '[object Error]';
	var funcTag$1 = '[object Function]';
	var mapTag = '[object Map]';
	var numberTag = '[object Number]';
	var objectTag = '[object Object]';
	var regexpTag = '[object RegExp]';
	var setTag = '[object Set]';
	var stringTag = '[object String]';
	var weakMapTag = '[object WeakMap]';
	
	var arrayBufferTag = '[object ArrayBuffer]';
	var dataViewTag = '[object DataView]';
	var float32Tag = '[object Float32Array]';
	var float64Tag = '[object Float64Array]';
	var int8Tag = '[object Int8Array]';
	var int16Tag = '[object Int16Array]';
	var int32Tag = '[object Int32Array]';
	var uint8Tag = '[object Uint8Array]';
	var uint8ClampedTag = '[object Uint8ClampedArray]';
	var uint16Tag = '[object Uint16Array]';
	var uint32Tag = '[object Uint32Array]';
	
	/** Used to identify `toStringTag` values of typed arrays. */
	var typedArrayTags = {};
	typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
	typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
	typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
	typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
	typedArrayTags[uint32Tag] = true;
	typedArrayTags[argsTag$1] = typedArrayTags[arrayTag] =
	typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
	typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
	typedArrayTags[errorTag] = typedArrayTags[funcTag$1] =
	typedArrayTags[mapTag] = typedArrayTags[numberTag] =
	typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
	typedArrayTags[setTag] = typedArrayTags[stringTag] =
	typedArrayTags[weakMapTag] = false;
	
	/**
	 * The base implementation of `_.isTypedArray` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 */
	function baseIsTypedArray(value) {
	  return isObjectLike(value) &&
	    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
	}
	
	/**
	 * The base implementation of `_.unary` without support for storing metadata.
	 *
	 * @private
	 * @param {Function} func The function to cap arguments for.
	 * @returns {Function} Returns the new capped function.
	 */
	function baseUnary(func) {
	  return function(value) {
	    return func(value);
	  };
	}
	
	/** Detect free variable `exports`. */
	var freeExports$1 = typeof exports == 'object' && exports && !exports.nodeType && exports;
	
	/** Detect free variable `module`. */
	var freeModule$1 = freeExports$1 && typeof module == 'object' && module && !module.nodeType && module;
	
	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
	
	/** Detect free variable `process` from Node.js. */
	var freeProcess = moduleExports$1 && freeGlobal.process;
	
	/** Used to access faster Node.js helpers. */
	var nodeUtil = (function() {
	  try {
	    return freeProcess && freeProcess.binding && freeProcess.binding('util');
	  } catch (e) {}
	}());
	
	/* Node.js helper references. */
	var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
	
	/**
	 * Checks if `value` is classified as a typed array.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 * @example
	 *
	 * _.isTypedArray(new Uint8Array);
	 * // => true
	 *
	 * _.isTypedArray([]);
	 * // => false
	 */
	var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
	
	/** Used for built-in method references. */
	var objectProto$2 = Object.prototype;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty$1 = objectProto$2.hasOwnProperty;
	
	/**
	 * Creates an array of the enumerable property names of the array-like `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @param {boolean} inherited Specify returning inherited property names.
	 * @returns {Array} Returns the array of property names.
	 */
	function arrayLikeKeys(value, inherited) {
	  var isArr = isArray(value),
	      isArg = !isArr && isArguments(value),
	      isBuff = !isArr && !isArg && isBuffer(value),
	      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
	      skipIndexes = isArr || isArg || isBuff || isType,
	      result = skipIndexes ? baseTimes(value.length, String) : [],
	      length = result.length;
	
	  for (var key in value) {
	    if ((inherited || hasOwnProperty$1.call(value, key)) &&
	        !(skipIndexes && (
	           // Safari 9 has enumerable `arguments.length` in strict mode.
	           key == 'length' ||
	           // Node.js 0.10 has enumerable non-index properties on buffers.
	           (isBuff && (key == 'offset' || key == 'parent')) ||
	           // PhantomJS 2 has enumerable non-index properties on typed arrays.
	           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
	           // Skip index properties.
	           isIndex(key, length)
	        ))) {
	      result.push(key);
	    }
	  }
	  return result;
	}
	
	/** Used for built-in method references. */
	var objectProto$5 = Object.prototype;
	
	/**
	 * Checks if `value` is likely a prototype object.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
	 */
	function isPrototype(value) {
	  var Ctor = value && value.constructor,
	      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$5;
	
	  return value === proto;
	}
	
	/**
	 * Creates a unary function that invokes `func` with its argument transformed.
	 *
	 * @private
	 * @param {Function} func The function to wrap.
	 * @param {Function} transform The argument transform.
	 * @returns {Function} Returns the new function.
	 */
	function overArg(func, transform) {
	  return function(arg) {
	    return func(transform(arg));
	  };
	}
	
	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeKeys = overArg(Object.keys, Object);
	
	/** Used for built-in method references. */
	var objectProto$4 = Object.prototype;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty$3 = objectProto$4.hasOwnProperty;
	
	/**
	 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function baseKeys(object) {
	  if (!isPrototype(object)) {
	    return nativeKeys(object);
	  }
	  var result = [];
	  for (var key in Object(object)) {
	    if (hasOwnProperty$3.call(object, key) && key != 'constructor') {
	      result.push(key);
	    }
	  }
	  return result;
	}
	
	/**
	 * Creates an array of the own enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects. See the
	 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	 * for more details.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keys(new Foo);
	 * // => ['a', 'b'] (iteration order is not guaranteed)
	 *
	 * _.keys('hi');
	 * // => ['0', '1']
	 */
	function keys(object) {
	  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
	}
	
	function createArrayIterator(coll) {
	    var i = -1;
	    var len = coll.length;
	    return function next() {
	        return ++i < len ? {value: coll[i], key: i} : null;
	    }
	}
	
	function createES2015Iterator(iterator) {
	    var i = -1;
	    return function next() {
	        var item = iterator.next();
	        if (item.done)
	            { return null; }
	        i++;
	        return {value: item.value, key: i};
	    }
	}
	
	function createObjectIterator(obj) {
	    var okeys = keys(obj);
	    var i = -1;
	    var len = okeys.length;
	    return function next() {
	        var key = okeys[++i];
	        return i < len ? {value: obj[key], key: key} : null;
	    };
	}
	
	function iterator(coll) {
	    if (isArrayLike(coll)) {
	        return createArrayIterator(coll);
	    }
	
	    var iterator = getIterator(coll);
	    return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);
	}
	
	function onlyOnce(fn) {
	    return function() {
	        if (fn === null) { throw new Error("Callback was already called."); }
	        var callFn = fn;
	        fn = null;
	        callFn.apply(this, arguments);
	    };
	}
	
	function _eachOfLimit(limit) {
	    return function (obj, iteratee, callback) {
	        callback = once(callback || noop);
	        if (limit <= 0 || !obj) {
	            return callback(null);
	        }
	        var nextElem = iterator(obj);
	        var done = false;
	        var running = 0;
	
	        function iterateeCallback(err, value) {
	            running -= 1;
	            if (err) {
	                done = true;
	                callback(err);
	            }
	            else if (value === breakLoop || (done && running <= 0)) {
	                done = true;
	                return callback(null);
	            }
	            else {
	                replenish();
	            }
	        }
	
	        function replenish () {
	            while (running < limit && !done) {
	                var elem = nextElem();
	                if (elem === null) {
	                    done = true;
	                    if (running <= 0) {
	                        callback(null);
	                    }
	                    return;
	                }
	                running += 1;
	                iteratee(elem.value, elem.key, onlyOnce(iterateeCallback));
	            }
	        }
	
	        replenish();
	    };
	}
	
	/**
	 * The same as [`eachOf`]{@link module:Collections.eachOf} but runs a maximum of `limit` async operations at a
	 * time.
	 *
	 * @name eachOfLimit
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @see [async.eachOf]{@link module:Collections.eachOf}
	 * @alias forEachOfLimit
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {number} limit - The maximum number of async operations at a time.
	 * @param {Function} iteratee - A function to apply to each
	 * item in `coll`. The `key` is the item's key, or index in the case of an
	 * array. The iteratee is passed a `callback(err)` which must be called once it
	 * has completed. If no error has occurred, the callback should be run without
	 * arguments or with an explicit `null` argument. Invoked with
	 * (item, key, callback).
	 * @param {Function} [callback] - A callback which is called when all
	 * `iteratee` functions have finished, or an error occurs. Invoked with (err).
	 */
	function eachOfLimit(coll, limit, iteratee, callback) {
	    _eachOfLimit(limit)(coll, iteratee, callback);
	}
	
	function doLimit(fn, limit) {
	    return function (iterable, iteratee, callback) {
	        return fn(iterable, limit, iteratee, callback);
	    };
	}
	
	// eachOf implementation optimized for array-likes
	function eachOfArrayLike(coll, iteratee, callback) {
	    callback = once(callback || noop);
	    var index = 0,
	        completed = 0,
	        length = coll.length;
	    if (length === 0) {
	        callback(null);
	    }
	
	    function iteratorCallback(err, value) {
	        if (err) {
	            callback(err);
	        } else if ((++completed === length) || value === breakLoop) {
	            callback(null);
	        }
	    }
	
	    for (; index < length; index++) {
	        iteratee(coll[index], index, onlyOnce(iteratorCallback));
	    }
	}
	
	// a generic version of eachOf which can handle array, object, and iterator cases.
	var eachOfGeneric = doLimit(eachOfLimit, Infinity);
	
	/**
	 * Like [`each`]{@link module:Collections.each}, except that it passes the key (or index) as the second argument
	 * to the iteratee.
	 *
	 * @name eachOf
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @alias forEachOf
	 * @category Collection
	 * @see [async.each]{@link module:Collections.each}
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {Function} iteratee - A function to apply to each
	 * item in `coll`. The `key` is the item's key, or index in the case of an
	 * array. The iteratee is passed a `callback(err)` which must be called once it
	 * has completed. If no error has occurred, the callback should be run without
	 * arguments or with an explicit `null` argument. Invoked with
	 * (item, key, callback).
	 * @param {Function} [callback] - A callback which is called when all
	 * `iteratee` functions have finished, or an error occurs. Invoked with (err).
	 * @example
	 *
	 * var obj = {dev: "/dev.json", test: "/test.json", prod: "/prod.json"};
	 * var configs = {};
	 *
	 * async.forEachOf(obj, function (value, key, callback) {
	 *     fs.readFile(__dirname + value, "utf8", function (err, data) {
	 *         if (err) return callback(err);
	 *         try {
	 *             configs[key] = JSON.parse(data);
	 *         } catch (e) {
	 *             return callback(e);
	 *         }
	 *         callback();
	 *     });
	 * }, function (err) {
	 *     if (err) console.error(err.message);
	 *     // configs is now a map of JSON data
	 *     doSomethingWith(configs);
	 * });
	 */
	var eachOf = function(coll, iteratee, callback) {
	    var eachOfImplementation = isArrayLike(coll) ? eachOfArrayLike : eachOfGeneric;
	    eachOfImplementation(coll, iteratee, callback);
	};
	
	function doParallel(fn) {
	    return function (obj, iteratee, callback) {
	        return fn(eachOf, obj, iteratee, callback);
	    };
	}
	
	function _asyncMap(eachfn, arr, iteratee, callback) {
	    callback = callback || noop;
	    arr = arr || [];
	    var results = [];
	    var counter = 0;
	
	    eachfn(arr, function (value, _, callback) {
	        var index = counter++;
	        iteratee(value, function (err, v) {
	            results[index] = v;
	            callback(err);
	        });
	    }, function (err) {
	        callback(err, results);
	    });
	}
	
	/**
	 * Produces a new collection of values by mapping each value in `coll` through
	 * the `iteratee` function. The `iteratee` is called with an item from `coll`
	 * and a callback for when it has finished processing. Each of these callback
	 * takes 2 arguments: an `error`, and the transformed item from `coll`. If
	 * `iteratee` passes an error to its callback, the main `callback` (for the
	 * `map` function) is immediately called with the error.
	 *
	 * Note, that since this function applies the `iteratee` to each item in
	 * parallel, there is no guarantee that the `iteratee` functions will complete
	 * in order. However, the results array will be in the same order as the
	 * original `coll`.
	 *
	 * If `map` is passed an Object, the results will be an Array.  The results
	 * will roughly be in the order of the original Objects' keys (but this can
	 * vary across JavaScript engines)
	 *
	 * @name map
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {Function} iteratee - A function to apply to each item in `coll`.
	 * The iteratee is passed a `callback(err, transformed)` which must be called
	 * once it has completed with an error (which can be `null`) and a
	 * transformed item. Invoked with (item, callback).
	 * @param {Function} [callback] - A callback which is called when all `iteratee`
	 * functions have finished, or an error occurs. Results is an Array of the
	 * transformed items from the `coll`. Invoked with (err, results).
	 * @example
	 *
	 * async.map(['file1','file2','file3'], fs.stat, function(err, results) {
	 *     // results is now an array of stats for each file
	 * });
	 */
	var map = doParallel(_asyncMap);
	
	/**
	 * Applies the provided arguments to each function in the array, calling
	 * `callback` after all functions have completed. If you only provide the first
	 * argument, `fns`, then it will return a function which lets you pass in the
	 * arguments as if it were a single function call. If more arguments are
	 * provided, `callback` is required while `args` is still optional.
	 *
	 * @name applyEach
	 * @static
	 * @memberOf module:ControlFlow
	 * @method
	 * @category Control Flow
	 * @param {Array|Iterable|Object} fns - A collection of asynchronous functions
	 * to all call with the same arguments
	 * @param {...*} [args] - any number of separate arguments to pass to the
	 * function.
	 * @param {Function} [callback] - the final argument should be the callback,
	 * called when all functions have completed processing.
	 * @returns {Function} - If only the first argument, `fns`, is provided, it will
	 * return a function which lets you pass in the arguments as if it were a single
	 * function call. The signature is `(..args, callback)`. If invoked with any
	 * arguments, `callback` is required.
	 * @example
	 *
	 * async.applyEach([enableSearch, updateSchema], 'bucket', callback);
	 *
	 * // partial application example:
	 * async.each(
	 *     buckets,
	 *     async.applyEach([enableSearch, updateSchema]),
	 *     callback
	 * );
	 */
	applyEach$1(map);
	
	function doParallelLimit(fn) {
	    return function (obj, limit, iteratee, callback) {
	        return fn(_eachOfLimit(limit), obj, iteratee, callback);
	    };
	}
	
	/**
	 * The same as [`map`]{@link module:Collections.map} but runs a maximum of `limit` async operations at a time.
	 *
	 * @name mapLimit
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @see [async.map]{@link module:Collections.map}
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {number} limit - The maximum number of async operations at a time.
	 * @param {Function} iteratee - A function to apply to each item in `coll`.
	 * The iteratee is passed a `callback(err, transformed)` which must be called
	 * once it has completed with an error (which can be `null`) and a transformed
	 * item. Invoked with (item, callback).
	 * @param {Function} [callback] - A callback which is called when all `iteratee`
	 * functions have finished, or an error occurs. Results is an array of the
	 * transformed items from the `coll`. Invoked with (err, results).
	 */
	var mapLimit = doParallelLimit(_asyncMap);
	
	/**
	 * The same as [`map`]{@link module:Collections.map} but runs only a single async operation at a time.
	 *
	 * @name mapSeries
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @see [async.map]{@link module:Collections.map}
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {Function} iteratee - A function to apply to each item in `coll`.
	 * The iteratee is passed a `callback(err, transformed)` which must be called
	 * once it has completed with an error (which can be `null`) and a
	 * transformed item. Invoked with (item, callback).
	 * @param {Function} [callback] - A callback which is called when all `iteratee`
	 * functions have finished, or an error occurs. Results is an array of the
	 * transformed items from the `coll`. Invoked with (err, results).
	 */
	var mapSeries = doLimit(mapLimit, 1);
	
	/**
	 * The same as [`applyEach`]{@link module:ControlFlow.applyEach} but runs only a single async operation at a time.
	 *
	 * @name applyEachSeries
	 * @static
	 * @memberOf module:ControlFlow
	 * @method
	 * @see [async.applyEach]{@link module:ControlFlow.applyEach}
	 * @category Control Flow
	 * @param {Array|Iterable|Object} fns - A collection of asynchronous functions to all
	 * call with the same arguments
	 * @param {...*} [args] - any number of separate arguments to pass to the
	 * function.
	 * @param {Function} [callback] - the final argument should be the callback,
	 * called when all functions have completed processing.
	 * @returns {Function} - If only the first argument is provided, it will return
	 * a function which lets you pass in the arguments as if it were a single
	 * function call.
	 */
	applyEach$1(mapSeries);
	
	/**
	 * Creates a continuation function with some arguments already applied.
	 *
	 * Useful as a shorthand when combined with other control flow functions. Any
	 * arguments passed to the returned function are added to the arguments
	 * originally passed to apply.
	 *
	 * @name apply
	 * @static
	 * @memberOf module:Utils
	 * @method
	 * @category Util
	 * @param {Function} function - The function you want to eventually apply all
	 * arguments to. Invokes with (arguments...).
	 * @param {...*} arguments... - Any number of arguments to automatically apply
	 * when the continuation is called.
	 * @example
	 *
	 * // using apply
	 * async.parallel([
	 *     async.apply(fs.writeFile, 'testfile1', 'test1'),
	 *     async.apply(fs.writeFile, 'testfile2', 'test2')
	 * ]);
	 *
	 *
	 * // the same process without using apply
	 * async.parallel([
	 *     function(callback) {
	 *         fs.writeFile('testfile1', 'test1', callback);
	 *     },
	 *     function(callback) {
	 *         fs.writeFile('testfile2', 'test2', callback);
	 *     }
	 * ]);
	 *
	 * // It's possible to pass any number of additional arguments when calling the
	 * // continuation:
	 *
	 * node> var fn = async.apply(sys.puts, 'one');
	 * node> fn('two', 'three');
	 * one
	 * two
	 * three
	 */
	rest(function(fn, args) {
	    return rest(function(callArgs) {
	        return fn.apply(null, args.concat(callArgs));
	    });
	});
	
	/**
	 * A specialized version of `_.forEach` for arrays without support for
	 * iteratee shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns `array`.
	 */
	function arrayEach(array, iteratee) {
	  var index = -1,
	      length = array == null ? 0 : array.length;
	
	  while (++index < length) {
	    if (iteratee(array[index], index, array) === false) {
	      break;
	    }
	  }
	  return array;
	}
	
	/**
	 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
	 *
	 * @private
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {Function} Returns the new base function.
	 */
	function createBaseFor(fromRight) {
	  return function(object, iteratee, keysFunc) {
	    var index = -1,
	        iterable = Object(object),
	        props = keysFunc(object),
	        length = props.length;
	
	    while (length--) {
	      var key = props[fromRight ? length : ++index];
	      if (iteratee(iterable[key], key, iterable) === false) {
	        break;
	      }
	    }
	    return object;
	  };
	}
	
	/**
	 * The base implementation of `baseForOwn` which iterates over `object`
	 * properties returned by `keysFunc` and invokes `iteratee` for each property.
	 * Iteratee functions may exit iteration early by explicitly returning `false`.
	 *
	 * @private
	 * @param {Object} object The object to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @param {Function} keysFunc The function to get the keys of `object`.
	 * @returns {Object} Returns `object`.
	 */
	var baseFor = createBaseFor();
	
	/**
	 * The base implementation of `_.forOwn` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Object} object The object to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Object} Returns `object`.
	 */
	function baseForOwn(object, iteratee) {
	  return object && baseFor(object, iteratee, keys);
	}
	
	/**
	 * The base implementation of `_.findIndex` and `_.findLastIndex` without
	 * support for iteratee shorthands.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {Function} predicate The function invoked per iteration.
	 * @param {number} fromIndex The index to search from.
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function baseFindIndex(array, predicate, fromIndex, fromRight) {
	  var length = array.length,
	      index = fromIndex + (fromRight ? 1 : -1);
	
	  while ((fromRight ? index-- : ++index < length)) {
	    if (predicate(array[index], index, array)) {
	      return index;
	    }
	  }
	  return -1;
	}
	
	/**
	 * The base implementation of `_.isNaN` without support for number objects.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
	 */
	function baseIsNaN(value) {
	  return value !== value;
	}
	
	/**
	 * A specialized version of `_.indexOf` which performs strict equality
	 * comparisons of values, i.e. `===`.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} value The value to search for.
	 * @param {number} fromIndex The index to search from.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function strictIndexOf(array, value, fromIndex) {
	  var index = fromIndex - 1,
	      length = array.length;
	
	  while (++index < length) {
	    if (array[index] === value) {
	      return index;
	    }
	  }
	  return -1;
	}
	
	/**
	 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} value The value to search for.
	 * @param {number} fromIndex The index to search from.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function baseIndexOf(array, value, fromIndex) {
	  return value === value
	    ? strictIndexOf(array, value, fromIndex)
	    : baseFindIndex(array, baseIsNaN, fromIndex);
	}
	
	/**
	 * Determines the best order for running the functions in `tasks`, based on
	 * their requirements. Each function can optionally depend on other functions
	 * being completed first, and each function is run as soon as its requirements
	 * are satisfied.
	 *
	 * If any of the functions pass an error to their callback, the `auto` sequence
	 * will stop. Further tasks will not execute (so any other functions depending
	 * on it will not run), and the main `callback` is immediately called with the
	 * error.
	 *
	 * Functions also receive an object containing the results of functions which
	 * have completed so far as the first argument, if they have dependencies. If a
	 * task function has no dependencies, it will only be passed a callback.
	 *
	 * @name auto
	 * @static
	 * @memberOf module:ControlFlow
	 * @method
	 * @category Control Flow
	 * @param {Object} tasks - An object. Each of its properties is either a
	 * function or an array of requirements, with the function itself the last item
	 * in the array. The object's key of a property serves as the name of the task
	 * defined by that property, i.e. can be used when specifying requirements for
	 * other tasks. The function receives one or two arguments:
	 * * a `results` object, containing the results of the previously executed
	 *   functions, only passed if the task has any dependencies,
	 * * a `callback(err, result)` function, which must be called when finished,
	 *   passing an `error` (which can be `null`) and the result of the function's
	 *   execution.
	 * @param {number} [concurrency=Infinity] - An optional `integer` for
	 * determining the maximum number of tasks that can be run in parallel. By
	 * default, as many as possible.
	 * @param {Function} [callback] - An optional callback which is called when all
	 * the tasks have been completed. It receives the `err` argument if any `tasks`
	 * pass an error to their callback. Results are always returned; however, if an
	 * error occurs, no further `tasks` will be performed, and the results object
	 * will only contain partial results. Invoked with (err, results).
	 * @returns undefined
	 * @example
	 *
	 * async.auto({
	 *     // this function will just be passed a callback
	 *     readData: async.apply(fs.readFile, 'data.txt', 'utf-8'),
	 *     showData: ['readData', function(results, cb) {
	 *         // results.readData is the file's contents
	 *         // ...
	 *     }]
	 * }, callback);
	 *
	 * async.auto({
	 *     get_data: function(callback) {
	 *         console.log('in get_data');
	 *         // async code to get some data
	 *         callback(null, 'data', 'converted to array');
	 *     },
	 *     make_folder: function(callback) {
	 *         console.log('in make_folder');
	 *         // async code to create a directory to store a file in
	 *         // this is run at the same time as getting the data
	 *         callback(null, 'folder');
	 *     },
	 *     write_file: ['get_data', 'make_folder', function(results, callback) {
	 *         console.log('in write_file', JSON.stringify(results));
	 *         // once there is some data and the directory exists,
	 *         // write the data to a file in the directory
	 *         callback(null, 'filename');
	 *     }],
	 *     email_link: ['write_file', function(results, callback) {
	 *         console.log('in email_link', JSON.stringify(results));
	 *         // once the file is written let's email a link to it...
	 *         // results.write_file contains the filename returned by write_file.
	 *         callback(null, {'file':results.write_file, 'email':'user@example.com'});
	 *     }]
	 * }, function(err, results) {
	 *     console.log('err = ', err);
	 *     console.log('results = ', results);
	 * });
	 */
	
	/**
	 * A specialized version of `_.map` for arrays without support for iteratee
	 * shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the new mapped array.
	 */
	
	/**
	 * The base implementation of `_.slice` without an iteratee call guard.
	 *
	 * @private
	 * @param {Array} array The array to slice.
	 * @param {number} [start=0] The start position.
	 * @param {number} [end=array.length] The end position.
	 * @returns {Array} Returns the slice of `array`.
	 */
	
	/**
	 * Converts an ASCII `string` to an array.
	 *
	 * @private
	 * @param {string} string The string to convert.
	 * @returns {Array} Returns the converted array.
	 */
	
	/** Used to compose unicode character classes. */
	
	/** Used to compose unicode character classes. */
	var rsAstralRange$1 = '\\ud800-\\udfff';
	var rsComboMarksRange$1 = '\\u0300-\\u036f';
	var reComboHalfMarksRange$1 = '\\ufe20-\\ufe2f';
	var rsComboSymbolsRange$1 = '\\u20d0-\\u20ff';
	var rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1;
	var rsVarRange$1 = '\\ufe0e\\ufe0f';
	
	/** Used to compose unicode capture groups. */
	var rsAstral = '[' + rsAstralRange$1 + ']';
	var rsCombo = '[' + rsComboRange$1 + ']';
	var rsFitz = '\\ud83c[\\udffb-\\udfff]';
	var rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')';
	var rsNonAstral = '[^' + rsAstralRange$1 + ']';
	var rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}';
	var rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]';
	var rsZWJ$1 = '\\u200d';
	
	/** Used to compose unicode regexes. */
	var reOptMod = rsModifier + '?';
	var rsOptVar = '[' + rsVarRange$1 + ']?';
	var rsOptJoin = '(?:' + rsZWJ$1 + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*';
	var rsSeq = rsOptVar + reOptMod + rsOptJoin;
	var rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';
	
	var hasSetImmediate = typeof setImmediate === 'function' && setImmediate;
	var hasNextTick = typeof process === 'object' && typeof process.nextTick === 'function';
	
	function fallback(fn) {
	    setTimeout(fn, 0);
	}
	
	function wrap(defer) {
	    return rest(function (fn, args) {
	        defer(function () {
	            fn.apply(null, args);
	        });
	    });
	}
	
	var _defer;
	
	if (hasSetImmediate) {
	    _defer = setImmediate;
	} else if (hasNextTick) {
	    _defer = process.nextTick;
	} else {
	    _defer = fallback;
	}
	
	wrap(_defer);
	
	// Simple doubly linked list (https://en.wikipedia.org/wiki/Doubly_linked_list) implementation
	// used for queues. This implementation assumes that the node provided by the user can be modified
	// to adjust the next and last properties. We implement only the minimal functionality
	// for queue support.
	
	/**
	 * The same as [`eachOf`]{@link module:Collections.eachOf} but runs only a single async operation at a time.
	 *
	 * @name eachOfSeries
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @see [async.eachOf]{@link module:Collections.eachOf}
	 * @alias forEachOfSeries
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {Function} iteratee - A function to apply to each item in `coll`. The
	 * `key` is the item's key, or index in the case of an array. The iteratee is
	 * passed a `callback(err)` which must be called once it has completed. If no
	 * error has occurred, the callback should be run without arguments or with an
	 * explicit `null` argument. Invoked with (item, key, callback).
	 * @param {Function} [callback] - A callback which is called when all `iteratee`
	 * functions have finished, or an error occurs. Invoked with (err).
	 */
	var eachOfSeries = doLimit(eachOfLimit, 1);
	
	/**
	 * Reduces `coll` into a single value using an async `iteratee` to return each
	 * successive step. `memo` is the initial state of the reduction. This function
	 * only operates in series.
	 *
	 * For performance reasons, it may make sense to split a call to this function
	 * into a parallel map, and then use the normal `Array.prototype.reduce` on the
	 * results. This function is for situations where each step in the reduction
	 * needs to be async; if you can get the data before reducing it, then it's
	 * probably a good idea to do so.
	 *
	 * @name reduce
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @alias inject
	 * @alias foldl
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {*} memo - The initial state of the reduction.
	 * @param {Function} iteratee - A function applied to each item in the
	 * array to produce the next step in the reduction. The `iteratee` is passed a
	 * `callback(err, reduction)` which accepts an optional error as its first
	 * argument, and the state of the reduction as the second. If an error is
	 * passed to the callback, the reduction is stopped and the main `callback` is
	 * immediately called with the error. Invoked with (memo, item, callback).
	 * @param {Function} [callback] - A callback which is called after all the
	 * `iteratee` functions have finished. Result is the reduced value. Invoked with
	 * (err, result).
	 * @example
	 *
	 * async.reduce([1,2,3], 0, function(memo, item, callback) {
	 *     // pointless async:
	 *     process.nextTick(function() {
	 *         callback(null, memo + item)
	 *     });
	 * }, function(err, result) {
	 *     // result is now equal to the last value of memo, which is 6
	 * });
	 */
	function reduce(coll, memo, iteratee, callback) {
	    callback = once(callback || noop);
	    eachOfSeries(coll, function(x, i, callback) {
	        iteratee(memo, x, function(err, v) {
	            memo = v;
	            callback(err);
	        });
	    }, function(err) {
	        callback(err, memo);
	    });
	}
	
	/**
	 * Version of the compose function that is more natural to read. Each function
	 * consumes the return value of the previous function. It is the equivalent of
	 * [compose]{@link module:ControlFlow.compose} with the arguments reversed.
	 *
	 * Each function is executed with the `this` binding of the composed function.
	 *
	 * @name seq
	 * @static
	 * @memberOf module:ControlFlow
	 * @method
	 * @see [async.compose]{@link module:ControlFlow.compose}
	 * @category Control Flow
	 * @param {...Function} functions - the asynchronous functions to compose
	 * @returns {Function} a function that composes the `functions` in order
	 * @example
	 *
	 * // Requires lodash (or underscore), express3 and dresende's orm2.
	 * // Part of an app, that fetches cats of the logged user.
	 * // This example uses `seq` function to avoid overnesting and error
	 * // handling clutter.
	 * app.get('/cats', function(request, response) {
	 *     var User = request.models.User;
	 *     async.seq(
	 *         _.bind(User.get, User),  // 'User.get' has signature (id, callback(err, data))
	 *         function(user, fn) {
	 *             user.getCats(fn);      // 'getCats' has signature (callback(err, data))
	 *         }
	 *     )(req.session.user_id, function (err, cats) {
	 *         if (err) {
	 *             console.error(err);
	 *             response.json({ status: 'error', message: err.message });
	 *         } else {
	 *             response.json({ status: 'ok', message: 'Cats found', data: cats });
	 *         }
	 *     });
	 * });
	 */
	var seq = rest(function seq(functions) {
	    return rest(function(args) {
	        var that = this;
	
	        var cb = args[args.length - 1];
	        if (typeof cb == 'function') {
	            args.pop();
	        } else {
	            cb = noop;
	        }
	
	        reduce(functions, args, function(newargs, fn, cb) {
	            fn.apply(that, newargs.concat(rest(function(err, nextargs) {
	                cb(err, nextargs);
	            })));
	        },
	        function(err, results) {
	            cb.apply(that, [err].concat(results));
	        });
	    });
	});
	
	/**
	 * Creates a function which is a composition of the passed asynchronous
	 * functions. Each function consumes the return value of the function that
	 * follows. Composing functions `f()`, `g()`, and `h()` would produce the result
	 * of `f(g(h()))`, only this version uses callbacks to obtain the return values.
	 *
	 * Each function is executed with the `this` binding of the composed function.
	 *
	 * @name compose
	 * @static
	 * @memberOf module:ControlFlow
	 * @method
	 * @category Control Flow
	 * @param {...Function} functions - the asynchronous functions to compose
	 * @returns {Function} an asynchronous function that is the composed
	 * asynchronous `functions`
	 * @example
	 *
	 * function add1(n, callback) {
	 *     setTimeout(function () {
	 *         callback(null, n + 1);
	 *     }, 10);
	 * }
	 *
	 * function mul3(n, callback) {
	 *     setTimeout(function () {
	 *         callback(null, n * 3);
	 *     }, 10);
	 * }
	 *
	 * var add1mul3 = async.compose(mul3, add1);
	 * add1mul3(4, function (err, result) {
	 *     // result now equals 15
	 * });
	 */
	rest(function(args) {
	    return seq.apply(null, args.reverse());
	});
	
	/**
	 * Applies `iteratee` to each item in `coll`, concatenating the results. Returns
	 * the concatenated list. The `iteratee`s are called in parallel, and the
	 * results are concatenated as they return. There is no guarantee that the
	 * results array will be returned in the original order of `coll` passed to the
	 * `iteratee` function.
	 *
	 * @name concat
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {Function} iteratee - A function to apply to each item in `coll`.
	 * The iteratee is passed a `callback(err, results)` which must be called once
	 * it has completed with an error (which can be `null`) and an array of results.
	 * Invoked with (item, callback).
	 * @param {Function} [callback(err)] - A callback which is called after all the
	 * `iteratee` functions have finished, or an error occurs. Results is an array
	 * containing the concatenated results of the `iteratee` function. Invoked with
	 * (err, results).
	 * @example
	 *
	 * async.concat(['dir1','dir2','dir3'], fs.readdir, function(err, files) {
	 *     // files is now a list of filenames that exist in the 3 directories
	 * });
	 */
	
	/**
	 * The same as [`concat`]{@link module:Collections.concat} but runs only a single async operation at a time.
	 *
	 * @name concatSeries
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @see [async.concat]{@link module:Collections.concat}
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {Function} iteratee - A function to apply to each item in `coll`.
	 * The iteratee is passed a `callback(err, results)` which must be called once
	 * it has completed with an error (which can be `null`) and an array of results.
	 * Invoked with (item, callback).
	 * @param {Function} [callback(err)] - A callback which is called after all the
	 * `iteratee` functions have finished, or an error occurs. Results is an array
	 * containing the concatenated results of the `iteratee` function. Invoked with
	 * (err, results).
	 */
	
	/**
	 * Returns a function that when called, calls-back with the values provided.
	 * Useful as the first function in a [`waterfall`]{@link module:ControlFlow.waterfall}, or for plugging values in to
	 * [`auto`]{@link module:ControlFlow.auto}.
	 *
	 * @name constant
	 * @static
	 * @memberOf module:Utils
	 * @method
	 * @category Util
	 * @param {...*} arguments... - Any number of arguments to automatically invoke
	 * callback with.
	 * @returns {Function} Returns a function that when invoked, automatically
	 * invokes the callback with the previous given arguments.
	 * @example
	 *
	 * async.waterfall([
	 *     async.constant(42),
	 *     function (value, next) {
	 *         // value === 42
	 *     },
	 *     //...
	 * ], callback);
	 *
	 * async.waterfall([
	 *     async.constant(filename, "utf8"),
	 *     fs.readFile,
	 *     function (fileData, next) {
	 *         //...
	 *     }
	 *     //...
	 * ], callback);
	 *
	 * async.auto({
	 *     hostname: async.constant("https://server.net/"),
	 *     port: findFreePort,
	 *     launchServer: ["hostname", "port", function (options, cb) {
	 *         startServer(options, cb);
	 *     }],
	 *     //...
	 * }, callback);
	 */
	rest(function(values) {
	    var args = [null].concat(values);
	    return initialParams(function (ignoredArgs, callback) {
	        return callback.apply(this, args);
	    });
	});
	
	/**
	 * Returns the first value in `coll` that passes an async truth test. The
	 * `iteratee` is applied in parallel, meaning the first iteratee to return
	 * `true` will fire the detect `callback` with that result. That means the
	 * result might not be the first item in the original `coll` (in terms of order)
	 * that passes the test.
	
	 * If order within the original `coll` is important, then look at
	 * [`detectSeries`]{@link module:Collections.detectSeries}.
	 *
	 * @name detect
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @alias find
	 * @category Collections
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {Function} iteratee - A truth test to apply to each item in `coll`.
	 * The iteratee is passed a `callback(err, truthValue)` which must be called
	 * with a boolean argument once it has completed. Invoked with (item, callback).
	 * @param {Function} [callback] - A callback which is called as soon as any
	 * iteratee returns `true`, or after all the `iteratee` functions have finished.
	 * Result will be the first item in the array that passes the truth test
	 * (iteratee) or the value `undefined` if none passed. Invoked with
	 * (err, result).
	 * @example
	 *
	 * async.detect(['file1','file2','file3'], function(filePath, callback) {
	 *     fs.access(filePath, function(err) {
	 *         callback(null, !err)
	 *     });
	 * }, function(err, result) {
	 *     // result now equals the first file in the list that exists
	 * });
	 */
	
	/**
	 * The same as [`detect`]{@link module:Collections.detect} but runs a maximum of `limit` async operations at a
	 * time.
	 *
	 * @name detectLimit
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @see [async.detect]{@link module:Collections.detect}
	 * @alias findLimit
	 * @category Collections
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {number} limit - The maximum number of async operations at a time.
	 * @param {Function} iteratee - A truth test to apply to each item in `coll`.
	 * The iteratee is passed a `callback(err, truthValue)` which must be called
	 * with a boolean argument once it has completed. Invoked with (item, callback).
	 * @param {Function} [callback] - A callback which is called as soon as any
	 * iteratee returns `true`, or after all the `iteratee` functions have finished.
	 * Result will be the first item in the array that passes the truth test
	 * (iteratee) or the value `undefined` if none passed. Invoked with
	 * (err, result).
	 */
	
	/**
	 * The same as [`detect`]{@link module:Collections.detect} but runs only a single async operation at a time.
	 *
	 * @name detectSeries
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @see [async.detect]{@link module:Collections.detect}
	 * @alias findSeries
	 * @category Collections
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {Function} iteratee - A truth test to apply to each item in `coll`.
	 * The iteratee is passed a `callback(err, truthValue)` which must be called
	 * with a boolean argument once it has completed. Invoked with (item, callback).
	 * @param {Function} [callback] - A callback which is called as soon as any
	 * iteratee returns `true`, or after all the `iteratee` functions have finished.
	 * Result will be the first item in the array that passes the truth test
	 * (iteratee) or the value `undefined` if none passed. Invoked with
	 * (err, result).
	 */
	
	function consoleFunc(name) {
	    return rest(function (fn, args) {
	        fn.apply(null, args.concat(rest(function (err, args) {
	            if (typeof console === 'object') {
	                if (err) {
	                    if (console.error) {
	                        console.error(err);
	                    }
	                }
	                else if (console[name]) {
	                    arrayEach(args, function (x) {
	                        console[name](x);
	                    });
	                }
	            }
	        })));
	    });
	}
	
	/**
	 * Logs the result of an `async` function to the `console` using `console.dir`
	 * to display the properties of the resulting object. Only works in Node.js or
	 * in browsers that support `console.dir` and `console.error` (such as FF and
	 * Chrome). If multiple arguments are returned from the async function,
	 * `console.dir` is called on each argument in order.
	 *
	 * @name dir
	 * @static
	 * @memberOf module:Utils
	 * @method
	 * @category Util
	 * @param {Function} function - The function you want to eventually apply all
	 * arguments to.
	 * @param {...*} arguments... - Any number of arguments to apply to the function.
	 * @example
	 *
	 * // in a module
	 * var hello = function(name, callback) {
	 *     setTimeout(function() {
	 *         callback(null, {hello: name});
	 *     }, 1000);
	 * };
	 *
	 * // in the node repl
	 * node> async.dir(hello, 'world');
	 * {hello: 'world'}
	 */
	consoleFunc('dir');
	
	function _withoutIndex(iteratee) {
	    return function (value, index, callback) {
	        return iteratee(value, callback);
	    };
	}
	
	/**
	 * Applies the function `iteratee` to each item in `coll`, in parallel.
	 * The `iteratee` is called with an item from the list, and a callback for when
	 * it has finished. If the `iteratee` passes an error to its `callback`, the
	 * main `callback` (for the `each` function) is immediately called with the
	 * error.
	 *
	 * Note, that since this function applies `iteratee` to each item in parallel,
	 * there is no guarantee that the iteratee functions will complete in order.
	 *
	 * @name each
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @alias forEach
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {Function} iteratee - A function to apply to each item
	 * in `coll`. The iteratee is passed a `callback(err)` which must be called once
	 * it has completed. If no error has occurred, the `callback` should be run
	 * without arguments or with an explicit `null` argument. The array index is not
	 * passed to the iteratee. Invoked with (item, callback). If you need the index,
	 * use `eachOf`.
	 * @param {Function} [callback] - A callback which is called when all
	 * `iteratee` functions have finished, or an error occurs. Invoked with (err).
	 * @example
	 *
	 * // assuming openFiles is an array of file names and saveFile is a function
	 * // to save the modified contents of that file:
	 *
	 * async.each(openFiles, saveFile, function(err){
	 *   // if any of the saves produced an error, err would equal that error
	 * });
	 *
	 * // assuming openFiles is an array of file names
	 * async.each(openFiles, function(file, callback) {
	 *
	 *     // Perform operation on file here.
	 *     console.log('Processing file ' + file);
	 *
	 *     if( file.length > 32 ) {
	 *       console.log('This file name is too long');
	 *       callback('File name too long');
	 *     } else {
	 *       // Do work to process file here
	 *       console.log('File processed');
	 *       callback();
	 *     }
	 * }, function(err) {
	 *     // if any of the file processing produced an error, err would equal that error
	 *     if( err ) {
	 *       // One of the iterations produced an error.
	 *       // All processing will now stop.
	 *       console.log('A file failed to process');
	 *     } else {
	 *       console.log('All files have been processed successfully');
	 *     }
	 * });
	 */
	function eachLimit(coll, iteratee, callback) {
	    eachOf(coll, _withoutIndex(iteratee), callback);
	}
	
	/**
	 * The same as [`each`]{@link module:Collections.each} but runs only a single async operation at a time.
	 *
	 * @name eachSeries
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @see [async.each]{@link module:Collections.each}
	 * @alias forEachSeries
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {Function} iteratee - A function to apply to each
	 * item in `coll`. The iteratee is passed a `callback(err)` which must be called
	 * once it has completed. If no error has occurred, the `callback` should be run
	 * without arguments or with an explicit `null` argument. The array index is
	 * not passed to the iteratee. Invoked with (item, callback). If you need the
	 * index, use `eachOfSeries`.
	 * @param {Function} [callback] - A callback which is called when all
	 * `iteratee` functions have finished, or an error occurs. Invoked with (err).
	 */
	
	/**
	 * Returns `true` if every element in `coll` satisfies an async test. If any
	 * iteratee call returns `false`, the main `callback` is immediately called.
	 *
	 * @name every
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @alias all
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {Function} iteratee - A truth test to apply to each item in the
	 * collection in parallel. The iteratee is passed a `callback(err, truthValue)`
	 * which must be called with a  boolean argument once it has completed. Invoked
	 * with (item, callback).
	 * @param {Function} [callback] - A callback which is called after all the
	 * `iteratee` functions have finished. Result will be either `true` or `false`
	 * depending on the values of the async tests. Invoked with (err, result).
	 * @example
	 *
	 * async.every(['file1','file2','file3'], function(filePath, callback) {
	 *     fs.access(filePath, function(err) {
	 *         callback(null, !err)
	 *     });
	 * }, function(err, result) {
	 *     // if result is true then every file exists
	 * });
	 */
	
	/**
	 * The same as [`every`]{@link module:Collections.every} but runs a maximum of `limit` async operations at a time.
	 *
	 * @name everyLimit
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @see [async.every]{@link module:Collections.every}
	 * @alias allLimit
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {number} limit - The maximum number of async operations at a time.
	 * @param {Function} iteratee - A truth test to apply to each item in the
	 * collection in parallel. The iteratee is passed a `callback(err, truthValue)`
	 * which must be called with a  boolean argument once it has completed. Invoked
	 * with (item, callback).
	 * @param {Function} [callback] - A callback which is called after all the
	 * `iteratee` functions have finished. Result will be either `true` or `false`
	 * depending on the values of the async tests. Invoked with (err, result).
	 */
	
	/**
	 * The same as [`every`]{@link module:Collections.every} but runs only a single async operation at a time.
	 *
	 * @name everySeries
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @see [async.every]{@link module:Collections.every}
	 * @alias allSeries
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {Function} iteratee - A truth test to apply to each item in the
	 * collection in parallel. The iteratee is passed a `callback(err, truthValue)`
	 * which must be called with a  boolean argument once it has completed. Invoked
	 * with (item, callback).
	 * @param {Function} [callback] - A callback which is called after all the
	 * `iteratee` functions have finished. Result will be either `true` or `false`
	 * depending on the values of the async tests. Invoked with (err, result).
	 */
	
	/**
	 * The base implementation of `_.property` without support for deep paths.
	 *
	 * @private
	 * @param {string} key The key of the property to get.
	 * @returns {Function} Returns the new accessor function.
	 */
	
	/**
	 * Returns a new array of all the values in `coll` which pass an async truth
	 * test. This operation is performed in parallel, but the results array will be
	 * in the same order as the original.
	 *
	 * @name filter
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @alias select
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {Function} iteratee - A truth test to apply to each item in `coll`.
	 * The `iteratee` is passed a `callback(err, truthValue)`, which must be called
	 * with a boolean argument once it has completed. Invoked with (item, callback).
	 * @param {Function} [callback] - A callback which is called after all the
	 * `iteratee` functions have finished. Invoked with (err, results).
	 * @example
	 *
	 * async.filter(['file1','file2','file3'], function(filePath, callback) {
	 *     fs.access(filePath, function(err) {
	 *         callback(null, !err)
	 *     });
	 * }, function(err, results) {
	 *     // results now equals an array of the existing files
	 * });
	 */
	
	/**
	 * The same as [`filter`]{@link module:Collections.filter} but runs a maximum of `limit` async operations at a
	 * time.
	 *
	 * @name filterLimit
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @see [async.filter]{@link module:Collections.filter}
	 * @alias selectLimit
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {number} limit - The maximum number of async operations at a time.
	 * @param {Function} iteratee - A truth test to apply to each item in `coll`.
	 * The `iteratee` is passed a `callback(err, truthValue)`, which must be called
	 * with a boolean argument once it has completed. Invoked with (item, callback).
	 * @param {Function} [callback] - A callback which is called after all the
	 * `iteratee` functions have finished. Invoked with (err, results).
	 */
	
	/**
	 * The same as [`filter`]{@link module:Collections.filter} but runs only a single async operation at a time.
	 *
	 * @name filterSeries
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @see [async.filter]{@link module:Collections.filter}
	 * @alias selectSeries
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {Function} iteratee - A truth test to apply to each item in `coll`.
	 * The `iteratee` is passed a `callback(err, truthValue)`, which must be called
	 * with a boolean argument once it has completed. Invoked with (item, callback).
	 * @param {Function} [callback] - A callback which is called after all the
	 * `iteratee` functions have finished. Invoked with (err, results)
	 */
	
	/**
	 * Logs the result of an `async` function to the `console`. Only works in
	 * Node.js or in browsers that support `console.log` and `console.error` (such
	 * as FF and Chrome). If multiple arguments are returned from the async
	 * function, `console.log` is called on each argument in order.
	 *
	 * @name log
	 * @static
	 * @memberOf module:Utils
	 * @method
	 * @category Util
	 * @param {Function} function - The function you want to eventually apply all
	 * arguments to.
	 * @param {...*} arguments... - Any number of arguments to apply to the function.
	 * @example
	 *
	 * // in a module
	 * var hello = function(name, callback) {
	 *     setTimeout(function() {
	 *         callback(null, 'hello ' + name);
	 *     }, 1000);
	 * };
	 *
	 * // in the node repl
	 * node> async.log(hello, 'world');
	 * 'hello world'
	 */
	consoleFunc('log');
	
	/**
	 * A relative of [`map`]{@link module:Collections.map}, designed for use with objects.
	 *
	 * Produces a new Object by mapping each value of `obj` through the `iteratee`
	 * function. The `iteratee` is called each `value` and `key` from `obj` and a
	 * callback for when it has finished processing. Each of these callbacks takes
	 * two arguments: an `error`, and the transformed item from `obj`. If `iteratee`
	 * passes an error to its callback, the main `callback` (for the `mapValues`
	 * function) is immediately called with the error.
	 *
	 * Note, the order of the keys in the result is not guaranteed.  The keys will
	 * be roughly in the order they complete, (but this is very engine-specific)
	 *
	 * @name mapValues
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @category Collection
	 * @param {Object} obj - A collection to iterate over.
	 * @param {Function} iteratee - A function to apply to each value and key in
	 * `coll`. The iteratee is passed a `callback(err, transformed)` which must be
	 * called once it has completed with an error (which can be `null`) and a
	 * transformed value. Invoked with (value, key, callback).
	 * @param {Function} [callback] - A callback which is called when all `iteratee`
	 * functions have finished, or an error occurs. `result` is a new object consisting
	 * of each key from `obj`, with each transformed value on the right-hand side.
	 * Invoked with (err, result).
	 * @example
	 *
	 * async.mapValues({
	 *     f1: 'file1',
	 *     f2: 'file2',
	 *     f3: 'file3'
	 * }, function (file, key, callback) {
	 *   fs.stat(file, callback);
	 * }, function(err, result) {
	 *     // result is now a map of stats for each file, e.g.
	 *     // {
	 *     //     f1: [stats for file1],
	 *     //     f2: [stats for file2],
	 *     //     f3: [stats for file3]
	 *     // }
	 * });
	 */
	
	/**
	 * The same as [`mapValues`]{@link module:Collections.mapValues} but runs only a single async operation at a time.
	 *
	 * @name mapValuesSeries
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @see [async.mapValues]{@link module:Collections.mapValues}
	 * @category Collection
	 * @param {Object} obj - A collection to iterate over.
	 * @param {Function} iteratee - A function to apply to each value in `obj`.
	 * The iteratee is passed a `callback(err, transformed)` which must be called
	 * once it has completed with an error (which can be `null`) and a
	 * transformed value. Invoked with (value, key, callback).
	 * @param {Function} [callback] - A callback which is called when all `iteratee`
	 * functions have finished, or an error occurs. `result` is a new object consisting
	 * of each key from `obj`, with each transformed value on the right-hand side.
	 * Invoked with (err, result).
	 */
	
	/**
	 * Calls `callback` on a later loop around the event loop. In Node.js this just
	 * calls `setImmediate`.  In the browser it will use `setImmediate` if
	 * available, otherwise `setTimeout(callback, 0)`, which means other higher
	 * priority events may precede the execution of `callback`.
	 *
	 * This is used internally for browser-compatibility purposes.
	 *
	 * @name nextTick
	 * @static
	 * @memberOf module:Utils
	 * @method
	 * @alias setImmediate
	 * @category Util
	 * @param {Function} callback - The function to call on a later loop around
	 * the event loop. Invoked with (args...).
	 * @param {...*} args... - any number of additional arguments to pass to the
	 * callback on the next tick.
	 * @example
	 *
	 * var call_order = [];
	 * async.nextTick(function() {
	 *     call_order.push('two');
	 *     // call_order now equals ['one','two']
	 * });
	 * call_order.push('one');
	 *
	 * async.setImmediate(function (a, b, c) {
	 *     // a, b, and c equal 1, 2, and 3
	 * }, 1, 2, 3);
	 */
	var _defer$1;
	
	if (hasNextTick) {
	    _defer$1 = process.nextTick;
	} else if (hasSetImmediate) {
	    _defer$1 = setImmediate;
	} else {
	    _defer$1 = fallback;
	}
	
	wrap(_defer$1);
	
	/**
	 * Calls `callback` on a later loop around the event loop. In Node.js this just
	 * calls `setImmediate`.  In the browser it will use `setImmediate` if
	 * available, otherwise `setTimeout(callback, 0)`, which means other higher
	 * priority events may precede the execution of `callback`.
	 *
	 * This is used internally for browser-compatibility purposes.
	 *
	 * @name setImmediate
	 * @static
	 * @memberOf module:Utils
	 * @method
	 * @alias nextTick
	 * @category Util
	 * @param {Function} callback - The function to call on a later loop around
	 * the event loop. Invoked with (args...).
	 * @param {...*} args... - any number of additional arguments to pass to the
	 * callback on the next tick.
	 * @example
	 *
	 * var call_order = [];
	 * async.nextTick(function() {
	 *     call_order.push('two');
	 *     // call_order now equals ['one','two']
	 * });
	 * call_order.push('one');
	 *
	 * async.setImmediate(function (a, b, c) {
	 *     // a, b, and c equal 1, 2, and 3
	 * }, 1, 2, 3);
	 */
	
	/**
	 * A queue of tasks for the worker function to complete.
	 * @typedef {Object} QueueObject
	 * @memberOf module:ControlFlow
	 * @property {Function} length - a function returning the number of items
	 * waiting to be processed. Invoke with `queue.length()`.
	 * @property {boolean} started - a boolean indicating whether or not any
	 * items have been pushed and processed by the queue.
	 * @property {Function} running - a function returning the number of items
	 * currently being processed. Invoke with `queue.running()`.
	 * @property {Function} workersList - a function returning the array of items
	 * currently being processed. Invoke with `queue.workersList()`.
	 * @property {Function} idle - a function returning false if there are items
	 * waiting or being processed, or true if not. Invoke with `queue.idle()`.
	 * @property {number} concurrency - an integer for determining how many `worker`
	 * functions should be run in parallel. This property can be changed after a
	 * `queue` is created to alter the concurrency on-the-fly.
	 * @property {Function} push - add a new task to the `queue`. Calls `callback`
	 * once the `worker` has finished processing the task. Instead of a single task,
	 * a `tasks` array can be submitted. The respective callback is used for every
	 * task in the list. Invoke with `queue.push(task, [callback])`,
	 * @property {Function} unshift - add a new task to the front of the `queue`.
	 * Invoke with `queue.unshift(task, [callback])`.
	 * @property {Function} saturated - a callback that is called when the number of
	 * running workers hits the `concurrency` limit, and further tasks will be
	 * queued.
	 * @property {Function} unsaturated - a callback that is called when the number
	 * of running workers is less than the `concurrency` & `buffer` limits, and
	 * further tasks will not be queued.
	 * @property {number} buffer - A minimum threshold buffer in order to say that
	 * the `queue` is `unsaturated`.
	 * @property {Function} empty - a callback that is called when the last item
	 * from the `queue` is given to a `worker`.
	 * @property {Function} drain - a callback that is called when the last item
	 * from the `queue` has returned from the `worker`.
	 * @property {Function} error - a callback that is called when a task errors.
	 * Has the signature `function(error, task)`.
	 * @property {boolean} paused - a boolean for determining whether the queue is
	 * in a paused state.
	 * @property {Function} pause - a function that pauses the processing of tasks
	 * until `resume()` is called. Invoke with `queue.pause()`.
	 * @property {Function} resume - a function that resumes the processing of
	 * queued tasks when the queue is paused. Invoke with `queue.resume()`.
	 * @property {Function} kill - a function that removes the `drain` callback and
	 * empties remaining tasks from the queue forcing it to go idle. Invoke with `queue.kill()`.
	 */
	
	/**
	 * Creates a `queue` object with the specified `concurrency`. Tasks added to the
	 * `queue` are processed in parallel (up to the `concurrency` limit). If all
	 * `worker`s are in progress, the task is queued until one becomes available.
	 * Once a `worker` completes a `task`, that `task`'s callback is called.
	 *
	 * @name queue
	 * @static
	 * @memberOf module:ControlFlow
	 * @method
	 * @category Control Flow
	 * @param {Function} worker - An asynchronous function for processing a queued
	 * task, which must call its `callback(err)` argument when finished, with an
	 * optional `error` as an argument.  If you want to handle errors from an
	 * individual task, pass a callback to `q.push()`. Invoked with
	 * (task, callback).
	 * @param {number} [concurrency=1] - An `integer` for determining how many
	 * `worker` functions should be run in parallel.  If omitted, the concurrency
	 * defaults to `1`.  If the concurrency is `0`, an error is thrown.
	 * @returns {module:ControlFlow.QueueObject} A queue object to manage the tasks. Callbacks can
	 * attached as certain properties to listen for specific events during the
	 * lifecycle of the queue.
	 * @example
	 *
	 * // create a queue object with concurrency 2
	 * var q = async.queue(function(task, callback) {
	 *     console.log('hello ' + task.name);
	 *     callback();
	 * }, 2);
	 *
	 * // assign a callback
	 * q.drain = function() {
	 *     console.log('all items have been processed');
	 * };
	 *
	 * // add some items to the queue
	 * q.push({name: 'foo'}, function(err) {
	 *     console.log('finished processing foo');
	 * });
	 * q.push({name: 'bar'}, function (err) {
	 *     console.log('finished processing bar');
	 * });
	 *
	 * // add some items to the queue (batch-wise)
	 * q.push([{name: 'baz'},{name: 'bay'},{name: 'bax'}], function(err) {
	 *     console.log('finished processing item');
	 * });
	 *
	 * // add some items to the front of the queue
	 * q.unshift({name: 'bar'}, function (err) {
	 *     console.log('finished processing bar');
	 * });
	 */
	
	/**
	 * The same as [async.queue]{@link module:ControlFlow.queue} only tasks are assigned a priority and
	 * completed in ascending priority order.
	 *
	 * @name priorityQueue
	 * @static
	 * @memberOf module:ControlFlow
	 * @method
	 * @see [async.queue]{@link module:ControlFlow.queue}
	 * @category Control Flow
	 * @param {Function} worker - An asynchronous function for processing a queued
	 * task, which must call its `callback(err)` argument when finished, with an
	 * optional `error` as an argument.  If you want to handle errors from an
	 * individual task, pass a callback to `q.push()`. Invoked with
	 * (task, callback).
	 * @param {number} concurrency - An `integer` for determining how many `worker`
	 * functions should be run in parallel.  If omitted, the concurrency defaults to
	 * `1`.  If the concurrency is `0`, an error is thrown.
	 * @returns {module:ControlFlow.QueueObject} A priorityQueue object to manage the tasks. There are two
	 * differences between `queue` and `priorityQueue` objects:
	 * * `push(task, priority, [callback])` - `priority` should be a number. If an
	 *   array of `tasks` is given, all tasks will be assigned the same priority.
	 * * The `unshift` method was removed.
	 */
	
	/**
	 * The opposite of [`filter`]{@link module:Collections.filter}. Removes values that pass an `async` truth test.
	 *
	 * @name reject
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @see [async.filter]{@link module:Collections.filter}
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {Function} iteratee - A truth test to apply to each item in `coll`.
	 * The `iteratee` is passed a `callback(err, truthValue)`, which must be called
	 * with a boolean argument once it has completed. Invoked with (item, callback).
	 * @param {Function} [callback] - A callback which is called after all the
	 * `iteratee` functions have finished. Invoked with (err, results).
	 * @example
	 *
	 * async.reject(['file1','file2','file3'], function(filePath, callback) {
	 *     fs.access(filePath, function(err) {
	 *         callback(null, !err)
	 *     });
	 * }, function(err, results) {
	 *     // results now equals an array of missing files
	 *     createFiles(results);
	 * });
	 */
	
	/**
	 * The same as [`reject`]{@link module:Collections.reject} but runs a maximum of `limit` async operations at a
	 * time.
	 *
	 * @name rejectLimit
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @see [async.reject]{@link module:Collections.reject}
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {number} limit - The maximum number of async operations at a time.
	 * @param {Function} iteratee - A truth test to apply to each item in `coll`.
	 * The `iteratee` is passed a `callback(err, truthValue)`, which must be called
	 * with a boolean argument once it has completed. Invoked with (item, callback).
	 * @param {Function} [callback] - A callback which is called after all the
	 * `iteratee` functions have finished. Invoked with (err, results).
	 */
	
	/**
	 * The same as [`reject`]{@link module:Collections.reject} but runs only a single async operation at a time.
	 *
	 * @name rejectSeries
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @see [async.reject]{@link module:Collections.reject}
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {Function} iteratee - A truth test to apply to each item in `coll`.
	 * The `iteratee` is passed a `callback(err, truthValue)`, which must be called
	 * with a boolean argument once it has completed. Invoked with (item, callback).
	 * @param {Function} [callback] - A callback which is called after all the
	 * `iteratee` functions have finished. Invoked with (err, results).
	 */
	
	/**
	 * Creates a function that returns `value`.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.4.0
	 * @category Util
	 * @param {*} value The value to return from the new function.
	 * @returns {Function} Returns the new constant function.
	 * @example
	 *
	 * var objects = _.times(2, _.constant({ 'a': 1 }));
	 *
	 * console.log(objects);
	 * // => [{ 'a': 1 }, { 'a': 1 }]
	 *
	 * console.log(objects[0] === objects[1]);
	 * // => true
	 */
	
	/**
	 * A close relative of [`retry`]{@link module:ControlFlow.retry}.  This method wraps a task and makes it
	 * retryable, rather than immediately calling it with retries.
	 *
	 * @name retryable
	 * @static
	 * @memberOf module:ControlFlow
	 * @method
	 * @see [async.retry]{@link module:ControlFlow.retry}
	 * @category Control Flow
	 * @param {Object|number} [opts = {times: 5, interval: 0}| 5] - optional
	 * options, exactly the same as from `retry`
	 * @param {Function} task - the asynchronous function to wrap
	 * @returns {Functions} The wrapped function, which when invoked, will retry on
	 * an error, based on the parameters specified in `opts`.
	 * @example
	 *
	 * async.auto({
	 *     dep1: async.retryable(3, getFromFlakyService),
	 *     process: ["dep1", async.retryable(3, function (results, cb) {
	 *         maybeProcessData(results.dep1, cb);
	 *     })]
	 * }, callback);
	 */
	
	/**
	 * Returns `true` if at least one element in the `coll` satisfies an async test.
	 * If any iteratee call returns `true`, the main `callback` is immediately
	 * called.
	 *
	 * @name some
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @alias any
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {Function} iteratee - A truth test to apply to each item in the array
	 * in parallel. The iteratee is passed a `callback(err, truthValue)` which must
	 * be called with a boolean argument once it has completed. Invoked with
	 * (item, callback).
	 * @param {Function} [callback] - A callback which is called as soon as any
	 * iteratee returns `true`, or after all the iteratee functions have finished.
	 * Result will be either `true` or `false` depending on the values of the async
	 * tests. Invoked with (err, result).
	 * @example
	 *
	 * async.some(['file1','file2','file3'], function(filePath, callback) {
	 *     fs.access(filePath, function(err) {
	 *         callback(null, !err)
	 *     });
	 * }, function(err, result) {
	 *     // if result is true then at least one of the files exists
	 * });
	 */
	
	/**
	 * The same as [`some`]{@link module:Collections.some} but runs a maximum of `limit` async operations at a time.
	 *
	 * @name someLimit
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @see [async.some]{@link module:Collections.some}
	 * @alias anyLimit
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {number} limit - The maximum number of async operations at a time.
	 * @param {Function} iteratee - A truth test to apply to each item in the array
	 * in parallel. The iteratee is passed a `callback(err, truthValue)` which must
	 * be called with a boolean argument once it has completed. Invoked with
	 * (item, callback).
	 * @param {Function} [callback] - A callback which is called as soon as any
	 * iteratee returns `true`, or after all the iteratee functions have finished.
	 * Result will be either `true` or `false` depending on the values of the async
	 * tests. Invoked with (err, result).
	 */
	
	/**
	 * The same as [`some`]{@link module:Collections.some} but runs only a single async operation at a time.
	 *
	 * @name someSeries
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @see [async.some]{@link module:Collections.some}
	 * @alias anySeries
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {Function} iteratee - A truth test to apply to each item in the array
	 * in parallel. The iteratee is passed a `callback(err, truthValue)` which must
	 * be called with a boolean argument once it has completed. Invoked with
	 * (item, callback).
	 * @param {Function} [callback] - A callback which is called as soon as any
	 * iteratee returns `true`, or after all the iteratee functions have finished.
	 * Result will be either `true` or `false` depending on the values of the async
	 * tests. Invoked with (err, result).
	 */
	
	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeCeil = Math.ceil;
	var nativeMax$1 = Math.max;
	
	/**
	 * Calls the `iteratee` function `n` times, and accumulates results in the same
	 * manner you would use with [map]{@link module:Collections.map}.
	 *
	 * @name times
	 * @static
	 * @memberOf module:ControlFlow
	 * @method
	 * @see [async.map]{@link module:Collections.map}
	 * @category Control Flow
	 * @param {number} n - The number of times to run the function.
	 * @param {Function} iteratee - The function to call `n` times. Invoked with the
	 * iteration index and a callback (n, next).
	 * @param {Function} callback - see {@link module:Collections.map}.
	 * @example
	 *
	 * // Pretend this is some complicated async factory
	 * var createUser = function(id, callback) {
	 *     callback(null, {
	 *         id: 'user' + id
	 *     });
	 * };
	 *
	 * // generate 5 users
	 * async.times(5, function(n, next) {
	 *     createUser(n, function(err, user) {
	 *         next(err, user);
	 *     });
	 * }, function(err, users) {
	 *     // we should now have 5 users
	 * });
	 */
	
	/**
	 * The same as [times]{@link module:ControlFlow.times} but runs only a single async operation at a time.
	 *
	 * @name timesSeries
	 * @static
	 * @memberOf module:ControlFlow
	 * @method
	 * @see [async.times]{@link module:ControlFlow.times}
	 * @category Control Flow
	 * @param {number} n - The number of times to run the function.
	 * @param {Function} iteratee - The function to call `n` times. Invoked with the
	 * iteration index and a callback (n, next).
	 * @param {Function} callback - see {@link module:Collections.map}.
	 */
	
	/**
	 * Undoes a [memoize]{@link module:Utils.memoize}d function, reverting it to the original,
	 * unmemoized form. Handy for testing.
	 *
	 * @name unmemoize
	 * @static
	 * @memberOf module:Utils
	 * @method
	 * @see [async.memoize]{@link module:Utils.memoize}
	 * @category Util
	 * @param {Function} fn - the memoized function
	 * @returns {Function} a function that calls the original unmemoized function
	 */
	
	/**
	 * Runs the `tasks` array of functions in series, each passing their results to
	 * the next in the array. However, if any of the `tasks` pass an error to their
	 * own callback, the next function is not executed, and the main `callback` is
	 * immediately called with the error.
	 *
	 * @name waterfall
	 * @static
	 * @memberOf module:ControlFlow
	 * @method
	 * @category Control Flow
	 * @param {Array} tasks - An array of functions to run, each function is passed
	 * a `callback(err, result1, result2, ...)` it must call on completion. The
	 * first argument is an error (which can be `null`) and any further arguments
	 * will be passed as arguments in order to the next task.
	 * @param {Function} [callback] - An optional callback to run once all the
	 * functions have completed. This will be passed the results of the last task's
	 * callback. Invoked with (err, [results]).
	 * @returns undefined
	 * @example
	 *
	 * async.waterfall([
	 *     function(callback) {
	 *         callback(null, 'one', 'two');
	 *     },
	 *     function(arg1, arg2, callback) {
	 *         // arg1 now equals 'one' and arg2 now equals 'two'
	 *         callback(null, 'three');
	 *     },
	 *     function(arg1, callback) {
	 *         // arg1 now equals 'three'
	 *         callback(null, 'done');
	 *     }
	 * ], function (err, result) {
	 *     // result now equals 'done'
	 * });
	 *
	 * // Or, with named functions:
	 * async.waterfall([
	 *     myFirstFunction,
	 *     mySecondFunction,
	 *     myLastFunction,
	 * ], function (err, result) {
	 *     // result now equals 'done'
	 * });
	 * function myFirstFunction(callback) {
	 *     callback(null, 'one', 'two');
	 * }
	 * function mySecondFunction(arg1, arg2, callback) {
	 *     // arg1 now equals 'one' and arg2 now equals 'two'
	 *     callback(null, 'three');
	 * }
	 * function myLastFunction(arg1, callback) {
	 *     // arg1 now equals 'three'
	 *     callback(null, 'done');
	 * }
	 */
	
	/**
	 * Async is a utility module which provides straight-forward, powerful functions
	 * for working with asynchronous JavaScript. Although originally designed for
	 * use with [Node.js](http://nodejs.org) and installable via
	 * `npm install --save async`, it can also be used directly in the browser.
	 * @module async
	 */
	
	/**
	 * A collection of `async` functions for manipulating collections, such as
	 * arrays and objects.
	 * @module Collections
	 */
	
	/**
	 * A collection of `async` functions for controlling the flow through a script.
	 * @module ControlFlow
	 */
	
	 /**
	  * A collection of `async` utility functions.
	  * @module Utils
	  */
	
	/**
	 * @hidden
	 */
	var errorCodeLookup;
	/**
	 * Lazily construct error code lookup, since DropboxJS might be loaded *after* BrowserFS (or not at all!)
	 * @hidden
	 */
	function constructErrorCodeLookup() {
	    if (errorCodeLookup) {
	        return;
	    }
	    errorCodeLookup = {};
	    // This indicates a network transmission error on modern browsers. Internet Explorer might cause this code to be reported on some API server errors.
	    errorCodeLookup[Dropbox.ApiError.NETWORK_ERROR] = ErrorCode.EIO;
	    // This happens when the contentHash parameter passed to a Dropbox.Client#readdir or Dropbox.Client#stat matches the most recent content, so the API call response is omitted, to save bandwidth.
	    // errorCodeLookup[Dropbox.ApiError.NO_CONTENT];
	    // The error property on {Dropbox.ApiError#response} should indicate which input parameter is invalid and why.
	    errorCodeLookup[Dropbox.ApiError.INVALID_PARAM] = ErrorCode.EINVAL;
	    // The OAuth token used for the request will never become valid again, so the user should be re-authenticated.
	    errorCodeLookup[Dropbox.ApiError.INVALID_TOKEN] = ErrorCode.EPERM;
	    // This indicates a bug in dropbox.js and should never occur under normal circumstances.
	    // ^ Actually, that's false. This occurs when you try to move folders to themselves, or move a file over another file.
	    errorCodeLookup[Dropbox.ApiError.OAUTH_ERROR] = ErrorCode.EPERM;
	    // This happens when trying to read from a non-existing file, readdir a non-existing directory, write a file into a non-existing directory, etc.
	    errorCodeLookup[Dropbox.ApiError.NOT_FOUND] = ErrorCode.ENOENT;
	    // This indicates a bug in dropbox.js and should never occur under normal circumstances.
	    errorCodeLookup[Dropbox.ApiError.INVALID_METHOD] = ErrorCode.EINVAL;
	    // This happens when a Dropbox.Client#readdir or Dropbox.Client#stat call would return more than a maximum amount of directory entries.
	    errorCodeLookup[Dropbox.ApiError.NOT_ACCEPTABLE] = ErrorCode.EINVAL;
	    // This is used by some backend methods to indicate that the client needs to download server-side changes and perform conflict resolution. Under normal usage, errors with this code should never surface to the code using dropbox.js.
	    errorCodeLookup[Dropbox.ApiError.CONFLICT] = ErrorCode.EINVAL;
	    // Status value indicating that the application is making too many requests.
	    errorCodeLookup[Dropbox.ApiError.RATE_LIMITED] = ErrorCode.EBUSY;
	    // The request should be retried after some time.
	    errorCodeLookup[Dropbox.ApiError.SERVER_ERROR] = ErrorCode.EBUSY;
	    // Status value indicating that the user's Dropbox is over its storage quota.
	    errorCodeLookup[Dropbox.ApiError.OVER_QUOTA] = ErrorCode.ENOSPC;
	}
	/**
	 * @hidden
	 */
	function isFileInfo(cache) {
	    return cache && cache.stat.isFile;
	}
	/**
	 * @hidden
	 */
	function isDirInfo(cache) {
	    return cache && cache.stat.isFolder;
	}
	/**
	 * @hidden
	 */
	function isArrayBuffer(ab) {
	    // Accept null / undefined, too.
	    return ab === null || ab === undefined || (typeof (ab) === 'object' && typeof (ab['byteLength']) === 'number');
	}
	/**
	 * Wraps a Dropbox client and caches operations.
	 * @hidden
	 */
	var CachedDropboxClient = function CachedDropboxClient(client) {
	    this._cache = {};
	    this._client = client;
	};
	CachedDropboxClient.prototype.readdir = function readdir (p, cb) {
	        var this$1 = this;
	
	    var cacheInfo = this.getCachedDirInfo(p);
	    this._wrap(function (interceptCb) {
	        if (cacheInfo !== null && cacheInfo.contents) {
	            this$1._client.readdir(p, {
	                contentHash: cacheInfo.stat.contentHash
	            }, interceptCb);
	        }
	        else {
	            this$1._client.readdir(p, interceptCb);
	        }
	    }, function (err, filenames, stat, folderEntries) {
	        if (err) {
	            if (err.status === Dropbox.ApiError.NO_CONTENT && cacheInfo !== null) {
	                cb(null, cacheInfo.contents.slice(0));
	            }
	            else {
	                cb(err);
	            }
	        }
	        else {
	            this$1.updateCachedDirInfo(p, stat, filenames.slice(0));
	            folderEntries.forEach(function (entry) {
	                this$1.updateCachedInfo(path.join(p, entry.name), entry);
	            });
	            cb(null, filenames);
	        }
	    });
	};
	CachedDropboxClient.prototype.remove = function remove (p, cb) {
	        var this$1 = this;
	
	    this._wrap(function (interceptCb) {
	        this$1._client.remove(p, interceptCb);
	    }, function (err, stat) {
	        if (!err) {
	            this$1.updateCachedInfo(p, stat);
	        }
	        cb(err);
	    });
	};
	CachedDropboxClient.prototype.move = function move (src, dest, cb) {
	        var this$1 = this;
	
	    this._wrap(function (interceptCb) {
	        this$1._client.move(src, dest, interceptCb);
	    }, function (err, stat) {
	        if (!err) {
	            this$1.deleteCachedInfo(src);
	            this$1.updateCachedInfo(dest, stat);
	        }
	        cb(err);
	    });
	};
	CachedDropboxClient.prototype.stat = function stat (p, cb) {
	        var this$1 = this;
	
	    this._wrap(function (interceptCb) {
	        this$1._client.stat(p, interceptCb);
	    }, function (err, stat) {
	        if (!err) {
	            this$1.updateCachedInfo(p, stat);
	        }
	        cb(err, stat);
	    });
	};
	CachedDropboxClient.prototype.readFile = function readFile (p, cb) {
	        var this$1 = this;
	
	    var cacheInfo = this.getCachedFileInfo(p);
	    if (cacheInfo !== null && cacheInfo.contents !== null) {
	        // Try to use cached info; issue a stat to see if contents are up-to-date.
	        this.stat(p, function (error, stat) {
	            if (error) {
	                cb(error);
	            }
	            else if (stat.contentHash === cacheInfo.stat.contentHash) {
	                // No file changes.
	                cb(error, cacheInfo.contents.slice(0), cacheInfo.stat);
	            }
	            else {
	                // File changes; rerun to trigger actual readFile.
	                this$1.readFile(p, cb);
	            }
	        });
	    }
	    else {
	        this._wrap(function (interceptCb) {
	            this$1._client.readFile(p, { arrayBuffer: true }, interceptCb);
	        }, function (err, contents, stat) {
	            if (!err) {
	                this$1.updateCachedInfo(p, stat, contents.slice(0));
	            }
	            cb(err, contents, stat);
	        });
	    }
	};
	CachedDropboxClient.prototype.writeFile = function writeFile (p, contents, cb) {
	        var this$1 = this;
	
	    this._wrap(function (interceptCb) {
	        this$1._client.writeFile(p, contents, interceptCb);
	    }, function (err, stat) {
	        if (!err) {
	            this$1.updateCachedInfo(p, stat, contents.slice(0));
	        }
	        cb(err, stat);
	    });
	};
	CachedDropboxClient.prototype.mkdir = function mkdir (p, cb) {
	        var this$1 = this;
	
	    this._wrap(function (interceptCb) {
	        this$1._client.mkdir(p, interceptCb);
	    }, function (err, stat) {
	        if (!err) {
	            this$1.updateCachedInfo(p, stat, []);
	        }
	        cb(err);
	    });
	};
	/**
	 * Wraps an operation such that we retry a failed operation 3 times.
	 * Necessary to deal with Dropbox rate limiting.
	 *
	 * @param performOp Function that performs the operation. Will be called up to three times.
	 * @param cb Called when the operation succeeds, fails in a non-temporary manner, or fails three times.
	 */
	CachedDropboxClient.prototype._wrap = function _wrap (performOp, cb) {
	    var numRun = 0;
	    var interceptCb = function (error) {
	        // Timeout duration, in seconds.
	        var timeoutDuration = 2;
	        if (error && 3 > (++numRun)) {
	            switch (error.status) {
	                case Dropbox.ApiError.SERVER_ERROR:
	                case Dropbox.ApiError.NETWORK_ERROR:
	                case Dropbox.ApiError.RATE_LIMITED:
	                    setTimeout(function () {
	                        performOp(interceptCb);
	                    }, timeoutDuration * 1000);
	                    break;
	                default:
	                    cb.apply(null, arguments);
	                    break;
	            }
	        }
	        else {
	            cb.apply(null, arguments);
	        }
	    };
	    performOp(interceptCb);
	};
	CachedDropboxClient.prototype.getCachedInfo = function getCachedInfo (p) {
	    return this._cache[p.toLowerCase()];
	};
	CachedDropboxClient.prototype.putCachedInfo = function putCachedInfo (p, cache) {
	    this._cache[p.toLowerCase()] = cache;
	};
	CachedDropboxClient.prototype.deleteCachedInfo = function deleteCachedInfo (p) {
	    delete this._cache[p.toLowerCase()];
	};
	CachedDropboxClient.prototype.getCachedDirInfo = function getCachedDirInfo (p) {
	    var info = this.getCachedInfo(p);
	    if (isDirInfo(info)) {
	        return info;
	    }
	    else {
	        return null;
	    }
	};
	CachedDropboxClient.prototype.getCachedFileInfo = function getCachedFileInfo (p) {
	    var info = this.getCachedInfo(p);
	    if (isFileInfo(info)) {
	        return info;
	    }
	    else {
	        return null;
	    }
	};
	CachedDropboxClient.prototype.updateCachedDirInfo = function updateCachedDirInfo (p, stat, contents) {
	        if ( contents === void 0 ) contents = null;
	
	    var cachedInfo = this.getCachedInfo(p);
	    // Dropbox uses the *contentHash* property for directories.
	    // Ignore stat objects w/o a contentHash defined; those actually exist!!!
	    // (Example: readdir returns an array of stat objs; stat objs for dirs in that context have no contentHash)
	    if (stat.contentHash !== null && (cachedInfo === undefined || cachedInfo.stat.contentHash !== stat.contentHash)) {
	        this.putCachedInfo(p, {
	            stat: stat,
	            contents: contents
	        });
	    }
	};
	CachedDropboxClient.prototype.updateCachedFileInfo = function updateCachedFileInfo (p, stat, contents) {
	        if ( contents === void 0 ) contents = null;
	
	    var cachedInfo = this.getCachedInfo(p);
	    // Dropbox uses the *versionTag* property for files.
	    // Ignore stat objects w/o a versionTag defined.
	    if (stat.versionTag !== null && (cachedInfo === undefined || cachedInfo.stat.versionTag !== stat.versionTag)) {
	        this.putCachedInfo(p, {
	            stat: stat,
	            contents: contents
	        });
	    }
	};
	CachedDropboxClient.prototype.updateCachedInfo = function updateCachedInfo (p, stat, contents) {
	        if ( contents === void 0 ) contents = null;
	
	    if (stat.isFile && isArrayBuffer(contents)) {
	        this.updateCachedFileInfo(p, stat, contents);
	    }
	    else if (stat.isFolder && Array.isArray(contents)) {
	        this.updateCachedDirInfo(p, stat, contents);
	    }
	};
	var DropboxFile = (function (PreloadFile$$1) {
	    function DropboxFile(_fs, _path, _flag, _stat, contents) {
	        PreloadFile$$1.call(this, _fs, _path, _flag, _stat, contents);
	    }
	
	    if ( PreloadFile$$1 ) DropboxFile.__proto__ = PreloadFile$$1;
	    DropboxFile.prototype = Object.create( PreloadFile$$1 && PreloadFile$$1.prototype );
	    DropboxFile.prototype.constructor = DropboxFile;
	    DropboxFile.prototype.sync = function sync (cb) {
	        var this$1 = this;
	
	        if (this.isDirty()) {
	            var buffer$$1 = this.getBuffer(), arrayBuffer = buffer2ArrayBuffer(buffer$$1);
	            this._fs._writeFileStrict(this.getPath(), arrayBuffer, function (e) {
	                if (!e) {
	                    this$1.resetDirty();
	                }
	                cb(e);
	            });
	        }
	        else {
	            cb();
	        }
	    };
	    DropboxFile.prototype.close = function close (cb) {
	        this.sync(cb);
	    };
	
	    return DropboxFile;
	}(PreloadFile));
	/**
	 * A read/write file system backed by Dropbox cloud storage.
	 *
	 * Uses the Dropbox V1 API.
	 *
	 * NOTE: You must use the v0.10 version of the [Dropbox JavaScript SDK](https://www.npmjs.com/package/dropbox).
	 */
	var DropboxFileSystem = (function (BaseFileSystem$$1) {
	    function DropboxFileSystem(client, deprecateMsg) {
	        if ( deprecateMsg === void 0 ) deprecateMsg = true;
	
	        BaseFileSystem$$1.call(this);
	        this._client = new CachedDropboxClient(client);
	        deprecationMessage(deprecateMsg, DropboxFileSystem.Name, { client: "authenticated dropbox client instance" });
	        constructErrorCodeLookup();
	    }
	
	    if ( BaseFileSystem$$1 ) DropboxFileSystem.__proto__ = BaseFileSystem$$1;
	    DropboxFileSystem.prototype = Object.create( BaseFileSystem$$1 && BaseFileSystem$$1.prototype );
	    DropboxFileSystem.prototype.constructor = DropboxFileSystem;
	    /**
	     * Creates a new DropboxFileSystem instance with the given options.
	     * Must be given an *authenticated* DropboxJS client from the old v0.10 version of the Dropbox JS SDK.
	     */
	    DropboxFileSystem.Create = function Create (opts, cb) {
	        cb(null, new DropboxFileSystem(opts.client, false));
	    };
	    DropboxFileSystem.isAvailable = function isAvailable () {
	        // Checks if the Dropbox library is loaded.
	        return typeof Dropbox !== 'undefined';
	    };
	    DropboxFileSystem.prototype.getName = function getName () {
	        return DropboxFileSystem.Name;
	    };
	    DropboxFileSystem.prototype.isReadOnly = function isReadOnly () {
	        return false;
	    };
	    // Dropbox doesn't support symlinks, properties, or synchronous calls
	    DropboxFileSystem.prototype.supportsSymlinks = function supportsSymlinks () {
	        return false;
	    };
	    DropboxFileSystem.prototype.supportsProps = function supportsProps () {
	        return false;
	    };
	    DropboxFileSystem.prototype.supportsSynch = function supportsSynch () {
	        return false;
	    };
	    DropboxFileSystem.prototype.empty = function empty (mainCb) {
	        var this$1 = this;
	
	        this._client.readdir('/', function (error, files) {
	            if (error) {
	                mainCb(this$1.convert(error, '/'));
	            }
	            else {
	                var deleteFile = function (file, cb) {
	                    var p = path.join('/', file);
	                    this$1._client.remove(p, function (err) {
	                        cb(err ? this$1.convert(err, p) : null);
	                    });
	                };
	                var finished = function (err) {
	                    if (err) {
	                        mainCb(err);
	                    }
	                    else {
	                        mainCb();
	                    }
	                };
	                // XXX: <any> typing is to get around overly-restrictive ErrorCallback typing.
	                eachLimit(files, deleteFile, finished);
	            }
	        });
	    };
	    DropboxFileSystem.prototype.rename = function rename (oldPath, newPath, cb) {
	        var this$1 = this;
	
	        this._client.move(oldPath, newPath, function (error) {
	            if (error) {
	                // the move is permitted if newPath is a file.
	                // Check if this is the case, and remove if so.
	                this$1._client.stat(newPath, function (error2, stat) {
	                    if (error2 || stat.isFolder) {
	                        var missingPath = error.response.error.indexOf(oldPath) > -1 ? oldPath : newPath;
	                        cb(this$1.convert(error, missingPath));
	                    }
	                    else {
	                        // Delete file, repeat rename.
	                        this$1._client.remove(newPath, function (error2) {
	                            if (error2) {
	                                cb(this$1.convert(error2, newPath));
	                            }
	                            else {
	                                this$1.rename(oldPath, newPath, cb);
	                            }
	                        });
	                    }
	                });
	            }
	            else {
	                cb();
	            }
	        });
	    };
	    DropboxFileSystem.prototype.stat = function stat (path$$1, isLstat, cb) {
	        var this$1 = this;
	
	        // Ignore lstat case -- Dropbox doesn't support symlinks
	        // Stat the file
	        this._client.stat(path$$1, function (error, stat) {
	            if (error) {
	                cb(this$1.convert(error, path$$1));
	            }
	            else if (stat && stat.isRemoved) {
	                // Dropbox keeps track of deleted files, so if a file has existed in the
	                // past but doesn't any longer, you wont get an error
	                cb(ApiError.FileError(ErrorCode.ENOENT, path$$1));
	            }
	            else {
	                var stats = new Stats(this$1._statType(stat), stat.size);
	                return cb(null, stats);
	            }
	        });
	    };
	    DropboxFileSystem.prototype.open = function open (path$$1, flags, mode, cb) {
	        var this$1 = this;
	
	        // Try and get the file's contents
	        this._client.readFile(path$$1, function (error, content, dbStat) {
	            if (error) {
	                // If the file's being opened for reading and doesn't exist, return an
	                // error
	                if (flags.isReadable()) {
	                    cb(this$1.convert(error, path$$1));
	                }
	                else {
	                    switch (error.status) {
	                        // If it's being opened for writing or appending, create it so that
	                        // it can be written to
	                        case Dropbox.ApiError.NOT_FOUND:
	                            var ab = new ArrayBuffer(0);
	                            return this$1._writeFileStrict(path$$1, ab, function (error2, stat) {
	                                if (error2) {
	                                    cb(error2);
	                                }
	                                else {
	                                    var file = this$1._makeFile(path$$1, flags, stat, arrayBuffer2Buffer(ab));
	                                    cb(null, file);
	                                }
	                            });
	                        default:
	                            return cb(this$1.convert(error, path$$1));
	                    }
	                }
	            }
	            else {
	                // No error
	                var buffer$$1;
	                // Dropbox.js seems to set `content` to `null` rather than to an empty
	                // buffer when reading an empty file. Not sure why this is.
	                if (content === null) {
	                    buffer$$1 = emptyBuffer();
	                }
	                else {
	                    buffer$$1 = arrayBuffer2Buffer(content);
	                }
	                var file = this$1._makeFile(path$$1, flags, dbStat, buffer$$1);
	                return cb(null, file);
	            }
	        });
	    };
	    DropboxFileSystem.prototype._writeFileStrict = function _writeFileStrict (p, data, cb) {
	        var this$1 = this;
	
	        var parent = path.dirname(p);
	        this.stat(parent, false, function (error, stat) {
	            if (error) {
	                cb(ApiError.FileError(ErrorCode.ENOENT, parent));
	            }
	            else {
	                this$1._client.writeFile(p, data, function (error2, stat) {
	                    if (error2) {
	                        cb(this$1.convert(error2, p));
	                    }
	                    else {
	                        cb(null, stat);
	                    }
	                });
	            }
	        });
	    };
	    /**
	     * Private
	     * Returns a BrowserFS object representing the type of a Dropbox.js stat object
	     */
	    DropboxFileSystem.prototype._statType = function _statType (stat) {
	        return stat.isFile ? FileType.FILE : FileType.DIRECTORY;
	    };
	    /**
	     * Private
	     * Returns a BrowserFS object representing a File, created from the data
	     * returned by calls to the Dropbox API.
	     */
	    DropboxFileSystem.prototype._makeFile = function _makeFile (path$$1, flag, stat, buffer$$1) {
	        var type = this._statType(stat);
	        var stats = new Stats(type, stat.size);
	        return new DropboxFile(this, path$$1, flag, stats, buffer$$1);
	    };
	    /**
	     * Private
	     * Delete a file or directory from Dropbox
	     * isFile should reflect which call was made to remove the it (`unlink` or
	     * `rmdir`). If this doesn't match what's actually at `path`, an error will be
	     * returned
	     */
	    DropboxFileSystem.prototype._remove = function _remove (path$$1, cb, isFile) {
	        var this$1 = this;
	
	        this._client.stat(path$$1, function (error, stat) {
	            if (error) {
	                cb(this$1.convert(error, path$$1));
	            }
	            else {
	                if (stat.isFile && !isFile) {
	                    cb(ApiError.FileError(ErrorCode.ENOTDIR, path$$1));
	                }
	                else if (!stat.isFile && isFile) {
	                    cb(ApiError.FileError(ErrorCode.EISDIR, path$$1));
	                }
	                else {
	                    this$1._client.remove(path$$1, function (error) {
	                        if (error) {
	                            cb(this$1.convert(error, path$$1));
	                        }
	                        else {
	                            cb(null);
	                        }
	                    });
	                }
	            }
	        });
	    };
	    /**
	     * Delete a file
	     */
	    DropboxFileSystem.prototype.unlink = function unlink (path$$1, cb) {
	        this._remove(path$$1, cb, true);
	    };
	    /**
	     * Delete a directory
	     */
	    DropboxFileSystem.prototype.rmdir = function rmdir (path$$1, cb) {
	        this._remove(path$$1, cb, false);
	    };
	    /**
	     * Create a directory
	     */
	    DropboxFileSystem.prototype.mkdir = function mkdir (p, mode, cb) {
	        var this$1 = this;
	
	        // Dropbox.js' client.mkdir() behaves like `mkdir -p`, i.e. it creates a
	        // directory and all its ancestors if they don't exist.
	        // Node's fs.mkdir() behaves like `mkdir`, i.e. it throws an error if an attempt
	        // is made to create a directory without a parent.
	        // To handle this inconsistency, a check for the existence of `path`'s parent
	        // must be performed before it is created, and an error thrown if it does
	        // not exist
	        var parent = path.dirname(p);
	        this._client.stat(parent, function (error, stat) {
	            if (error) {
	                cb(this$1.convert(error, parent));
	            }
	            else {
	                this$1._client.mkdir(p, function (error) {
	                    if (error) {
	                        cb(ApiError.FileError(ErrorCode.EEXIST, p));
	                    }
	                    else {
	                        cb(null);
	                    }
	                });
	            }
	        });
	    };
	    /**
	     * Get the names of the files in a directory
	     */
	    DropboxFileSystem.prototype.readdir = function readdir (path$$1, cb) {
	        var this$1 = this;
	
	        this._client.readdir(path$$1, function (error, files) {
	            if (error) {
	                return cb(this$1.convert(error));
	            }
	            else {
	                return cb(null, files);
	            }
	        });
	    };
	    /**
	     * Converts a Dropbox-JS error into a BFS error.
	     */
	    DropboxFileSystem.prototype.convert = function convert (err, path$$1) {
	        if ( path$$1 === void 0 ) path$$1 = null;
	
	        var errorCode = errorCodeLookup[err.status];
	        if (errorCode === undefined) {
	            errorCode = ErrorCode.EIO;
	        }
	        if (!path$$1) {
	            return new ApiError(errorCode);
	        }
	        else {
	            return ApiError.FileError(errorCode, path$$1);
	        }
	    };
	
	    return DropboxFileSystem;
	}(BaseFileSystem));
	
	DropboxFileSystem.Name = "Dropbox";
	DropboxFileSystem.Options = {
	    client: {
	        type: "object",
	        description: "An *authenticated* Dropbox client. Must be from the 0.10 JS SDK.",
	        validator: function (opt, cb) {
	            if (opt.isAuthenticated && opt.isAuthenticated()) {
	                cb();
	            }
	            else {
	                cb(new ApiError(ErrorCode.EINVAL, "'client' option must be an authenticated Dropbox client from the v0.10 JS SDK."));
	            }
	        }
	    }
	};
	
	/**
	 * @hidden
	 */
	function convertError(e, path$$1) {
	    if ( path$$1 === void 0 ) path$$1 = '';
	
	    var errno = e.errno;
	    var parent = e.node;
	    var paths = [];
	    while (parent) {
	        paths.unshift(parent.name);
	        if (parent === parent.parent) {
	            break;
	        }
	        parent = parent.parent;
	    }
	    return new ApiError(errno, ErrorStrings[errno], paths.length > 0 ? '/' + paths.join('/') : path$$1);
	}
	var EmscriptenFile = (function (BaseFile$$1) {
	    function EmscriptenFile(_fs, _FS, _path, _stream) {
	        BaseFile$$1.call(this);
	        this._fs = _fs;
	        this._FS = _FS;
	        this._path = _path;
	        this._stream = _stream;
	    }
	
	    if ( BaseFile$$1 ) EmscriptenFile.__proto__ = BaseFile$$1;
	    EmscriptenFile.prototype = Object.create( BaseFile$$1 && BaseFile$$1.prototype );
	    EmscriptenFile.prototype.constructor = EmscriptenFile;
	    EmscriptenFile.prototype.getPos = function getPos () {
	        return undefined;
	    };
	    EmscriptenFile.prototype.close = function close (cb) {
	        var err = null;
	        try {
	            this.closeSync();
	        }
	        catch (e) {
	            err = e;
	        }
	        finally {
	            cb(err);
	        }
	    };
	    EmscriptenFile.prototype.closeSync = function closeSync () {
	        try {
	            this._FS.close(this._stream);
	        }
	        catch (e) {
	            throw convertError(e, this._path);
	        }
	    };
	    EmscriptenFile.prototype.stat = function stat (cb) {
	        try {
	            cb(null, this.statSync());
	        }
	        catch (e) {
	            cb(e);
	        }
	    };
	    EmscriptenFile.prototype.statSync = function statSync () {
	        try {
	            return this._fs.statSync(this._path, false);
	        }
	        catch (e) {
	            throw convertError(e, this._path);
	        }
	    };
	    EmscriptenFile.prototype.truncate = function truncate (len, cb) {
	        var err = null;
	        try {
	            this.truncateSync(len);
	        }
	        catch (e) {
	            err = e;
	        }
	        finally {
	            cb(err);
	        }
	    };
	    EmscriptenFile.prototype.truncateSync = function truncateSync (len) {
	        try {
	            this._FS.ftruncate(this._stream.fd, len);
	        }
	        catch (e) {
	            throw convertError(e, this._path);
	        }
	    };
	    EmscriptenFile.prototype.write = function write (buffer$$1, offset, length, position, cb) {
	        try {
	            cb(null, this.writeSync(buffer$$1, offset, length, position), buffer$$1);
	        }
	        catch (e) {
	            cb(e);
	        }
	    };
	    EmscriptenFile.prototype.writeSync = function writeSync (buffer$$1, offset, length, position) {
	        try {
	            var u8 = buffer2Uint8array(buffer$$1);
	            // Emscripten is particular about what position is set to.
	            var emPosition = position === null ? undefined : position;
	            return this._FS.write(this._stream, u8, offset, length, emPosition);
	        }
	        catch (e) {
	            throw convertError(e, this._path);
	        }
	    };
	    EmscriptenFile.prototype.read = function read (buffer$$1, offset, length, position, cb) {
	        try {
	            cb(null, this.readSync(buffer$$1, offset, length, position), buffer$$1);
	        }
	        catch (e) {
	            cb(e);
	        }
	    };
	    EmscriptenFile.prototype.readSync = function readSync (buffer$$1, offset, length, position) {
	        try {
	            var u8 = buffer2Uint8array(buffer$$1);
	            // Emscripten is particular about what position is set to.
	            var emPosition = position === null ? undefined : position;
	            return this._FS.read(this._stream, u8, offset, length, emPosition);
	        }
	        catch (e) {
	            throw convertError(e, this._path);
	        }
	    };
	    EmscriptenFile.prototype.sync = function sync (cb) {
	        // NOP.
	        cb();
	    };
	    EmscriptenFile.prototype.syncSync = function syncSync () {
	        // NOP.
	    };
	    EmscriptenFile.prototype.chown = function chown (uid, gid, cb) {
	        var err = null;
	        try {
	            this.chownSync(uid, gid);
	        }
	        catch (e) {
	            err = e;
	        }
	        finally {
	            cb(err);
	        }
	    };
	    EmscriptenFile.prototype.chownSync = function chownSync (uid, gid) {
	        try {
	            this._FS.fchown(this._stream.fd, uid, gid);
	        }
	        catch (e) {
	            throw convertError(e, this._path);
	        }
	    };
	    EmscriptenFile.prototype.chmod = function chmod (mode, cb) {
	        var err = null;
	        try {
	            this.chmodSync(mode);
	        }
	        catch (e) {
	            err = e;
	        }
	        finally {
	            cb(err);
	        }
	    };
	    EmscriptenFile.prototype.chmodSync = function chmodSync (mode) {
	        try {
	            this._FS.fchmod(this._stream.fd, mode);
	        }
	        catch (e) {
	            throw convertError(e, this._path);
	        }
	    };
	    EmscriptenFile.prototype.utimes = function utimes (atime, mtime, cb) {
	        var err = null;
	        try {
	            this.utimesSync(atime, mtime);
	        }
	        catch (e) {
	            err = e;
	        }
	        finally {
	            cb(err);
	        }
	    };
	    EmscriptenFile.prototype.utimesSync = function utimesSync (atime, mtime) {
	        this._fs.utimesSync(this._path, atime, mtime);
	    };
	
	    return EmscriptenFile;
	}(BaseFile));
	/**
	 * Mounts an Emscripten file system into the BrowserFS file system.
	 */
	var EmscriptenFileSystem = (function (SynchronousFileSystem$$1) {
	    function EmscriptenFileSystem(_FS) {
	        SynchronousFileSystem$$1.call(this);
	        this._FS = _FS;
	    }
	
	    if ( SynchronousFileSystem$$1 ) EmscriptenFileSystem.__proto__ = SynchronousFileSystem$$1;
	    EmscriptenFileSystem.prototype = Object.create( SynchronousFileSystem$$1 && SynchronousFileSystem$$1.prototype );
	    EmscriptenFileSystem.prototype.constructor = EmscriptenFileSystem;
	    /**
	     * Create an EmscriptenFileSystem instance with the given options.
	     */
	    EmscriptenFileSystem.Create = function Create (opts, cb) {
	        cb(null, new EmscriptenFileSystem(opts.FS));
	    };
	    EmscriptenFileSystem.isAvailable = function isAvailable () { return true; };
	    EmscriptenFileSystem.prototype.getName = function getName () { return this._FS.DB_NAME(); };
	    EmscriptenFileSystem.prototype.isReadOnly = function isReadOnly () { return false; };
	    EmscriptenFileSystem.prototype.supportsLinks = function supportsLinks () { return true; };
	    EmscriptenFileSystem.prototype.supportsProps = function supportsProps () { return true; };
	    EmscriptenFileSystem.prototype.supportsSynch = function supportsSynch () { return true; };
	    EmscriptenFileSystem.prototype.renameSync = function renameSync (oldPath, newPath) {
	        try {
	            this._FS.rename(oldPath, newPath);
	        }
	        catch (e) {
	            if (e.errno === ErrorCode.ENOENT) {
	                throw convertError(e, this.existsSync(oldPath) ? newPath : oldPath);
	            }
	            else {
	                throw convertError(e);
	            }
	        }
	    };
	    EmscriptenFileSystem.prototype.statSync = function statSync (p, isLstat) {
	        try {
	            var stats = isLstat ? this._FS.lstat(p) : this._FS.stat(p);
	            var itemType = this.modeToFileType(stats.mode);
	            return new Stats(itemType, stats.size, stats.mode, stats.atime, stats.mtime, stats.ctime);
	        }
	        catch (e) {
	            throw convertError(e, p);
	        }
	    };
	    EmscriptenFileSystem.prototype.openSync = function openSync (p, flag, mode) {
	        try {
	            var stream = this._FS.open(p, flag.getFlagString(), mode);
	            if (this._FS.isDir(stream.node.mode)) {
	                this._FS.close(stream);
	                throw ApiError.EISDIR(p);
	            }
	            return new EmscriptenFile(this, this._FS, p, stream);
	        }
	        catch (e) {
	            throw convertError(e, p);
	        }
	    };
	    EmscriptenFileSystem.prototype.unlinkSync = function unlinkSync (p) {
	        try {
	            this._FS.unlink(p);
	        }
	        catch (e) {
	            throw convertError(e, p);
	        }
	    };
	    EmscriptenFileSystem.prototype.rmdirSync = function rmdirSync (p) {
	        try {
	            this._FS.rmdir(p);
	        }
	        catch (e) {
	            throw convertError(e, p);
	        }
	    };
	    EmscriptenFileSystem.prototype.mkdirSync = function mkdirSync (p, mode) {
	        try {
	            this._FS.mkdir(p, mode);
	        }
	        catch (e) {
	            throw convertError(e, p);
	        }
	    };
	    EmscriptenFileSystem.prototype.readdirSync = function readdirSync (p) {
	        try {
	            // Emscripten returns items for '.' and '..'. Node does not.
	            return this._FS.readdir(p).filter(function (p) { return p !== '.' && p !== '..'; });
	        }
	        catch (e) {
	            throw convertError(e, p);
	        }
	    };
	    EmscriptenFileSystem.prototype.truncateSync = function truncateSync (p, len) {
	        try {
	            this._FS.truncate(p, len);
	        }
	        catch (e) {
	            throw convertError(e, p);
	        }
	    };
	    EmscriptenFileSystem.prototype.readFileSync = function readFileSync (p, encoding, flag) {
	        try {
	            var data = this._FS.readFile(p, { flags: flag.getFlagString() });
	            var buff = uint8Array2Buffer(data);
	            if (encoding) {
	                return buff.toString(encoding);
	            }
	            else {
	                return buff;
	            }
	        }
	        catch (e) {
	            throw convertError(e, p);
	        }
	    };
	    EmscriptenFileSystem.prototype.writeFileSync = function writeFileSync (p, data, encoding, flag, mode) {
	        try {
	            if (encoding) {
	                data = Buffer.from(data, encoding);
	            }
	            var u8 = buffer2Uint8array(data);
	            this._FS.writeFile(p, u8, { flags: flag.getFlagString(), encoding: 'binary' });
	            this._FS.chmod(p, mode);
	        }
	        catch (e) {
	            throw convertError(e, p);
	        }
	    };
	    EmscriptenFileSystem.prototype.chmodSync = function chmodSync (p, isLchmod, mode) {
	        try {
	            isLchmod ? this._FS.lchmod(p, mode) : this._FS.chmod(p, mode);
	        }
	        catch (e) {
	            throw convertError(e, p);
	        }
	    };
	    EmscriptenFileSystem.prototype.chownSync = function chownSync (p, isLchown, uid, gid) {
	        try {
	            isLchown ? this._FS.lchown(p, uid, gid) : this._FS.chown(p, uid, gid);
	        }
	        catch (e) {
	            throw convertError(e, p);
	        }
	    };
	    EmscriptenFileSystem.prototype.symlinkSync = function symlinkSync (srcpath, dstpath, type) {
	        try {
	            this._FS.symlink(srcpath, dstpath);
	        }
	        catch (e) {
	            throw convertError(e);
	        }
	    };
	    EmscriptenFileSystem.prototype.readlinkSync = function readlinkSync (p) {
	        try {
	            return this._FS.readlink(p);
	        }
	        catch (e) {
	            throw convertError(e, p);
	        }
	    };
	    EmscriptenFileSystem.prototype.utimesSync = function utimesSync (p, atime, mtime) {
	        try {
	            this._FS.utime(p, atime.getTime(), mtime.getTime());
	        }
	        catch (e) {
	            throw convertError(e, p);
	        }
	    };
	    EmscriptenFileSystem.prototype.modeToFileType = function modeToFileType (mode) {
	        if (this._FS.isDir(mode)) {
	            return FileType.DIRECTORY;
	        }
	        else if (this._FS.isFile(mode)) {
	            return FileType.FILE;
	        }
	        else if (this._FS.isLink(mode)) {
	            return FileType.SYMLINK;
	        }
	        else {
	            throw ApiError.EPERM(("Invalid mode: " + mode));
	        }
	    };
	
	    return EmscriptenFileSystem;
	}(SynchronousFileSystem));
	
	EmscriptenFileSystem.Name = "EmscriptenFileSystem";
	EmscriptenFileSystem.Options = {
	    FS: {
	        type: "object",
	        description: "The Emscripten file system to use (the `FS` variable)"
	    }
	};
	
	/**
	 * The FolderAdapter file system wraps a file system, and scopes all interactions to a subfolder of that file system.
	 *
	 * Example: Given a file system `foo` with folder `bar` and file `bar/baz`...
	 *
	 * ```javascript
	 * BrowserFS.configure({
	 *   fs: "FolderAdapter",
	 *   options: {
	 *     folder: "bar",
	 *     wrapped: foo
	 *   }
	 * }, function(e) {
	 *   var fs = BrowserFS.BFSRequire('fs');
	 *   fs.readdirSync('/'); // ['baz']
	 * });
	 * ```
	 */
	var FolderAdapter = (function (BaseFileSystem$$1) {
	    function FolderAdapter(folder, wrapped) {
	        BaseFileSystem$$1.call(this);
	        this._folder = folder;
	        this._wrapped = wrapped;
	    }
	
	    if ( BaseFileSystem$$1 ) FolderAdapter.__proto__ = BaseFileSystem$$1;
	    FolderAdapter.prototype = Object.create( BaseFileSystem$$1 && BaseFileSystem$$1.prototype );
	    FolderAdapter.prototype.constructor = FolderAdapter;
	    /**
	     * Creates a FolderAdapter instance with the given options.
	     */
	    FolderAdapter.Create = function Create (opts, cb) {
	        cb(null, new FolderAdapter(opts.folder, opts.wrapped));
	    };
	    FolderAdapter.isAvailable = function isAvailable () {
	        return true;
	    };
	    /**
	     * Initialize the file system. Ensures that the wrapped file system
	     * has the given folder.
	     */
	    FolderAdapter.prototype.initialize = function initialize (cb) {
	        var this$1 = this;
	
	        this._wrapped.exists(this._folder, function (exists) {
	            if (exists) {
	                cb();
	            }
	            else if (this$1._wrapped.isReadOnly()) {
	                cb(ApiError.ENOENT(this$1._folder));
	            }
	            else {
	                this$1._wrapped.mkdir(this$1._folder, 0x1ff, cb);
	            }
	        });
	    };
	    FolderAdapter.prototype.getName = function getName () { return this._wrapped.getName(); };
	    FolderAdapter.prototype.isReadOnly = function isReadOnly () { return this._wrapped.isReadOnly(); };
	    FolderAdapter.prototype.supportsProps = function supportsProps () { return this._wrapped.supportsProps(); };
	    FolderAdapter.prototype.supportsSynch = function supportsSynch () { return this._wrapped.supportsSynch(); };
	    FolderAdapter.prototype.supportsLinks = function supportsLinks () { return false; };
	
	    return FolderAdapter;
	}(BaseFileSystem));
	
	FolderAdapter.Name = "FolderAdapter";
	FolderAdapter.Options = {
	    folder: {
	        type: "string",
	        description: "The folder to use as the root directory"
	    },
	    wrapped: {
	        type: "object",
	        description: "The file system to wrap"
	    }
	};
	/**
	 * @hidden
	 */
	function translateError(folder, e) {
	    if (e !== null && typeof e === 'object') {
	        var err = e;
	        var p = err.path;
	        if (p) {
	            p = '/' + path.relative(folder, p);
	            err.message = err.message.replace(err.path, p);
	            err.path = p;
	        }
	    }
	    return e;
	}
	/**
	 * @hidden
	 */
	function wrapCallback(folder, cb) {
	    if (typeof cb === 'function') {
	        return function (err) {
	            if (arguments.length > 0) {
	                arguments[0] = translateError(folder, err);
	            }
	            cb.apply(null, arguments);
	        };
	    }
	    else {
	        return cb;
	    }
	}
	/**
	 * @hidden
	 */
	function wrapFunction(name, wrapFirst, wrapSecond) {
	    if (name.slice(name.length - 4) !== 'Sync') {
	        // Async function. Translate error in callback.
	        return function () {
	            if (arguments.length > 0) {
	                if (wrapFirst) {
	                    arguments[0] = path.join(this._folder, arguments[0]);
	                }
	                if (wrapSecond) {
	                    arguments[1] = path.join(this._folder, arguments[1]);
	                }
	                arguments[arguments.length - 1] = wrapCallback(this._folder, arguments[arguments.length - 1]);
	            }
	            return this._wrapped[name].apply(this._wrapped, arguments);
	        };
	    }
	    else {
	        // Sync function. Translate error in catch.
	        return function () {
	            try {
	                if (wrapFirst) {
	                    arguments[0] = path.join(this._folder, arguments[0]);
	                }
	                if (wrapSecond) {
	                    arguments[1] = path.join(this._folder, arguments[1]);
	                }
	                return this._wrapped[name].apply(this._wrapped, arguments);
	            }
	            catch (e) {
	                throw translateError(this._folder, e);
	            }
	        };
	    }
	}
	// First argument is a path.
	['diskSpace', 'stat', 'statSync', 'open', 'openSync', 'unlink', 'unlinkSync',
	    'rmdir', 'rmdirSync', 'mkdir', 'mkdirSync', 'readdir', 'readdirSync', 'exists',
	    'existsSync', 'realpath', 'realpathSync', 'truncate', 'truncateSync', 'readFile',
	    'readFileSync', 'writeFile', 'writeFileSync', 'appendFile', 'appendFileSync',
	    'chmod', 'chmodSync', 'chown', 'chownSync', 'utimes', 'utimesSync', 'readlink',
	    'readlinkSync'].forEach(function (name) {
	    FolderAdapter.prototype[name] = wrapFunction(name, true, false);
	});
	// First and second arguments are paths.
	['rename', 'renameSync', 'link', 'linkSync', 'symlink', 'symlinkSync'].forEach(function (name) {
	    FolderAdapter.prototype[name] = wrapFunction(name, true, true);
	});
	
	/**
	 * @hidden
	 */
	var toExport;
	if (typeof (window) !== 'undefined') {
	    toExport = window;
	}
	else if (typeof (self) !== 'undefined') {
	    toExport = self;
	}
	else {
	    toExport = global;
	}
	var global$1 = toExport;
	
	/**
	 * @hidden
	 */
	function isDirectoryEntry(entry) {
	    return entry.isDirectory;
	}
	/**
	 * @hidden
	 */
	var _getFS = global$1.webkitRequestFileSystem || global$1.requestFileSystem || null;
	/**
	 * @hidden
	 */
	function _requestQuota(type, size, success, errorCallback) {
	    // We cast navigator and window to '<any>' because everything here is
	    // nonstandard functionality, despite the fact that Chrome has the only
	    // implementation of the HTML5FS and is likely driving the standardization
	    // process. Thus, these objects defined off of navigator and window are not
	    // present in the DefinitelyTyped TypeScript typings for FileSystem.
	    if (typeof navigator['webkitPersistentStorage'] !== 'undefined') {
	        switch (type) {
	            case global$1.PERSISTENT:
	                navigator.webkitPersistentStorage.requestQuota(size, success, errorCallback);
	                break;
	            case global$1.TEMPORARY:
	                navigator.webkitTemporaryStorage.requestQuota(size, success, errorCallback);
	                break;
	            default:
	                errorCallback(new TypeError(("Invalid storage type: " + type)));
	                break;
	        }
	    }
	    else {
	        global$1.webkitStorageInfo.requestQuota(type, size, success, errorCallback);
	    }
	}
	/**
	 * @hidden
	 */
	function _toArray(list) {
	    return Array.prototype.slice.call(list || [], 0);
	}
	/**
	 * Converts the given DOMError into an appropriate ApiError.
	 * @url https://developer.mozilla.org/en-US/docs/Web/API/DOMError
	 * @hidden
	 */
	function convertError$1(err, p, expectedDir) {
	    switch (err.name) {
	        /* The user agent failed to create a file or directory due to the existence of a file or
	            directory with the same path.  */
	        case "PathExistsError":
	            return ApiError.EEXIST(p);
	        /* The operation failed because it would cause the application to exceed its storage quota.  */
	        case 'QuotaExceededError':
	            return ApiError.FileError(ErrorCode.ENOSPC, p);
	        /*  A required file or directory could not be found at the time an operation was processed.   */
	        case 'NotFoundError':
	            return ApiError.ENOENT(p);
	        /* This is a security error code to be used in situations not covered by any other error codes.
	            - A required file was unsafe for access within a Web application
	            - Too many calls are being made on filesystem resources */
	        case 'SecurityError':
	            return ApiError.FileError(ErrorCode.EACCES, p);
	        /* The modification requested was illegal. Examples of invalid modifications include moving a
	            directory into its own child, moving a file into its parent directory without changing its name,
	            or copying a directory to a path occupied by a file.  */
	        case 'InvalidModificationError':
	            return ApiError.FileError(ErrorCode.EPERM, p);
	        /* The user has attempted to look up a file or directory, but the Entry found is of the wrong type
	            [e.g. is a DirectoryEntry when the user requested a FileEntry].  */
	        case 'TypeMismatchError':
	            return ApiError.FileError(expectedDir ? ErrorCode.ENOTDIR : ErrorCode.EISDIR, p);
	        /* A path or URL supplied to the API was malformed.  */
	        case "EncodingError":
	        /* An operation depended on state cached in an interface object, but that state that has changed
	            since it was read from disk.  */
	        case "InvalidStateError":
	        /* The user attempted to write to a file or directory which could not be modified due to the state
	            of the underlying filesystem.  */
	        case "NoModificationAllowedError":
	        default:
	            return ApiError.FileError(ErrorCode.EINVAL, p);
	    }
	}
	// A note about getFile and getDirectory options:
	// These methods are called at numerous places in this file, and are passed
	// some combination of these two options:
	//   - create: If true, the entry will be created if it doesn't exist.
	//             If false, an error will be thrown if it doesn't exist.
	//   - exclusive: If true, only create the entry if it doesn't already exist,
	//                and throw an error if it does.
	var HTML5FSFile = (function (PreloadFile$$1) {
	    function HTML5FSFile(fs, entry, path$$1, flag, stat, contents) {
	        PreloadFile$$1.call(this, fs, path$$1, flag, stat, contents);
	        this._entry = entry;
	    }
	
	    if ( PreloadFile$$1 ) HTML5FSFile.__proto__ = PreloadFile$$1;
	    HTML5FSFile.prototype = Object.create( PreloadFile$$1 && PreloadFile$$1.prototype );
	    HTML5FSFile.prototype.constructor = HTML5FSFile;
	    HTML5FSFile.prototype.sync = function sync (cb) {
	        var this$1 = this;
	
	        if (!this.isDirty()) {
	            return cb();
	        }
	        this._entry.createWriter(function (writer) {
	            var buffer$$1 = this$1.getBuffer();
	            var blob = new Blob([buffer2ArrayBuffer(buffer$$1)]);
	            var length = blob.size;
	            writer.onwriteend = function (err) {
	                writer.onwriteend = null;
	                writer.onerror = null;
	                writer.truncate(length);
	                this$1.resetDirty();
	                cb();
	            };
	            writer.onerror = function (err) {
	                cb(convertError$1(err, this$1.getPath(), false));
	            };
	            writer.write(blob);
	        });
	    };
	    HTML5FSFile.prototype.close = function close (cb) {
	        this.sync(cb);
	    };
	
	    return HTML5FSFile;
	}(PreloadFile));
	/**
	 * A read-write filesystem backed by the HTML5 FileSystem API.
	 *
	 * As the HTML5 FileSystem is only implemented in Blink, this interface is
	 * only available in Chrome.
	 */
	var HTML5FS = (function (BaseFileSystem$$1) {
	    function HTML5FS(size, type, deprecateMsg) {
	        if ( size === void 0 ) size = 5;
	        if ( type === void 0 ) type = global$1.PERSISTENT;
	        if ( deprecateMsg === void 0 ) deprecateMsg = true;
	
	        BaseFileSystem$$1.call(this);
	        // Convert MB to bytes.
	        this.size = 1024 * 1024 * size;
	        this.type = type;
	        deprecationMessage(deprecateMsg, HTML5FS.Name, { size: size, type: type });
	    }
	
	    if ( BaseFileSystem$$1 ) HTML5FS.__proto__ = BaseFileSystem$$1;
	    HTML5FS.prototype = Object.create( BaseFileSystem$$1 && BaseFileSystem$$1.prototype );
	    HTML5FS.prototype.constructor = HTML5FS;
	    /**
	     * Creates an HTML5FS instance with the given options.
	     */
	    HTML5FS.Create = function Create (opts, cb) {
	        var fs = new HTML5FS(opts.size, opts.type, false);
	        fs.allocate(function (e) { return e ? cb(e) : cb(null, fs); }, false);
	    };
	    HTML5FS.isAvailable = function isAvailable () {
	        return !!_getFS;
	    };
	    HTML5FS.prototype.getName = function getName () {
	        return HTML5FS.Name;
	    };
	    HTML5FS.prototype.isReadOnly = function isReadOnly () {
	        return false;
	    };
	    HTML5FS.prototype.supportsSymlinks = function supportsSymlinks () {
	        return false;
	    };
	    HTML5FS.prototype.supportsProps = function supportsProps () {
	        return false;
	    };
	    HTML5FS.prototype.supportsSynch = function supportsSynch () {
	        return false;
	    };
	    /**
	     * **Deprecated. Please use Create() method instead to create and allocate an HTML5FS.**
	     *
	     * Requests a storage quota from the browser to back this FS.
	     * Must be called before file system can be used!
	     */
	    HTML5FS.prototype.allocate = function allocate (cb, deprecateMsg) {
	        var this$1 = this;
	        if ( cb === void 0 ) cb = function () { };
	        if ( deprecateMsg === void 0 ) deprecateMsg = true;
	
	        if (deprecateMsg) {
	            console.warn(("[HTML5FS] HTML5FS.allocate() is deprecated and will be removed in the next major release. Please use 'HTML5FS.Create({type: " + (this.type) + ", size: " + (this.size) + "}, cb)' to create and allocate HTML5FS instances."));
	        }
	        var success = function (fs) {
	            this$1.fs = fs;
	            cb();
	        };
	        var error = function (err) {
	            cb(convertError$1(err, "/", true));
	        };
	        if (this.type === global$1.PERSISTENT) {
	            _requestQuota(this.type, this.size, function (granted) {
	                _getFS(this$1.type, granted, success, error);
	            }, error);
	        }
	        else {
	            _getFS(this.type, this.size, success, error);
	        }
	    };
	    /**
	     * Deletes everything in the FS. Used for testing.
	     * Karma clears the storage after you quit it but not between runs of the test
	     * suite, and the tests expect an empty FS every time.
	     */
	    HTML5FS.prototype.empty = function empty (mainCb) {
	        // Get a list of all entries in the root directory to delete them
	        this._readdir('/', function (err, entries) {
	            if (err) {
	                console.error('Failed to empty FS');
	                mainCb(err);
	            }
	            else {
	                // Called when every entry has been operated on
	                var finished = function (er) {
	                    if (err) {
	                        console.error("Failed to empty FS");
	                        mainCb(err);
	                    }
	                    else {
	                        mainCb();
	                    }
	                };
	                // Removes files and recursively removes directories
	                var deleteEntry = function (entry, cb) {
	                    var succ = function () {
	                        cb();
	                    };
	                    var error = function (err) {
	                        cb(convertError$1(err, entry.fullPath, !entry.isDirectory));
	                    };
	                    if (isDirectoryEntry(entry)) {
	                        entry.removeRecursively(succ, error);
	                    }
	                    else {
	                        entry.remove(succ, error);
	                    }
	                };
	                // Loop through the entries and remove them, then call the callback
	                // when they're all finished.
	                eachLimit(entries, deleteEntry, finished);
	            }
	        });
	    };
	    HTML5FS.prototype.rename = function rename (oldPath, newPath, cb) {
	        var this$1 = this;
	
	        var semaphore = 2;
	        var successCount = 0;
	        var root = this.fs.root;
	        var currentPath = oldPath;
	        var error = function (err) {
	            if (--semaphore <= 0) {
	                cb(convertError$1(err, currentPath, false));
	            }
	        };
	        var success = function (file) {
	            if (++successCount === 2) {
	                return cb(new ApiError(ErrorCode.EINVAL, "Something was identified as both a file and a directory. This should never happen."));
	            }
	            // SPECIAL CASE: If newPath === oldPath, and the path exists, then
	            // this operation trivially succeeds.
	            if (oldPath === newPath) {
	                return cb();
	            }
	            // Get the new parent directory.
	            currentPath = path.dirname(newPath);
	            root.getDirectory(currentPath, {}, function (parentDir) {
	                currentPath = path.basename(newPath);
	                file.moveTo(parentDir, currentPath, function (entry) { cb(); }, function (err) {
	                    // SPECIAL CASE: If oldPath is a directory, and newPath is a
	                    // file, rename should delete the file and perform the move.
	                    if (file.isDirectory) {
	                        currentPath = newPath;
	                        // Unlink only works on files. Try to delete newPath.
	                        this$1.unlink(newPath, function (e) {
	                            if (e) {
	                                // newPath is probably a directory.
	                                error(err);
	                            }
	                            else {
	                                // Recur, now that newPath doesn't exist.
	                                this$1.rename(oldPath, newPath, cb);
	                            }
	                        });
	                    }
	                    else {
	                        error(err);
	                    }
	                });
	            }, error);
	        };
	        // We don't know if oldPath is a *file* or a *directory*, and there's no
	        // way to stat items. So launch both requests, see which one succeeds.
	        root.getFile(oldPath, {}, success, error);
	        root.getDirectory(oldPath, {}, success, error);
	    };
	    HTML5FS.prototype.stat = function stat (path$$1, isLstat, cb) {
	        var this$1 = this;
	
	        // Throw an error if the entry doesn't exist, because then there's nothing
	        // to stat.
	        var opts = {
	            create: false
	        };
	        // Called when the path has been successfully loaded as a file.
	        var loadAsFile = function (entry) {
	            var fileFromEntry = function (file) {
	                var stat = new Stats(FileType.FILE, file.size);
	                cb(null, stat);
	            };
	            entry.file(fileFromEntry, failedToLoad);
	        };
	        // Called when the path has been successfully loaded as a directory.
	        var loadAsDir = function (dir$$1) {
	            // Directory entry size can't be determined from the HTML5 FS API, and is
	            // implementation-dependant anyway, so a dummy value is used.
	            var size = 4096;
	            var stat = new Stats(FileType.DIRECTORY, size);
	            cb(null, stat);
	        };
	        // Called when the path couldn't be opened as a directory or a file.
	        var failedToLoad = function (err) {
	            cb(convertError$1(err, path$$1, false /* Unknown / irrelevant */));
	        };
	        // Called when the path couldn't be opened as a file, but might still be a
	        // directory.
	        var failedToLoadAsFile = function () {
	            this$1.fs.root.getDirectory(path$$1, opts, loadAsDir, failedToLoad);
	        };
	        // No method currently exists to determine whether a path refers to a
	        // directory or a file, so this implementation tries both and uses the first
	        // one that succeeds.
	        this.fs.root.getFile(path$$1, opts, loadAsFile, failedToLoadAsFile);
	    };
	    HTML5FS.prototype.open = function open (p, flags, mode, cb) {
	        var this$1 = this;
	
	        // XXX: err is a DOMError
	        var error = function (err) {
	            if (err.name === 'InvalidModificationError' && flags.isExclusive()) {
	                cb(ApiError.EEXIST(p));
	            }
	            else {
	                cb(convertError$1(err, p, false));
	            }
	        };
	        this.fs.root.getFile(p, {
	            create: flags.pathNotExistsAction() === ActionType.CREATE_FILE,
	            exclusive: flags.isExclusive()
	        }, function (entry) {
	            // Try to fetch corresponding file.
	            entry.file(function (file) {
	                var reader = new FileReader();
	                reader.onloadend = function (event) {
	                    var bfsFile = this$1._makeFile(p, entry, flags, file, reader.result);
	                    cb(null, bfsFile);
	                };
	                reader.onerror = function (ev) {
	                    error(reader.error);
	                };
	                reader.readAsArrayBuffer(file);
	            }, error);
	        }, error);
	    };
	    HTML5FS.prototype.unlink = function unlink (path$$1, cb) {
	        this._remove(path$$1, cb, true);
	    };
	    HTML5FS.prototype.rmdir = function rmdir (path$$1, cb) {
	        var this$1 = this;
	
	        // Check if directory is non-empty, first.
	        this.readdir(path$$1, function (e, files) {
	            if (e) {
	                cb(e);
	            }
	            else if (files.length > 0) {
	                cb(ApiError.ENOTEMPTY(path$$1));
	            }
	            else {
	                this$1._remove(path$$1, cb, false);
	            }
	        });
	    };
	    HTML5FS.prototype.mkdir = function mkdir (path$$1, mode, cb) {
	        // Create the directory, but throw an error if it already exists, as per
	        // mkdir(1)
	        var opts = {
	            create: true,
	            exclusive: true
	        };
	        var success = function (dir$$1) {
	            cb();
	        };
	        var error = function (err) {
	            cb(convertError$1(err, path$$1, true));
	        };
	        this.fs.root.getDirectory(path$$1, opts, success, error);
	    };
	    /**
	     * Map _readdir's list of `FileEntry`s to their names and return that.
	     */
	    HTML5FS.prototype.readdir = function readdir (path$$1, cb) {
	        this._readdir(path$$1, function (e, entries) {
	            if (entries) {
	                var rv = [];
	                for (var i = 0, list = entries; i < list.length; i += 1) {
	                    var entry = list[i];
	
	                    rv.push(entry.name);
	                }
	                cb(null, rv);
	            }
	            else {
	                return cb(e);
	            }
	        });
	    };
	    /**
	     * Returns a BrowserFS object representing a File.
	     */
	    HTML5FS.prototype._makeFile = function _makeFile (path$$1, entry, flag, stat, data) {
	        if ( data === void 0 ) data = new ArrayBuffer(0);
	
	        var stats = new Stats(FileType.FILE, stat.size);
	        var buffer$$1 = arrayBuffer2Buffer(data);
	        return new HTML5FSFile(this, entry, path$$1, flag, stats, buffer$$1);
	    };
	    /**
	     * Returns an array of `FileEntry`s. Used internally by empty and readdir.
	     */
	    HTML5FS.prototype._readdir = function _readdir (path$$1, cb) {
	        var error = function (err) {
	            cb(convertError$1(err, path$$1, true));
	        };
	        // Grab the requested directory.
	        this.fs.root.getDirectory(path$$1, { create: false }, function (dirEntry) {
	            var reader = dirEntry.createReader();
	            var entries = [];
	            // Call the reader.readEntries() until no more results are returned.
	            var readEntries = function () {
	                reader.readEntries((function (results) {
	                    if (results.length) {
	                        entries = entries.concat(_toArray(results));
	                        readEntries();
	                    }
	                    else {
	                        cb(null, entries);
	                    }
	                }), error);
	            };
	            readEntries();
	        }, error);
	    };
	    /**
	     * Delete a file or directory from the file system
	     * isFile should reflect which call was made to remove the it (`unlink` or
	     * `rmdir`). If this doesn't match what's actually at `path`, an error will be
	     * returned
	     */
	    HTML5FS.prototype._remove = function _remove (path$$1, cb, isFile) {
	        var success = function (entry) {
	            var succ = function () {
	                cb();
	            };
	            var err = function (err) {
	                cb(convertError$1(err, path$$1, !isFile));
	            };
	            entry.remove(succ, err);
	        };
	        var error = function (err) {
	            cb(convertError$1(err, path$$1, !isFile));
	        };
	        // Deleting the entry, so don't create it
	        var opts = {
	            create: false
	        };
	        if (isFile) {
	            this.fs.root.getFile(path$$1, opts, success, error);
	        }
	        else {
	            this.fs.root.getDirectory(path$$1, opts, success, error);
	        }
	    };
	
	    return HTML5FS;
	}(BaseFileSystem));
	
	HTML5FS.Name = "HTML5FS";
	HTML5FS.Options = {
	    size: {
	        type: "number",
	        optional: true,
	        description: "Storage quota to request, in megabytes. Allocated value may be less. Defaults to 5."
	    },
	    type: {
	        type: "number",
	        optional: true,
	        description: "window.PERSISTENT or window.TEMPORARY. Defaults to PERSISTENT."
	    }
	};
	
	/**
	 * Generic inode definition that can easily be serialized.
	 */
	var Inode = function Inode(id, size, mode, atime, mtime, ctime) {
	    this.id = id;
	    this.size = size;
	    this.mode = mode;
	    this.atime = atime;
	    this.mtime = mtime;
	    this.ctime = ctime;
	};
	/**
	 * Converts the buffer into an Inode.
	 */
	Inode.fromBuffer = function fromBuffer (buffer$$1) {
	    if (buffer$$1 === undefined) {
	        throw new Error("NO");
	    }
	    return new Inode(buffer$$1.toString('ascii', 30), buffer$$1.readUInt32LE(0), buffer$$1.readUInt16LE(4), buffer$$1.readDoubleLE(6), buffer$$1.readDoubleLE(14), buffer$$1.readDoubleLE(22));
	};
	/**
	 * Handy function that converts the Inode to a Node Stats object.
	 */
	Inode.prototype.toStats = function toStats () {
	    return new Stats((this.mode & 0xF000) === FileType.DIRECTORY ? FileType.DIRECTORY : FileType.FILE, this.size, this.mode, new Date(this.atime), new Date(this.mtime), new Date(this.ctime));
	};
	/**
	 * Get the size of this Inode, in bytes.
	 */
	Inode.prototype.getSize = function getSize () {
	    // ASSUMPTION: ID is ASCII (1 byte per char).
	    return 30 + this.id.length;
	};
	/**
	 * Writes the inode into the start of the buffer.
	 */
	Inode.prototype.toBuffer = function toBuffer (buff) {
	        if ( buff === void 0 ) buff = Buffer.alloc(this.getSize());
	
	    buff.writeUInt32LE(this.size, 0);
	    buff.writeUInt16LE(this.mode, 4);
	    buff.writeDoubleLE(this.atime, 6);
	    buff.writeDoubleLE(this.mtime, 14);
	    buff.writeDoubleLE(this.ctime, 22);
	    buff.write(this.id, 30, this.id.length, 'ascii');
	    return buff;
	};
	/**
	 * Updates the Inode using information from the stats object. Used by file
	 * systems at sync time, e.g.:
	 * - Program opens file and gets a File object.
	 * - Program mutates file. File object is responsible for maintaining
	 *   metadata changes locally -- typically in a Stats object.
	 * - Program closes file. File object's metadata changes are synced with the
	 *   file system.
	 * @return True if any changes have occurred.
	 */
	Inode.prototype.update = function update (stats) {
	    var hasChanged = false;
	    if (this.size !== stats.size) {
	        this.size = stats.size;
	        hasChanged = true;
	    }
	    if (this.mode !== stats.mode) {
	        this.mode = stats.mode;
	        hasChanged = true;
	    }
	    var atimeMs = stats.atime.getTime();
	    if (this.atime !== atimeMs) {
	        this.atime = atimeMs;
	        hasChanged = true;
	    }
	    var mtimeMs = stats.mtime.getTime();
	    if (this.mtime !== mtimeMs) {
	        this.mtime = mtimeMs;
	        hasChanged = true;
	    }
	    var ctimeMs = stats.ctime.getTime();
	    if (this.ctime !== ctimeMs) {
	        this.ctime = ctimeMs;
	        hasChanged = true;
	    }
	    return hasChanged;
	};
	// XXX: Copied from Stats. Should reconcile these two into something more
	//  compact.
	/**
	 * @return [Boolean] True if this item is a file.
	 */
	Inode.prototype.isFile = function isFile () {
	    return (this.mode & 0xF000) === FileType.FILE;
	};
	/**
	 * @return [Boolean] True if this item is a directory.
	 */
	Inode.prototype.isDirectory = function isDirectory () {
	    return (this.mode & 0xF000) === FileType.DIRECTORY;
	};
	
	/**
	 * @hidden
	 */
	var ROOT_NODE_ID = "/";
	/**
	 * @hidden
	 */
	var emptyDirNode = null;
	/**
	 * Returns an empty directory node.
	 * @hidden
	 */
	function getEmptyDirNode() {
	    if (emptyDirNode) {
	        return emptyDirNode;
	    }
	    return emptyDirNode = Buffer.from("{}");
	}
	/**
	 * Generates a random ID.
	 * @hidden
	 */
	function GenerateRandomID() {
	    // From http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript
	    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
	        var r = Math.random() * 16 | 0;
	        var v = c === 'x' ? r : (r & 0x3 | 0x8);
	        return v.toString(16);
	    });
	}
	/**
	 * Helper function. Checks if 'e' is defined. If so, it triggers the callback
	 * with 'e' and returns false. Otherwise, returns true.
	 * @hidden
	 */
	function noError(e, cb) {
	    if (e) {
	        cb(e);
	        return false;
	    }
	    return true;
	}
	/**
	 * Helper function. Checks if 'e' is defined. If so, it aborts the transaction,
	 * triggers the callback with 'e', and returns false. Otherwise, returns true.
	 * @hidden
	 */
	function noErrorTx(e, tx, cb) {
	    if (e) {
	        tx.abort(function () {
	            cb(e);
	        });
	        return false;
	    }
	    return true;
	}
	/**
	 * A simple RW transaction for simple synchronous key-value stores.
	 */
	var SimpleSyncRWTransaction = function SimpleSyncRWTransaction(store) {
	    this.store = store;
	    /**
	     * Stores data in the keys we modify prior to modifying them.
	     * Allows us to roll back commits.
	     */
	    this.originalData = {};
	    /**
	     * List of keys modified in this transaction, if any.
	     */
	    this.modifiedKeys = [];
	};
	SimpleSyncRWTransaction.prototype.get = function get (key) {
	    var val = this.store.get(key);
	    this.stashOldValue(key, val);
	    return val;
	};
	SimpleSyncRWTransaction.prototype.put = function put (key, data, overwrite) {
	    this.markModified(key);
	    return this.store.put(key, data, overwrite);
	};
	SimpleSyncRWTransaction.prototype.del = function del (key) {
	    this.markModified(key);
	    this.store.del(key);
	};
	SimpleSyncRWTransaction.prototype.commit = function commit () { };
	SimpleSyncRWTransaction.prototype.abort = function abort () {
	        var this$1 = this;
	
	    // Rollback old values.
	    for (var i = 0, list = this$1.modifiedKeys; i < list.length; i += 1) {
	        var key = list[i];
	
	            var value = this$1.originalData[key];
	        if (!value) {
	            // Key didn't exist.
	            this$1.store.del(key);
	        }
	        else {
	            // Key existed. Store old value.
	            this$1.store.put(key, value, true);
	        }
	    }
	};
	/**
	 * Stashes given key value pair into `originalData` if it doesn't already
	 * exist. Allows us to stash values the program is requesting anyway to
	 * prevent needless `get` requests if the program modifies the data later
	 * on during the transaction.
	 */
	SimpleSyncRWTransaction.prototype.stashOldValue = function stashOldValue (key, value) {
	    // Keep only the earliest value in the transaction.
	    if (!this.originalData.hasOwnProperty(key)) {
	        this.originalData[key] = value;
	    }
	};
	/**
	 * Marks the given key as modified, and stashes its value if it has not been
	 * stashed already.
	 */
	SimpleSyncRWTransaction.prototype.markModified = function markModified (key) {
	    if (this.modifiedKeys.indexOf(key) === -1) {
	        this.modifiedKeys.push(key);
	        if (!this.originalData.hasOwnProperty(key)) {
	            this.originalData[key] = this.store.get(key);
	        }
	    }
	};
	var SyncKeyValueFile = (function (PreloadFile$$1) {
	    function SyncKeyValueFile(_fs, _path, _flag, _stat, contents) {
	        PreloadFile$$1.call(this, _fs, _path, _flag, _stat, contents);
	    }
	
	    if ( PreloadFile$$1 ) SyncKeyValueFile.__proto__ = PreloadFile$$1;
	    SyncKeyValueFile.prototype = Object.create( PreloadFile$$1 && PreloadFile$$1.prototype );
	    SyncKeyValueFile.prototype.constructor = SyncKeyValueFile;
	    SyncKeyValueFile.prototype.syncSync = function syncSync () {
	        if (this.isDirty()) {
	            this._fs._syncSync(this.getPath(), this.getBuffer(), this.getStats());
	            this.resetDirty();
	        }
	    };
	    SyncKeyValueFile.prototype.closeSync = function closeSync () {
	        this.syncSync();
	    };
	
	    return SyncKeyValueFile;
	}(PreloadFile));
	/**
	 * A "Synchronous key-value file system". Stores data to/retrieves data from an
	 * underlying key-value store.
	 *
	 * We use a unique ID for each node in the file system. The root node has a
	 * fixed ID.
	 * @todo Introduce Node ID caching.
	 * @todo Check modes.
	 */
	var SyncKeyValueFileSystem = (function (SynchronousFileSystem$$1) {
	    function SyncKeyValueFileSystem(options) {
	        SynchronousFileSystem$$1.call(this);
	        this.store = options.store;
	        // INVARIANT: Ensure that the root exists.
	        this.makeRootDirectory();
	    }
	
	    if ( SynchronousFileSystem$$1 ) SyncKeyValueFileSystem.__proto__ = SynchronousFileSystem$$1;
	    SyncKeyValueFileSystem.prototype = Object.create( SynchronousFileSystem$$1 && SynchronousFileSystem$$1.prototype );
	    SyncKeyValueFileSystem.prototype.constructor = SyncKeyValueFileSystem;
	    SyncKeyValueFileSystem.isAvailable = function isAvailable () { return true; };
	
	    SyncKeyValueFileSystem.prototype.getName = function getName () { return this.store.name(); };
	    SyncKeyValueFileSystem.prototype.isReadOnly = function isReadOnly () { return false; };
	    SyncKeyValueFileSystem.prototype.supportsSymlinks = function supportsSymlinks () { return false; };
	    SyncKeyValueFileSystem.prototype.supportsProps = function supportsProps () { return false; };
	    SyncKeyValueFileSystem.prototype.supportsSynch = function supportsSynch () { return true; };
	    /**
	     * Delete all contents stored in the file system.
	     */
	    SyncKeyValueFileSystem.prototype.empty = function empty () {
	        this.store.clear();
	        // INVARIANT: Root always exists.
	        this.makeRootDirectory();
	    };
	    SyncKeyValueFileSystem.prototype.renameSync = function renameSync (oldPath, newPath) {
	        var tx = this.store.beginTransaction('readwrite'), oldParent = path.dirname(oldPath), oldName = path.basename(oldPath), newParent = path.dirname(newPath), newName = path.basename(newPath), 
	        // Remove oldPath from parent's directory listing.
	        oldDirNode = this.findINode(tx, oldParent), oldDirList = this.getDirListing(tx, oldParent, oldDirNode);
	        if (!oldDirList[oldName]) {
	            throw ApiError.ENOENT(oldPath);
	        }
	        var nodeId = oldDirList[oldName];
	        delete oldDirList[oldName];
	        // Invariant: Can't move a folder inside itself.
	        // This funny little hack ensures that the check passes only if oldPath
	        // is a subpath of newParent. We append '/' to avoid matching folders that
	        // are a substring of the bottom-most folder in the path.
	        if ((newParent + '/').indexOf(oldPath + '/') === 0) {
	            throw new ApiError(ErrorCode.EBUSY, oldParent);
	        }
	        // Add newPath to parent's directory listing.
	        var newDirNode, newDirList;
	        if (newParent === oldParent) {
	            // Prevent us from re-grabbing the same directory listing, which still
	            // contains oldName.
	            newDirNode = oldDirNode;
	            newDirList = oldDirList;
	        }
	        else {
	            newDirNode = this.findINode(tx, newParent);
	            newDirList = this.getDirListing(tx, newParent, newDirNode);
	        }
	        if (newDirList[newName]) {
	            // If it's a file, delete it.
	            var newNameNode = this.getINode(tx, newPath, newDirList[newName]);
	            if (newNameNode.isFile()) {
	                try {
	                    tx.del(newNameNode.id);
	                    tx.del(newDirList[newName]);
	                }
	                catch (e) {
	                    tx.abort();
	                    throw e;
	                }
	            }
	            else {
	                // If it's a directory, throw a permissions error.
	                throw ApiError.EPERM(newPath);
	            }
	        }
	        newDirList[newName] = nodeId;
	        // Commit the two changed directory listings.
	        try {
	            tx.put(oldDirNode.id, Buffer.from(JSON.stringify(oldDirList)), true);
	            tx.put(newDirNode.id, Buffer.from(JSON.stringify(newDirList)), true);
	        }
	        catch (e) {
	            tx.abort();
	            throw e;
	        }
	        tx.commit();
	    };
	    SyncKeyValueFileSystem.prototype.statSync = function statSync (p, isLstat) {
	        // Get the inode to the item, convert it into a Stats object.
	        return this.findINode(this.store.beginTransaction('readonly'), p).toStats();
	    };
	    SyncKeyValueFileSystem.prototype.createFileSync = function createFileSync (p, flag, mode) {
	        var tx = this.store.beginTransaction('readwrite'), data = emptyBuffer(), newFile = this.commitNewFile(tx, p, FileType.FILE, mode, data);
	        // Open the file.
	        return new SyncKeyValueFile(this, p, flag, newFile.toStats(), data);
	    };
	    SyncKeyValueFileSystem.prototype.openFileSync = function openFileSync (p, flag) {
	        var tx = this.store.beginTransaction('readonly'), node = this.findINode(tx, p), data = tx.get(node.id);
	        if (data === undefined) {
	            throw ApiError.ENOENT(p);
	        }
	        return new SyncKeyValueFile(this, p, flag, node.toStats(), data);
	    };
	    SyncKeyValueFileSystem.prototype.unlinkSync = function unlinkSync (p) {
	        this.removeEntry(p, false);
	    };
	    SyncKeyValueFileSystem.prototype.rmdirSync = function rmdirSync (p) {
	        // Check first if directory is empty.
	        if (this.readdirSync(p).length > 0) {
	            throw ApiError.ENOTEMPTY(p);
	        }
	        else {
	            this.removeEntry(p, true);
	        }
	    };
	    SyncKeyValueFileSystem.prototype.mkdirSync = function mkdirSync (p, mode) {
	        var tx = this.store.beginTransaction('readwrite'), data = Buffer.from('{}');
	        this.commitNewFile(tx, p, FileType.DIRECTORY, mode, data);
	    };
	    SyncKeyValueFileSystem.prototype.readdirSync = function readdirSync (p) {
	        var tx = this.store.beginTransaction('readonly');
	        return Object.keys(this.getDirListing(tx, p, this.findINode(tx, p)));
	    };
	    SyncKeyValueFileSystem.prototype._syncSync = function _syncSync (p, data, stats) {
	        // @todo Ensure mtime updates properly, and use that to determine if a data
	        //       update is required.
	        var tx = this.store.beginTransaction('readwrite'), 
	        // We use the _findInode helper because we actually need the INode id.
	        fileInodeId = this._findINode(tx, path.dirname(p), path.basename(p)), fileInode = this.getINode(tx, p, fileInodeId), inodeChanged = fileInode.update(stats);
	        try {
	            // Sync data.
	            tx.put(fileInode.id, data, true);
	            // Sync metadata.
	            if (inodeChanged) {
	                tx.put(fileInodeId, fileInode.toBuffer(), true);
	            }
	        }
	        catch (e) {
	            tx.abort();
	            throw e;
	        }
	        tx.commit();
	    };
	    /**
	     * Checks if the root directory exists. Creates it if it doesn't.
	     */
	    SyncKeyValueFileSystem.prototype.makeRootDirectory = function makeRootDirectory () {
	        var tx = this.store.beginTransaction('readwrite');
	        if (tx.get(ROOT_NODE_ID) === undefined) {
	            // Create new inode.
	            var currTime = (new Date()).getTime(), 
	            // Mode 0666
	            dirInode = new Inode(GenerateRandomID(), 4096, 511 | FileType.DIRECTORY, currTime, currTime, currTime);
	            // If the root doesn't exist, the first random ID shouldn't exist,
	            // either.
	            tx.put(dirInode.id, getEmptyDirNode(), false);
	            tx.put(ROOT_NODE_ID, dirInode.toBuffer(), false);
	            tx.commit();
	        }
	    };
	    /**
	     * Helper function for findINode.
	     * @param parent The parent directory of the file we are attempting to find.
	     * @param filename The filename of the inode we are attempting to find, minus
	     *   the parent.
	     * @return string The ID of the file's inode in the file system.
	     */
	    SyncKeyValueFileSystem.prototype._findINode = function _findINode (tx, parent, filename) {
	        var this$1 = this;
	
	        var readDirectory = function (inode) {
	            // Get the root's directory listing.
	            var dirList = this$1.getDirListing(tx, parent, inode);
	            // Get the file's ID.
	            if (dirList[filename]) {
	                return dirList[filename];
	            }
	            else {
	                throw ApiError.ENOENT(path.resolve(parent, filename));
	            }
	        };
	        if (parent === '/') {
	            if (filename === '') {
	                // BASE CASE #1: Return the root's ID.
	                return ROOT_NODE_ID;
	            }
	            else {
	                // BASE CASE #2: Find the item in the root ndoe.
	                return readDirectory(this.getINode(tx, parent, ROOT_NODE_ID));
	            }
	        }
	        else {
	            return readDirectory(this.getINode(tx, parent + path.sep + filename, this._findINode(tx, path.dirname(parent), path.basename(parent))));
	        }
	    };
	    /**
	     * Finds the Inode of the given path.
	     * @param p The path to look up.
	     * @return The Inode of the path p.
	     * @todo memoize/cache
	     */
	    SyncKeyValueFileSystem.prototype.findINode = function findINode (tx, p) {
	        return this.getINode(tx, p, this._findINode(tx, path.dirname(p), path.basename(p)));
	    };
	    /**
	     * Given the ID of a node, retrieves the corresponding Inode.
	     * @param tx The transaction to use.
	     * @param p The corresponding path to the file (used for error messages).
	     * @param id The ID to look up.
	     */
	    SyncKeyValueFileSystem.prototype.getINode = function getINode (tx, p, id) {
	        var inode = tx.get(id);
	        if (inode === undefined) {
	            throw ApiError.ENOENT(p);
	        }
	        return Inode.fromBuffer(inode);
	    };
	    /**
	     * Given the Inode of a directory, retrieves the corresponding directory
	     * listing.
	     */
	    SyncKeyValueFileSystem.prototype.getDirListing = function getDirListing (tx, p, inode) {
	        if (!inode.isDirectory()) {
	            throw ApiError.ENOTDIR(p);
	        }
	        var data = tx.get(inode.id);
	        if (data === undefined) {
	            throw ApiError.ENOENT(p);
	        }
	        return JSON.parse(data.toString());
	    };
	    /**
	     * Creates a new node under a random ID. Retries 5 times before giving up in
	     * the exceedingly unlikely chance that we try to reuse a random GUID.
	     * @return The GUID that the data was stored under.
	     */
	    SyncKeyValueFileSystem.prototype.addNewNode = function addNewNode (tx, data) {
	        var retries = 0;
	        var currId;
	        while (retries < 5) {
	            try {
	                currId = GenerateRandomID();
	                tx.put(currId, data, false);
	                return currId;
	            }
	            catch (e) {
	                // Ignore and reroll.
	            }
	        }
	        throw new ApiError(ErrorCode.EIO, 'Unable to commit data to key-value store.');
	    };
	    /**
	     * Commits a new file (well, a FILE or a DIRECTORY) to the file system with
	     * the given mode.
	     * Note: This will commit the transaction.
	     * @param p The path to the new file.
	     * @param type The type of the new file.
	     * @param mode The mode to create the new file with.
	     * @param data The data to store at the file's data node.
	     * @return The Inode for the new file.
	     */
	    SyncKeyValueFileSystem.prototype.commitNewFile = function commitNewFile (tx, p, type, mode, data) {
	        var parentDir = path.dirname(p), fname = path.basename(p), parentNode = this.findINode(tx, parentDir), dirListing = this.getDirListing(tx, parentDir, parentNode), currTime = (new Date()).getTime();
	        // Invariant: The root always exists.
	        // If we don't check this prior to taking steps below, we will create a
	        // file with name '' in root should p == '/'.
	        if (p === '/') {
	            throw ApiError.EEXIST(p);
	        }
	        // Check if file already exists.
	        if (dirListing[fname]) {
	            throw ApiError.EEXIST(p);
	        }
	        var fileNode;
	        try {
	            // Commit data.
	            var dataId = this.addNewNode(tx, data);
	            fileNode = new Inode(dataId, data.length, mode | type, currTime, currTime, currTime);
	            // Commit file node.
	            var fileNodeId = this.addNewNode(tx, fileNode.toBuffer());
	            // Update and commit parent directory listing.
	            dirListing[fname] = fileNodeId;
	            tx.put(parentNode.id, Buffer.from(JSON.stringify(dirListing)), true);
	        }
	        catch (e) {
	            tx.abort();
	            throw e;
	        }
	        tx.commit();
	        return fileNode;
	    };
	    /**
	     * Remove all traces of the given path from the file system.
	     * @param p The path to remove from the file system.
	     * @param isDir Does the path belong to a directory, or a file?
	     * @todo Update mtime.
	     */
	    SyncKeyValueFileSystem.prototype.removeEntry = function removeEntry (p, isDir) {
	        var tx = this.store.beginTransaction('readwrite'), parent = path.dirname(p), parentNode = this.findINode(tx, parent), parentListing = this.getDirListing(tx, parent, parentNode), fileName = path.basename(p);
	        if (!parentListing[fileName]) {
	            throw ApiError.ENOENT(p);
	        }
	        // Remove from directory listing of parent.
	        var fileNodeId = parentListing[fileName];
	        delete parentListing[fileName];
	        // Get file inode.
	        var fileNode = this.getINode(tx, p, fileNodeId);
	        if (!isDir && fileNode.isDirectory()) {
	            throw ApiError.EISDIR(p);
	        }
	        else if (isDir && !fileNode.isDirectory()) {
	            throw ApiError.ENOTDIR(p);
	        }
	        try {
	            // Delete data.
	            tx.del(fileNode.id);
	            // Delete node.
	            tx.del(fileNodeId);
	            // Update directory listing.
	            tx.put(parentNode.id, Buffer.from(JSON.stringify(parentListing)), true);
	        }
	        catch (e) {
	            tx.abort();
	            throw e;
	        }
	        // Success.
	        tx.commit();
	    };
	
	    return SyncKeyValueFileSystem;
	}(SynchronousFileSystem));
	var AsyncKeyValueFile = (function (PreloadFile$$1) {
	    function AsyncKeyValueFile(_fs, _path, _flag, _stat, contents) {
	        PreloadFile$$1.call(this, _fs, _path, _flag, _stat, contents);
	    }
	
	    if ( PreloadFile$$1 ) AsyncKeyValueFile.__proto__ = PreloadFile$$1;
	    AsyncKeyValueFile.prototype = Object.create( PreloadFile$$1 && PreloadFile$$1.prototype );
	    AsyncKeyValueFile.prototype.constructor = AsyncKeyValueFile;
	    AsyncKeyValueFile.prototype.sync = function sync (cb) {
	        var this$1 = this;
	
	        if (this.isDirty()) {
	            this._fs._sync(this.getPath(), this.getBuffer(), this.getStats(), function (e) {
	                if (!e) {
	                    this$1.resetDirty();
	                }
	                cb(e);
	            });
	        }
	        else {
	            cb();
	        }
	    };
	    AsyncKeyValueFile.prototype.close = function close (cb) {
	        this.sync(cb);
	    };
	
	    return AsyncKeyValueFile;
	}(PreloadFile));
	/**
	 * An "Asynchronous key-value file system". Stores data to/retrieves data from
	 * an underlying asynchronous key-value store.
	 */
	var AsyncKeyValueFileSystem = (function (BaseFileSystem$$1) {
	    function AsyncKeyValueFileSystem () {
	        BaseFileSystem$$1.apply(this, arguments);
	    }
	
	    if ( BaseFileSystem$$1 ) AsyncKeyValueFileSystem.__proto__ = BaseFileSystem$$1;
	    AsyncKeyValueFileSystem.prototype = Object.create( BaseFileSystem$$1 && BaseFileSystem$$1.prototype );
	    AsyncKeyValueFileSystem.prototype.constructor = AsyncKeyValueFileSystem;
	
	    AsyncKeyValueFileSystem.isAvailable = function isAvailable () { return true; };
	    /**
	     * Initializes the file system. Typically called by subclasses' async
	     * constructors.
	     */
	    AsyncKeyValueFileSystem.prototype.init = function init (store, cb) {
	        this.store = store;
	        // INVARIANT: Ensure that the root exists.
	        this.makeRootDirectory(cb);
	    };
	    AsyncKeyValueFileSystem.prototype.getName = function getName () { return this.store.name(); };
	    AsyncKeyValueFileSystem.prototype.isReadOnly = function isReadOnly () { return false; };
	    AsyncKeyValueFileSystem.prototype.supportsSymlinks = function supportsSymlinks () { return false; };
	    AsyncKeyValueFileSystem.prototype.supportsProps = function supportsProps () { return false; };
	    AsyncKeyValueFileSystem.prototype.supportsSynch = function supportsSynch () { return false; };
	    /**
	     * Delete all contents stored in the file system.
	     */
	    AsyncKeyValueFileSystem.prototype.empty = function empty (cb) {
	        var this$1 = this;
	
	        this.store.clear(function (e) {
	            if (noError(e, cb)) {
	                // INVARIANT: Root always exists.
	                this$1.makeRootDirectory(cb);
	            }
	        });
	    };
	    AsyncKeyValueFileSystem.prototype.rename = function rename (oldPath, newPath, cb) {
	        var this$1 = this;
	
	        var tx = this.store.beginTransaction('readwrite');
	        var oldParent = path.dirname(oldPath), oldName = path.basename(oldPath);
	        var newParent = path.dirname(newPath), newName = path.basename(newPath);
	        var inodes = {};
	        var lists = {};
	        var errorOccurred = false;
	        // Invariant: Can't move a folder inside itself.
	        // This funny little hack ensures that the check passes only if oldPath
	        // is a subpath of newParent. We append '/' to avoid matching folders that
	        // are a substring of the bottom-most folder in the path.
	        if ((newParent + '/').indexOf(oldPath + '/') === 0) {
	            return cb(new ApiError(ErrorCode.EBUSY, oldParent));
	        }
	        /**
	         * Responsible for Phase 2 of the rename operation: Modifying and
	         * committing the directory listings. Called once we have successfully
	         * retrieved both the old and new parent's inodes and listings.
	         */
	        var theOleSwitcharoo = function () {
	            // Sanity check: Ensure both paths are present, and no error has occurred.
	            if (errorOccurred || !lists.hasOwnProperty(oldParent) || !lists.hasOwnProperty(newParent)) {
	                return;
	            }
	            var oldParentList = lists[oldParent], oldParentINode = inodes[oldParent], newParentList = lists[newParent], newParentINode = inodes[newParent];
	            // Delete file from old parent.
	            if (!oldParentList[oldName]) {
	                cb(ApiError.ENOENT(oldPath));
	            }
	            else {
	                var fileId = oldParentList[oldName];
	                delete oldParentList[oldName];
	                // Finishes off the renaming process by adding the file to the new
	                // parent.
	                var completeRename = function () {
	                    newParentList[newName] = fileId;
	                    // Commit old parent's list.
	                    tx.put(oldParentINode.id, Buffer.from(JSON.stringify(oldParentList)), true, function (e) {
	                        if (noErrorTx(e, tx, cb)) {
	                            if (oldParent === newParent) {
	                                // DONE!
	                                tx.commit(cb);
	                            }
	                            else {
	                                // Commit new parent's list.
	                                tx.put(newParentINode.id, Buffer.from(JSON.stringify(newParentList)), true, function (e) {
	                                    if (noErrorTx(e, tx, cb)) {
	                                        tx.commit(cb);
	                                    }
	                                });
	                            }
	                        }
	                    });
	                };
	                if (newParentList[newName]) {
	                    // 'newPath' already exists. Check if it's a file or a directory, and
	                    // act accordingly.
	                    this$1.getINode(tx, newPath, newParentList[newName], function (e, inode) {
	                        if (noErrorTx(e, tx, cb)) {
	                            if (inode.isFile()) {
	                                // Delete the file and continue.
	                                tx.del(inode.id, function (e) {
	                                    if (noErrorTx(e, tx, cb)) {
	                                        tx.del(newParentList[newName], function (e) {
	                                            if (noErrorTx(e, tx, cb)) {
	                                                completeRename();
	                                            }
	                                        });
	                                    }
	                                });
	                            }
	                            else {
	                                // Can't overwrite a directory using rename.
	                                tx.abort(function (e) {
	                                    cb(ApiError.EPERM(newPath));
	                                });
	                            }
	                        }
	                    });
	                }
	                else {
	                    completeRename();
	                }
	            }
	        };
	        /**
	         * Grabs a path's inode and directory listing, and shoves it into the
	         * inodes and lists hashes.
	         */
	        var processInodeAndListings = function (p) {
	            this$1.findINodeAndDirListing(tx, p, function (e, node, dirList) {
	                if (e) {
	                    if (!errorOccurred) {
	                        errorOccurred = true;
	                        tx.abort(function () {
	                            cb(e);
	                        });
	                    }
	                    // If error has occurred already, just stop here.
	                }
	                else {
	                    inodes[p] = node;
	                    lists[p] = dirList;
	                    theOleSwitcharoo();
	                }
	            });
	        };
	        processInodeAndListings(oldParent);
	        if (oldParent !== newParent) {
	            processInodeAndListings(newParent);
	        }
	    };
	    AsyncKeyValueFileSystem.prototype.stat = function stat (p, isLstat, cb) {
	        var tx = this.store.beginTransaction('readonly');
	        this.findINode(tx, p, function (e, inode) {
	            if (noError(e, cb)) {
	                cb(null, inode.toStats());
	            }
	        });
	    };
	    AsyncKeyValueFileSystem.prototype.createFile = function createFile (p, flag, mode, cb) {
	        var this$1 = this;
	
	        var tx = this.store.beginTransaction('readwrite'), data = emptyBuffer();
	        this.commitNewFile(tx, p, FileType.FILE, mode, data, function (e, newFile) {
	            if (noError(e, cb)) {
	                cb(null, new AsyncKeyValueFile(this$1, p, flag, newFile.toStats(), data));
	            }
	        });
	    };
	    AsyncKeyValueFileSystem.prototype.openFile = function openFile (p, flag, cb) {
	        var this$1 = this;
	
	        var tx = this.store.beginTransaction('readonly');
	        // Step 1: Grab the file's inode.
	        this.findINode(tx, p, function (e, inode) {
	            if (noError(e, cb)) {
	                // Step 2: Grab the file's data.
	                tx.get(inode.id, function (e, data) {
	                    if (noError(e, cb)) {
	                        if (data === undefined) {
	                            cb(ApiError.ENOENT(p));
	                        }
	                        else {
	                            cb(null, new AsyncKeyValueFile(this$1, p, flag, inode.toStats(), data));
	                        }
	                    }
	                });
	            }
	        });
	    };
	    AsyncKeyValueFileSystem.prototype.unlink = function unlink (p, cb) {
	        this.removeEntry(p, false, cb);
	    };
	    AsyncKeyValueFileSystem.prototype.rmdir = function rmdir (p, cb) {
	        var this$1 = this;
	
	        // Check first if directory is empty.
	        this.readdir(p, function (err, files) {
	            if (err) {
	                cb(err);
	            }
	            else if (files.length > 0) {
	                cb(ApiError.ENOTEMPTY(p));
	            }
	            else {
	                this$1.removeEntry(p, true, cb);
	            }
	        });
	    };
	    AsyncKeyValueFileSystem.prototype.mkdir = function mkdir (p, mode, cb) {
	        var tx = this.store.beginTransaction('readwrite'), data = Buffer.from('{}');
	        this.commitNewFile(tx, p, FileType.DIRECTORY, mode, data, cb);
	    };
	    AsyncKeyValueFileSystem.prototype.readdir = function readdir (p, cb) {
	        var this$1 = this;
	
	        var tx = this.store.beginTransaction('readonly');
	        this.findINode(tx, p, function (e, inode) {
	            if (noError(e, cb)) {
	                this$1.getDirListing(tx, p, inode, function (e, dirListing) {
	                    if (noError(e, cb)) {
	                        cb(null, Object.keys(dirListing));
	                    }
	                });
	            }
	        });
	    };
	    AsyncKeyValueFileSystem.prototype._sync = function _sync (p, data, stats, cb) {
	        var this$1 = this;
	
	        // @todo Ensure mtime updates properly, and use that to determine if a data
	        //       update is required.
	        var tx = this.store.beginTransaction('readwrite');
	        // Step 1: Get the file node's ID.
	        this._findINode(tx, path.dirname(p), path.basename(p), function (e, fileInodeId) {
	            if (noErrorTx(e, tx, cb)) {
	                // Step 2: Get the file inode.
	                this$1.getINode(tx, p, fileInodeId, function (e, fileInode) {
	                    if (noErrorTx(e, tx, cb)) {
	                        var inodeChanged = fileInode.update(stats);
	                        // Step 3: Sync the data.
	                        tx.put(fileInode.id, data, true, function (e) {
	                            if (noErrorTx(e, tx, cb)) {
	                                // Step 4: Sync the metadata (if it changed)!
	                                if (inodeChanged) {
	                                    tx.put(fileInodeId, fileInode.toBuffer(), true, function (e) {
	                                        if (noErrorTx(e, tx, cb)) {
	                                            tx.commit(cb);
	                                        }
	                                    });
	                                }
	                                else {
	                                    // No need to sync metadata; return.
	                                    tx.commit(cb);
	                                }
	                            }
	                        });
	                    }
	                });
	            }
	        });
	    };
	    /**
	     * Checks if the root directory exists. Creates it if it doesn't.
	     */
	    AsyncKeyValueFileSystem.prototype.makeRootDirectory = function makeRootDirectory (cb) {
	        var tx = this.store.beginTransaction('readwrite');
	        tx.get(ROOT_NODE_ID, function (e, data) {
	            if (e || data === undefined) {
	                // Create new inode.
	                var currTime = (new Date()).getTime(), 
	                // Mode 0666
	                dirInode = new Inode(GenerateRandomID(), 4096, 511 | FileType.DIRECTORY, currTime, currTime, currTime);
	                // If the root doesn't exist, the first random ID shouldn't exist,
	                // either.
	                tx.put(dirInode.id, getEmptyDirNode(), false, function (e) {
	                    if (noErrorTx(e, tx, cb)) {
	                        tx.put(ROOT_NODE_ID, dirInode.toBuffer(), false, function (e) {
	                            if (e) {
	                                tx.abort(function () { cb(e); });
	                            }
	                            else {
	                                tx.commit(cb);
	                            }
	                        });
	                    }
	                });
	            }
	            else {
	                // We're good.
	                tx.commit(cb);
	            }
	        });
	    };
	    /**
	     * Helper function for findINode.
	     * @param parent The parent directory of the file we are attempting to find.
	     * @param filename The filename of the inode we are attempting to find, minus
	     *   the parent.
	     * @param cb Passed an error or the ID of the file's inode in the file system.
	     */
	    AsyncKeyValueFileSystem.prototype._findINode = function _findINode (tx, parent, filename, cb) {
	        var this$1 = this;
	
	        var handleDirectoryListings = function (e, inode, dirList) {
	            if (e) {
	                cb(e);
	            }
	            else if (dirList[filename]) {
	                cb(null, dirList[filename]);
	            }
	            else {
	                cb(ApiError.ENOENT(path.resolve(parent, filename)));
	            }
	        };
	        if (parent === '/') {
	            if (filename === '') {
	                // BASE CASE #1: Return the root's ID.
	                cb(null, ROOT_NODE_ID);
	            }
	            else {
	                // BASE CASE #2: Find the item in the root node.
	                this.getINode(tx, parent, ROOT_NODE_ID, function (e, inode) {
	                    if (noError(e, cb)) {
	                        this$1.getDirListing(tx, parent, inode, function (e, dirList) {
	                            // handle_directory_listings will handle e for us.
	                            handleDirectoryListings(e, inode, dirList);
	                        });
	                    }
	                });
	            }
	        }
	        else {
	            // Get the parent directory's INode, and find the file in its directory
	            // listing.
	            this.findINodeAndDirListing(tx, parent, handleDirectoryListings);
	        }
	    };
	    /**
	     * Finds the Inode of the given path.
	     * @param p The path to look up.
	     * @param cb Passed an error or the Inode of the path p.
	     * @todo memoize/cache
	     */
	    AsyncKeyValueFileSystem.prototype.findINode = function findINode (tx, p, cb) {
	        var this$1 = this;
	
	        this._findINode(tx, path.dirname(p), path.basename(p), function (e, id) {
	            if (noError(e, cb)) {
	                this$1.getINode(tx, p, id, cb);
	            }
	        });
	    };
	    /**
	     * Given the ID of a node, retrieves the corresponding Inode.
	     * @param tx The transaction to use.
	     * @param p The corresponding path to the file (used for error messages).
	     * @param id The ID to look up.
	     * @param cb Passed an error or the inode under the given id.
	     */
	    AsyncKeyValueFileSystem.prototype.getINode = function getINode (tx, p, id, cb) {
	        tx.get(id, function (e, data) {
	            if (noError(e, cb)) {
	                if (data === undefined) {
	                    cb(ApiError.ENOENT(p));
	                }
	                else {
	                    cb(null, Inode.fromBuffer(data));
	                }
	            }
	        });
	    };
	    /**
	     * Given the Inode of a directory, retrieves the corresponding directory
	     * listing.
	     */
	    AsyncKeyValueFileSystem.prototype.getDirListing = function getDirListing (tx, p, inode, cb) {
	        if (!inode.isDirectory()) {
	            cb(ApiError.ENOTDIR(p));
	        }
	        else {
	            tx.get(inode.id, function (e, data) {
	                if (noError(e, cb)) {
	                    try {
	                        cb(null, JSON.parse(data.toString()));
	                    }
	                    catch (e) {
	                        // Occurs when data is undefined, or corresponds to something other
	                        // than a directory listing. The latter should never occur unless
	                        // the file system is corrupted.
	                        cb(ApiError.ENOENT(p));
	                    }
	                }
	            });
	        }
	    };
	    /**
	     * Given a path to a directory, retrieves the corresponding INode and
	     * directory listing.
	     */
	    AsyncKeyValueFileSystem.prototype.findINodeAndDirListing = function findINodeAndDirListing (tx, p, cb) {
	        var this$1 = this;
	
	        this.findINode(tx, p, function (e, inode) {
	            if (noError(e, cb)) {
	                this$1.getDirListing(tx, p, inode, function (e, listing) {
	                    if (noError(e, cb)) {
	                        cb(null, inode, listing);
	                    }
	                });
	            }
	        });
	    };
	    /**
	     * Adds a new node under a random ID. Retries 5 times before giving up in
	     * the exceedingly unlikely chance that we try to reuse a random GUID.
	     * @param cb Passed an error or the GUID that the data was stored under.
	     */
	    AsyncKeyValueFileSystem.prototype.addNewNode = function addNewNode (tx, data, cb) {
	        var retries = 0, currId;
	        var reroll = function () {
	            if (++retries === 5) {
	                // Max retries hit. Return with an error.
	                cb(new ApiError(ErrorCode.EIO, 'Unable to commit data to key-value store.'));
	            }
	            else {
	                // Try again.
	                currId = GenerateRandomID();
	                tx.put(currId, data, false, function (e, committed) {
	                    if (e || !committed) {
	                        reroll();
	                    }
	                    else {
	                        // Successfully stored under 'currId'.
	                        cb(null, currId);
	                    }
	                });
	            }
	        };
	        reroll();
	    };
	    /**
	     * Commits a new file (well, a FILE or a DIRECTORY) to the file system with
	     * the given mode.
	     * Note: This will commit the transaction.
	     * @param p The path to the new file.
	     * @param type The type of the new file.
	     * @param mode The mode to create the new file with.
	     * @param data The data to store at the file's data node.
	     * @param cb Passed an error or the Inode for the new file.
	     */
	    AsyncKeyValueFileSystem.prototype.commitNewFile = function commitNewFile (tx, p, type, mode, data, cb) {
	        var this$1 = this;
	
	        var parentDir = path.dirname(p), fname = path.basename(p), currTime = (new Date()).getTime();
	        // Invariant: The root always exists.
	        // If we don't check this prior to taking steps below, we will create a
	        // file with name '' in root should p == '/'.
	        if (p === '/') {
	            return cb(ApiError.EEXIST(p));
	        }
	        // Let's build a pyramid of code!
	        // Step 1: Get the parent directory's inode and directory listing
	        this.findINodeAndDirListing(tx, parentDir, function (e, parentNode, dirListing) {
	            if (noErrorTx(e, tx, cb)) {
	                if (dirListing[fname]) {
	                    // File already exists.
	                    tx.abort(function () {
	                        cb(ApiError.EEXIST(p));
	                    });
	                }
	                else {
	                    // Step 2: Commit data to store.
	                    this$1.addNewNode(tx, data, function (e, dataId) {
	                        if (noErrorTx(e, tx, cb)) {
	                            // Step 3: Commit the file's inode to the store.
	                            var fileInode = new Inode(dataId, data.length, mode | type, currTime, currTime, currTime);
	                            this$1.addNewNode(tx, fileInode.toBuffer(), function (e, fileInodeId) {
	                                if (noErrorTx(e, tx, cb)) {
	                                    // Step 4: Update parent directory's listing.
	                                    dirListing[fname] = fileInodeId;
	                                    tx.put(parentNode.id, Buffer.from(JSON.stringify(dirListing)), true, function (e) {
	                                        if (noErrorTx(e, tx, cb)) {
	                                            // Step 5: Commit and return the new inode.
	                                            tx.commit(function (e) {
	                                                if (noErrorTx(e, tx, cb)) {
	                                                    cb(null, fileInode);
	                                                }
	                                            });
	                                        }
	                                    });
	                                }
	                            });
	                        }
	                    });
	                }
	            }
	        });
	    };
	    /**
	     * Remove all traces of the given path from the file system.
	     * @param p The path to remove from the file system.
	     * @param isDir Does the path belong to a directory, or a file?
	     * @todo Update mtime.
	     */
	    AsyncKeyValueFileSystem.prototype.removeEntry = function removeEntry (p, isDir, cb) {
	        var this$1 = this;
	
	        var tx = this.store.beginTransaction('readwrite'), parent = path.dirname(p), fileName = path.basename(p);
	        // Step 1: Get parent directory's node and directory listing.
	        this.findINodeAndDirListing(tx, parent, function (e, parentNode, parentListing) {
	            if (noErrorTx(e, tx, cb)) {
	                if (!parentListing[fileName]) {
	                    tx.abort(function () {
	                        cb(ApiError.ENOENT(p));
	                    });
	                }
	                else {
	                    // Remove from directory listing of parent.
	                    var fileNodeId = parentListing[fileName];
	                    delete parentListing[fileName];
	                    // Step 2: Get file inode.
	                    this$1.getINode(tx, p, fileNodeId, function (e, fileNode) {
	                        if (noErrorTx(e, tx, cb)) {
	                            if (!isDir && fileNode.isDirectory()) {
	                                tx.abort(function () {
	                                    cb(ApiError.EISDIR(p));
	                                });
	                            }
	                            else if (isDir && !fileNode.isDirectory()) {
	                                tx.abort(function () {
	                                    cb(ApiError.ENOTDIR(p));
	                                });
	                            }
	                            else {
	                                // Step 3: Delete data.
	                                tx.del(fileNode.id, function (e) {
	                                    if (noErrorTx(e, tx, cb)) {
	                                        // Step 4: Delete node.
	                                        tx.del(fileNodeId, function (e) {
	                                            if (noErrorTx(e, tx, cb)) {
	                                                // Step 5: Update directory listing.
	                                                tx.put(parentNode.id, Buffer.from(JSON.stringify(parentListing)), true, function (e) {
	                                                    if (noErrorTx(e, tx, cb)) {
	                                                        tx.commit(cb);
	                                                    }
	                                                });
	                                            }
	                                        });
	                                    }
	                                });
	                            }
	                        }
	                    });
	                }
	            }
	        });
	    };
	
	    return AsyncKeyValueFileSystem;
	}(BaseFileSystem));
	
	/**
	 * A simple in-memory key-value store backed by a JavaScript object.
	 */
	var InMemoryStore = function InMemoryStore() {
	    this.store = {};
	};
	InMemoryStore.prototype.name = function name () { return InMemoryFileSystem.Name; };
	InMemoryStore.prototype.clear = function clear () { this.store = {}; };
	InMemoryStore.prototype.beginTransaction = function beginTransaction (type) {
	    return new SimpleSyncRWTransaction(this);
	};
	InMemoryStore.prototype.get = function get (key) {
	    return this.store[key];
	};
	InMemoryStore.prototype.put = function put (key, data, overwrite) {
	    if (!overwrite && this.store.hasOwnProperty(key)) {
	        return false;
	    }
	    this.store[key] = data;
	    return true;
	};
	InMemoryStore.prototype.del = function del (key) {
	    delete this.store[key];
	};
	/**
	 * A simple in-memory file system backed by an InMemoryStore.
	 * Files are not persisted across page loads.
	 */
	var InMemoryFileSystem = (function (SyncKeyValueFileSystem$$1) {
	    function InMemoryFileSystem() {
	        SyncKeyValueFileSystem$$1.call(this, { store: new InMemoryStore() });
	    }
	
	    if ( SyncKeyValueFileSystem$$1 ) InMemoryFileSystem.__proto__ = SyncKeyValueFileSystem$$1;
	    InMemoryFileSystem.prototype = Object.create( SyncKeyValueFileSystem$$1 && SyncKeyValueFileSystem$$1.prototype );
	    InMemoryFileSystem.prototype.constructor = InMemoryFileSystem;
	    /**
	     * Creates an InMemoryFileSystem instance.
	     */
	    InMemoryFileSystem.Create = function Create (options, cb) {
	        cb(null, new InMemoryFileSystem());
	    };
	
	    return InMemoryFileSystem;
	}(SyncKeyValueFileSystem));
	
	InMemoryFileSystem.Name = "InMemory";
	InMemoryFileSystem.Options = {};
	
	/**
	 * Get the indexedDB constructor for the current browser.
	 * @hidden
	 */
	var indexedDB = global$1.indexedDB ||
	    global$1.mozIndexedDB ||
	    global$1.webkitIndexedDB ||
	    global$1.msIndexedDB;
	/**
	 * Converts a DOMException or a DOMError from an IndexedDB event into a
	 * standardized BrowserFS API error.
	 * @hidden
	 */
	function convertError$2(e, message) {
	    if ( message === void 0 ) message = e.toString();
	
	    switch (e.name) {
	        case "NotFoundError":
	            return new ApiError(ErrorCode.ENOENT, message);
	        case "QuotaExceededError":
	            return new ApiError(ErrorCode.ENOSPC, message);
	        default:
	            // The rest do not seem to map cleanly to standard error codes.
	            return new ApiError(ErrorCode.EIO, message);
	    }
	}
	/**
	 * Produces a new onerror handler for IDB. Our errors are always fatal, so we
	 * handle them generically: Call the user-supplied callback with a translated
	 * version of the error, and let the error bubble up.
	 * @hidden
	 */
	function onErrorHandler(cb, code, message) {
	    if ( code === void 0 ) code = ErrorCode.EIO;
	    if ( message === void 0 ) message = null;
	
	    return function (e) {
	        // Prevent the error from canceling the transaction.
	        e.preventDefault();
	        cb(new ApiError(code, message !== null ? message : undefined));
	    };
	}
	/**
	 * @hidden
	 */
	var IndexedDBROTransaction = function IndexedDBROTransaction(tx, store) {
	    this.tx = tx;
	    this.store = store;
	};
	IndexedDBROTransaction.prototype.get = function get (key, cb) {
	    try {
	        var r = this.store.get(key);
	        r.onerror = onErrorHandler(cb);
	        r.onsuccess = function (event) {
	            // IDB returns the value 'undefined' when you try to get keys that
	            // don't exist. The caller expects this behavior.
	            var result = event.target.result;
	            if (result === undefined) {
	                cb(null, result);
	            }
	            else {
	                // IDB data is stored as an ArrayBuffer
	                cb(null, arrayBuffer2Buffer(result));
	            }
	        };
	    }
	    catch (e) {
	        cb(convertError$2(e));
	    }
	};
	/**
	 * @hidden
	 */
	var IndexedDBRWTransaction = (function (IndexedDBROTransaction) {
	    function IndexedDBRWTransaction(tx, store) {
	        IndexedDBROTransaction.call(this, tx, store);
	    }
	
	    if ( IndexedDBROTransaction ) IndexedDBRWTransaction.__proto__ = IndexedDBROTransaction;
	    IndexedDBRWTransaction.prototype = Object.create( IndexedDBROTransaction && IndexedDBROTransaction.prototype );
	    IndexedDBRWTransaction.prototype.constructor = IndexedDBRWTransaction;
	    IndexedDBRWTransaction.prototype.put = function put (key, data, overwrite, cb) {
	        try {
	            var arraybuffer = buffer2ArrayBuffer(data);
	            var r;
	            if (overwrite) {
	                r = this.store.put(arraybuffer, key);
	            }
	            else {
	                // 'add' will never overwrite an existing key.
	                r = this.store.add(arraybuffer, key);
	            }
	            // XXX: NEED TO RETURN FALSE WHEN ADD HAS A KEY CONFLICT. NO ERROR.
	            r.onerror = onErrorHandler(cb);
	            r.onsuccess = function (event) {
	                cb(null, true);
	            };
	        }
	        catch (e) {
	            cb(convertError$2(e));
	        }
	    };
	    IndexedDBRWTransaction.prototype.del = function del (key, cb) {
	        try {
	            // NOTE: IE8 has a bug with identifiers named 'delete' unless used as a string
	            // like this.
	            // http://stackoverflow.com/a/26479152
	            var r = this.store['delete'](key);
	            r.onerror = onErrorHandler(cb);
	            r.onsuccess = function (event) {
	                cb();
	            };
	        }
	        catch (e) {
	            cb(convertError$2(e));
	        }
	    };
	    IndexedDBRWTransaction.prototype.commit = function commit (cb) {
	        // Return to the event loop to commit the transaction.
	        setTimeout(cb, 0);
	    };
	    IndexedDBRWTransaction.prototype.abort = function abort (cb) {
	        var _e = null;
	        try {
	            this.tx.abort();
	        }
	        catch (e) {
	            _e = convertError$2(e);
	        }
	        finally {
	            cb(_e);
	        }
	    };
	
	    return IndexedDBRWTransaction;
	}(IndexedDBROTransaction));
	var IndexedDBStore = function IndexedDBStore(cb, storeName) {
	    var this$1 = this;
	    if ( storeName === void 0 ) storeName = 'browserfs';
	
	    this.storeName = storeName;
	    var openReq = indexedDB.open(this.storeName, 1);
	    openReq.onupgradeneeded = function (event) {
	        var db = event.target.result;
	        // Huh. This should never happen; we're at version 1. Why does another
	        // database exist?
	        if (db.objectStoreNames.contains(this$1.storeName)) {
	            db.deleteObjectStore(this$1.storeName);
	        }
	        db.createObjectStore(this$1.storeName);
	    };
	    openReq.onsuccess = function (event) {
	        this$1.db = event.target.result;
	        cb(null, this$1);
	    };
	    openReq.onerror = onErrorHandler(cb, ErrorCode.EACCES);
	};
	IndexedDBStore.prototype.name = function name () {
	    return IndexedDBFileSystem.Name + " - " + this.storeName;
	};
	IndexedDBStore.prototype.clear = function clear (cb) {
	    try {
	        var tx = this.db.transaction(this.storeName, 'readwrite'), objectStore = tx.objectStore(this.storeName), r = objectStore.clear();
	        r.onsuccess = function (event) {
	            // Use setTimeout to commit transaction.
	            setTimeout(cb, 0);
	        };
	        r.onerror = onErrorHandler(cb);
	    }
	    catch (e) {
	        cb(convertError$2(e));
	    }
	};
	IndexedDBStore.prototype.beginTransaction = function beginTransaction (type) {
	        if ( type === void 0 ) type = 'readonly';
	
	    var tx = this.db.transaction(this.storeName, type), objectStore = tx.objectStore(this.storeName);
	    if (type === 'readwrite') {
	        return new IndexedDBRWTransaction(tx, objectStore);
	    }
	    else if (type === 'readonly') {
	        return new IndexedDBROTransaction(tx, objectStore);
	    }
	    else {
	        throw new ApiError(ErrorCode.EINVAL, 'Invalid transaction type.');
	    }
	};
	/**
	 * A file system that uses the IndexedDB key value file system.
	 */
	var IndexedDBFileSystem = (function (AsyncKeyValueFileSystem$$1) {
	    function IndexedDBFileSystem(cb, storeName, deprecateMsg) {
	        var this$1 = this;
	        if ( deprecateMsg === void 0 ) deprecateMsg = true;
	
	        AsyncKeyValueFileSystem$$1.call(this);
	        this.store = new IndexedDBStore(function (e) {
	            if (e) {
	                cb(e);
	            }
	            else {
	                this$1.init(this$1.store, function (e) {
	                    cb(e, this$1);
	                });
	            }
	        }, storeName);
	        deprecationMessage(deprecateMsg, IndexedDBFileSystem.Name, { storeName: storeName });
	    }
	
	    if ( AsyncKeyValueFileSystem$$1 ) IndexedDBFileSystem.__proto__ = AsyncKeyValueFileSystem$$1;
	    IndexedDBFileSystem.prototype = Object.create( AsyncKeyValueFileSystem$$1 && AsyncKeyValueFileSystem$$1.prototype );
	    IndexedDBFileSystem.prototype.constructor = IndexedDBFileSystem;
	    /**
	     * Constructs an IndexedDB file system with the given options.
	     */
	    IndexedDBFileSystem.Create = function Create (opts, cb) {
	        // tslint:disable-next-line:no-unused-new
	        new IndexedDBFileSystem(cb, opts.storeName, false);
	        // tslint:enable-next-line:no-unused-new
	    };
	    IndexedDBFileSystem.isAvailable = function isAvailable () {
	        // In Safari's private browsing mode, indexedDB.open returns NULL.
	        // In Firefox, it throws an exception.
	        // In Chrome, it "just works", and clears the database when you leave the page.
	        // Untested: Opera, IE.
	        try {
	            return typeof indexedDB !== 'undefined' && null !== indexedDB.open("__browserfs_test__");
	        }
	        catch (e) {
	            return false;
	        }
	    };
	
	    return IndexedDBFileSystem;
	}(AsyncKeyValueFileSystem));
	
	IndexedDBFileSystem.Name = "IndexedDB";
	IndexedDBFileSystem.Options = {
	    storeName: {
	        type: "string",
	        optional: true,
	        description: "The name of this file system. You can have multiple IndexedDB file systems operating at once, but each must have a different name."
	    }
	};
	
	/**
	 * Some versions of FF and all versions of IE do not support the full range of
	 * 16-bit numbers encoded as characters, as they enforce UTF-16 restrictions.
	 * @url http://stackoverflow.com/questions/11170716/are-there-any-characters-that-are-not-allowed-in-localstorage/11173673#11173673
	 * @hidden
	 */
	var supportsBinaryString = false;
	var binaryEncoding;
	try {
	    global$1.localStorage.setItem("__test__", String.fromCharCode(0xD800));
	    supportsBinaryString = global$1.localStorage.getItem("__test__") === String.fromCharCode(0xD800);
	}
	catch (e) {
	    // IE throws an exception.
	    supportsBinaryString = false;
	}
	binaryEncoding = supportsBinaryString ? 'binary_string' : 'binary_string_ie';
	if (!Buffer.isEncoding(binaryEncoding)) {
	    // Fallback for non BrowserFS implementations of buffer that lack a
	    // binary_string format.
	    binaryEncoding = "base64";
	}
	/**
	 * A synchronous key-value store backed by localStorage.
	 */
	var LocalStorageStore = function LocalStorageStore () {};
	
	LocalStorageStore.prototype.name = function name () {
	    return LocalStorageFileSystem.Name;
	};
	LocalStorageStore.prototype.clear = function clear () {
	    global$1.localStorage.clear();
	};
	LocalStorageStore.prototype.beginTransaction = function beginTransaction (type) {
	    // No need to differentiate.
	    return new SimpleSyncRWTransaction(this);
	};
	LocalStorageStore.prototype.get = function get (key) {
	    try {
	        var data = global$1.localStorage.getItem(key);
	        if (data !== null) {
	            return Buffer.from(data, binaryEncoding);
	        }
	    }
	    catch (e) {
	        // Do nothing.
	    }
	    // Key doesn't exist, or a failure occurred.
	    return undefined;
	};
	LocalStorageStore.prototype.put = function put (key, data, overwrite) {
	    try {
	        if (!overwrite && global$1.localStorage.getItem(key) !== null) {
	            // Don't want to overwrite the key!
	            return false;
	        }
	        global$1.localStorage.setItem(key, data.toString(binaryEncoding));
	        return true;
	    }
	    catch (e) {
	        throw new ApiError(ErrorCode.ENOSPC, "LocalStorage is full.");
	    }
	};
	LocalStorageStore.prototype.del = function del (key) {
	    try {
	        global$1.localStorage.removeItem(key);
	    }
	    catch (e) {
	        throw new ApiError(ErrorCode.EIO, "Unable to delete key " + key + ": " + e);
	    }
	};
	/**
	 * A synchronous file system backed by localStorage. Connects our
	 * LocalStorageStore to our SyncKeyValueFileSystem.
	 */
	var LocalStorageFileSystem = (function (SyncKeyValueFileSystem$$1) {
	    function LocalStorageFileSystem() { SyncKeyValueFileSystem$$1.call(this, { store: new LocalStorageStore() }); }
	
	    if ( SyncKeyValueFileSystem$$1 ) LocalStorageFileSystem.__proto__ = SyncKeyValueFileSystem$$1;
	    LocalStorageFileSystem.prototype = Object.create( SyncKeyValueFileSystem$$1 && SyncKeyValueFileSystem$$1.prototype );
	    LocalStorageFileSystem.prototype.constructor = LocalStorageFileSystem;
	    /**
	     * Creates a LocalStorageFileSystem instance.
	     */
	    LocalStorageFileSystem.Create = function Create (options, cb) {
	        cb(null, new LocalStorageFileSystem());
	    };
	    LocalStorageFileSystem.isAvailable = function isAvailable () {
	        return typeof global$1.localStorage !== 'undefined';
	    };
	
	    return LocalStorageFileSystem;
	}(SyncKeyValueFileSystem));
	
	LocalStorageFileSystem.Name = "LocalStorage";
	LocalStorageFileSystem.Options = {};
	
	/**
	 * The MountableFileSystem allows you to mount multiple backend types or
	 * multiple instantiations of the same backend into a single file system tree.
	 * The file systems do not need to know about each other; all interactions are
	 * automatically facilitated through this interface.
	 *
	 * For example, if a file system is mounted at /mnt/blah, and a request came in
	 * for /mnt/blah/foo.txt, the file system would see a request for /foo.txt.
	 *
	 * You can mount file systems when you configure the file system:
	 * ```javascript
	 * BrowserFS.configure({
	 *   fs: "MountableFileSystem",
	 *   options: {
	 *     '/data': { fs: 'XmlHttpRequest', options: { index: "http://mysite.com/files/index.json" } },
	 *     '/home': { fs: 'LocalStorage' }
	 *   }
	 * }, function(e) {
	 *
	 * });
	 * ```
	 *
	 * For advanced users, you can also mount file systems *after* MFS is constructed:
	 * ```javascript
	 * BrowserFS.FileSystem.XmlHttpRequest.Create({
	 *   index: "http://mysite.com/files/index.json"
	 * }, function(e, xhrfs) {
	 *   BrowserFS.FileSystem.MountableFileSystem.Create({
	 *     '/data': xhrfs
	 *   }, function(e, mfs) {
	 *     BrowserFS.initialize(mfs);
	 *
	 *     // Added after-the-fact...
	 *     BrowserFS.FileSystem.LocalStorage.Create(function(e, lsfs) {
	 *       mfs.mount('/home', lsfs);
	 *     });
	 *   });
	 * });
	 * ```
	 *
	 * Since MountableFileSystem simply proxies requests to mounted file systems, it supports all of the operations that the mounted file systems support.
	 *
	 * With no mounted file systems, `MountableFileSystem` acts as a simple `InMemory` filesystem.
	 */
	var MountableFileSystem = (function (BaseFileSystem$$1) {
	    function MountableFileSystem() {
	        BaseFileSystem$$1.call(this);
	        // Contains the list of mount points in mntMap, sorted by string length in decreasing order.
	        // Ensures that we scan the most specific mount points for a match first, which lets us
	        // nest mount points.
	        this.mountList = [];
	        this.mntMap = {};
	        // The InMemory file system serves purely to provide directory listings for
	        // mounted file systems.
	        this.rootFs = new InMemoryFileSystem();
	    }
	
	    if ( BaseFileSystem$$1 ) MountableFileSystem.__proto__ = BaseFileSystem$$1;
	    MountableFileSystem.prototype = Object.create( BaseFileSystem$$1 && BaseFileSystem$$1.prototype );
	    MountableFileSystem.prototype.constructor = MountableFileSystem;
	    /**
	     * Creates a MountableFileSystem instance with the given options.
	     */
	    MountableFileSystem.Create = function Create (opts, cb) {
	        var fs = new MountableFileSystem();
	        Object.keys(opts).forEach(function (mountPoint) {
	            fs.mount(mountPoint, opts[mountPoint]);
	        });
	        cb(null, fs);
	    };
	    MountableFileSystem.isAvailable = function isAvailable () {
	        return true;
	    };
	    /**
	     * Mounts the file system at the given mount point.
	     */
	    MountableFileSystem.prototype.mount = function mount (mountPoint, fs) {
	        if (mountPoint[0] !== '/') {
	            mountPoint = "/" + mountPoint;
	        }
	        mountPoint = path.resolve(mountPoint);
	        if (this.mntMap[mountPoint]) {
	            throw new ApiError(ErrorCode.EINVAL, "Mount point " + mountPoint + " is already taken.");
	        }
	        mkdirpSync(mountPoint, 0x1ff, this.rootFs);
	        this.mntMap[mountPoint] = fs;
	        this.mountList.push(mountPoint);
	        this.mountList = this.mountList.sort(function (a, b) { return b.length - a.length; });
	    };
	    MountableFileSystem.prototype.umount = function umount (mountPoint) {
	        var this$1 = this;
	
	        if (mountPoint[0] !== '/') {
	            mountPoint = "/" + mountPoint;
	        }
	        mountPoint = path.resolve(mountPoint);
	        if (!this.mntMap[mountPoint]) {
	            throw new ApiError(ErrorCode.EINVAL, "Mount point " + mountPoint + " is already unmounted.");
	        }
	        delete this.mntMap[mountPoint];
	        this.mountList.splice(this.mountList.indexOf(mountPoint), 1);
	        while (mountPoint !== '/') {
	            if (this$1.rootFs.readdirSync(mountPoint).length === 0) {
	                this$1.rootFs.rmdirSync(mountPoint);
	                mountPoint = path.dirname(mountPoint);
	            }
	            else {
	                break;
	            }
	        }
	    };
	    /**
	     * Returns the file system that the path points to.
	     */
	    MountableFileSystem.prototype._getFs = function _getFs (path$$1) {
	        var this$1 = this;
	
	        var mountList = this.mountList, len = mountList.length;
	        for (var i = 0; i < len; i++) {
	            var mountPoint = mountList[i];
	            // We know path is normalized, so it is a substring of the mount point.
	            if (mountPoint.length <= path$$1.length && path$$1.indexOf(mountPoint) === 0) {
	                path$$1 = path$$1.substr(mountPoint.length > 1 ? mountPoint.length : 0);
	                if (path$$1 === '') {
	                    path$$1 = '/';
	                }
	                return { fs: this$1.mntMap[mountPoint], path: path$$1 };
	            }
	        }
	        // Query our root file system.
	        return { fs: this.rootFs, path: path$$1 };
	    };
	    // Global information methods
	    MountableFileSystem.prototype.getName = function getName () {
	        return MountableFileSystem.Name;
	    };
	    MountableFileSystem.prototype.diskSpace = function diskSpace (path$$1, cb) {
	        cb(0, 0);
	    };
	    MountableFileSystem.prototype.isReadOnly = function isReadOnly () {
	        return false;
	    };
	    MountableFileSystem.prototype.supportsLinks = function supportsLinks () {
	        // I'm not ready for cross-FS links yet.
	        return false;
	    };
	    MountableFileSystem.prototype.supportsProps = function supportsProps () {
	        return false;
	    };
	    MountableFileSystem.prototype.supportsSynch = function supportsSynch () {
	        return true;
	    };
	    /**
	     * Fixes up error messages so they mention the mounted file location relative
	     * to the MFS root, not to the particular FS's root.
	     * Mutates the input error, and returns it.
	     */
	    MountableFileSystem.prototype.standardizeError = function standardizeError (err, path$$1, realPath) {
	        var index = err.message.indexOf(path$$1);
	        if (index !== -1) {
	            err.message = err.message.substr(0, index) + realPath + err.message.substr(index + path$$1.length);
	            err.path = realPath;
	        }
	        return err;
	    };
	    // The following methods involve multiple file systems, and thus have custom
	    // logic.
	    // Note that we go through the Node API to use its robust default argument
	    // processing.
	    MountableFileSystem.prototype.rename = function rename (oldPath, newPath, cb) {
	        var this$1 = this;
	
	        // Scenario 1: old and new are on same FS.
	        var fs1rv = this._getFs(oldPath);
	        var fs2rv = this._getFs(newPath);
	        if (fs1rv.fs === fs2rv.fs) {
	            return fs1rv.fs.rename(fs1rv.path, fs2rv.path, function (e) {
	                if (e) {
	                    this$1.standardizeError(this$1.standardizeError(e, fs1rv.path, oldPath), fs2rv.path, newPath);
	                }
	                cb(e);
	            });
	        }
	        // Scenario 2: Different file systems.
	        // Read old file, write new file, delete old file.
	        return _fsMock.readFile(oldPath, function (err, data) {
	            if (err) {
	                return cb(err);
	            }
	            _fsMock.writeFile(newPath, data, function (err) {
	                if (err) {
	                    return cb(err);
	                }
	                _fsMock.unlink(oldPath, cb);
	            });
	        });
	    };
	    MountableFileSystem.prototype.renameSync = function renameSync (oldPath, newPath) {
	        // Scenario 1: old and new are on same FS.
	        var fs1rv = this._getFs(oldPath);
	        var fs2rv = this._getFs(newPath);
	        if (fs1rv.fs === fs2rv.fs) {
	            try {
	                return fs1rv.fs.renameSync(fs1rv.path, fs2rv.path);
	            }
	            catch (e) {
	                this.standardizeError(this.standardizeError(e, fs1rv.path, oldPath), fs2rv.path, newPath);
	                throw e;
	            }
	        }
	        // Scenario 2: Different file systems.
	        var data = _fsMock.readFileSync(oldPath);
	        _fsMock.writeFileSync(newPath, data);
	        return _fsMock.unlinkSync(oldPath);
	    };
	    MountableFileSystem.prototype.readdirSync = function readdirSync (p) {
	        var fsInfo = this._getFs(p);
	        // If null, rootfs did not have the directory
	        // (or the target FS is the root fs).
	        var rv = null;
	        // Mount points are all defined in the root FS.
	        // Ensure that we list those, too.
	        if (fsInfo.fs !== this.rootFs) {
	            try {
	                rv = this.rootFs.readdirSync(p);
	            }
	            catch (e) {
	                // Ignore.
	            }
	        }
	        try {
	            var rv2 = fsInfo.fs.readdirSync(fsInfo.path);
	            if (rv === null) {
	                return rv2;
	            }
	            else {
	                // Filter out duplicates.
	                return rv2.concat(rv.filter(function (val) { return rv2.indexOf(val) === -1; }));
	            }
	        }
	        catch (e) {
	            if (rv === null) {
	                throw this.standardizeError(e, fsInfo.path, p);
	            }
	            else {
	                // The root FS had something.
	                return rv;
	            }
	        }
	    };
	    MountableFileSystem.prototype.readdir = function readdir (p, cb) {
	        var this$1 = this;
	
	        var fsInfo = this._getFs(p);
	        fsInfo.fs.readdir(fsInfo.path, function (err, files) {
	            if (fsInfo.fs !== this$1.rootFs) {
	                try {
	                    var rv = this$1.rootFs.readdirSync(p);
	                    if (files) {
	                        // Filter out duplicates.
	                        files = files.concat(rv.filter(function (val) { return files.indexOf(val) === -1; }));
	                    }
	                    else {
	                        files = rv;
	                    }
	                }
	                catch (e) {
	                    // Root FS and target FS did not have directory.
	                    if (err) {
	                        return cb(this$1.standardizeError(err, fsInfo.path, p));
	                    }
	                }
	            }
	            else if (err) {
	                // Root FS and target FS are the same, and did not have directory.
	                return cb(this$1.standardizeError(err, fsInfo.path, p));
	            }
	            cb(null, files);
	        });
	    };
	    MountableFileSystem.prototype.rmdirSync = function rmdirSync (p) {
	        var fsInfo = this._getFs(p);
	        if (this._containsMountPt(p)) {
	            throw ApiError.ENOTEMPTY(p);
	        }
	        else {
	            try {
	                fsInfo.fs.rmdirSync(fsInfo.path);
	            }
	            catch (e) {
	                throw this.standardizeError(e, fsInfo.path, p);
	            }
	        }
	    };
	    MountableFileSystem.prototype.rmdir = function rmdir (p, cb) {
	        var this$1 = this;
	
	        var fsInfo = this._getFs(p);
	        if (this._containsMountPt(p)) {
	            cb(ApiError.ENOTEMPTY(p));
	        }
	        else {
	            fsInfo.fs.rmdir(fsInfo.path, function (err) {
	                cb(err ? this$1.standardizeError(err, fsInfo.path, p) : null);
	            });
	        }
	    };
	    /**
	     * Returns true if the given path contains a mount point.
	     */
	    MountableFileSystem.prototype._containsMountPt = function _containsMountPt (p) {
	        var mountPoints = this.mountList, len = mountPoints.length;
	        for (var i = 0; i < len; i++) {
	            var pt = mountPoints[i];
	            if (pt.length >= p.length && pt.slice(0, p.length) === p) {
	                return true;
	            }
	        }
	        return false;
	    };
	
	    return MountableFileSystem;
	}(BaseFileSystem));
	
	MountableFileSystem.Name = "MountableFileSystem";
	MountableFileSystem.Options = {};
	/**
	 * Tricky: Define all of the functions that merely forward arguments to the
	 * relevant file system, or return/throw an error.
	 * Take advantage of the fact that the *first* argument is always the path, and
	 * the *last* is the callback function (if async).
	 * @todo Can use numArgs to make proxying more efficient.
	 * @hidden
	 */
	function defineFcn(name, isSync, numArgs) {
	    if (isSync) {
	        return function () {
	            var args = [], len = arguments.length;
	            while ( len-- ) args[ len ] = arguments[ len ];
	
	            var path$$1 = args[0];
	            var rv = this._getFs(path$$1);
	            args[0] = rv.path;
	            try {
	                return rv.fs[name].apply(rv.fs, args);
	            }
	            catch (e) {
	                this.standardizeError(e, rv.path, path$$1);
	                throw e;
	            }
	        };
	    }
	    else {
	        return function () {
	            var this$1 = this;
	            var args = [], len = arguments.length;
	            while ( len-- ) args[ len ] = arguments[ len ];
	
	            var path$$1 = args[0];
	            var rv = this._getFs(path$$1);
	            args[0] = rv.path;
	            if (typeof args[args.length - 1] === 'function') {
	                var cb = args[args.length - 1];
	                args[args.length - 1] = function () {
	                    var args = [], len = arguments.length;
	                    while ( len-- ) args[ len ] = arguments[ len ];
	
	                    if (args.length > 0 && args[0] instanceof ApiError) {
	                        this$1.standardizeError(args[0], rv.path, path$$1);
	                    }
	                    cb.apply(null, args);
	                };
	            }
	            return rv.fs[name].apply(rv.fs, args);
	        };
	    }
	}
	/**
	 * @hidden
	 */
	var fsCmdMap = [
	    // 1 arg functions
	    ['exists', 'unlink', 'readlink'],
	    // 2 arg functions
	    ['stat', 'mkdir', 'realpath', 'truncate'],
	    // 3 arg functions
	    ['open', 'readFile', 'chmod', 'utimes'],
	    // 4 arg functions
	    ['chown'],
	    // 5 arg functions
	    ['writeFile', 'appendFile']
	];
	for (var i = 0; i < fsCmdMap.length; i++) {
	    var cmds = fsCmdMap[i];
	    for (var i$1 = 0, list = cmds; i$1 < list.length; i$1 += 1) {
	        var fnName = list[i$1];
	
	        MountableFileSystem.prototype[fnName] = defineFcn(fnName, false, i + 1);
	        MountableFileSystem.prototype[fnName + 'Sync'] = defineFcn(fnName + 'Sync', true, i + 1);
	    }
	}
	
	/**
	 * @hidden
	 */
	var bfsSetImmediate;
	if (typeof (setImmediate) !== "undefined") {
	    bfsSetImmediate = setImmediate;
	}
	else {
	    var gScope = global$1;
	    var timeouts = [];
	    var messageName = "zero-timeout-message";
	    var canUsePostMessage = function () {
	        if (typeof gScope.importScripts !== 'undefined' || !gScope.postMessage) {
	            return false;
	        }
	        var postMessageIsAsync = true;
	        var oldOnMessage = gScope.onmessage;
	        gScope.onmessage = function () {
	            postMessageIsAsync = false;
	        };
	        gScope.postMessage('', '*');
	        gScope.onmessage = oldOnMessage;
	        return postMessageIsAsync;
	    };
	    if (canUsePostMessage()) {
	        bfsSetImmediate = function (fn) {
	            timeouts.push(fn);
	            gScope.postMessage(messageName, "*");
	        };
	        var handleMessage = function (event) {
	            if (event.source === self && event.data === messageName) {
	                if (event.stopPropagation) {
	                    event.stopPropagation();
	                }
	                else {
	                    event.cancelBubble = true;
	                }
	                if (timeouts.length > 0) {
	                    var fn = timeouts.shift();
	                    return fn();
	                }
	            }
	        };
	        if (gScope.addEventListener) {
	            gScope.addEventListener('message', handleMessage, true);
	        }
	        else {
	            gScope.attachEvent('onmessage', handleMessage);
	        }
	    }
	    else if (gScope.MessageChannel) {
	        // WebWorker MessageChannel
	        var channel = new gScope.MessageChannel();
	        channel.port1.onmessage = function (event) {
	            if (timeouts.length > 0) {
	                return timeouts.shift()();
	            }
	        };
	        bfsSetImmediate = function (fn) {
	            timeouts.push(fn);
	            channel.port2.postMessage('');
	        };
	    }
	    else {
	        bfsSetImmediate = function (fn) {
	            return setTimeout(fn, 0);
	        };
	    }
	}
	var setImmediate$3 = bfsSetImmediate;
	
	/**
	 * Non-recursive mutex
	 * @hidden
	 */
	var Mutex = function Mutex() {
	    this._locked = false;
	    this._waiters = [];
	};
	Mutex.prototype.lock = function lock (cb) {
	    if (this._locked) {
	        this._waiters.push(cb);
	        return;
	    }
	    this._locked = true;
	    cb();
	};
	Mutex.prototype.unlock = function unlock () {
	    if (!this._locked) {
	        throw new Error('unlock of a non-locked mutex');
	    }
	    var next = this._waiters.shift();
	    // don't unlock - we want to queue up next for the
	    // _end_ of the current task execution, but we don't
	    // want it to be called inline with whatever the
	    // current stack is.  This way we still get the nice
	    // behavior that an unlock immediately followed by a
	    // lock won't cause starvation.
	    if (next) {
	        setImmediate$3(next);
	        return;
	    }
	    this._locked = false;
	};
	Mutex.prototype.tryLock = function tryLock () {
	    if (this._locked) {
	        return false;
	    }
	    this._locked = true;
	    return true;
	};
	Mutex.prototype.isLocked = function isLocked () {
	    return this._locked;
	};
	
	/**
	 * This class serializes access to an underlying async filesystem.
	 * For example, on an OverlayFS instance with an async lower
	 * directory operations like rename and rmdir may involve multiple
	 * requests involving both the upper and lower filesystems -- they
	 * are not executed in a single atomic step.  OverlayFS uses this
	 * LockedFS to avoid having to reason about the correctness of
	 * multiple requests interleaving.
	 */
	var LockedFS = function LockedFS(fs) {
	    this._fs = fs;
	    this._mu = new Mutex();
	};
	LockedFS.prototype.getName = function getName () {
	    return 'LockedFS<' + this._fs.getName() + '>';
	};
	LockedFS.prototype.getFSUnlocked = function getFSUnlocked () {
	    return this._fs;
	};
	LockedFS.prototype.initialize = function initialize (cb) {
	    // FIXME: check to see if FS supports initialization
	    this._fs.initialize(cb);
	};
	LockedFS.prototype.diskSpace = function diskSpace (p, cb) {
	    // FIXME: should this lock?
	    this._fs.diskSpace(p, cb);
	};
	LockedFS.prototype.isReadOnly = function isReadOnly () {
	    return this._fs.isReadOnly();
	};
	LockedFS.prototype.supportsLinks = function supportsLinks () {
	    return this._fs.supportsLinks();
	};
	LockedFS.prototype.supportsProps = function supportsProps () {
	    return this._fs.supportsProps();
	};
	LockedFS.prototype.supportsSynch = function supportsSynch () {
	    return this._fs.supportsSynch();
	};
	LockedFS.prototype.rename = function rename (oldPath, newPath, cb) {
	        var this$1 = this;
	
	    this._mu.lock(function () {
	        this$1._fs.rename(oldPath, newPath, function (err) {
	            this$1._mu.unlock();
	            cb(err);
	        });
	    });
	};
	LockedFS.prototype.renameSync = function renameSync (oldPath, newPath) {
	    if (this._mu.isLocked()) {
	        throw new Error('invalid sync call');
	    }
	    return this._fs.renameSync(oldPath, newPath);
	};
	LockedFS.prototype.stat = function stat (p, isLstat, cb) {
	        var this$1 = this;
	
	    this._mu.lock(function () {
	        this$1._fs.stat(p, isLstat, function (err, stat) {
	            this$1._mu.unlock();
	            cb(err, stat);
	        });
	    });
	};
	LockedFS.prototype.statSync = function statSync (p, isLstat) {
	    if (this._mu.isLocked()) {
	        throw new Error('invalid sync call');
	    }
	    return this._fs.statSync(p, isLstat);
	};
	LockedFS.prototype.open = function open (p, flag, mode, cb) {
	        var this$1 = this;
	
	    this._mu.lock(function () {
	        this$1._fs.open(p, flag, mode, function (err, fd) {
	            this$1._mu.unlock();
	            cb(err, fd);
	        });
	    });
	};
	LockedFS.prototype.openSync = function openSync (p, flag, mode) {
	    if (this._mu.isLocked()) {
	        throw new Error('invalid sync call');
	    }
	    return this._fs.openSync(p, flag, mode);
	};
	LockedFS.prototype.unlink = function unlink (p, cb) {
	        var this$1 = this;
	
	    this._mu.lock(function () {
	        this$1._fs.unlink(p, function (err) {
	            this$1._mu.unlock();
	            cb(err);
	        });
	    });
	};
	LockedFS.prototype.unlinkSync = function unlinkSync (p) {
	    if (this._mu.isLocked()) {
	        throw new Error('invalid sync call');
	    }
	    return this._fs.unlinkSync(p);
	};
	LockedFS.prototype.rmdir = function rmdir (p, cb) {
	        var this$1 = this;
	
	    this._mu.lock(function () {
	        this$1._fs.rmdir(p, function (err) {
	            this$1._mu.unlock();
	            cb(err);
	        });
	    });
	};
	LockedFS.prototype.rmdirSync = function rmdirSync (p) {
	    if (this._mu.isLocked()) {
	        throw new Error('invalid sync call');
	    }
	    return this._fs.rmdirSync(p);
	};
	LockedFS.prototype.mkdir = function mkdir (p, mode, cb) {
	        var this$1 = this;
	
	    this._mu.lock(function () {
	        this$1._fs.mkdir(p, mode, function (err) {
	            this$1._mu.unlock();
	            cb(err);
	        });
	    });
	};
	LockedFS.prototype.mkdirSync = function mkdirSync (p, mode) {
	    if (this._mu.isLocked()) {
	        throw new Error('invalid sync call');
	    }
	    return this._fs.mkdirSync(p, mode);
	};
	LockedFS.prototype.readdir = function readdir (p, cb) {
	        var this$1 = this;
	
	    this._mu.lock(function () {
	        this$1._fs.readdir(p, function (err, files) {
	            this$1._mu.unlock();
	            cb(err, files);
	        });
	    });
	};
	LockedFS.prototype.readdirSync = function readdirSync (p) {
	    if (this._mu.isLocked()) {
	        throw new Error('invalid sync call');
	    }
	    return this._fs.readdirSync(p);
	};
	LockedFS.prototype.exists = function exists (p, cb) {
	        var this$1 = this;
	
	    this._mu.lock(function () {
	        this$1._fs.exists(p, function (exists) {
	            this$1._mu.unlock();
	            cb(exists);
	        });
	    });
	};
	LockedFS.prototype.existsSync = function existsSync (p) {
	    if (this._mu.isLocked()) {
	        throw new Error('invalid sync call');
	    }
	    return this._fs.existsSync(p);
	};
	LockedFS.prototype.realpath = function realpath (p, cache, cb) {
	        var this$1 = this;
	
	    this._mu.lock(function () {
	        this$1._fs.realpath(p, cache, function (err, resolvedPath) {
	            this$1._mu.unlock();
	            cb(err, resolvedPath);
	        });
	    });
	};
	LockedFS.prototype.realpathSync = function realpathSync (p, cache) {
	    if (this._mu.isLocked()) {
	        throw new Error('invalid sync call');
	    }
	    return this._fs.realpathSync(p, cache);
	};
	LockedFS.prototype.truncate = function truncate (p, len, cb) {
	        var this$1 = this;
	
	    this._mu.lock(function () {
	        this$1._fs.truncate(p, len, function (err) {
	            this$1._mu.unlock();
	            cb(err);
	        });
	    });
	};
	LockedFS.prototype.truncateSync = function truncateSync (p, len) {
	    if (this._mu.isLocked()) {
	        throw new Error('invalid sync call');
	    }
	    return this._fs.truncateSync(p, len);
	};
	LockedFS.prototype.readFile = function readFile (fname, encoding, flag, cb) {
	        var this$1 = this;
	
	    this._mu.lock(function () {
	        this$1._fs.readFile(fname, encoding, flag, function (err, data) {
	            this$1._mu.unlock();
	            cb(err, data);
	        });
	    });
	};
	LockedFS.prototype.readFileSync = function readFileSync (fname, encoding, flag) {
	    if (this._mu.isLocked()) {
	        throw new Error('invalid sync call');
	    }
	    return this._fs.readFileSync(fname, encoding, flag);
	};
	LockedFS.prototype.writeFile = function writeFile (fname, data, encoding, flag, mode, cb) {
	        var this$1 = this;
	
	    this._mu.lock(function () {
	        this$1._fs.writeFile(fname, data, encoding, flag, mode, function (err) {
	            this$1._mu.unlock();
	            cb(err);
	        });
	    });
	};
	LockedFS.prototype.writeFileSync = function writeFileSync (fname, data, encoding, flag, mode) {
	    if (this._mu.isLocked()) {
	        throw new Error('invalid sync call');
	    }
	    return this._fs.writeFileSync(fname, data, encoding, flag, mode);
	};
	LockedFS.prototype.appendFile = function appendFile (fname, data, encoding, flag, mode, cb) {
	        var this$1 = this;
	
	    this._mu.lock(function () {
	        this$1._fs.appendFile(fname, data, encoding, flag, mode, function (err) {
	            this$1._mu.unlock();
	            cb(err);
	        });
	    });
	};
	LockedFS.prototype.appendFileSync = function appendFileSync (fname, data, encoding, flag, mode) {
	    if (this._mu.isLocked()) {
	        throw new Error('invalid sync call');
	    }
	    return this._fs.appendFileSync(fname, data, encoding, flag, mode);
	};
	LockedFS.prototype.chmod = function chmod (p, isLchmod, mode, cb) {
	        var this$1 = this;
	
	    this._mu.lock(function () {
	        this$1._fs.chmod(p, isLchmod, mode, function (err) {
	            this$1._mu.unlock();
	            cb(err);
	        });
	    });
	};
	LockedFS.prototype.chmodSync = function chmodSync (p, isLchmod, mode) {
	    if (this._mu.isLocked()) {
	        throw new Error('invalid sync call');
	    }
	    return this._fs.chmodSync(p, isLchmod, mode);
	};
	LockedFS.prototype.chown = function chown (p, isLchown, uid, gid, cb) {
	        var this$1 = this;
	
	    this._mu.lock(function () {
	        this$1._fs.chown(p, isLchown, uid, gid, function (err) {
	            this$1._mu.unlock();
	            cb(err);
	        });
	    });
	};
	LockedFS.prototype.chownSync = function chownSync (p, isLchown, uid, gid) {
	    if (this._mu.isLocked()) {
	        throw new Error('invalid sync call');
	    }
	    return this._fs.chownSync(p, isLchown, uid, gid);
	};
	LockedFS.prototype.utimes = function utimes (p, atime, mtime, cb) {
	        var this$1 = this;
	
	    this._mu.lock(function () {
	        this$1._fs.utimes(p, atime, mtime, function (err) {
	            this$1._mu.unlock();
	            cb(err);
	        });
	    });
	};
	LockedFS.prototype.utimesSync = function utimesSync (p, atime, mtime) {
	    if (this._mu.isLocked()) {
	        throw new Error('invalid sync call');
	    }
	    return this._fs.utimesSync(p, atime, mtime);
	};
	LockedFS.prototype.link = function link (srcpath, dstpath, cb) {
	        var this$1 = this;
	
	    this._mu.lock(function () {
	        this$1._fs.link(srcpath, dstpath, function (err) {
	            this$1._mu.unlock();
	            cb(err);
	        });
	    });
	};
	LockedFS.prototype.linkSync = function linkSync (srcpath, dstpath) {
	    if (this._mu.isLocked()) {
	        throw new Error('invalid sync call');
	    }
	    return this._fs.linkSync(srcpath, dstpath);
	};
	LockedFS.prototype.symlink = function symlink (srcpath, dstpath, type, cb) {
	        var this$1 = this;
	
	    this._mu.lock(function () {
	        this$1._fs.symlink(srcpath, dstpath, type, function (err) {
	            this$1._mu.unlock();
	            cb(err);
	        });
	    });
	};
	LockedFS.prototype.symlinkSync = function symlinkSync (srcpath, dstpath, type) {
	    if (this._mu.isLocked()) {
	        throw new Error('invalid sync call');
	    }
	    return this._fs.symlinkSync(srcpath, dstpath, type);
	};
	LockedFS.prototype.readlink = function readlink (p, cb) {
	        var this$1 = this;
	
	    this._mu.lock(function () {
	        this$1._fs.readlink(p, function (err, linkString) {
	            this$1._mu.unlock();
	            cb(err, linkString);
	        });
	    });
	};
	LockedFS.prototype.readlinkSync = function readlinkSync (p) {
	    if (this._mu.isLocked()) {
	        throw new Error('invalid sync call');
	    }
	    return this._fs.readlinkSync(p);
	};
	
	/**
	 * @hidden
	 */
	var deletionLogPath = '/.deletedFiles.log';
	/**
	 * Given a read-only mode, makes it writable.
	 * @hidden
	 */
	function makeModeWritable(mode) {
	    return 146 | mode;
	}
	/**
	 * @hidden
	 */
	function getFlag(f) {
	    return FileFlag.getFileFlag(f);
	}
	/**
	 * Overlays a RO file to make it writable.
	 */
	var OverlayFile = (function (PreloadFile$$1) {
	    function OverlayFile(fs, path$$1, flag, stats, data) {
	        PreloadFile$$1.call(this, fs, path$$1, flag, stats, data);
	    }
	
	    if ( PreloadFile$$1 ) OverlayFile.__proto__ = PreloadFile$$1;
	    OverlayFile.prototype = Object.create( PreloadFile$$1 && PreloadFile$$1.prototype );
	    OverlayFile.prototype.constructor = OverlayFile;
	    OverlayFile.prototype.sync = function sync (cb) {
	        var this$1 = this;
	
	        if (!this.isDirty()) {
	            cb(null);
	            return;
	        }
	        this._fs._syncAsync(this, function (err) {
	            this$1.resetDirty();
	            cb(err);
	        });
	    };
	    OverlayFile.prototype.syncSync = function syncSync () {
	        if (this.isDirty()) {
	            this._fs._syncSync(this);
	            this.resetDirty();
	        }
	    };
	    OverlayFile.prototype.close = function close (cb) {
	        this.sync(cb);
	    };
	    OverlayFile.prototype.closeSync = function closeSync () {
	        this.syncSync();
	    };
	
	    return OverlayFile;
	}(PreloadFile));
	/**
	 * *INTERNAL, DO NOT USE DIRECTLY!*
	 *
	 * Core OverlayFS class that contains no locking whatsoever. We wrap these objects
	 * in a LockedFS to prevent races.
	 */
	var UnlockedOverlayFS = (function (BaseFileSystem$$1) {
	    function UnlockedOverlayFS(writable, readable) {
	        BaseFileSystem$$1.call(this);
	        this._isInitialized = false;
	        this._initializeCallbacks = [];
	        this._deletedFiles = {};
	        this._deleteLog = '';
	        // If 'true', we have scheduled a delete log update.
	        this._deleteLogUpdatePending = false;
	        // If 'true', a delete log update is needed after the scheduled delete log
	        // update finishes.
	        this._deleteLogUpdateNeeded = false;
	        // If there was an error updating the delete log...
	        this._deleteLogError = null;
	        this._writable = writable;
	        this._readable = readable;
	        if (this._writable.isReadOnly()) {
	            throw new ApiError(ErrorCode.EINVAL, "Writable file system must be writable.");
	        }
	    }
	
	    if ( BaseFileSystem$$1 ) UnlockedOverlayFS.__proto__ = BaseFileSystem$$1;
	    UnlockedOverlayFS.prototype = Object.create( BaseFileSystem$$1 && BaseFileSystem$$1.prototype );
	    UnlockedOverlayFS.prototype.constructor = UnlockedOverlayFS;
	    UnlockedOverlayFS.isAvailable = function isAvailable () {
	        return true;
	    };
	    UnlockedOverlayFS.prototype.getOverlayedFileSystems = function getOverlayedFileSystems () {
	        return {
	            readable: this._readable,
	            writable: this._writable
	        };
	    };
	    UnlockedOverlayFS.prototype._syncAsync = function _syncAsync (file, cb) {
	        var this$1 = this;
	
	        this.createParentDirectoriesAsync(file.getPath(), function (err) {
	            if (err) {
	                return cb(err);
	            }
	            this$1._writable.writeFile(file.getPath(), file.getBuffer(), null, getFlag('w'), file.getStats().mode, cb);
	        });
	    };
	    UnlockedOverlayFS.prototype._syncSync = function _syncSync (file) {
	        this.createParentDirectories(file.getPath());
	        this._writable.writeFileSync(file.getPath(), file.getBuffer(), null, getFlag('w'), file.getStats().mode);
	    };
	    UnlockedOverlayFS.prototype.getName = function getName () {
	        return OverlayFS.Name;
	    };
	    /**
	     * Called once to load up metadata stored on the writable file system.
	     */
	    UnlockedOverlayFS.prototype.initialize = function initialize (cb) {
	        var this$1 = this;
	
	        var callbackArray = this._initializeCallbacks;
	        var end = function (e) {
	            this$1._isInitialized = !e;
	            this$1._initializeCallbacks = [];
	            callbackArray.forEach((function (cb) { return cb(e); }));
	        };
	        // if we're already initialized, immediately invoke the callback
	        if (this._isInitialized) {
	            return cb();
	        }
	        callbackArray.push(cb);
	        // The first call to initialize initializes, the rest wait for it to complete.
	        if (callbackArray.length !== 1) {
	            return;
	        }
	        // Read deletion log, process into metadata.
	        this._writable.readFile(deletionLogPath, 'utf8', getFlag('r'), function (err, data) {
	            if (err) {
	                // ENOENT === Newly-instantiated file system, and thus empty log.
	                if (err.errno !== ErrorCode.ENOENT) {
	                    return end(err);
	                }
	            }
	            else {
	                this$1._deleteLog = data;
	            }
	            this$1._reparseDeletionLog();
	            end();
	        });
	    };
	    UnlockedOverlayFS.prototype.isReadOnly = function isReadOnly () { return false; };
	    UnlockedOverlayFS.prototype.supportsSynch = function supportsSynch () { return this._readable.supportsSynch() && this._writable.supportsSynch(); };
	    UnlockedOverlayFS.prototype.supportsLinks = function supportsLinks () { return false; };
	    UnlockedOverlayFS.prototype.supportsProps = function supportsProps () { return this._readable.supportsProps() && this._writable.supportsProps(); };
	    UnlockedOverlayFS.prototype.getDeletionLog = function getDeletionLog () {
	        return this._deleteLog;
	    };
	    UnlockedOverlayFS.prototype.restoreDeletionLog = function restoreDeletionLog (log) {
	        this._deleteLog = log;
	        this._reparseDeletionLog();
	        this.updateLog('');
	    };
	    UnlockedOverlayFS.prototype.rename = function rename (oldPath, newPath, cb) {
	        var this$1 = this;
	
	        if (!this.checkInitAsync(cb) || this.checkPathAsync(oldPath, cb) || this.checkPathAsync(newPath, cb)) {
	            return;
	        }
	        if (oldPath === deletionLogPath || newPath === deletionLogPath) {
	            return cb(ApiError.EPERM('Cannot rename deletion log.'));
	        }
	        // nothing to do if paths match
	        if (oldPath === newPath) {
	            return cb();
	        }
	        this.stat(oldPath, false, function (oldErr, oldStats) {
	            if (oldErr) {
	                return cb(oldErr);
	            }
	            return this$1.stat(newPath, false, function (newErr, newStats) {
	                var self = this$1;
	                // precondition: both oldPath and newPath exist and are dirs.
	                // decreases: |files|
	                // Need to move *every file/folder* currently stored on
	                // readable to its new location on writable.
	                function copyDirContents(files) {
	                    var file = files.shift();
	                    if (!file) {
	                        return cb();
	                    }
	                    var oldFile = path.resolve(oldPath, file);
	                    var newFile = path.resolve(newPath, file);
	                    // Recursion! Should work for any nested files / folders.
	                    self.rename(oldFile, newFile, function (err) {
	                        if (err) {
	                            return cb(err);
	                        }
	                        copyDirContents(files);
	                    });
	                }
	                var mode = 511;
	                // from linux's rename(2) manpage: oldpath can specify a
	                // directory.  In this case, newpath must either not exist, or
	                // it must specify an empty directory.
	                if (oldStats.isDirectory()) {
	                    if (newErr) {
	                        if (newErr.errno !== ErrorCode.ENOENT) {
	                            return cb(newErr);
	                        }
	                        return this$1._writable.exists(oldPath, function (exists) {
	                            // simple case - both old and new are on the writable layer
	                            if (exists) {
	                                return this$1._writable.rename(oldPath, newPath, cb);
	                            }
	                            this$1._writable.mkdir(newPath, mode, function (mkdirErr) {
	                                if (mkdirErr) {
	                                    return cb(mkdirErr);
	                                }
	                                this$1._readable.readdir(oldPath, function (err, files) {
	                                    if (err) {
	                                        return cb();
	                                    }
	                                    copyDirContents(files);
	                                });
	                            });
	                        });
	                    }
	                    mode = newStats.mode;
	                    if (!newStats.isDirectory()) {
	                        return cb(ApiError.ENOTDIR(newPath));
	                    }
	                    this$1.readdir(newPath, function (readdirErr, files) {
	                        if (files && files.length) {
	                            return cb(ApiError.ENOTEMPTY(newPath));
	                        }
	                        this$1._readable.readdir(oldPath, function (err, files) {
	                            if (err) {
	                                return cb();
	                            }
	                            copyDirContents(files);
	                        });
	                    });
	                }
	                if (newStats && newStats.isDirectory()) {
	                    return cb(ApiError.EISDIR(newPath));
	                }
	                this$1.readFile(oldPath, null, getFlag('r'), function (err, data) {
	                    if (err) {
	                        return cb(err);
	                    }
	                    return this$1.writeFile(newPath, data, null, getFlag('w'), oldStats.mode, function (err) {
	                        if (err) {
	                            return cb(err);
	                        }
	                        return this$1.unlink(oldPath, cb);
	                    });
	                });
	            });
	        });
	    };
	    UnlockedOverlayFS.prototype.renameSync = function renameSync (oldPath, newPath) {
	        var this$1 = this;
	
	        this.checkInitialized();
	        this.checkPath(oldPath);
	        this.checkPath(newPath);
	        if (oldPath === deletionLogPath || newPath === deletionLogPath) {
	            throw ApiError.EPERM('Cannot rename deletion log.');
	        }
	        // Write newPath using oldPath's contents, delete oldPath.
	        var oldStats = this.statSync(oldPath, false);
	        if (oldStats.isDirectory()) {
	            // Optimization: Don't bother moving if old === new.
	            if (oldPath === newPath) {
	                return;
	            }
	            var mode = 511;
	            if (this.existsSync(newPath)) {
	                var stats = this.statSync(newPath, false);
	                mode = stats.mode;
	                if (stats.isDirectory()) {
	                    if (this.readdirSync(newPath).length > 0) {
	                        throw ApiError.ENOTEMPTY(newPath);
	                    }
	                }
	                else {
	                    throw ApiError.ENOTDIR(newPath);
	                }
	            }
	            // Take care of writable first. Move any files there, or create an empty directory
	            // if it doesn't exist.
	            if (this._writable.existsSync(oldPath)) {
	                this._writable.renameSync(oldPath, newPath);
	            }
	            else if (!this._writable.existsSync(newPath)) {
	                this._writable.mkdirSync(newPath, mode);
	            }
	            // Need to move *every file/folder* currently stored on readable to its new location
	            // on writable.
	            if (this._readable.existsSync(oldPath)) {
	                this._readable.readdirSync(oldPath).forEach(function (name) {
	                    // Recursion! Should work for any nested files / folders.
	                    this$1.renameSync(path.resolve(oldPath, name), path.resolve(newPath, name));
	                });
	            }
	        }
	        else {
	            if (this.existsSync(newPath) && this.statSync(newPath, false).isDirectory()) {
	                throw ApiError.EISDIR(newPath);
	            }
	            this.writeFileSync(newPath, this.readFileSync(oldPath, null, getFlag('r')), null, getFlag('w'), oldStats.mode);
	        }
	        if (oldPath !== newPath && this.existsSync(oldPath)) {
	            this.unlinkSync(oldPath);
	        }
	    };
	    UnlockedOverlayFS.prototype.stat = function stat (p, isLstat, cb) {
	        var this$1 = this;
	
	        if (!this.checkInitAsync(cb)) {
	            return;
	        }
	        this._writable.stat(p, isLstat, function (err, stat) {
	            if (err && err.errno === ErrorCode.ENOENT) {
	                if (this$1._deletedFiles[p]) {
	                    cb(ApiError.ENOENT(p));
	                }
	                this$1._readable.stat(p, isLstat, function (err, stat) {
	                    if (stat) {
	                        // Make the oldStat's mode writable. Preserve the topmost
	                        // part of the mode, which specifies if it is a file or a
	                        // directory.
	                        stat = stat.clone();
	                        stat.mode = makeModeWritable(stat.mode);
	                    }
	                    cb(err, stat);
	                });
	            }
	            else {
	                cb(err, stat);
	            }
	        });
	    };
	    UnlockedOverlayFS.prototype.statSync = function statSync (p, isLstat) {
	        this.checkInitialized();
	        try {
	            return this._writable.statSync(p, isLstat);
	        }
	        catch (e) {
	            if (this._deletedFiles[p]) {
	                throw ApiError.ENOENT(p);
	            }
	            var oldStat = this._readable.statSync(p, isLstat).clone();
	            // Make the oldStat's mode writable. Preserve the topmost part of the
	            // mode, which specifies if it is a file or a directory.
	            oldStat.mode = makeModeWritable(oldStat.mode);
	            return oldStat;
	        }
	    };
	    UnlockedOverlayFS.prototype.open = function open (p, flag, mode, cb) {
	        var this$1 = this;
	
	        if (!this.checkInitAsync(cb) || this.checkPathAsync(p, cb)) {
	            return;
	        }
	        this.stat(p, false, function (err, stats) {
	            if (stats) {
	                switch (flag.pathExistsAction()) {
	                    case ActionType.TRUNCATE_FILE:
	                        return this$1.createParentDirectoriesAsync(p, function (err) {
	                            if (err) {
	                                return cb(err);
	                            }
	                            this$1._writable.open(p, flag, mode, cb);
	                        });
	                    case ActionType.NOP:
	                        return this$1._writable.exists(p, function (exists) {
	                            if (exists) {
	                                this$1._writable.open(p, flag, mode, cb);
	                            }
	                            else {
	                                // at this point we know the stats object we got is from
	                                // the readable FS.
	                                stats = stats.clone();
	                                stats.mode = mode;
	                                this$1._readable.readFile(p, null, getFlag('r'), function (readFileErr, data) {
	                                    if (readFileErr) {
	                                        return cb(readFileErr);
	                                    }
	                                    if (stats.size === -1) {
	                                        stats.size = data.length;
	                                    }
	                                    var f = new OverlayFile(this$1, p, flag, stats, data);
	                                    cb(null, f);
	                                });
	                            }
	                        });
	                    default:
	                        return cb(ApiError.EEXIST(p));
	                }
	            }
	            else {
	                switch (flag.pathNotExistsAction()) {
	                    case ActionType.CREATE_FILE:
	                        return this$1.createParentDirectoriesAsync(p, function (err) {
	                            if (err) {
	                                return cb(err);
	                            }
	                            return this$1._writable.open(p, flag, mode, cb);
	                        });
	                    default:
	                        return cb(ApiError.ENOENT(p));
	                }
	            }
	        });
	    };
	    UnlockedOverlayFS.prototype.openSync = function openSync (p, flag, mode) {
	        this.checkInitialized();
	        this.checkPath(p);
	        if (p === deletionLogPath) {
	            throw ApiError.EPERM('Cannot open deletion log.');
	        }
	        if (this.existsSync(p)) {
	            switch (flag.pathExistsAction()) {
	                case ActionType.TRUNCATE_FILE:
	                    this.createParentDirectories(p);
	                    return this._writable.openSync(p, flag, mode);
	                case ActionType.NOP:
	                    if (this._writable.existsSync(p)) {
	                        return this._writable.openSync(p, flag, mode);
	                    }
	                    else {
	                        // Create an OverlayFile.
	                        var buf = this._readable.readFileSync(p, null, getFlag('r'));
	                        var stats = this._readable.statSync(p, false).clone();
	                        stats.mode = mode;
	                        return new OverlayFile(this, p, flag, stats, buf);
	                    }
	                default:
	                    throw ApiError.EEXIST(p);
	            }
	        }
	        else {
	            switch (flag.pathNotExistsAction()) {
	                case ActionType.CREATE_FILE:
	                    this.createParentDirectories(p);
	                    return this._writable.openSync(p, flag, mode);
	                default:
	                    throw ApiError.ENOENT(p);
	            }
	        }
	    };
	    UnlockedOverlayFS.prototype.unlink = function unlink (p, cb) {
	        var this$1 = this;
	
	        if (!this.checkInitAsync(cb) || this.checkPathAsync(p, cb)) {
	            return;
	        }
	        this.exists(p, function (exists) {
	            if (!exists) {
	                return cb(ApiError.ENOENT(p));
	            }
	            this$1._writable.exists(p, function (writableExists) {
	                if (writableExists) {
	                    return this$1._writable.unlink(p, function (err) {
	                        if (err) {
	                            return cb(err);
	                        }
	                        this$1.exists(p, function (readableExists) {
	                            if (readableExists) {
	                                this$1.deletePath(p);
	                            }
	                            cb(null);
	                        });
	                    });
	                }
	                else {
	                    // if this only exists on the readable FS, add it to the
	                    // delete map.
	                    this$1.deletePath(p);
	                    cb(null);
	                }
	            });
	        });
	    };
	    UnlockedOverlayFS.prototype.unlinkSync = function unlinkSync (p) {
	        this.checkInitialized();
	        this.checkPath(p);
	        if (this.existsSync(p)) {
	            if (this._writable.existsSync(p)) {
	                this._writable.unlinkSync(p);
	            }
	            // if it still exists add to the delete log
	            if (this.existsSync(p)) {
	                this.deletePath(p);
	            }
	        }
	        else {
	            throw ApiError.ENOENT(p);
	        }
	    };
	    UnlockedOverlayFS.prototype.rmdir = function rmdir (p, cb) {
	        var this$1 = this;
	
	        if (!this.checkInitAsync(cb)) {
	            return;
	        }
	        var rmdirLower = function () {
	            this$1.readdir(p, function (err, files) {
	                if (err) {
	                    return cb(err);
	                }
	                if (files.length) {
	                    return cb(ApiError.ENOTEMPTY(p));
	                }
	                this$1.deletePath(p);
	                cb(null);
	            });
	        };
	        this.exists(p, function (exists) {
	            if (!exists) {
	                return cb(ApiError.ENOENT(p));
	            }
	            this$1._writable.exists(p, function (writableExists) {
	                if (writableExists) {
	                    this$1._writable.rmdir(p, function (err) {
	                        if (err) {
	                            return cb(err);
	                        }
	                        this$1._readable.exists(p, function (readableExists) {
	                            if (readableExists) {
	                                rmdirLower();
	                            }
	                            else {
	                                cb();
	                            }
	                        });
	                    });
	                }
	                else {
	                    rmdirLower();
	                }
	            });
	        });
	    };
	    UnlockedOverlayFS.prototype.rmdirSync = function rmdirSync (p) {
	        this.checkInitialized();
	        if (this.existsSync(p)) {
	            if (this._writable.existsSync(p)) {
	                this._writable.rmdirSync(p);
	            }
	            if (this.existsSync(p)) {
	                // Check if directory is empty.
	                if (this.readdirSync(p).length > 0) {
	                    throw ApiError.ENOTEMPTY(p);
	                }
	                else {
	                    this.deletePath(p);
	                }
	            }
	        }
	        else {
	            throw ApiError.ENOENT(p);
	        }
	    };
	    UnlockedOverlayFS.prototype.mkdir = function mkdir (p, mode, cb) {
	        var this$1 = this;
	
	        if (!this.checkInitAsync(cb)) {
	            return;
	        }
	        this.exists(p, function (exists) {
	            if (exists) {
	                return cb(ApiError.EEXIST(p));
	            }
	            // The below will throw should any of the parent directories
	            // fail to exist on _writable.
	            this$1.createParentDirectoriesAsync(p, function (err) {
	                if (err) {
	                    return cb(err);
	                }
	                this$1._writable.mkdir(p, mode, cb);
	            });
	        });
	    };
	    UnlockedOverlayFS.prototype.mkdirSync = function mkdirSync (p, mode) {
	        this.checkInitialized();
	        if (this.existsSync(p)) {
	            throw ApiError.EEXIST(p);
	        }
	        else {
	            // The below will throw should any of the parent directories fail to exist
	            // on _writable.
	            this.createParentDirectories(p);
	            this._writable.mkdirSync(p, mode);
	        }
	    };
	    UnlockedOverlayFS.prototype.readdir = function readdir (p, cb) {
	        var this$1 = this;
	
	        if (!this.checkInitAsync(cb)) {
	            return;
	        }
	        this.stat(p, false, function (err, dirStats) {
	            if (err) {
	                return cb(err);
	            }
	            if (!dirStats.isDirectory()) {
	                return cb(ApiError.ENOTDIR(p));
	            }
	            this$1._writable.readdir(p, function (err, wFiles) {
	                if (err && err.code !== 'ENOENT') {
	                    return cb(err);
	                }
	                else if (err || !wFiles) {
	                    wFiles = [];
	                }
	                this$1._readable.readdir(p, function (err, rFiles) {
	                    // if the directory doesn't exist on the lower FS set rFiles
	                    // here to simplify the following code.
	                    if (err || !rFiles) {
	                        rFiles = [];
	                    }
	                    // Readdir in both, check delete log on read-only file system's files, merge, return.
	                    var seenMap = {};
	                    var filtered = wFiles.concat(rFiles.filter(function (fPath) { return !this$1._deletedFiles[(p + "/" + fPath)]; })).filter(function (fPath) {
	                        // Remove duplicates.
	                        var result = !seenMap[fPath];
	                        seenMap[fPath] = true;
	                        return result;
	                    });
	                    cb(null, filtered);
	                });
	            });
	        });
	    };
	    UnlockedOverlayFS.prototype.readdirSync = function readdirSync (p) {
	        var this$1 = this;
	
	        this.checkInitialized();
	        var dirStats = this.statSync(p, false);
	        if (!dirStats.isDirectory()) {
	            throw ApiError.ENOTDIR(p);
	        }
	        // Readdir in both, check delete log on RO file system's listing, merge, return.
	        var contents = [];
	        try {
	            contents = contents.concat(this._writable.readdirSync(p));
	        }
	        catch (e) {
	            // NOP.
	        }
	        try {
	            contents = contents.concat(this._readable.readdirSync(p).filter(function (fPath) { return !this$1._deletedFiles[(p + "/" + fPath)]; }));
	        }
	        catch (e) {
	            // NOP.
	        }
	        var seenMap = {};
	        return contents.filter(function (fileP) {
	            var result = !seenMap[fileP];
	            seenMap[fileP] = true;
	            return result;
	        });
	    };
	    UnlockedOverlayFS.prototype.exists = function exists (p, cb) {
	        var this$1 = this;
	
	        // Cannot pass an error back to callback, so throw an exception instead
	        // if not initialized.
	        this.checkInitialized();
	        this._writable.exists(p, function (existsWritable) {
	            if (existsWritable) {
	                return cb(true);
	            }
	            this$1._readable.exists(p, function (existsReadable) {
	                cb(existsReadable && this$1._deletedFiles[p] !== true);
	            });
	        });
	    };
	    UnlockedOverlayFS.prototype.existsSync = function existsSync (p) {
	        this.checkInitialized();
	        return this._writable.existsSync(p) || (this._readable.existsSync(p) && this._deletedFiles[p] !== true);
	    };
	    UnlockedOverlayFS.prototype.chmod = function chmod (p, isLchmod, mode, cb) {
	        var this$1 = this;
	
	        if (!this.checkInitAsync(cb)) {
	            return;
	        }
	        this.operateOnWritableAsync(p, function (err) {
	            if (err) {
	                return cb(err);
	            }
	            else {
	                this$1._writable.chmod(p, isLchmod, mode, cb);
	            }
	        });
	    };
	    UnlockedOverlayFS.prototype.chmodSync = function chmodSync (p, isLchmod, mode) {
	        var this$1 = this;
	
	        this.checkInitialized();
	        this.operateOnWritable(p, function () {
	            this$1._writable.chmodSync(p, isLchmod, mode);
	        });
	    };
	    UnlockedOverlayFS.prototype.chown = function chown (p, isLchmod, uid, gid, cb) {
	        var this$1 = this;
	
	        if (!this.checkInitAsync(cb)) {
	            return;
	        }
	        this.operateOnWritableAsync(p, function (err) {
	            if (err) {
	                return cb(err);
	            }
	            else {
	                this$1._writable.chown(p, isLchmod, uid, gid, cb);
	            }
	        });
	    };
	    UnlockedOverlayFS.prototype.chownSync = function chownSync (p, isLchown, uid, gid) {
	        var this$1 = this;
	
	        this.checkInitialized();
	        this.operateOnWritable(p, function () {
	            this$1._writable.chownSync(p, isLchown, uid, gid);
	        });
	    };
	    UnlockedOverlayFS.prototype.utimes = function utimes (p, atime, mtime, cb) {
	        var this$1 = this;
	
	        if (!this.checkInitAsync(cb)) {
	            return;
	        }
	        this.operateOnWritableAsync(p, function (err) {
	            if (err) {
	                return cb(err);
	            }
	            else {
	                this$1._writable.utimes(p, atime, mtime, cb);
	            }
	        });
	    };
	    UnlockedOverlayFS.prototype.utimesSync = function utimesSync (p, atime, mtime) {
	        var this$1 = this;
	
	        this.checkInitialized();
	        this.operateOnWritable(p, function () {
	            this$1._writable.utimesSync(p, atime, mtime);
	        });
	    };
	    UnlockedOverlayFS.prototype.deletePath = function deletePath (p) {
	        this._deletedFiles[p] = true;
	        this.updateLog(("d" + p + "\n"));
	    };
	    UnlockedOverlayFS.prototype.updateLog = function updateLog (addition) {
	        var this$1 = this;
	
	        this._deleteLog += addition;
	        if (this._deleteLogUpdatePending) {
	            this._deleteLogUpdateNeeded = true;
	        }
	        else {
	            this._deleteLogUpdatePending = true;
	            this._writable.writeFile(deletionLogPath, this._deleteLog, 'utf8', FileFlag.getFileFlag('w'), 420, function (e) {
	                this$1._deleteLogUpdatePending = false;
	                if (e) {
	                    this$1._deleteLogError = e;
	                }
	                else if (this$1._deleteLogUpdateNeeded) {
	                    this$1._deleteLogUpdateNeeded = false;
	                    this$1.updateLog('');
	                }
	            });
	        }
	    };
	    UnlockedOverlayFS.prototype._reparseDeletionLog = function _reparseDeletionLog () {
	        var this$1 = this;
	
	        this._deletedFiles = {};
	        this._deleteLog.split('\n').forEach(function (path$$1) {
	            // If the log entry begins w/ 'd', it's a deletion.
	            this$1._deletedFiles[path$$1.slice(1)] = path$$1.slice(0, 1) === 'd';
	        });
	    };
	    UnlockedOverlayFS.prototype.checkInitialized = function checkInitialized () {
	        if (!this._isInitialized) {
	            throw new ApiError(ErrorCode.EPERM, "OverlayFS is not initialized. Please initialize OverlayFS using its initialize() method before using it.");
	        }
	        else if (this._deleteLogError !== null) {
	            var e = this._deleteLogError;
	            this._deleteLogError = null;
	            throw e;
	        }
	    };
	    UnlockedOverlayFS.prototype.checkInitAsync = function checkInitAsync (cb) {
	        if (!this._isInitialized) {
	            cb(new ApiError(ErrorCode.EPERM, "OverlayFS is not initialized. Please initialize OverlayFS using its initialize() method before using it."));
	            return false;
	        }
	        else if (this._deleteLogError !== null) {
	            var e = this._deleteLogError;
	            this._deleteLogError = null;
	            cb(e);
	            return false;
	        }
	        return true;
	    };
	    UnlockedOverlayFS.prototype.checkPath = function checkPath (p) {
	        if (p === deletionLogPath) {
	            throw ApiError.EPERM(p);
	        }
	    };
	    UnlockedOverlayFS.prototype.checkPathAsync = function checkPathAsync (p, cb) {
	        if (p === deletionLogPath) {
	            cb(ApiError.EPERM(p));
	            return true;
	        }
	        return false;
	    };
	    UnlockedOverlayFS.prototype.createParentDirectoriesAsync = function createParentDirectoriesAsync (p, cb) {
	        var parent = path.dirname(p);
	        var toCreate = [];
	        var self = this;
	        this._writable.stat(parent, false, statDone);
	        function statDone(err, stat) {
	            if (err) {
	                toCreate.push(parent);
	                parent = path.dirname(parent);
	                self._writable.stat(parent, false, statDone);
	            }
	            else {
	                createParents();
	            }
	        }
	        function createParents() {
	            if (!toCreate.length) {
	                return cb();
	            }
	            var dir = toCreate.pop();
	            self._readable.stat(dir, false, function (err, stats) {
	                // stop if we couldn't read the dir
	                if (!stats) {
	                    return cb();
	                }
	                self._writable.mkdir(dir, stats.mode, function (err) {
	                    if (err) {
	                        return cb(err);
	                    }
	                    createParents();
	                });
	            });
	        }
	    };
	    /**
	     * With the given path, create the needed parent directories on the writable storage
	     * should they not exist. Use modes from the read-only storage.
	     */
	    UnlockedOverlayFS.prototype.createParentDirectories = function createParentDirectories (p) {
	        var this$1 = this;
	
	        var parent = path.dirname(p), toCreate = [];
	        while (!this._writable.existsSync(parent)) {
	            toCreate.push(parent);
	            parent = path.dirname(parent);
	        }
	        toCreate = toCreate.reverse();
	        toCreate.forEach(function (p) {
	            this$1._writable.mkdirSync(p, this$1.statSync(p, false).mode);
	        });
	    };
	    /**
	     * Helper function:
	     * - Ensures p is on writable before proceeding. Throws an error if it doesn't exist.
	     * - Calls f to perform operation on writable.
	     */
	    UnlockedOverlayFS.prototype.operateOnWritable = function operateOnWritable (p, f) {
	        if (this.existsSync(p)) {
	            if (!this._writable.existsSync(p)) {
	                // File is on readable storage. Copy to writable storage before
	                // changing its mode.
	                this.copyToWritable(p);
	            }
	            f();
	        }
	        else {
	            throw ApiError.ENOENT(p);
	        }
	    };
	    UnlockedOverlayFS.prototype.operateOnWritableAsync = function operateOnWritableAsync (p, cb) {
	        var this$1 = this;
	
	        this.exists(p, function (exists) {
	            if (!exists) {
	                return cb(ApiError.ENOENT(p));
	            }
	            this$1._writable.exists(p, function (existsWritable) {
	                if (existsWritable) {
	                    cb();
	                }
	                else {
	                    return this$1.copyToWritableAsync(p, cb);
	                }
	            });
	        });
	    };
	    /**
	     * Copy from readable to writable storage.
	     * PRECONDITION: File does not exist on writable storage.
	     */
	    UnlockedOverlayFS.prototype.copyToWritable = function copyToWritable (p) {
	        var pStats = this.statSync(p, false);
	        if (pStats.isDirectory()) {
	            this._writable.mkdirSync(p, pStats.mode);
	        }
	        else {
	            this.writeFileSync(p, this._readable.readFileSync(p, null, getFlag('r')), null, getFlag('w'), this.statSync(p, false).mode);
	        }
	    };
	    UnlockedOverlayFS.prototype.copyToWritableAsync = function copyToWritableAsync (p, cb) {
	        var this$1 = this;
	
	        this.stat(p, false, function (err, pStats) {
	            if (err) {
	                return cb(err);
	            }
	            if (pStats.isDirectory()) {
	                return this$1._writable.mkdir(p, pStats.mode, cb);
	            }
	            // need to copy file.
	            this$1._readable.readFile(p, null, getFlag('r'), function (err, data) {
	                if (err) {
	                    return cb(err);
	                }
	                this$1.writeFile(p, data, null, getFlag('w'), pStats.mode, cb);
	            });
	        });
	    };
	
	    return UnlockedOverlayFS;
	}(BaseFileSystem));
	/**
	 * OverlayFS makes a read-only filesystem writable by storing writes on a second,
	 * writable file system. Deletes are persisted via metadata stored on the writable
	 * file system.
	 */
	var OverlayFS = (function (LockedFS$$1) {
	    function OverlayFS(writable, readable, deprecateMsg) {
	        if ( deprecateMsg === void 0 ) deprecateMsg = true;
	
	        LockedFS$$1.call(this, new UnlockedOverlayFS(writable, readable));
	        deprecationMessage(deprecateMsg, OverlayFS.Name, { readable: "readable file system", writable: "writable file system" });
	    }
	
	    if ( LockedFS$$1 ) OverlayFS.__proto__ = LockedFS$$1;
	    OverlayFS.prototype = Object.create( LockedFS$$1 && LockedFS$$1.prototype );
	    OverlayFS.prototype.constructor = OverlayFS;
	    /**
	     * Constructs and initializes an OverlayFS instance with the given options.
	     */
	    OverlayFS.Create = function Create (opts, cb) {
	        try {
	            var fs = new OverlayFS(opts.writable, opts.readable, false);
	            fs.initialize(function (e) {
	                cb(e, fs);
	            }, false);
	        }
	        catch (e) {
	            cb(e);
	        }
	    };
	    OverlayFS.isAvailable = function isAvailable () {
	        return UnlockedOverlayFS.isAvailable();
	    };
	    /**
	     * **Deprecated. Please use OverlayFS.Create() to construct and initialize OverlayFS instances.**
	     */
	    OverlayFS.prototype.initialize = function initialize (cb, deprecateMsg) {
	        if ( deprecateMsg === void 0 ) deprecateMsg = true;
	
	        if (deprecateMsg) {
	            console.warn("[OverlayFS] OverlayFS.initialize() is deprecated and will be removed in the next major release. Please use 'OverlayFS.Create({readable: readable file system instance, writable: writable file system instance}, cb)' to create and initialize OverlayFS instances.");
	        }
	        LockedFS$$1.prototype.initialize.call(this, cb);
	    };
	    OverlayFS.prototype.getOverlayedFileSystems = function getOverlayedFileSystems () {
	        return LockedFS$$1.prototype.getFSUnlocked.call(this).getOverlayedFileSystems();
	    };
	    OverlayFS.prototype.unwrap = function unwrap () {
	        return LockedFS$$1.prototype.getFSUnlocked.call(this);
	    };
	
	    return OverlayFS;
	}(LockedFS));
	
	OverlayFS.Name = "OverlayFS";
	OverlayFS.Options = {
	    writable: {
	        type: "object",
	        description: "The file system to write modified files to."
	    },
	    readable: {
	        type: "object",
	        description: "The file system that initially populates this file system."
	    }
	};
	
	/**
	 * @hidden
	 */
	var SpecialArgType;
	(function (SpecialArgType) {
	    // Callback
	    SpecialArgType[SpecialArgType["CB"] = 0] = "CB";
	    // File descriptor
	    SpecialArgType[SpecialArgType["FD"] = 1] = "FD";
	    // API error
	    SpecialArgType[SpecialArgType["API_ERROR"] = 2] = "API_ERROR";
	    // Stats object
	    SpecialArgType[SpecialArgType["STATS"] = 3] = "STATS";
	    // Initial probe for file system information.
	    SpecialArgType[SpecialArgType["PROBE"] = 4] = "PROBE";
	    // FileFlag object.
	    SpecialArgType[SpecialArgType["FILEFLAG"] = 5] = "FILEFLAG";
	    // Buffer object.
	    SpecialArgType[SpecialArgType["BUFFER"] = 6] = "BUFFER";
	    // Generic Error object.
	    SpecialArgType[SpecialArgType["ERROR"] = 7] = "ERROR";
	})(SpecialArgType || (SpecialArgType = {}));
	/**
	 * Converts callback arguments into ICallbackArgument objects, and back
	 * again.
	 * @hidden
	 */
	var CallbackArgumentConverter = function CallbackArgumentConverter() {
	    this._callbacks = {};
	    this._nextId = 0;
	};
	CallbackArgumentConverter.prototype.toRemoteArg = function toRemoteArg (cb) {
	    var id = this._nextId++;
	    this._callbacks[id] = cb;
	    return {
	        type: SpecialArgType.CB,
	        id: id
	    };
	};
	CallbackArgumentConverter.prototype.toLocalArg = function toLocalArg (id) {
	    var cb = this._callbacks[id];
	    delete this._callbacks[id];
	    return cb;
	};
	/**
	 * @hidden
	 */
	var FileDescriptorArgumentConverter = function FileDescriptorArgumentConverter() {
	    this._fileDescriptors = {};
	    this._nextId = 0;
	};
	FileDescriptorArgumentConverter.prototype.toRemoteArg = function toRemoteArg (fd, p, flag, cb) {
	    var id = this._nextId++;
	    var data;
	    var stat;
	    this._fileDescriptors[id] = fd;
	    // Extract needed information asynchronously.
	    fd.stat(function (err, stats) {
	        if (err) {
	            cb(err);
	        }
	        else {
	            stat = bufferToTransferrableObject(stats.toBuffer());
	            // If it's a readable flag, we need to grab contents.
	            if (flag.isReadable()) {
	                fd.read(Buffer.alloc(stats.size), 0, stats.size, 0, function (err, bytesRead, buff) {
	                    if (err) {
	                        cb(err);
	                    }
	                    else {
	                        data = bufferToTransferrableObject(buff);
	                        cb(null, {
	                            type: SpecialArgType.FD,
	                            id: id,
	                            data: data,
	                            stat: stat,
	                            path: p,
	                            flag: flag.getFlagString()
	                        });
	                    }
	                });
	            }
	            else {
	                // File is not readable, which means writing to it will append or
	                // truncate/replace existing contents. Return an empty arraybuffer.
	                cb(null, {
	                    type: SpecialArgType.FD,
	                    id: id,
	                    data: new ArrayBuffer(0),
	                    stat: stat,
	                    path: p,
	                    flag: flag.getFlagString()
	                });
	            }
	        }
	    });
	};
	FileDescriptorArgumentConverter.prototype.applyFdAPIRequest = function applyFdAPIRequest (request, cb) {
	        var this$1 = this;
	
	    var fdArg = request.args[0];
	    this._applyFdChanges(fdArg, function (err, fd) {
	        if (err) {
	            cb(err);
	        }
	        else {
	            // Apply method on now-changed file descriptor.
	            fd[request.method](function (e) {
	                if (request.method === 'close') {
	                    delete this$1._fileDescriptors[fdArg.id];
	                }
	                cb(e);
	            });
	        }
	    });
	};
	FileDescriptorArgumentConverter.prototype._applyFdChanges = function _applyFdChanges (remoteFd, cb) {
	    var fd = this._fileDescriptors[remoteFd.id], data = transferrableObjectToBuffer(remoteFd.data), remoteStats = Stats.fromBuffer(transferrableObjectToBuffer(remoteFd.stat));
	    // Write data if the file is writable.
	    var flag = FileFlag.getFileFlag(remoteFd.flag);
	    if (flag.isWriteable()) {
	        // Appendable: Write to end of file.
	        // Writeable: Replace entire contents of file.
	        fd.write(data, 0, data.length, flag.isAppendable() ? fd.getPos() : 0, function (e) {
	            function applyStatChanges() {
	                // Check if mode changed.
	                fd.stat(function (e, stats) {
	                    if (e) {
	                        cb(e);
	                    }
	                    else {
	                        if (stats.mode !== remoteStats.mode) {
	                            fd.chmod(remoteStats.mode, function (e) {
	                                cb(e, fd);
	                            });
	                        }
	                        else {
	                            cb(e, fd);
	                        }
	                    }
	                });
	            }
	            if (e) {
	                cb(e);
	            }
	            else {
	                // If writeable & not appendable, we need to ensure file contents are
	                // identical to those from the remote FD. Thus, we truncate to the
	                // length of the remote file.
	                if (!flag.isAppendable()) {
	                    fd.truncate(data.length, function () {
	                        applyStatChanges();
	                    });
	                }
	                else {
	                    applyStatChanges();
	                }
	            }
	        });
	    }
	    else {
	        cb(null, fd);
	    }
	};
	/**
	 * @hidden
	 */
	function apiErrorLocal2Remote(e) {
	    return {
	        type: SpecialArgType.API_ERROR,
	        errorData: bufferToTransferrableObject(e.writeToBuffer())
	    };
	}
	/**
	 * @hidden
	 */
	function apiErrorRemote2Local(e) {
	    return ApiError.fromBuffer(transferrableObjectToBuffer(e.errorData));
	}
	/**
	 * @hidden
	 */
	function errorLocal2Remote(e) {
	    return {
	        type: SpecialArgType.ERROR,
	        name: e.name,
	        message: e.message,
	        stack: e.stack
	    };
	}
	/**
	 * @hidden
	 */
	function errorRemote2Local(e) {
	    var cnstr = global$1[e.name];
	    if (typeof (cnstr) !== 'function') {
	        cnstr = Error;
	    }
	    var err = new cnstr(e.message);
	    err.stack = e.stack;
	    return err;
	}
	/**
	 * @hidden
	 */
	function statsLocal2Remote(stats) {
	    return {
	        type: SpecialArgType.STATS,
	        statsData: bufferToTransferrableObject(stats.toBuffer())
	    };
	}
	/**
	 * @hidden
	 */
	function statsRemote2Local(stats) {
	    return Stats.fromBuffer(transferrableObjectToBuffer(stats.statsData));
	}
	/**
	 * @hidden
	 */
	function fileFlagLocal2Remote(flag) {
	    return {
	        type: SpecialArgType.FILEFLAG,
	        flagStr: flag.getFlagString()
	    };
	}
	/**
	 * @hidden
	 */
	function fileFlagRemote2Local(remoteFlag) {
	    return FileFlag.getFileFlag(remoteFlag.flagStr);
	}
	/**
	 * @hidden
	 */
	function bufferToTransferrableObject(buff) {
	    return buffer2ArrayBuffer(buff);
	}
	/**
	 * @hidden
	 */
	function transferrableObjectToBuffer(buff) {
	    return arrayBuffer2Buffer(buff);
	}
	/**
	 * @hidden
	 */
	function bufferLocal2Remote(buff) {
	    return {
	        type: SpecialArgType.BUFFER,
	        data: bufferToTransferrableObject(buff)
	    };
	}
	/**
	 * @hidden
	 */
	function bufferRemote2Local(buffArg) {
	    return transferrableObjectToBuffer(buffArg.data);
	}
	/**
	 * @hidden
	 */
	function isAPIRequest(data) {
	    return data && typeof data === 'object' && data.hasOwnProperty('browserfsMessage') && data['browserfsMessage'];
	}
	/**
	 * @hidden
	 */
	function isAPIResponse(data) {
	    return data && typeof data === 'object' && data.hasOwnProperty('browserfsMessage') && data['browserfsMessage'];
	}
	/**
	 * Represents a remote file in a different worker/thread.
	 */
	var WorkerFile = (function (PreloadFile$$1) {
	    function WorkerFile(_fs, _path, _flag, _stat, remoteFdId, contents) {
	        PreloadFile$$1.call(this, _fs, _path, _flag, _stat, contents);
	        this._remoteFdId = remoteFdId;
	    }
	
	    if ( PreloadFile$$1 ) WorkerFile.__proto__ = PreloadFile$$1;
	    WorkerFile.prototype = Object.create( PreloadFile$$1 && PreloadFile$$1.prototype );
	    WorkerFile.prototype.constructor = WorkerFile;
	    WorkerFile.prototype.getRemoteFdId = function getRemoteFdId () {
	        return this._remoteFdId;
	    };
	    /**
	     * @hidden
	     */
	    WorkerFile.prototype.toRemoteArg = function toRemoteArg () {
	        return {
	            type: SpecialArgType.FD,
	            id: this._remoteFdId,
	            data: bufferToTransferrableObject(this.getBuffer()),
	            stat: bufferToTransferrableObject(this.getStats().toBuffer()),
	            path: this.getPath(),
	            flag: this.getFlag().getFlagString()
	        };
	    };
	    WorkerFile.prototype.sync = function sync (cb) {
	        this._syncClose('sync', cb);
	    };
	    WorkerFile.prototype.close = function close (cb) {
	        this._syncClose('close', cb);
	    };
	    WorkerFile.prototype._syncClose = function _syncClose (type, cb) {
	        var this$1 = this;
	
	        if (this.isDirty()) {
	            this._fs.syncClose(type, this, function (e) {
	                if (!e) {
	                    this$1.resetDirty();
	                }
	                cb(e);
	            });
	        }
	        else {
	            cb();
	        }
	    };
	
	    return WorkerFile;
	}(PreloadFile));
	/**
	 * WorkerFS lets you access a BrowserFS instance that is running in a different
	 * JavaScript context (e.g. access BrowserFS in one of your WebWorkers, or
	 * access BrowserFS running on the main page from a WebWorker).
	 *
	 * For example, to have a WebWorker access files in the main browser thread,
	 * do the following:
	 *
	 * MAIN BROWSER THREAD:
	 *
	 * ```javascript
	 *   // Listen for remote file system requests.
	 *   BrowserFS.FileSystem.WorkerFS.attachRemoteListener(webWorkerObject);
	 * ```
	 *
	 * WEBWORKER THREAD:
	 *
	 * ```javascript
	 *   // Set the remote file system as the root file system.
	 *   BrowserFS.configure({ fs: "WorkerFS", options: { worker: self }}, function(e) {
	 *     // Ready!
	 *   });
	 * ```
	 *
	 * Note that synchronous operations are not permitted on the WorkerFS, regardless
	 * of the configuration option of the remote FS.
	 */
	var WorkerFS = (function (BaseFileSystem$$1) {
	    function WorkerFS(worker, deprecateMsg) {
	        var this$1 = this;
	        if ( deprecateMsg === void 0 ) deprecateMsg = true;
	
	        BaseFileSystem$$1.call(this);
	        this._callbackConverter = new CallbackArgumentConverter();
	        this._isInitialized = false;
	        this._isReadOnly = false;
	        this._supportLinks = false;
	        this._supportProps = false;
	        this._worker = worker;
	        deprecationMessage(deprecateMsg, WorkerFS.Name, { worker: "Web Worker instance" });
	        this._worker.addEventListener('message', function (e) {
	            var resp = e.data;
	            if (isAPIResponse(resp)) {
	                var i;
	                var args = resp.args;
	                var fixedArgs = new Array(args.length);
	                // Dispatch event to correct id.
	                for (i = 0; i < fixedArgs.length; i++) {
	                    fixedArgs[i] = this$1._argRemote2Local(args[i]);
	                }
	                this$1._callbackConverter.toLocalArg(resp.cbId).apply(null, fixedArgs);
	            }
	        });
	    }
	
	    if ( BaseFileSystem$$1 ) WorkerFS.__proto__ = BaseFileSystem$$1;
	    WorkerFS.prototype = Object.create( BaseFileSystem$$1 && BaseFileSystem$$1.prototype );
	    WorkerFS.prototype.constructor = WorkerFS;
	    WorkerFS.Create = function Create (opts, cb) {
	        var fs = new WorkerFS(opts.worker, false);
	        fs.initialize(function () {
	            cb(null, fs);
	        });
	    };
	    WorkerFS.isAvailable = function isAvailable () {
	        return typeof (importScripts) !== 'undefined' || typeof (Worker) !== 'undefined';
	    };
	    /**
	     * Attaches a listener to the remote worker for file system requests.
	     */
	    WorkerFS.attachRemoteListener = function attachRemoteListener (worker) {
	        var fdConverter = new FileDescriptorArgumentConverter();
	        function argLocal2Remote(arg, requestArgs, cb) {
	            switch (typeof arg) {
	                case 'object':
	                    if (arg instanceof Stats) {
	                        cb(null, statsLocal2Remote(arg));
	                    }
	                    else if (arg instanceof ApiError) {
	                        cb(null, apiErrorLocal2Remote(arg));
	                    }
	                    else if (arg instanceof BaseFile) {
	                        // Pass in p and flags from original request.
	                        cb(null, fdConverter.toRemoteArg(arg, requestArgs[0], requestArgs[1], cb));
	                    }
	                    else if (arg instanceof FileFlag) {
	                        cb(null, fileFlagLocal2Remote(arg));
	                    }
	                    else if (arg instanceof Buffer) {
	                        cb(null, bufferLocal2Remote(arg));
	                    }
	                    else if (arg instanceof Error) {
	                        cb(null, errorLocal2Remote(arg));
	                    }
	                    else {
	                        cb(null, arg);
	                    }
	                    break;
	                default:
	                    cb(null, arg);
	                    break;
	            }
	        }
	        function argRemote2Local(arg, fixedRequestArgs) {
	            if (!arg) {
	                return arg;
	            }
	            switch (typeof arg) {
	                case 'object':
	                    if (typeof arg['type'] === 'number') {
	                        var specialArg = arg;
	                        switch (specialArg.type) {
	                            case SpecialArgType.CB:
	                                var cbId = arg.id;
	                                return function () {
	                                    var arguments$1 = arguments;
	
	                                    var i;
	                                    var fixedArgs = new Array(arguments.length);
	                                    var message, countdown = arguments.length;
	                                    function abortAndSendError(err) {
	                                        if (countdown > 0) {
	                                            countdown = -1;
	                                            message = {
	                                                browserfsMessage: true,
	                                                cbId: cbId,
	                                                args: [apiErrorLocal2Remote(err)]
	                                            };
	                                            worker.postMessage(message);
	                                        }
	                                    }
	                                    for (i = 0; i < arguments.length; i++) {
	                                        // Capture i and argument.
	                                        (function (i, arg) {
	                                            argLocal2Remote(arg, fixedRequestArgs, function (err, fixedArg) {
	                                                fixedArgs[i] = fixedArg;
	                                                if (err) {
	                                                    abortAndSendError(err);
	                                                }
	                                                else if (--countdown === 0) {
	                                                    message = {
	                                                        browserfsMessage: true,
	                                                        cbId: cbId,
	                                                        args: fixedArgs
	                                                    };
	                                                    worker.postMessage(message);
	                                                }
	                                            });
	                                        })(i, arguments$1[i]);
	                                    }
	                                    if (arguments.length === 0) {
	                                        message = {
	                                            browserfsMessage: true,
	                                            cbId: cbId,
	                                            args: fixedArgs
	                                        };
	                                        worker.postMessage(message);
	                                    }
	                                };
	                            case SpecialArgType.API_ERROR:
	                                return apiErrorRemote2Local(specialArg);
	                            case SpecialArgType.STATS:
	                                return statsRemote2Local(specialArg);
	                            case SpecialArgType.FILEFLAG:
	                                return fileFlagRemote2Local(specialArg);
	                            case SpecialArgType.BUFFER:
	                                return bufferRemote2Local(specialArg);
	                            case SpecialArgType.ERROR:
	                                return errorRemote2Local(specialArg);
	                            default:
	                                // No idea what this is.
	                                return arg;
	                        }
	                    }
	                    else {
	                        return arg;
	                    }
	                default:
	                    return arg;
	            }
	        }
	        worker.addEventListener('message', function (e) {
	            var request = e.data;
	            if (isAPIRequest(request)) {
	                var args = request.args, fixedArgs = new Array(args.length);
	                switch (request.method) {
	                    case 'close':
	                    case 'sync':
	                        (function () {
	                            // File descriptor-relative methods.
	                            var remoteCb = args[1];
	                            fdConverter.applyFdAPIRequest(request, function (err) {
	                                // Send response.
	                                var response = {
	                                    browserfsMessage: true,
	                                    cbId: remoteCb.id,
	                                    args: err ? [apiErrorLocal2Remote(err)] : []
	                                };
	                                worker.postMessage(response);
	                            });
	                        })();
	                        break;
	                    case 'probe':
	                        (function () {
	                            var rootFs = _fsMock.getRootFS(), remoteCb = args[1], probeResponse = {
	                                type: SpecialArgType.PROBE,
	                                isReadOnly: rootFs.isReadOnly(),
	                                supportsLinks: rootFs.supportsLinks(),
	                                supportsProps: rootFs.supportsProps()
	                            }, response = {
	                                browserfsMessage: true,
	                                cbId: remoteCb.id,
	                                args: [probeResponse]
	                            };
	                            worker.postMessage(response);
	                        })();
	                        break;
	                    default:
	                        // File system methods.
	                        for (var i = 0; i < args.length; i++) {
	                            fixedArgs[i] = argRemote2Local(args[i], fixedArgs);
	                        }
	                        var rootFS = _fsMock.getRootFS();
	                        rootFS[request.method].apply(rootFS, fixedArgs);
	                        break;
	                }
	            }
	        });
	    };
	    WorkerFS.prototype.getName = function getName () {
	        return WorkerFS.Name;
	    };
	    /**
	     * **Deprecated. Please use WorkerFS.Create() method to construct and initialize WorkerFS instances.**
	     *
	     * Called once both local and remote sides are set up.
	     */
	    WorkerFS.prototype.initialize = function initialize (cb) {
	        var this$1 = this;
	
	        if (!this._isInitialized) {
	            var message = {
	                browserfsMessage: true,
	                method: 'probe',
	                args: [this._argLocal2Remote(emptyBuffer()), this._callbackConverter.toRemoteArg(function (probeResponse) {
	                        this$1._isInitialized = true;
	                        this$1._isReadOnly = probeResponse.isReadOnly;
	                        this$1._supportLinks = probeResponse.supportsLinks;
	                        this$1._supportProps = probeResponse.supportsProps;
	                        cb();
	                    })]
	            };
	            this._worker.postMessage(message);
	        }
	        else {
	            cb();
	        }
	    };
	    WorkerFS.prototype.isReadOnly = function isReadOnly () { return this._isReadOnly; };
	    WorkerFS.prototype.supportsSynch = function supportsSynch () { return false; };
	    WorkerFS.prototype.supportsLinks = function supportsLinks () { return this._supportLinks; };
	    WorkerFS.prototype.supportsProps = function supportsProps () { return this._supportProps; };
	    WorkerFS.prototype.rename = function rename (oldPath, newPath, cb) {
	        this._rpc('rename', arguments);
	    };
	    WorkerFS.prototype.stat = function stat (p, isLstat, cb) {
	        this._rpc('stat', arguments);
	    };
	    WorkerFS.prototype.open = function open (p, flag, mode, cb) {
	        this._rpc('open', arguments);
	    };
	    WorkerFS.prototype.unlink = function unlink (p, cb) {
	        this._rpc('unlink', arguments);
	    };
	    WorkerFS.prototype.rmdir = function rmdir (p, cb) {
	        this._rpc('rmdir', arguments);
	    };
	    WorkerFS.prototype.mkdir = function mkdir (p, mode, cb) {
	        this._rpc('mkdir', arguments);
	    };
	    WorkerFS.prototype.readdir = function readdir (p, cb) {
	        this._rpc('readdir', arguments);
	    };
	    WorkerFS.prototype.exists = function exists (p, cb) {
	        this._rpc('exists', arguments);
	    };
	    WorkerFS.prototype.realpath = function realpath (p, cache, cb) {
	        this._rpc('realpath', arguments);
	    };
	    WorkerFS.prototype.truncate = function truncate (p, len, cb) {
	        this._rpc('truncate', arguments);
	    };
	    WorkerFS.prototype.readFile = function readFile (fname, encoding, flag, cb) {
	        this._rpc('readFile', arguments);
	    };
	    WorkerFS.prototype.writeFile = function writeFile (fname, data, encoding, flag, mode, cb) {
	        this._rpc('writeFile', arguments);
	    };
	    WorkerFS.prototype.appendFile = function appendFile (fname, data, encoding, flag, mode, cb) {
	        this._rpc('appendFile', arguments);
	    };
	    WorkerFS.prototype.chmod = function chmod (p, isLchmod, mode, cb) {
	        this._rpc('chmod', arguments);
	    };
	    WorkerFS.prototype.chown = function chown (p, isLchown, uid, gid, cb) {
	        this._rpc('chown', arguments);
	    };
	    WorkerFS.prototype.utimes = function utimes (p, atime, mtime, cb) {
	        this._rpc('utimes', arguments);
	    };
	    WorkerFS.prototype.link = function link (srcpath, dstpath, cb) {
	        this._rpc('link', arguments);
	    };
	    WorkerFS.prototype.symlink = function symlink (srcpath, dstpath, type, cb) {
	        this._rpc('symlink', arguments);
	    };
	    WorkerFS.prototype.readlink = function readlink (p, cb) {
	        this._rpc('readlink', arguments);
	    };
	    WorkerFS.prototype.syncClose = function syncClose (method, fd, cb) {
	        this._worker.postMessage({
	            browserfsMessage: true,
	            method: method,
	            args: [fd.toRemoteArg(), this._callbackConverter.toRemoteArg(cb)]
	        });
	    };
	    WorkerFS.prototype._argRemote2Local = function _argRemote2Local (arg) {
	        if (!arg) {
	            return arg;
	        }
	        switch (typeof arg) {
	            case 'object':
	                if (typeof arg['type'] === 'number') {
	                    var specialArg = arg;
	                    switch (specialArg.type) {
	                        case SpecialArgType.API_ERROR:
	                            return apiErrorRemote2Local(specialArg);
	                        case SpecialArgType.FD:
	                            var fdArg = specialArg;
	                            return new WorkerFile(this, fdArg.path, FileFlag.getFileFlag(fdArg.flag), Stats.fromBuffer(transferrableObjectToBuffer(fdArg.stat)), fdArg.id, transferrableObjectToBuffer(fdArg.data));
	                        case SpecialArgType.STATS:
	                            return statsRemote2Local(specialArg);
	                        case SpecialArgType.FILEFLAG:
	                            return fileFlagRemote2Local(specialArg);
	                        case SpecialArgType.BUFFER:
	                            return bufferRemote2Local(specialArg);
	                        case SpecialArgType.ERROR:
	                            return errorRemote2Local(specialArg);
	                        default:
	                            return arg;
	                    }
	                }
	                else {
	                    return arg;
	                }
	            default:
	                return arg;
	        }
	    };
	    WorkerFS.prototype._rpc = function _rpc (methodName, args) {
	        var this$1 = this;
	
	        var fixedArgs = new Array(args.length);
	        for (var i = 0; i < args.length; i++) {
	            fixedArgs[i] = this$1._argLocal2Remote(args[i]);
	        }
	        var message = {
	            browserfsMessage: true,
	            method: methodName,
	            args: fixedArgs
	        };
	        this._worker.postMessage(message);
	    };
	    /**
	     * Converts a local argument into a remote argument. Public so WorkerFile objects can call it.
	     */
	    WorkerFS.prototype._argLocal2Remote = function _argLocal2Remote (arg) {
	        if (!arg) {
	            return arg;
	        }
	        switch (typeof arg) {
	            case "object":
	                if (arg instanceof Stats) {
	                    return statsLocal2Remote(arg);
	                }
	                else if (arg instanceof ApiError) {
	                    return apiErrorLocal2Remote(arg);
	                }
	                else if (arg instanceof WorkerFile) {
	                    return arg.toRemoteArg();
	                }
	                else if (arg instanceof FileFlag) {
	                    return fileFlagLocal2Remote(arg);
	                }
	                else if (arg instanceof Buffer) {
	                    return bufferLocal2Remote(arg);
	                }
	                else if (arg instanceof Error) {
	                    return errorLocal2Remote(arg);
	                }
	                else {
	                    return "Unknown argument";
	                }
	            case "function":
	                return this._callbackConverter.toRemoteArg(arg);
	            default:
	                return arg;
	        }
	    };
	
	    return WorkerFS;
	}(BaseFileSystem));
	
	WorkerFS.Name = "WorkerFS";
	WorkerFS.Options = {
	    worker: {
	        type: "object",
	        description: "The target worker that you want to connect to, or the current worker if in a worker context.",
	        validator: function (v, cb) {
	            // Check for a `postMessage` function.
	            if (v['postMessage']) {
	                cb();
	            }
	            else {
	                cb(new ApiError(ErrorCode.EINVAL, "option must be a Web Worker instance."));
	            }
	        }
	    }
	};
	
	/**
	 * Contains utility methods for performing a variety of tasks with
	 * XmlHttpRequest across browsers.
	 */
	function asyncDownloadFileModern(p, type, cb) {
	    var req = new XMLHttpRequest();
	    req.open('GET', p, true);
	    var jsonSupported = true;
	    switch (type) {
	        case 'buffer':
	            req.responseType = 'arraybuffer';
	            break;
	        case 'json':
	            // Some browsers don't support the JSON response type.
	            // They either reset responseType, or throw an exception.
	            // @see https://github.com/Modernizr/Modernizr/blob/master/src/testXhrType.js
	            try {
	                req.responseType = 'json';
	                jsonSupported = req.responseType === 'json';
	            }
	            catch (e) {
	                jsonSupported = false;
	            }
	            break;
	        default:
	            return cb(new ApiError(ErrorCode.EINVAL, "Invalid download type: " + type));
	    }
	    req.onreadystatechange = function (e) {
	        if (req.readyState === 4) {
	            if (req.status === 200) {
	                switch (type) {
	                    case 'buffer':
	                        // XXX: WebKit-based browsers return *null* when XHRing an empty file.
	                        return cb(null, req.response ? Buffer.from(req.response) : emptyBuffer());
	                    case 'json':
	                        if (jsonSupported) {
	                            return cb(null, req.response);
	                        }
	                        else {
	                            return cb(null, JSON.parse(req.responseText));
	                        }
	                }
	            }
	            else {
	                return cb(new ApiError(req.status, "XHR error."));
	            }
	        }
	    };
	    req.send();
	}
	function syncDownloadFileModern(p, type) {
	    var req = new XMLHttpRequest();
	    req.open('GET', p, false);
	    // On most platforms, we cannot set the responseType of synchronous downloads.
	    // @todo Test for this; IE10 allows this, as do older versions of Chrome/FF.
	    var data = null;
	    var err = null;
	    // Classic hack to download binary data as a string.
	    req.overrideMimeType('text/plain; charset=x-user-defined');
	    req.onreadystatechange = function (e) {
	        if (req.readyState === 4) {
	            if (req.status === 200) {
	                switch (type) {
	                    case 'buffer':
	                        // Convert the text into a buffer.
	                        var text = req.responseText;
	                        data = Buffer.alloc(text.length);
	                        // Throw away the upper bits of each character.
	                        for (var i = 0; i < text.length; i++) {
	                            // This will automatically throw away the upper bit of each
	                            // character for us.
	                            data[i] = text.charCodeAt(i);
	                        }
	                        return;
	                    case 'json':
	                        data = JSON.parse(req.responseText);
	                        return;
	                }
	            }
	            else {
	                err = new ApiError(req.status, "XHR error.");
	                return;
	            }
	        }
	    };
	    req.send();
	    if (err) {
	        throw err;
	    }
	    return data;
	}
	function syncDownloadFileIE10(p, type) {
	    var req = new XMLHttpRequest();
	    req.open('GET', p, false);
	    switch (type) {
	        case 'buffer':
	            req.responseType = 'arraybuffer';
	            break;
	        case 'json':
	            // IE10 does not support the JSON type.
	            break;
	        default:
	            throw new ApiError(ErrorCode.EINVAL, "Invalid download type: " + type);
	    }
	    var data;
	    var err;
	    req.onreadystatechange = function (e) {
	        if (req.readyState === 4) {
	            if (req.status === 200) {
	                switch (type) {
	                    case 'buffer':
	                        data = Buffer.from(req.response);
	                        break;
	                    case 'json':
	                        data = JSON.parse(req.response);
	                        break;
	                }
	            }
	            else {
	                err = new ApiError(req.status, "XHR error.");
	            }
	        }
	    };
	    req.send();
	    if (err) {
	        throw err;
	    }
	    return data;
	}
	/**
	 * @hidden
	 */
	function getFileSize(async, p, cb) {
	    var req = new XMLHttpRequest();
	    req.open('HEAD', p, async);
	    req.onreadystatechange = function (e) {
	        if (req.readyState === 4) {
	            if (req.status === 200) {
	                try {
	                    return cb(null, parseInt(req.getResponseHeader('Content-Length') || '-1', 10));
	                }
	                catch (e) {
	                    // In the event that the header isn't present or there is an error...
	                    return cb(new ApiError(ErrorCode.EIO, "XHR HEAD error: Could not read content-length."));
	                }
	            }
	            else {
	                return cb(new ApiError(req.status, "XHR HEAD error."));
	            }
	        }
	    };
	    req.send();
	}
	/**
	 * Asynchronously download a file as a buffer or a JSON object.
	 * Note that the third function signature with a non-specialized type is
	 * invalid, but TypeScript requires it when you specialize string arguments to
	 * constants.
	 * @hidden
	 */
	var asyncDownloadFile = asyncDownloadFileModern;
	/**
	 * Synchronously download a file as a buffer or a JSON object.
	 * Note that the third function signature with a non-specialized type is
	 * invalid, but TypeScript requires it when you specialize string arguments to
	 * constants.
	 * @hidden
	 */
	var syncDownloadFile = (isIE && typeof Blob !== 'undefined') ? syncDownloadFileIE10 : syncDownloadFileModern;
	/**
	 * Synchronously retrieves the size of the given file in bytes.
	 * @hidden
	 */
	function getFileSizeSync(p) {
	    var rv = -1;
	    getFileSize(false, p, function (err, size) {
	        if (err) {
	            throw err;
	        }
	        rv = size;
	    });
	    return rv;
	}
	/**
	 * Asynchronously retrieves the size of the given file in bytes.
	 * @hidden
	 */
	function getFileSizeAsync(p, cb) {
	    getFileSize(true, p, cb);
	}
	
	/**
	 * A simple class for storing a filesystem index. Assumes that all paths passed
	 * to it are *absolute* paths.
	 *
	 * Can be used as a partial or a full index, although care must be taken if used
	 * for the former purpose, especially when directories are concerned.
	 */
	var FileIndex = function FileIndex() {
	    // _index is a single-level key,value store that maps *directory* paths to
	    // DirInodes. File information is only contained in DirInodes themselves.
	    this._index = {};
	    // Create the root directory.
	    this.addPath('/', new DirInode());
	};
	/**
	 * Static method for constructing indices from a JSON listing.
	 * @param listing Directory listing generated by tools/XHRIndexer.coffee
	 * @return A new FileIndex object.
	 */
	FileIndex.fromListing = function fromListing (listing) {
	    var idx = new FileIndex();
	    // Add a root DirNode.
	    var rootInode = new DirInode();
	    idx._index['/'] = rootInode;
	    var queue = [['', listing, rootInode]];
	    while (queue.length > 0) {
	        var inode = (void 0);
	        var next = queue.pop();
	        var pwd = next[0];
	        var tree = next[1];
	        var parent = next[2];
	        for (var node in tree) {
	            if (tree.hasOwnProperty(node)) {
	                var children = tree[node];
	                var name = pwd + "/" + node;
	                if (children) {
	                    idx._index[name] = inode = new DirInode();
	                    queue.push([name, children, inode]);
	                }
	                else {
	                    // This inode doesn't have correct size information, noted with -1.
	                    inode = new FileInode(new Stats(FileType.FILE, -1, 0x16D));
	                }
	                if (parent) {
	                    parent._ls[node] = inode;
	                }
	            }
	        }
	    }
	    return idx;
	};
	/**
	 * Runs the given function over all files in the index.
	 */
	FileIndex.prototype.fileIterator = function fileIterator (cb) {
	        var this$1 = this;
	
	    for (var path$$1 in this$1._index) {
	        if (this$1._index.hasOwnProperty(path$$1)) {
	            var dir = this$1._index[path$$1];
	            var files = dir.getListing();
	            for (var i = 0, list = files; i < list.length; i += 1) {
	                var file = list[i];
	
	                    var item = dir.getItem(file);
	                if (isFileInode(item)) {
	                    cb(item.getData());
	                }
	            }
	        }
	    }
	};
	/**
	 * Adds the given absolute path to the index if it is not already in the index.
	 * Creates any needed parent directories.
	 * @param path The path to add to the index.
	 * @param inode The inode for the
	 *   path to add.
	 * @return 'True' if it was added or already exists, 'false' if there
	 *   was an issue adding it (e.g. item in path is a file, item exists but is
	 *   different).
	 * @todo If adding fails and implicitly creates directories, we do not clean up
	 *   the new empty directories.
	 */
	FileIndex.prototype.addPath = function addPath (path$$1, inode) {
	    if (!inode) {
	        throw new Error('Inode must be specified');
	    }
	    if (path$$1[0] !== '/') {
	        throw new Error('Path must be absolute, got: ' + path$$1);
	    }
	    // Check if it already exists.
	    if (this._index.hasOwnProperty(path$$1)) {
	        return this._index[path$$1] === inode;
	    }
	    var splitPath = this._split_path(path$$1);
	    var dirpath = splitPath[0];
	    var itemname = splitPath[1];
	    // Try to add to its parent directory first.
	    var parent = this._index[dirpath];
	    if (parent === undefined && path$$1 !== '/') {
	        // Create parent.
	        parent = new DirInode();
	        if (!this.addPath(dirpath, parent)) {
	            return false;
	        }
	    }
	    // Add myself to my parent.
	    if (path$$1 !== '/') {
	        if (!parent.addItem(itemname, inode)) {
	            return false;
	        }
	    }
	    // If I'm a directory, add myself to the index.
	    if (isDirInode(inode)) {
	        this._index[path$$1] = inode;
	    }
	    return true;
	};
	/**
	 * Adds the given absolute path to the index if it is not already in the index.
	 * The path is added without special treatment (no joining of adjacent separators, etc).
	 * Creates any needed parent directories.
	 * @param path The path to add to the index.
	 * @param inode The inode for the
	 *   path to add.
	 * @return 'True' if it was added or already exists, 'false' if there
	 *   was an issue adding it (e.g. item in path is a file, item exists but is
	 *   different).
	 * @todo If adding fails and implicitly creates directories, we do not clean up
	 *   the new empty directories.
	 */
	FileIndex.prototype.addPathFast = function addPathFast (path$$1, inode) {
	    var itemNameMark = path$$1.lastIndexOf('/');
	    var parentPath = itemNameMark === 0 ? "/" : path$$1.substring(0, itemNameMark);
	    var itemName = path$$1.substring(itemNameMark + 1);
	    // Try to add to its parent directory first.
	    var parent = this._index[parentPath];
	    if (parent === undefined) {
	        // Create parent.
	        parent = new DirInode();
	        this.addPathFast(parentPath, parent);
	    }
	    if (!parent.addItem(itemName, inode)) {
	        return false;
	    }
	    // If adding a directory, add to the index as well.
	    if (inode.isDir()) {
	        this._index[path$$1] = inode;
	    }
	    return true;
	};
	/**
	 * Removes the given path. Can be a file or a directory.
	 * @return The removed item,
	 *   or null if it did not exist.
	 */
	FileIndex.prototype.removePath = function removePath (path$$1) {
	        var this$1 = this;
	
	    var splitPath = this._split_path(path$$1);
	    var dirpath = splitPath[0];
	    var itemname = splitPath[1];
	    // Try to remove it from its parent directory first.
	    var parent = this._index[dirpath];
	    if (parent === undefined) {
	        return null;
	    }
	    // Remove myself from my parent.
	    var inode = parent.remItem(itemname);
	    if (inode === null) {
	        return null;
	    }
	    // If I'm a directory, remove myself from the index, and remove my children.
	    if (isDirInode(inode)) {
	        var children = inode.getListing();
	        for (var i = 0, list = children; i < list.length; i += 1) {
	            var child = list[i];
	
	                this$1.removePath(path$$1 + '/' + child);
	        }
	        // Remove the directory from the index, unless it's the root.
	        if (path$$1 !== '/') {
	            delete this._index[path$$1];
	        }
	    }
	    return inode;
	};
	/**
	 * Retrieves the directory listing of the given path.
	 * @return An array of files in the given path, or 'null' if it does not exist.
	 */
	FileIndex.prototype.ls = function ls (path$$1) {
	    var item = this._index[path$$1];
	    if (item === undefined) {
	        return null;
	    }
	    return item.getListing();
	};
	/**
	 * Returns the inode of the given item.
	 * @return Returns null if the item does not exist.
	 */
	FileIndex.prototype.getInode = function getInode (path$$1) {
	    var splitPath = this._split_path(path$$1);
	    var dirpath = splitPath[0];
	    var itemname = splitPath[1];
	    // Retrieve from its parent directory.
	    var parent = this._index[dirpath];
	    if (parent === undefined) {
	        return null;
	    }
	    // Root case
	    if (dirpath === path$$1) {
	        return parent;
	    }
	    return parent.getItem(itemname);
	};
	/**
	 * Split into a (directory path, item name) pair
	 */
	FileIndex.prototype._split_path = function _split_path (p) {
	    var dirpath = path.dirname(p);
	    var itemname = p.substr(dirpath.length + (dirpath === "/" ? 0 : 1));
	    return [dirpath, itemname];
	};
	/**
	 * Inode for a file. Stores an arbitrary (filesystem-specific) data payload.
	 */
	var FileInode = function FileInode(data) {
	    this.data = data;
	};
	FileInode.prototype.isFile = function isFile () { return true; };
	FileInode.prototype.isDir = function isDir () { return false; };
	FileInode.prototype.getData = function getData () { return this.data; };
	FileInode.prototype.setData = function setData (data) { this.data = data; };
	/**
	 * Inode for a directory. Currently only contains the directory listing.
	 */
	var DirInode = function DirInode(data) {
	    if ( data === void 0 ) data = null;
	
	    this.data = data;
	    this._ls = {};
	};
	DirInode.prototype.isFile = function isFile () {
	    return false;
	};
	DirInode.prototype.isDir = function isDir () {
	    return true;
	};
	DirInode.prototype.getData = function getData () { return this.data; };
	/**
	 * Return a Stats object for this inode.
	 * @todo Should probably remove this at some point. This isn't the
	 *   responsibility of the FileIndex.
	 */
	DirInode.prototype.getStats = function getStats () {
	    return new Stats(FileType.DIRECTORY, 4096, 0x16D);
	};
	/**
	 * Returns the directory listing for this directory. Paths in the directory are
	 * relative to the directory's path.
	 * @return The directory listing for this directory.
	 */
	DirInode.prototype.getListing = function getListing () {
	    return Object.keys(this._ls);
	};
	/**
	 * Returns the inode for the indicated item, or null if it does not exist.
	 * @param p Name of item in this directory.
	 */
	DirInode.prototype.getItem = function getItem (p) {
	    var item = this._ls[p];
	    return item ? item : null;
	};
	/**
	 * Add the given item to the directory listing. Note that the given inode is
	 * not copied, and will be mutated by the DirInode if it is a DirInode.
	 * @param p Item name to add to the directory listing.
	 * @param inode The inode for the
	 *   item to add to the directory inode.
	 * @return True if it was added, false if it already existed.
	 */
	DirInode.prototype.addItem = function addItem (p, inode) {
	    if (p in this._ls) {
	        return false;
	    }
	    this._ls[p] = inode;
	    return true;
	};
	/**
	 * Removes the given item from the directory listing.
	 * @param p Name of item to remove from the directory listing.
	 * @return Returns the item
	 *   removed, or null if the item did not exist.
	 */
	DirInode.prototype.remItem = function remItem (p) {
	    var item = this._ls[p];
	    if (item === undefined) {
	        return null;
	    }
	    delete this._ls[p];
	    return item;
	};
	/**
	 * @hidden
	 */
	function isFileInode(inode) {
	    return !!inode && inode.isFile();
	}
	/**
	 * @hidden
	 */
	function isDirInode(inode) {
	    return !!inode && inode.isDir();
	}
	
	/**
	 * Try to convert the given buffer into a string, and pass it to the callback.
	 * Optimization that removes the needed try/catch into a helper function, as
	 * this is an uncommon case.
	 * @hidden
	 */
	function tryToString(buff, encoding, cb) {
	    try {
	        cb(null, buff.toString(encoding));
	    }
	    catch (e) {
	        cb(e);
	    }
	}
	/**
	 * A simple filesystem backed by XMLHttpRequests. You must create a directory listing using the
	 * `make_xhrfs_index` tool provided by BrowserFS.
	 *
	 * If you install BrowserFS globally with `npm i -g browserfs`, you can generate a listing by
	 * running `make_xhrfs_index` in your terminal in the directory you would like to index:
	 *
	 * ```
	 * make_xhrfs_index > index.json
	 * ```
	 *
	 * Listings objects look like the following:
	 *
	 * ```json
	 * {
	 *   "home": {
	 *     "jvilk": {
	 *       "someFile.txt": null,
	 *       "someDir": {
	 *         // Empty directory
	 *       }
	 *     }
	 *   }
	 * }
	 * ```
	 *
	 * *This example has the folder `/home/jvilk` with subfile `someFile.txt` and subfolder `someDir`.*
	 */
	var XmlHttpRequest = (function (BaseFileSystem$$1) {
	    function XmlHttpRequest(listingUrlOrObj, prefixUrl, deprecateMsg) {
	        if ( prefixUrl === void 0 ) prefixUrl = '';
	        if ( deprecateMsg === void 0 ) deprecateMsg = true;
	
	        BaseFileSystem$$1.call(this);
	        if (!listingUrlOrObj) {
	            listingUrlOrObj = 'index.json';
	        }
	        // prefix_url must end in a directory separator.
	        if (prefixUrl.length > 0 && prefixUrl.charAt(prefixUrl.length - 1) !== '/') {
	            prefixUrl = prefixUrl + '/';
	        }
	        this.prefixUrl = prefixUrl;
	        var listing = null;
	        if (typeof (listingUrlOrObj) === "string") {
	            listing = this._requestFileSync(listingUrlOrObj, 'json');
	            if (!listing) {
	                throw new Error("Unable to find listing at URL: ${listingUrlOrObj}");
	            }
	        }
	        else {
	            listing = listingUrlOrObj;
	        }
	        deprecationMessage(deprecateMsg, XmlHttpRequest.Name, { index: typeof (listingUrlOrObj) === "string" ? listingUrlOrObj : "file index as an object", baseUrl: prefixUrl });
	        this._index = FileIndex.fromListing(listing);
	    }
	
	    if ( BaseFileSystem$$1 ) XmlHttpRequest.__proto__ = BaseFileSystem$$1;
	    XmlHttpRequest.prototype = Object.create( BaseFileSystem$$1 && BaseFileSystem$$1.prototype );
	    XmlHttpRequest.prototype.constructor = XmlHttpRequest;
	    /**
	     * Construct an XmlHttpRequest file system backend with the given options.
	     */
	    XmlHttpRequest.Create = function Create (opts, cb) {
	        if (opts.index === undefined) {
	            opts.index = "index.json";
	        }
	        if (typeof (opts.index) === "string") {
	            XmlHttpRequest.FromURL(opts.index, cb, opts.baseUrl, false);
	        }
	        else {
	            cb(null, new XmlHttpRequest(opts.index, opts.baseUrl, false));
	        }
	    };
	    XmlHttpRequest.isAvailable = function isAvailable () {
	        return typeof (XMLHttpRequest) !== "undefined" && XMLHttpRequest !== null;
	    };
	    /**
	     * **Deprecated. Please use XmlHttpRequest.Create() method instead to construct XmlHttpRequest objects.**
	     *
	     * Constructs an XmlHttpRequest object using the directory listing at the given URL.
	     * Uses the base URL as the URL prefix for fetched files.
	     * @param cb Called when the file system has been instantiated, or if an error occurs.
	     */
	    XmlHttpRequest.FromURL = function FromURL (url, cb, baseUrl, deprecateMsg) {
	        if ( baseUrl === void 0 ) baseUrl = url.slice(0, url.lastIndexOf('/') + 1);
	        if ( deprecateMsg === void 0 ) deprecateMsg = true;
	
	        if (deprecateMsg) {
	            console.warn(("[XmlHttpRequest] XmlHttpRequest.FromURL() is deprecated and will be removed in the next major release. Please use 'XmlHttpRequest.Create({ index: \"" + url + "\", baseUrl: \"" + baseUrl + "\" }, cb)' instead."));
	        }
	        asyncDownloadFile(url, "json", function (e, data) {
	            if (e) {
	                cb(e);
	            }
	            else {
	                cb(null, new XmlHttpRequest(data, baseUrl, false));
	            }
	        });
	    };
	    XmlHttpRequest.prototype.empty = function empty () {
	        this._index.fileIterator(function (file) {
	            file.fileData = null;
	        });
	    };
	    XmlHttpRequest.prototype.getName = function getName () {
	        return XmlHttpRequest.Name;
	    };
	    XmlHttpRequest.prototype.diskSpace = function diskSpace (path$$1, cb) {
	        // Read-only file system. We could calculate the total space, but that's not
	        // important right now.
	        cb(0, 0);
	    };
	    XmlHttpRequest.prototype.isReadOnly = function isReadOnly () {
	        return true;
	    };
	    XmlHttpRequest.prototype.supportsLinks = function supportsLinks () {
	        return false;
	    };
	    XmlHttpRequest.prototype.supportsProps = function supportsProps () {
	        return false;
	    };
	    XmlHttpRequest.prototype.supportsSynch = function supportsSynch () {
	        return true;
	    };
	    /**
	     * Special XHR function: Preload the given file into the index.
	     * @param [String] path
	     * @param [BrowserFS.Buffer] buffer
	     */
	    XmlHttpRequest.prototype.preloadFile = function preloadFile (path$$1, buffer$$1) {
	        var inode = this._index.getInode(path$$1);
	        if (isFileInode(inode)) {
	            if (inode === null) {
	                throw ApiError.ENOENT(path$$1);
	            }
	            var stats = inode.getData();
	            stats.size = buffer$$1.length;
	            stats.fileData = buffer$$1;
	        }
	        else {
	            throw ApiError.EISDIR(path$$1);
	        }
	    };
	    XmlHttpRequest.prototype.stat = function stat (path$$1, isLstat, cb) {
	        var inode = this._index.getInode(path$$1);
	        if (inode === null) {
	            return cb(ApiError.ENOENT(path$$1));
	        }
	        var stats;
	        if (isFileInode(inode)) {
	            stats = inode.getData();
	            // At this point, a non-opened file will still have default stats from the listing.
	            if (stats.size < 0) {
	                this._requestFileSizeAsync(path$$1, function (e, size) {
	                    if (e) {
	                        return cb(e);
	                    }
	                    stats.size = size;
	                    cb(null, stats.clone());
	                });
	            }
	            else {
	                cb(null, stats.clone());
	            }
	        }
	        else if (isDirInode(inode)) {
	            stats = inode.getStats();
	            cb(null, stats);
	        }
	        else {
	            cb(ApiError.FileError(ErrorCode.EINVAL, path$$1));
	        }
	    };
	    XmlHttpRequest.prototype.statSync = function statSync (path$$1, isLstat) {
	        var inode = this._index.getInode(path$$1);
	        if (inode === null) {
	            throw ApiError.ENOENT(path$$1);
	        }
	        var stats;
	        if (isFileInode(inode)) {
	            stats = inode.getData();
	            // At this point, a non-opened file will still have default stats from the listing.
	            if (stats.size < 0) {
	                stats.size = this._requestFileSizeSync(path$$1);
	            }
	        }
	        else if (isDirInode(inode)) {
	            stats = inode.getStats();
	        }
	        else {
	            throw ApiError.FileError(ErrorCode.EINVAL, path$$1);
	        }
	        return stats;
	    };
	    XmlHttpRequest.prototype.open = function open (path$$1, flags, mode, cb) {
	        // INVARIANT: You can't write to files on this file system.
	        if (flags.isWriteable()) {
	            return cb(new ApiError(ErrorCode.EPERM, path$$1));
	        }
	        var self = this;
	        // Check if the path exists, and is a file.
	        var inode = this._index.getInode(path$$1);
	        if (inode === null) {
	            return cb(ApiError.ENOENT(path$$1));
	        }
	        if (isFileInode(inode)) {
	            var stats = inode.getData();
	            switch (flags.pathExistsAction()) {
	                case ActionType.THROW_EXCEPTION:
	                case ActionType.TRUNCATE_FILE:
	                    return cb(ApiError.EEXIST(path$$1));
	                case ActionType.NOP:
	                    // Use existing file contents.
	                    // XXX: Uh, this maintains the previously-used flag.
	                    if (stats.fileData) {
	                        return cb(null, new NoSyncFile(self, path$$1, flags, stats.clone(), stats.fileData));
	                    }
	                    // @todo be lazier about actually requesting the file
	                    this._requestFileAsync(path$$1, 'buffer', function (err, buffer$$1) {
	                        if (err) {
	                            return cb(err);
	                        }
	                        // we don't initially have file sizes
	                        stats.size = buffer$$1.length;
	                        stats.fileData = buffer$$1;
	                        return cb(null, new NoSyncFile(self, path$$1, flags, stats.clone(), buffer$$1));
	                    });
	                    break;
	                default:
	                    return cb(new ApiError(ErrorCode.EINVAL, 'Invalid FileMode object.'));
	            }
	        }
	        else {
	            return cb(ApiError.EISDIR(path$$1));
	        }
	    };
	    XmlHttpRequest.prototype.openSync = function openSync (path$$1, flags, mode) {
	        // INVARIANT: You can't write to files on this file system.
	        if (flags.isWriteable()) {
	            throw new ApiError(ErrorCode.EPERM, path$$1);
	        }
	        // Check if the path exists, and is a file.
	        var inode = this._index.getInode(path$$1);
	        if (inode === null) {
	            throw ApiError.ENOENT(path$$1);
	        }
	        if (isFileInode(inode)) {
	            var stats = inode.getData();
	            switch (flags.pathExistsAction()) {
	                case ActionType.THROW_EXCEPTION:
	                case ActionType.TRUNCATE_FILE:
	                    throw ApiError.EEXIST(path$$1);
	                case ActionType.NOP:
	                    // Use existing file contents.
	                    // XXX: Uh, this maintains the previously-used flag.
	                    if (stats.fileData) {
	                        return new NoSyncFile(this, path$$1, flags, stats.clone(), stats.fileData);
	                    }
	                    // @todo be lazier about actually requesting the file
	                    var buffer$$1 = this._requestFileSync(path$$1, 'buffer');
	                    // we don't initially have file sizes
	                    stats.size = buffer$$1.length;
	                    stats.fileData = buffer$$1;
	                    return new NoSyncFile(this, path$$1, flags, stats.clone(), buffer$$1);
	                default:
	                    throw new ApiError(ErrorCode.EINVAL, 'Invalid FileMode object.');
	            }
	        }
	        else {
	            throw ApiError.EISDIR(path$$1);
	        }
	    };
	    XmlHttpRequest.prototype.readdir = function readdir (path$$1, cb) {
	        try {
	            cb(null, this.readdirSync(path$$1));
	        }
	        catch (e) {
	            cb(e);
	        }
	    };
	    XmlHttpRequest.prototype.readdirSync = function readdirSync (path$$1) {
	        // Check if it exists.
	        var inode = this._index.getInode(path$$1);
	        if (inode === null) {
	            throw ApiError.ENOENT(path$$1);
	        }
	        else if (isDirInode(inode)) {
	            return inode.getListing();
	        }
	        else {
	            throw ApiError.ENOTDIR(path$$1);
	        }
	    };
	    /**
	     * We have the entire file as a buffer; optimize readFile.
	     */
	    XmlHttpRequest.prototype.readFile = function readFile (fname, encoding, flag, cb) {
	        // Wrap cb in file closing code.
	        var oldCb = cb;
	        // Get file.
	        this.open(fname, flag, 0x1a4, function (err, fd) {
	            if (err) {
	                return cb(err);
	            }
	            cb = function (err, arg) {
	                fd.close(function (err2) {
	                    if (!err) {
	                        err = err2;
	                    }
	                    return oldCb(err, arg);
	                });
	            };
	            var fdCast = fd;
	            var fdBuff = fdCast.getBuffer();
	            if (encoding === null) {
	                cb(err, copyingSlice(fdBuff));
	            }
	            else {
	                tryToString(fdBuff, encoding, cb);
	            }
	        });
	    };
	    /**
	     * Specially-optimized readfile.
	     */
	    XmlHttpRequest.prototype.readFileSync = function readFileSync (fname, encoding, flag) {
	        // Get file.
	        var fd = this.openSync(fname, flag, 0x1a4);
	        try {
	            var fdCast = fd;
	            var fdBuff = fdCast.getBuffer();
	            if (encoding === null) {
	                return copyingSlice(fdBuff);
	            }
	            return fdBuff.toString(encoding);
	        }
	        finally {
	            fd.closeSync();
	        }
	    };
	    XmlHttpRequest.prototype.getXhrPath = function getXhrPath (filePath) {
	        if (filePath.charAt(0) === '/') {
	            filePath = filePath.slice(1);
	        }
	        return this.prefixUrl + filePath;
	    };
	    XmlHttpRequest.prototype._requestFileAsync = function _requestFileAsync (p, type, cb) {
	        asyncDownloadFile(this.getXhrPath(p), type, cb);
	    };
	    XmlHttpRequest.prototype._requestFileSync = function _requestFileSync (p, type) {
	        return syncDownloadFile(this.getXhrPath(p), type);
	    };
	    /**
	     * Only requests the HEAD content, for the file size.
	     */
	    XmlHttpRequest.prototype._requestFileSizeAsync = function _requestFileSizeAsync (path$$1, cb) {
	        getFileSizeAsync(this.getXhrPath(path$$1), cb);
	    };
	    XmlHttpRequest.prototype._requestFileSizeSync = function _requestFileSizeSync (path$$1) {
	        return getFileSizeSync(this.getXhrPath(path$$1));
	    };
	
	    return XmlHttpRequest;
	}(BaseFileSystem));
	
	XmlHttpRequest.Name = "XmlHttpRequest";
	XmlHttpRequest.Options = {
	    index: {
	        type: ["string", "object"],
	        optional: true,
	        description: "URL to a file index as a JSON file or the file index object itself, generated with the make_xhrfs_index script. Defaults to `index.json`."
	    },
	    baseUrl: {
	        type: "string",
	        optional: true,
	        description: "Used as the URL prefix for fetched files. Default: Fetch files relative to the index."
	    }
	};
	
	/**
	 * (Nonstandard) String utility function for 8-bit ASCII with the extended
	 * character set. Unlike the ASCII above, we do not mask the high bits.
	 *
	 * Placed into a separate file so it can be used with other Buffer implementations.
	 * @see http://en.wikipedia.org/wiki/Extended_ASCII
	 */
	/**
	 * (Nonstandard) String utility function for 8-bit ASCII with the extended
	 * character set. Unlike the ASCII above, we do not mask the high bits.
	 *
	 * Placed into a separate file so it can be used with other Buffer implementations.
	 * @see http://en.wikipedia.org/wiki/Extended_ASCII
	 */ var ExtendedASCII = function ExtendedASCII () {};
	
	 ExtendedASCII.str2byte = function str2byte (str, buf) {
	    var length = str.length > buf.length ? buf.length : str.length;
	    for (var i = 0; i < length; i++) {
	        var charCode = str.charCodeAt(i);
	        if (charCode > 0x7F) {
	            // Check if extended ASCII.
	            var charIdx = ExtendedASCII.extendedChars.indexOf(str.charAt(i));
	            if (charIdx > -1) {
	                charCode = charIdx + 0x80;
	            }
	            // Otherwise, keep it as-is.
	        }
	        buf[charCode] = i;
	    }
	    return length;
	};
	ExtendedASCII.byte2str = function byte2str (buff) {
	    var chars = new Array(buff.length);
	    for (var i = 0; i < buff.length; i++) {
	        var charCode = buff[i];
	        if (charCode > 0x7F) {
	            chars[i] = ExtendedASCII.extendedChars[charCode - 128];
	        }
	        else {
	            chars[i] = String.fromCharCode(charCode);
	        }
	    }
	    return chars.join('');
	};
	ExtendedASCII.byteLength = function byteLength (str) { return str.length; };
	
	 ExtendedASCII.extendedChars = ['\u00C7', '\u00FC', '\u00E9', '\u00E2', '\u00E4',
	    '\u00E0', '\u00E5', '\u00E7', '\u00EA', '\u00EB', '\u00E8', '\u00EF',
	    '\u00EE', '\u00EC', '\u00C4', '\u00C5', '\u00C9', '\u00E6', '\u00C6',
	    '\u00F4', '\u00F6', '\u00F2', '\u00FB', '\u00F9', '\u00FF', '\u00D6',
	    '\u00DC', '\u00F8', '\u00A3', '\u00D8', '\u00D7', '\u0192', '\u00E1',
	    '\u00ED', '\u00F3', '\u00FA', '\u00F1', '\u00D1', '\u00AA', '\u00BA',
	    '\u00BF', '\u00AE', '\u00AC', '\u00BD', '\u00BC', '\u00A1', '\u00AB',
	    '\u00BB', '_', '_', '_', '\u00A6', '\u00A6', '\u00C1', '\u00C2', '\u00C0',
	    '\u00A9', '\u00A6', '\u00A6', '+', '+', '\u00A2', '\u00A5', '+', '+', '-',
	    '-', '+', '-', '+', '\u00E3', '\u00C3', '+', '+', '-', '-', '\u00A6', '-',
	    '+', '\u00A4', '\u00F0', '\u00D0', '\u00CA', '\u00CB', '\u00C8', 'i',
	    '\u00CD', '\u00CE', '\u00CF', '+', '+', '_', '_', '\u00A6', '\u00CC', '_',
	    '\u00D3', '\u00DF', '\u00D4', '\u00D2', '\u00F5', '\u00D5', '\u00B5',
	    '\u00FE', '\u00DE', '\u00DA', '\u00DB', '\u00D9', '\u00FD', '\u00DD',
	    '\u00AF', '\u00B4', '\u00AD', '\u00B1', '_', '\u00BE', '\u00B6', '\u00A7',
	    '\u00F7', '\u00B8', '\u00B0', '\u00A8', '\u00B7', '\u00B9', '\u00B3',
	    '\u00B2', '_', ' '];
	
	/**
	 * @hidden
	 */
	var inflateRaw = __webpack_require__(31).inflateRaw;
	/**
	 * Maps CompressionMethod => function that decompresses.
	 * @hidden
	 */
	var decompressionMethods = {};
	/**
	 * 4.4.2.2: Indicates the compatibiltiy of a file's external attributes.
	 */
	var ExternalFileAttributeType;
	(function (ExternalFileAttributeType) {
	    ExternalFileAttributeType[ExternalFileAttributeType["MSDOS"] = 0] = "MSDOS";
	    ExternalFileAttributeType[ExternalFileAttributeType["AMIGA"] = 1] = "AMIGA";
	    ExternalFileAttributeType[ExternalFileAttributeType["OPENVMS"] = 2] = "OPENVMS";
	    ExternalFileAttributeType[ExternalFileAttributeType["UNIX"] = 3] = "UNIX";
	    ExternalFileAttributeType[ExternalFileAttributeType["VM_CMS"] = 4] = "VM_CMS";
	    ExternalFileAttributeType[ExternalFileAttributeType["ATARI_ST"] = 5] = "ATARI_ST";
	    ExternalFileAttributeType[ExternalFileAttributeType["OS2_HPFS"] = 6] = "OS2_HPFS";
	    ExternalFileAttributeType[ExternalFileAttributeType["MAC"] = 7] = "MAC";
	    ExternalFileAttributeType[ExternalFileAttributeType["Z_SYSTEM"] = 8] = "Z_SYSTEM";
	    ExternalFileAttributeType[ExternalFileAttributeType["CP_M"] = 9] = "CP_M";
	    ExternalFileAttributeType[ExternalFileAttributeType["NTFS"] = 10] = "NTFS";
	    ExternalFileAttributeType[ExternalFileAttributeType["MVS"] = 11] = "MVS";
	    ExternalFileAttributeType[ExternalFileAttributeType["VSE"] = 12] = "VSE";
	    ExternalFileAttributeType[ExternalFileAttributeType["ACORN_RISC"] = 13] = "ACORN_RISC";
	    ExternalFileAttributeType[ExternalFileAttributeType["VFAT"] = 14] = "VFAT";
	    ExternalFileAttributeType[ExternalFileAttributeType["ALT_MVS"] = 15] = "ALT_MVS";
	    ExternalFileAttributeType[ExternalFileAttributeType["BEOS"] = 16] = "BEOS";
	    ExternalFileAttributeType[ExternalFileAttributeType["TANDEM"] = 17] = "TANDEM";
	    ExternalFileAttributeType[ExternalFileAttributeType["OS_400"] = 18] = "OS_400";
	    ExternalFileAttributeType[ExternalFileAttributeType["OSX"] = 19] = "OSX";
	})(ExternalFileAttributeType || (ExternalFileAttributeType = {}));
	/**
	 * 4.4.5
	 */
	var CompressionMethod;
	(function (CompressionMethod) {
	    CompressionMethod[CompressionMethod["STORED"] = 0] = "STORED";
	    CompressionMethod[CompressionMethod["SHRUNK"] = 1] = "SHRUNK";
	    CompressionMethod[CompressionMethod["REDUCED_1"] = 2] = "REDUCED_1";
	    CompressionMethod[CompressionMethod["REDUCED_2"] = 3] = "REDUCED_2";
	    CompressionMethod[CompressionMethod["REDUCED_3"] = 4] = "REDUCED_3";
	    CompressionMethod[CompressionMethod["REDUCED_4"] = 5] = "REDUCED_4";
	    CompressionMethod[CompressionMethod["IMPLODE"] = 6] = "IMPLODE";
	    CompressionMethod[CompressionMethod["DEFLATE"] = 8] = "DEFLATE";
	    CompressionMethod[CompressionMethod["DEFLATE64"] = 9] = "DEFLATE64";
	    CompressionMethod[CompressionMethod["TERSE_OLD"] = 10] = "TERSE_OLD";
	    CompressionMethod[CompressionMethod["BZIP2"] = 12] = "BZIP2";
	    CompressionMethod[CompressionMethod["LZMA"] = 14] = "LZMA";
	    CompressionMethod[CompressionMethod["TERSE_NEW"] = 18] = "TERSE_NEW";
	    CompressionMethod[CompressionMethod["LZ77"] = 19] = "LZ77";
	    CompressionMethod[CompressionMethod["WAVPACK"] = 97] = "WAVPACK";
	    CompressionMethod[CompressionMethod["PPMD"] = 98] = "PPMD"; // PPMd version I, Rev 1
	})(CompressionMethod || (CompressionMethod = {}));
	/**
	 * Converts the input time and date in MS-DOS format into a JavaScript Date
	 * object.
	 * @hidden
	 */
	function msdos2date(time, date) {
	    // MS-DOS Date
	    // |0 0 0 0  0|0 0 0  0|0 0 0  0 0 0 0
	    //   D (1-31)  M (1-23)  Y (from 1980)
	    var day = date & 0x1F;
	    // JS date is 0-indexed, DOS is 1-indexed.
	    var month = ((date >> 5) & 0xF) - 1;
	    var year = (date >> 9) + 1980;
	    // MS DOS Time
	    // |0 0 0 0  0|0 0 0  0 0 0|0  0 0 0 0
	    //    Second      Minute       Hour
	    var second = time & 0x1F;
	    var minute = (time >> 5) & 0x3F;
	    var hour = time >> 11;
	    return new Date(year, month, day, hour, minute, second);
	}
	/**
	 * Safely returns the string from the buffer, even if it is 0 bytes long.
	 * (Normally, calling toString() on a buffer with start === end causes an
	 * exception).
	 * @hidden
	 */
	function safeToString(buff, useUTF8, start, length) {
	    if (length === 0) {
	        return "";
	    }
	    else if (useUTF8) {
	        return buff.toString('utf8', start, start + length);
	    }
	    else {
	        return ExtendedASCII.byte2str(buff.slice(start, start + length));
	    }
	}
	/*
	   4.3.6 Overall .ZIP file format:
	
	      [local file header 1]
	      [encryption header 1]
	      [file data 1]
	      [data descriptor 1]
	      .
	      .
	      .
	      [local file header n]
	      [encryption header n]
	      [file data n]
	      [data descriptor n]
	      [archive decryption header]
	      [archive extra data record]
	      [central directory header 1]
	      .
	      .
	      .
	      [central directory header n]
	      [zip64 end of central directory record]
	      [zip64 end of central directory locator]
	      [end of central directory record]
	*/
	/**
	 * 4.3.7  Local file header:
	 *
	 *     local file header signature     4 bytes  (0x04034b50)
	 *     version needed to extract       2 bytes
	 *     general purpose bit flag        2 bytes
	 *     compression method              2 bytes
	 *    last mod file time              2 bytes
	 *    last mod file date              2 bytes
	 *    crc-32                          4 bytes
	 *    compressed size                 4 bytes
	 *    uncompressed size               4 bytes
	 *    file name length                2 bytes
	 *    extra field length              2 bytes
	 *
	 *    file name (variable size)
	 *    extra field (variable size)
	 */
	var FileHeader = function FileHeader(data) {
	     this.data = data;
	     if (data.readUInt32LE(0) !== 0x04034b50) {
	         throw new ApiError(ErrorCode.EINVAL, "Invalid Zip file: Local file header has invalid signature: " + this.data.readUInt32LE(0));
	     }
	 };
	 FileHeader.prototype.versionNeeded = function versionNeeded () { return this.data.readUInt16LE(4); };
	 FileHeader.prototype.flags = function flags () { return this.data.readUInt16LE(6); };
	 FileHeader.prototype.compressionMethod = function compressionMethod () { return this.data.readUInt16LE(8); };
	 FileHeader.prototype.lastModFileTime = function lastModFileTime () {
	     // Time and date is in MS-DOS format.
	     return msdos2date(this.data.readUInt16LE(10), this.data.readUInt16LE(12));
	 };
	 FileHeader.prototype.rawLastModFileTime = function rawLastModFileTime () {
	     return this.data.readUInt32LE(10);
	 };
	 FileHeader.prototype.crc32 = function crc32 () { return this.data.readUInt32LE(14); };
	 /**
	  * These two values are COMPLETELY USELESS.
	  *
	  * Section 4.4.9:
	  *If bit 3 of the general purpose bit flag is set,
	  *these fields are set to zero in the local header and the
	  *correct values are put in the data descriptor and
	  *in the central directory.
	  *
	  * So we'll just use the central directory's values.
	  */
	 // public compressedSize(): number { return this.data.readUInt32LE(18); }
	 // public uncompressedSize(): number { return this.data.readUInt32LE(22); }
	 FileHeader.prototype.fileNameLength = function fileNameLength () { return this.data.readUInt16LE(26); };
	 FileHeader.prototype.extraFieldLength = function extraFieldLength () { return this.data.readUInt16LE(28); };
	 FileHeader.prototype.fileName = function fileName () {
	     return safeToString(this.data, this.useUTF8(), 30, this.fileNameLength());
	 };
	 FileHeader.prototype.extraField = function extraField () {
	     var start = 30 + this.fileNameLength();
	     return this.data.slice(start, start + this.extraFieldLength());
	 };
	 FileHeader.prototype.totalSize = function totalSize () { return 30 + this.fileNameLength() + this.extraFieldLength(); };
	 FileHeader.prototype.useUTF8 = function useUTF8 () { return (this.flags() & 0x800) === 0x800; };
	/**
	 * 4.3.8  File data
	 *
	 *   Immediately following the local header for a file
	 *   SHOULD be placed the compressed or stored data for the file.
	 *   If the file is encrypted, the encryption header for the file
	 *   SHOULD be placed after the local header and before the file
	 *   data. The series of [local file header][encryption header]
	 *   [file data][data descriptor] repeats for each file in the
	 *   .ZIP archive.
	 *
	 *   Zero-byte files, directories, and other file types that
	 *   contain no content MUST not include file data.
	 */
	var FileData = function FileData(header, record, data) {
	     this.header = header;
	     this.record = record;
	     this.data = data;
	 };
	 FileData.prototype.decompress = function decompress () {
	     // Check the compression
	     var compressionMethod = this.header.compressionMethod();
	     var fcn = decompressionMethods[compressionMethod];
	     if (fcn) {
	         return fcn(this.data, this.record.compressedSize(), this.record.uncompressedSize(), this.record.flag());
	     }
	     else {
	         var name = CompressionMethod[compressionMethod];
	         if (!name) {
	             name = "Unknown: " + compressionMethod;
	         }
	         throw new ApiError(ErrorCode.EINVAL, ("Invalid compression method on file '" + (this.header.fileName()) + "': " + name));
	     }
	 };
	 FileData.prototype.getHeader = function getHeader () {
	     return this.header;
	 };
	 FileData.prototype.getRecord = function getRecord () {
	     return this.record;
	 };
	 FileData.prototype.getRawData = function getRawData () {
	     return this.data;
	 };
	/**
	 * 4.3.9  Data descriptor:
	 *
	 *    crc-32                          4 bytes
	 *    compressed size                 4 bytes
	 *    uncompressed size               4 bytes
	 */
	var DataDescriptor = function DataDescriptor(data) {
	     this.data = data;
	 };
	 DataDescriptor.prototype.crc32 = function crc32 () { return this.data.readUInt32LE(0); };
	 DataDescriptor.prototype.compressedSize = function compressedSize () { return this.data.readUInt32LE(4); };
	 DataDescriptor.prototype.uncompressedSize = function uncompressedSize () { return this.data.readUInt32LE(8); };
	/*
	` 4.3.10  Archive decryption header:
	
	      4.3.10.1 The Archive Decryption Header is introduced in version 6.2
	      of the ZIP format specification.  This record exists in support
	      of the Central Directory Encryption Feature implemented as part of
	      the Strong Encryption Specification as described in this document.
	      When the Central Directory Structure is encrypted, this decryption
	      header MUST precede the encrypted data segment.
	 */
	/**
	 * 4.3.11  Archive extra data record:
	 *
	 *      archive extra data signature    4 bytes  (0x08064b50)
	 *      extra field length              4 bytes
	 *      extra field data                (variable size)
	 *
	 *    4.3.11.1 The Archive Extra Data Record is introduced in version 6.2
	 *    of the ZIP format specification.  This record MAY be used in support
	 *    of the Central Directory Encryption Feature implemented as part of
	 *    the Strong Encryption Specification as described in this document.
	 *    When present, this record MUST immediately precede the central
	 *    directory data structure.
	 */
	var ArchiveExtraDataRecord = function ArchiveExtraDataRecord(data) {
	     this.data = data;
	     if (this.data.readUInt32LE(0) !== 0x08064b50) {
	         throw new ApiError(ErrorCode.EINVAL, "Invalid archive extra data record signature: " + this.data.readUInt32LE(0));
	     }
	 };
	 ArchiveExtraDataRecord.prototype.length = function length () { return this.data.readUInt32LE(4); };
	 ArchiveExtraDataRecord.prototype.extraFieldData = function extraFieldData () { return this.data.slice(8, 8 + this.length()); };
	/**
	 * 4.3.13 Digital signature:
	 *
	 *      header signature                4 bytes  (0x05054b50)
	 *      size of data                    2 bytes
	 *      signature data (variable size)
	 *
	 *    With the introduction of the Central Directory Encryption
	 *    feature in version 6.2 of this specification, the Central
	 *    Directory Structure MAY be stored both compressed and encrypted.
	 *    Although not required, it is assumed when encrypting the
	 *    Central Directory Structure, that it will be compressed
	 *    for greater storage efficiency.  Information on the
	 *    Central Directory Encryption feature can be found in the section
	 *    describing the Strong Encryption Specification. The Digital
	 *    Signature record will be neither compressed nor encrypted.
	 */
	var DigitalSignature = function DigitalSignature(data) {
	     this.data = data;
	     if (this.data.readUInt32LE(0) !== 0x05054b50) {
	         throw new ApiError(ErrorCode.EINVAL, "Invalid digital signature signature: " + this.data.readUInt32LE(0));
	     }
	 };
	 DigitalSignature.prototype.size = function size () { return this.data.readUInt16LE(4); };
	 DigitalSignature.prototype.signatureData = function signatureData () { return this.data.slice(6, 6 + this.size()); };
	/**
	 * 4.3.12  Central directory structure:
	 *
	 *  central file header signature   4 bytes  (0x02014b50)
	 *  version made by                 2 bytes
	 *  version needed to extract       2 bytes
	 *  general purpose bit flag        2 bytes
	 *  compression method              2 bytes
	 *  last mod file time              2 bytes
	 *  last mod file date              2 bytes
	 *  crc-32                          4 bytes
	 *  compressed size                 4 bytes
	 *  uncompressed size               4 bytes
	 *  file name length                2 bytes
	 *  extra field length              2 bytes
	 *  file comment length             2 bytes
	 *  disk number start               2 bytes
	 *  internal file attributes        2 bytes
	 *  external file attributes        4 bytes
	 *  relative offset of local header 4 bytes
	 *
	 *  file name (variable size)
	 *  extra field (variable size)
	 *  file comment (variable size)
	 */
	var CentralDirectory = function CentralDirectory(zipData, data) {
	     this.zipData = zipData;
	     this.data = data;
	     // Sanity check.
	     if (this.data.readUInt32LE(0) !== 0x02014b50) {
	         throw new ApiError(ErrorCode.EINVAL, ("Invalid Zip file: Central directory record has invalid signature: " + (this.data.readUInt32LE(0))));
	     }
	     this._filename = this.produceFilename();
	 };
	 CentralDirectory.prototype.versionMadeBy = function versionMadeBy () { return this.data.readUInt16LE(4); };
	 CentralDirectory.prototype.versionNeeded = function versionNeeded () { return this.data.readUInt16LE(6); };
	 CentralDirectory.prototype.flag = function flag () { return this.data.readUInt16LE(8); };
	 CentralDirectory.prototype.compressionMethod = function compressionMethod () { return this.data.readUInt16LE(10); };
	 CentralDirectory.prototype.lastModFileTime = function lastModFileTime () {
	     // Time and date is in MS-DOS format.
	     return msdos2date(this.data.readUInt16LE(12), this.data.readUInt16LE(14));
	 };
	 CentralDirectory.prototype.rawLastModFileTime = function rawLastModFileTime () {
	     return this.data.readUInt32LE(12);
	 };
	 CentralDirectory.prototype.crc32 = function crc32 () { return this.data.readUInt32LE(16); };
	 CentralDirectory.prototype.compressedSize = function compressedSize () { return this.data.readUInt32LE(20); };
	 CentralDirectory.prototype.uncompressedSize = function uncompressedSize () { return this.data.readUInt32LE(24); };
	 CentralDirectory.prototype.fileNameLength = function fileNameLength () { return this.data.readUInt16LE(28); };
	 CentralDirectory.prototype.extraFieldLength = function extraFieldLength () { return this.data.readUInt16LE(30); };
	 CentralDirectory.prototype.fileCommentLength = function fileCommentLength () { return this.data.readUInt16LE(32); };
	 CentralDirectory.prototype.diskNumberStart = function diskNumberStart () { return this.data.readUInt16LE(34); };
	 CentralDirectory.prototype.internalAttributes = function internalAttributes () { return this.data.readUInt16LE(36); };
	 CentralDirectory.prototype.externalAttributes = function externalAttributes () { return this.data.readUInt32LE(38); };
	 CentralDirectory.prototype.headerRelativeOffset = function headerRelativeOffset () { return this.data.readUInt32LE(42); };
	 CentralDirectory.prototype.produceFilename = function produceFilename () {
	     /*
	       4.4.17.1 claims:
	       * All slashes are forward ('/') slashes.
	       * Filename doesn't begin with a slash.
	       * No drive letters or any nonsense like that.
	       * If filename is missing, the input came from standard input.
	    
	       Unfortunately, this isn't true in practice. Some Windows zip utilities use
	       a backslash here, but the correct Unix-style path in file headers.
	    
	       To avoid seeking all over the file to recover the known-good filenames
	       from file headers, we simply convert '/' to '\' here.
	     */
	     var fileName = safeToString(this.data, this.useUTF8(), 46, this.fileNameLength());
	     return fileName.replace(/\\/g, "/");
	 };
	 CentralDirectory.prototype.fileName = function fileName () {
	     return this._filename;
	 };
	 CentralDirectory.prototype.rawFileName = function rawFileName () {
	     return this.data.slice(46, 46 + this.fileNameLength());
	 };
	 CentralDirectory.prototype.extraField = function extraField () {
	     var start = 44 + this.fileNameLength();
	     return this.data.slice(start, start + this.extraFieldLength());
	 };
	 CentralDirectory.prototype.fileComment = function fileComment () {
	     var start = 46 + this.fileNameLength() + this.extraFieldLength();
	     return safeToString(this.data, this.useUTF8(), start, this.fileCommentLength());
	 };
	 CentralDirectory.prototype.rawFileComment = function rawFileComment () {
	     var start = 46 + this.fileNameLength() + this.extraFieldLength();
	     return this.data.slice(start, start + this.fileCommentLength());
	 };
	 CentralDirectory.prototype.totalSize = function totalSize () {
	     return 46 + this.fileNameLength() + this.extraFieldLength() + this.fileCommentLength();
	 };
	 CentralDirectory.prototype.isDirectory = function isDirectory () {
	     // NOTE: This assumes that the zip file implementation uses the lower byte
	     //    of external attributes for DOS attributes for
	     //    backwards-compatibility. This is not mandated, but appears to be
	     //    commonplace.
	     //    According to the spec, the layout of external attributes is
	     //    platform-dependent.
	     //    If that fails, we also check if the name of the file ends in '/',
	     //    which is what Java's ZipFile implementation does.
	     var fileName = this.fileName();
	     return (this.externalAttributes() & 0x10 ? true : false) || (fileName.charAt(fileName.length - 1) === '/');
	 };
	 CentralDirectory.prototype.isFile = function isFile () { return !this.isDirectory(); };
	 CentralDirectory.prototype.useUTF8 = function useUTF8 () { return (this.flag() & 0x800) === 0x800; };
	 CentralDirectory.prototype.isEncrypted = function isEncrypted () { return (this.flag() & 0x1) === 0x1; };
	 CentralDirectory.prototype.getFileData = function getFileData () {
	     // Need to grab the header before we can figure out where the actual
	     // compressed data starts.
	     var start = this.headerRelativeOffset();
	     var header = new FileHeader(this.zipData.slice(start));
	     return new FileData(header, this, this.zipData.slice(start + header.totalSize()));
	 };
	 CentralDirectory.prototype.getData = function getData () {
	     return this.getFileData().decompress();
	 };
	 CentralDirectory.prototype.getRawData = function getRawData () {
	     return this.getFileData().getRawData();
	 };
	 CentralDirectory.prototype.getStats = function getStats () {
	     return new Stats(FileType.FILE, this.uncompressedSize(), 0x16D, new Date(), this.lastModFileTime());
	 };
	/**
	 * 4.3.16: end of central directory record
	 *  end of central dir signature    4 bytes  (0x06054b50)
	 *  number of this disk             2 bytes
	 *  number of the disk with the
	 *  start of the central directory  2 bytes
	 *  total number of entries in the
	 *  central directory on this disk  2 bytes
	 *  total number of entries in
	 *  the central directory           2 bytes
	 *  size of the central directory   4 bytes
	 *  offset of start of central
	 *  directory with respect to
	 *  the starting disk number        4 bytes
	 *  .ZIP file comment length        2 bytes
	 *  .ZIP file comment       (variable size)
	 */
	var EndOfCentralDirectory = function EndOfCentralDirectory(data) {
	     this.data = data;
	     if (this.data.readUInt32LE(0) !== 0x06054b50) {
	         throw new ApiError(ErrorCode.EINVAL, ("Invalid Zip file: End of central directory record has invalid signature: " + (this.data.readUInt32LE(0))));
	     }
	 };
	 EndOfCentralDirectory.prototype.diskNumber = function diskNumber () { return this.data.readUInt16LE(4); };
	 EndOfCentralDirectory.prototype.cdDiskNumber = function cdDiskNumber () { return this.data.readUInt16LE(6); };
	 EndOfCentralDirectory.prototype.cdDiskEntryCount = function cdDiskEntryCount () { return this.data.readUInt16LE(8); };
	 EndOfCentralDirectory.prototype.cdTotalEntryCount = function cdTotalEntryCount () { return this.data.readUInt16LE(10); };
	 EndOfCentralDirectory.prototype.cdSize = function cdSize () { return this.data.readUInt32LE(12); };
	 EndOfCentralDirectory.prototype.cdOffset = function cdOffset () { return this.data.readUInt32LE(16); };
	 EndOfCentralDirectory.prototype.cdZipCommentLength = function cdZipCommentLength () { return this.data.readUInt16LE(20); };
	 EndOfCentralDirectory.prototype.cdZipComment = function cdZipComment () {
	     // Assuming UTF-8. The specification doesn't specify.
	     return safeToString(this.data, true, 22, this.cdZipCommentLength());
	 };
	 EndOfCentralDirectory.prototype.rawCdZipComment = function rawCdZipComment () {
	     return this.data.slice(22, 22 + this.cdZipCommentLength());
	 };
	/**
	 * Contains the table of contents of a Zip file.
	 */
	var ZipTOC = function ZipTOC(index, directoryEntries, eocd, data) {
	     this.index = index;
	     this.directoryEntries = directoryEntries;
	     this.eocd = eocd;
	     this.data = data;
	 };
	/**
	 * Zip file-backed filesystem
	 * Implemented according to the standard:
	 * http://www.pkware.com/documents/casestudies/APPNOTE.TXT
	 *
	 * While there are a few zip libraries for JavaScript (e.g. JSZip and zip.js),
	 * they are not a good match for BrowserFS. In particular, these libraries
	 * perform a lot of unneeded data copying, and eagerly decompress every file
	 * in the zip file upon loading to check the CRC32. They also eagerly decode
	 * strings. Furthermore, these libraries duplicate functionality already present
	 * in BrowserFS (e.g. UTF-8 decoding and binary data manipulation).
	 *
	 * This filesystem takes advantage of BrowserFS's Buffer implementation, which
	 * efficiently represents the zip file in memory (in both ArrayBuffer-enabled
	 * browsers *and* non-ArrayBuffer browsers), and which can neatly be 'sliced'
	 * without copying data. Each struct defined in the standard is represented with
	 * a buffer slice pointing to an offset in the zip file, and has getters for
	 * each field. As we anticipate that this data will not be read often, we choose
	 * not to store each struct field in the JavaScript object; instead, to reduce
	 * memory consumption, we retrieve it directly from the binary data each time it
	 * is requested.
	 *
	 * When the filesystem is instantiated, we determine the directory structure
	 * of the zip file as quickly as possible. We lazily decompress and check the
	 * CRC32 of files. We do not cache decompressed files; if this is a desired
	 * feature, it is best implemented as a generic file system wrapper that can
	 * cache data from arbitrary file systems.
	 *
	 * For inflation, we use `pako`'s implementation:
	 * https://github.com/nodeca/pako
	 *
	 * Current limitations:
	 * * No encryption.
	 * * No ZIP64 support.
	 * * Read-only.
	 *   Write support would require that we:
	 *   - Keep track of changed/new files.
	 *   - Compress changed files, and generate appropriate metadata for each.
	 *   - Update file offsets for other files in the zip file.
	 *   - Stream it out to a location.
	 *   This isn't that bad, so we might do this at a later date.
	 */
	var ZipFS = (function (SynchronousFileSystem$$1) {
	   function ZipFS(input, name, deprecateMsg) {
	        if ( name === void 0 ) name = '';
	        if ( deprecateMsg === void 0 ) deprecateMsg = true;
	
	        SynchronousFileSystem$$1.call(this);
	        this.name = name;
	        this._index = new FileIndex();
	        this._directoryEntries = [];
	        this._eocd = null;
	        deprecationMessage(deprecateMsg, ZipFS.Name, { zipData: "zip data as a Buffer", name: name });
	        if (input instanceof ZipTOC) {
	            this._index = input.index;
	            this._directoryEntries = input.directoryEntries;
	            this._eocd = input.eocd;
	            this.data = input.data;
	        }
	        else {
	            this.data = input;
	            this.populateIndex();
	        }
	    }
	
	   if ( SynchronousFileSystem$$1 ) ZipFS.__proto__ = SynchronousFileSystem$$1;
	   ZipFS.prototype = Object.create( SynchronousFileSystem$$1 && SynchronousFileSystem$$1.prototype );
	   ZipFS.prototype.constructor = ZipFS;
	    /**
	     * Constructs a ZipFS instance with the given options.
	     */
	    ZipFS.Create = function Create (opts, cb) {
	        try {
	            ZipFS.computeIndex(opts.zipData, function (zipTOC) {
	                var fs = new ZipFS(zipTOC, opts.name, false);
	                cb(null, fs);
	            }, false);
	        }
	        catch (e) {
	            cb(e);
	        }
	    };
	    ZipFS.isAvailable = function isAvailable () { return true; };
	    ZipFS.RegisterDecompressionMethod = function RegisterDecompressionMethod (m, fcn) {
	        decompressionMethods[m] = fcn;
	    };
	    /**
	     * **Deprecated. Please use ZipFS.Create() method instead.**
	     */
	    ZipFS.computeIndex = function computeIndex (data, cb, deprecateMsg) {
	        if ( deprecateMsg === void 0 ) deprecateMsg = true;
	
	        // TODO: Refactor to plumb errors through. Right now, they throw.
	        if (deprecateMsg) {
	            console.warn("[ZipFS] ZipFS.computeIndex is now deprecated, and will be removed in the next major release. Please update your code to use 'ZipFS.Create({ zipData: zip file as a Buffer}, cb)' instead.");
	        }
	        var index = new FileIndex();
	        var eocd = ZipFS.getEOCD(data);
	        if (eocd.diskNumber() !== eocd.cdDiskNumber()) {
	            throw new ApiError(ErrorCode.EINVAL, "ZipFS does not support spanned zip files.");
	        }
	        var cdPtr = eocd.cdOffset();
	        if (cdPtr === 0xFFFFFFFF) {
	            throw new ApiError(ErrorCode.EINVAL, "ZipFS does not support Zip64.");
	        }
	        var cdEnd = cdPtr + eocd.cdSize();
	        ZipFS.computeIndexResponsive(data, index, cdPtr, cdEnd, cb, [], eocd);
	    };
	    /**
	     * Locates the end of central directory record at the end of the file.
	     * Throws an exception if it cannot be found.
	     */
	    ZipFS.getEOCD = function getEOCD (data) {
	        // Unfortunately, the comment is variable size and up to 64K in size.
	        // We assume that the magic signature does not appear in the comment, and
	        // in the bytes between the comment and the signature. Other ZIP
	        // implementations make this same assumption, since the alternative is to
	        // read thread every entry in the file to get to it. :(
	        // These are *negative* offsets from the end of the file.
	        var startOffset = 22;
	        var endOffset = Math.min(startOffset + 0xFFFF, data.length - 1);
	        // There's not even a byte alignment guarantee on the comment so we need to
	        // search byte by byte. *grumble grumble*
	        for (var i = startOffset; i < endOffset; i++) {
	            // Magic number: EOCD Signature
	            if (data.readUInt32LE(data.length - i) === 0x06054b50) {
	                return new EndOfCentralDirectory(data.slice(data.length - i));
	            }
	        }
	        throw new ApiError(ErrorCode.EINVAL, "Invalid ZIP file: Could not locate End of Central Directory signature.");
	    };
	    ZipFS.addToIndex = function addToIndex (cd, index) {
	        // Paths must be absolute, yet zip file paths are always relative to the
	        // zip root. So we append '/' and call it a day.
	        var filename = cd.fileName();
	        if (filename.charAt(0) === '/') {
	            throw new Error("WHY IS THIS ABSOLUTE");
	        }
	        // XXX: For the file index, strip the trailing '/'.
	        if (filename.charAt(filename.length - 1) === '/') {
	            filename = filename.substr(0, filename.length - 1);
	        }
	        if (cd.isDirectory()) {
	            index.addPathFast('/' + filename, new DirInode(cd));
	        }
	        else {
	            index.addPathFast('/' + filename, new FileInode(cd));
	        }
	    };
	    ZipFS.computeIndexResponsive = function computeIndexResponsive (data, index, cdPtr, cdEnd, cb, cdEntries, eocd) {
	        if (cdPtr < cdEnd) {
	            var count = 0;
	            while (count++ < 200 && cdPtr < cdEnd) {
	                var cd = new CentralDirectory(data, data.slice(cdPtr));
	                ZipFS.addToIndex(cd, index);
	                cdPtr += cd.totalSize();
	                cdEntries.push(cd);
	            }
	            setImmediate$3(function () {
	                ZipFS.computeIndexResponsive(data, index, cdPtr, cdEnd, cb, cdEntries, eocd);
	            });
	        }
	        else {
	            cb(new ZipTOC(index, cdEntries, eocd, data));
	        }
	    };
	    ZipFS.prototype.getName = function getName () {
	        return ZipFS.Name + (this.name !== '' ? (" " + (this.name)) : '');
	    };
	    /**
	     * Get the CentralDirectory object for the given path.
	     */
	    ZipFS.prototype.getCentralDirectoryEntry = function getCentralDirectoryEntry (path$$1) {
	        var inode = this._index.getInode(path$$1);
	        if (inode === null) {
	            throw ApiError.ENOENT(path$$1);
	        }
	        if (isFileInode(inode)) {
	            return inode.getData();
	        }
	        else if (isDirInode(inode)) {
	            return inode.getData();
	        }
	        else {
	            // Should never occur.
	            throw ApiError.EPERM(("Invalid inode: " + inode));
	        }
	    };
	    ZipFS.prototype.getCentralDirectoryEntryAt = function getCentralDirectoryEntryAt (index) {
	        var dirEntry = this._directoryEntries[index];
	        if (!dirEntry) {
	            throw new RangeError(("Invalid directory index: " + index + "."));
	        }
	        return dirEntry;
	    };
	    ZipFS.prototype.getNumberOfCentralDirectoryEntries = function getNumberOfCentralDirectoryEntries () {
	        return this._directoryEntries.length;
	    };
	    ZipFS.prototype.getEndOfCentralDirectory = function getEndOfCentralDirectory () {
	        return this._eocd;
	    };
	    ZipFS.prototype.diskSpace = function diskSpace (path$$1, cb) {
	        // Read-only file system.
	        cb(this.data.length, 0);
	    };
	    ZipFS.prototype.isReadOnly = function isReadOnly () {
	        return true;
	    };
	    ZipFS.prototype.supportsLinks = function supportsLinks () {
	        return false;
	    };
	    ZipFS.prototype.supportsProps = function supportsProps () {
	        return false;
	    };
	    ZipFS.prototype.supportsSynch = function supportsSynch () {
	        return true;
	    };
	    ZipFS.prototype.statSync = function statSync (path$$1, isLstat) {
	        var inode = this._index.getInode(path$$1);
	        if (inode === null) {
	            throw ApiError.ENOENT(path$$1);
	        }
	        var stats;
	        if (isFileInode(inode)) {
	            stats = inode.getData().getStats();
	        }
	        else if (isDirInode(inode)) {
	            stats = inode.getStats();
	        }
	        else {
	            throw new ApiError(ErrorCode.EINVAL, "Invalid inode.");
	        }
	        return stats;
	    };
	    ZipFS.prototype.openSync = function openSync (path$$1, flags, mode) {
	        // INVARIANT: Cannot write to RO file systems.
	        if (flags.isWriteable()) {
	            throw new ApiError(ErrorCode.EPERM, path$$1);
	        }
	        // Check if the path exists, and is a file.
	        var inode = this._index.getInode(path$$1);
	        if (!inode) {
	            throw ApiError.ENOENT(path$$1);
	        }
	        else if (isFileInode(inode)) {
	            var cdRecord = inode.getData();
	            var stats = cdRecord.getStats();
	            switch (flags.pathExistsAction()) {
	                case ActionType.THROW_EXCEPTION:
	                case ActionType.TRUNCATE_FILE:
	                    throw ApiError.EEXIST(path$$1);
	                case ActionType.NOP:
	                    return new NoSyncFile(this, path$$1, flags, stats, cdRecord.getData());
	                default:
	                    throw new ApiError(ErrorCode.EINVAL, 'Invalid FileMode object.');
	            }
	        }
	        else {
	            throw ApiError.EISDIR(path$$1);
	        }
	    };
	    ZipFS.prototype.readdirSync = function readdirSync (path$$1) {
	        // Check if it exists.
	        var inode = this._index.getInode(path$$1);
	        if (!inode) {
	            throw ApiError.ENOENT(path$$1);
	        }
	        else if (isDirInode(inode)) {
	            return inode.getListing();
	        }
	        else {
	            throw ApiError.ENOTDIR(path$$1);
	        }
	    };
	    /**
	     * Specially-optimized readfile.
	     */
	    ZipFS.prototype.readFileSync = function readFileSync (fname, encoding, flag) {
	        // Get file.
	        var fd = this.openSync(fname, flag, 0x1a4);
	        try {
	            var fdCast = fd;
	            var fdBuff = fdCast.getBuffer();
	            if (encoding === null) {
	                return copyingSlice(fdBuff);
	            }
	            return fdBuff.toString(encoding);
	        }
	        finally {
	            fd.closeSync();
	        }
	    };
	    ZipFS.prototype.populateIndex = function populateIndex () {
	        var this$1 = this;
	
	        var eocd = this._eocd = ZipFS.getEOCD(this.data);
	        if (eocd.diskNumber() !== eocd.cdDiskNumber()) {
	            throw new ApiError(ErrorCode.EINVAL, "ZipFS does not support spanned zip files.");
	        }
	        var cdPtr = eocd.cdOffset();
	        if (cdPtr === 0xFFFFFFFF) {
	            throw new ApiError(ErrorCode.EINVAL, "ZipFS does not support Zip64.");
	        }
	        var cdEnd = cdPtr + eocd.cdSize();
	        while (cdPtr < cdEnd) {
	            var cd = new CentralDirectory(this$1.data, this$1.data.slice(cdPtr));
	            cdPtr += cd.totalSize();
	            ZipFS.addToIndex(cd, this$1._index);
	            this$1._directoryEntries.push(cd);
	        }
	    };
	
	   return ZipFS;
	}(SynchronousFileSystem));
	
	ZipFS.Name = "ZipFS";
	ZipFS.Options = {
	    zipData: {
	        type: "object",
	        description: "The zip file as a Buffer object.",
	        validator: bufferValidator
	    },
	    name: {
	        type: "string",
	        optional: true,
	        description: "The name of the zip file (optional)."
	    }
	};
	ZipFS.CompressionMethod = CompressionMethod;
	ZipFS.RegisterDecompressionMethod(CompressionMethod.DEFLATE, function (data, compressedSize, uncompressedSize) {
	    return arrayish2Buffer(inflateRaw(data.slice(0, compressedSize), { chunkSize: uncompressedSize }));
	});
	ZipFS.RegisterDecompressionMethod(CompressionMethod.STORED, function (data, compressedSize, uncompressedSize) {
	    return copyingSlice(data, 0, uncompressedSize);
	});
	
	/**
	 * @hidden
	 */
	var rockRidgeIdentifier = "IEEE_P1282";
	/**
	 * @hidden
	 */
	function getASCIIString(data, startIndex, length) {
	    return data.toString('ascii', startIndex, startIndex + length).trim();
	}
	/**
	 * @hidden
	 */
	function getJolietString(data, startIndex, length) {
	    if (length === 1) {
	        // Special: Root, parent, current directory are still a single byte.
	        return String.fromCharCode(data[startIndex]);
	    }
	    // UTF16-BE, which isn't natively supported by NodeJS Buffers.
	    // Length should be even, but pessimistically floor just in case.
	    var pairs = Math.floor(length / 2);
	    var chars = new Array(pairs);
	    for (var i = 0; i < pairs; i++) {
	        var pos = startIndex + (i << 1);
	        chars[i] = String.fromCharCode(data[pos + 1] | (data[pos] << 8));
	    }
	    return chars.join('');
	}
	/**
	 * @hidden
	 */
	function getDate(data, startIndex) {
	    var year = parseInt(getASCIIString(data, startIndex, 4), 10);
	    var mon = parseInt(getASCIIString(data, startIndex + 4, 2), 10);
	    var day = parseInt(getASCIIString(data, startIndex + 6, 2), 10);
	    var hour = parseInt(getASCIIString(data, startIndex + 8, 2), 10);
	    var min = parseInt(getASCIIString(data, startIndex + 10, 2), 10);
	    var sec = parseInt(getASCIIString(data, startIndex + 12, 2), 10);
	    var hundrethsSec = parseInt(getASCIIString(data, startIndex + 14, 2), 10);
	    // Last is a time-zone offset, but JavaScript dates don't support time zones well.
	    return new Date(year, mon, day, hour, min, sec, hundrethsSec * 100);
	}
	/**
	 * @hidden
	 */
	function getShortFormDate(data, startIndex) {
	    var yearsSince1900 = data[startIndex];
	    var month = data[startIndex + 1];
	    var day = data[startIndex + 2];
	    var hour = data[startIndex + 3];
	    var minute = data[startIndex + 4];
	    var second = data[startIndex + 5];
	    // JavaScript's Date support isn't so great; ignore timezone.
	    // const offsetFromGMT = this._data[24];
	    return new Date(yearsSince1900, month - 1, day, hour, minute, second);
	}
	/**
	 * @hidden
	 */
	function constructSystemUseEntry(bigData, i) {
	    var data = bigData.slice(i);
	    var sue = new SystemUseEntry(data);
	    switch (sue.signatureWord()) {
	        case 17221 /* CE */:
	            return new CEEntry(data);
	        case 20548 /* PD */:
	            return new PDEntry(data);
	        case 21328 /* SP */:
	            return new SPEntry(data);
	        case 21332 /* ST */:
	            return new STEntry(data);
	        case 17746 /* ER */:
	            return new EREntry(data);
	        case 17747 /* ES */:
	            return new ESEntry(data);
	        case 20568 /* PX */:
	            return new PXEntry(data);
	        case 20558 /* PN */:
	            return new PNEntry(data);
	        case 21324 /* SL */:
	            return new SLEntry(data);
	        case 20045 /* NM */:
	            return new NMEntry(data);
	        case 17228 /* CL */:
	            return new CLEntry(data);
	        case 20556 /* PL */:
	            return new PLEntry(data);
	        case 21061 /* RE */:
	            return new REEntry(data);
	        case 21574 /* TF */:
	            return new TFEntry(data);
	        case 21318 /* SF */:
	            return new SFEntry(data);
	        case 21074 /* RR */:
	            return new RREntry(data);
	        default:
	            return sue;
	    }
	}
	/**
	 * @hidden
	 */
	function constructSystemUseEntries(data, i, len, isoData) {
	    // If the remaining allocated space following the last recorded System Use Entry in a System
	    // Use field or Continuation Area is less than four bytes long, it cannot contain a System
	    // Use Entry and shall be ignored
	    len = len - 4;
	    var entries = new Array();
	    while (i < len) {
	        var entry = constructSystemUseEntry(data, i);
	        var length = entry.length();
	        if (length === 0) {
	            // Invalid SU section; prevent infinite loop.
	            return entries;
	        }
	        i += length;
	        if (entry instanceof STEntry) {
	            // ST indicates the end of entries.
	            break;
	        }
	        if (entry instanceof CEEntry) {
	            entries = entries.concat(entry.getEntries(isoData));
	        }
	        else {
	            entries.push(entry);
	        }
	    }
	    return entries;
	}
	/**
	 * @hidden
	 */
	var VolumeDescriptor = function VolumeDescriptor(data) {
	    this._data = data;
	};
	VolumeDescriptor.prototype.type = function type () {
	    return this._data[0];
	};
	VolumeDescriptor.prototype.standardIdentifier = function standardIdentifier () {
	    return getASCIIString(this._data, 1, 5);
	};
	VolumeDescriptor.prototype.version = function version () {
	    return this._data[6];
	};
	VolumeDescriptor.prototype.data = function data () {
	    return this._data.slice(7, 2048);
	};
	/**
	 * @hidden
	 */
	var PrimaryOrSupplementaryVolumeDescriptor = (function (VolumeDescriptor) {
	    function PrimaryOrSupplementaryVolumeDescriptor(data) {
	        VolumeDescriptor.call(this, data);
	        this._root = null;
	    }
	
	    if ( VolumeDescriptor ) PrimaryOrSupplementaryVolumeDescriptor.__proto__ = VolumeDescriptor;
	    PrimaryOrSupplementaryVolumeDescriptor.prototype = Object.create( VolumeDescriptor && VolumeDescriptor.prototype );
	    PrimaryOrSupplementaryVolumeDescriptor.prototype.constructor = PrimaryOrSupplementaryVolumeDescriptor;
	    PrimaryOrSupplementaryVolumeDescriptor.prototype.systemIdentifier = function systemIdentifier () {
	        return this._getString32(8);
	    };
	    PrimaryOrSupplementaryVolumeDescriptor.prototype.volumeIdentifier = function volumeIdentifier () {
	        return this._getString32(40);
	    };
	    PrimaryOrSupplementaryVolumeDescriptor.prototype.volumeSpaceSize = function volumeSpaceSize () {
	        return this._data.readUInt32LE(80);
	    };
	    PrimaryOrSupplementaryVolumeDescriptor.prototype.volumeSetSize = function volumeSetSize () {
	        return this._data.readUInt16LE(120);
	    };
	    PrimaryOrSupplementaryVolumeDescriptor.prototype.volumeSequenceNumber = function volumeSequenceNumber () {
	        return this._data.readUInt16LE(124);
	    };
	    PrimaryOrSupplementaryVolumeDescriptor.prototype.logicalBlockSize = function logicalBlockSize () {
	        return this._data.readUInt16LE(128);
	    };
	    PrimaryOrSupplementaryVolumeDescriptor.prototype.pathTableSize = function pathTableSize () {
	        return this._data.readUInt32LE(132);
	    };
	    PrimaryOrSupplementaryVolumeDescriptor.prototype.locationOfTypeLPathTable = function locationOfTypeLPathTable () {
	        return this._data.readUInt32LE(140);
	    };
	    PrimaryOrSupplementaryVolumeDescriptor.prototype.locationOfOptionalTypeLPathTable = function locationOfOptionalTypeLPathTable () {
	        return this._data.readUInt32LE(144);
	    };
	    PrimaryOrSupplementaryVolumeDescriptor.prototype.locationOfTypeMPathTable = function locationOfTypeMPathTable () {
	        return this._data.readUInt32BE(148);
	    };
	    PrimaryOrSupplementaryVolumeDescriptor.prototype.locationOfOptionalTypeMPathTable = function locationOfOptionalTypeMPathTable () {
	        return this._data.readUInt32BE(152);
	    };
	    PrimaryOrSupplementaryVolumeDescriptor.prototype.rootDirectoryEntry = function rootDirectoryEntry (isoData) {
	        if (this._root === null) {
	            this._root = this._constructRootDirectoryRecord(this._data.slice(156));
	            this._root.rootCheckForRockRidge(isoData);
	        }
	        return this._root;
	    };
	    PrimaryOrSupplementaryVolumeDescriptor.prototype.volumeSetIdentifier = function volumeSetIdentifier () {
	        return this._getString(190, 128);
	    };
	    PrimaryOrSupplementaryVolumeDescriptor.prototype.publisherIdentifier = function publisherIdentifier () {
	        return this._getString(318, 128);
	    };
	    PrimaryOrSupplementaryVolumeDescriptor.prototype.dataPreparerIdentifier = function dataPreparerIdentifier () {
	        return this._getString(446, 128);
	    };
	    PrimaryOrSupplementaryVolumeDescriptor.prototype.applicationIdentifier = function applicationIdentifier () {
	        return this._getString(574, 128);
	    };
	    PrimaryOrSupplementaryVolumeDescriptor.prototype.copyrightFileIdentifier = function copyrightFileIdentifier () {
	        return this._getString(702, 38);
	    };
	    PrimaryOrSupplementaryVolumeDescriptor.prototype.abstractFileIdentifier = function abstractFileIdentifier () {
	        return this._getString(740, 36);
	    };
	    PrimaryOrSupplementaryVolumeDescriptor.prototype.bibliographicFileIdentifier = function bibliographicFileIdentifier () {
	        return this._getString(776, 37);
	    };
	    PrimaryOrSupplementaryVolumeDescriptor.prototype.volumeCreationDate = function volumeCreationDate () {
	        return getDate(this._data, 813);
	    };
	    PrimaryOrSupplementaryVolumeDescriptor.prototype.volumeModificationDate = function volumeModificationDate () {
	        return getDate(this._data, 830);
	    };
	    PrimaryOrSupplementaryVolumeDescriptor.prototype.volumeExpirationDate = function volumeExpirationDate () {
	        return getDate(this._data, 847);
	    };
	    PrimaryOrSupplementaryVolumeDescriptor.prototype.volumeEffectiveDate = function volumeEffectiveDate () {
	        return getDate(this._data, 864);
	    };
	    PrimaryOrSupplementaryVolumeDescriptor.prototype.fileStructureVersion = function fileStructureVersion () {
	        return this._data[881];
	    };
	    PrimaryOrSupplementaryVolumeDescriptor.prototype.applicationUsed = function applicationUsed () {
	        return this._data.slice(883, 883 + 512);
	    };
	    PrimaryOrSupplementaryVolumeDescriptor.prototype.reserved = function reserved () {
	        return this._data.slice(1395, 1395 + 653);
	    };
	    PrimaryOrSupplementaryVolumeDescriptor.prototype._getString32 = function _getString32 (idx) {
	        return this._getString(idx, 32);
	    };
	
	    return PrimaryOrSupplementaryVolumeDescriptor;
	}(VolumeDescriptor));
	/**
	 * @hidden
	 */
	var PrimaryVolumeDescriptor = (function (PrimaryOrSupplementaryVolumeDescriptor) {
	    function PrimaryVolumeDescriptor(data) {
	        PrimaryOrSupplementaryVolumeDescriptor.call(this, data);
	        if (this.type() !== 1 /* PrimaryVolumeDescriptor */) {
	            throw new ApiError(ErrorCode.EIO, "Invalid primary volume descriptor.");
	        }
	    }
	
	    if ( PrimaryOrSupplementaryVolumeDescriptor ) PrimaryVolumeDescriptor.__proto__ = PrimaryOrSupplementaryVolumeDescriptor;
	    PrimaryVolumeDescriptor.prototype = Object.create( PrimaryOrSupplementaryVolumeDescriptor && PrimaryOrSupplementaryVolumeDescriptor.prototype );
	    PrimaryVolumeDescriptor.prototype.constructor = PrimaryVolumeDescriptor;
	    PrimaryVolumeDescriptor.prototype.name = function name () {
	        return "ISO9660";
	    };
	    PrimaryVolumeDescriptor.prototype._constructRootDirectoryRecord = function _constructRootDirectoryRecord (data) {
	        return new ISODirectoryRecord(data, -1);
	    };
	    PrimaryVolumeDescriptor.prototype._getString = function _getString (idx, len) {
	        return this._getString(idx, len);
	    };
	
	    return PrimaryVolumeDescriptor;
	}(PrimaryOrSupplementaryVolumeDescriptor));
	/**
	 * @hidden
	 */
	var SupplementaryVolumeDescriptor = (function (PrimaryOrSupplementaryVolumeDescriptor) {
	    function SupplementaryVolumeDescriptor(data) {
	        PrimaryOrSupplementaryVolumeDescriptor.call(this, data);
	        if (this.type() !== 2 /* SupplementaryVolumeDescriptor */) {
	            throw new ApiError(ErrorCode.EIO, "Invalid supplementary volume descriptor.");
	        }
	        var escapeSequence = this.escapeSequence();
	        var third = escapeSequence[2];
	        // Third character identifies what 'level' of the UCS specification to follow.
	        // We ignore it.
	        if (escapeSequence[0] !== 0x25 || escapeSequence[1] !== 0x2F ||
	            (third !== 0x40 && third !== 0x43 && third !== 0x45)) {
	            throw new ApiError(ErrorCode.EIO, ("Unrecognized escape sequence for SupplementaryVolumeDescriptor: " + (escapeSequence.toString())));
	        }
	    }
	
	    if ( PrimaryOrSupplementaryVolumeDescriptor ) SupplementaryVolumeDescriptor.__proto__ = PrimaryOrSupplementaryVolumeDescriptor;
	    SupplementaryVolumeDescriptor.prototype = Object.create( PrimaryOrSupplementaryVolumeDescriptor && PrimaryOrSupplementaryVolumeDescriptor.prototype );
	    SupplementaryVolumeDescriptor.prototype.constructor = SupplementaryVolumeDescriptor;
	    SupplementaryVolumeDescriptor.prototype.name = function name () {
	        return "Joliet";
	    };
	    SupplementaryVolumeDescriptor.prototype.escapeSequence = function escapeSequence () {
	        return this._data.slice(88, 120);
	    };
	    SupplementaryVolumeDescriptor.prototype._constructRootDirectoryRecord = function _constructRootDirectoryRecord (data) {
	        return new JolietDirectoryRecord(data, -1);
	    };
	    SupplementaryVolumeDescriptor.prototype._getString = function _getString (idx, len) {
	        return getJolietString(this._data, idx, len);
	    };
	
	    return SupplementaryVolumeDescriptor;
	}(PrimaryOrSupplementaryVolumeDescriptor));
	/**
	 * @hidden
	 */
	var DirectoryRecord = function DirectoryRecord(data, rockRidgeOffset) {
	    this._suEntries = null;
	    this._fileOrDir = null;
	    this._data = data;
	    this._rockRidgeOffset = rockRidgeOffset;
	};
	DirectoryRecord.prototype.hasRockRidge = function hasRockRidge () {
	    return this._rockRidgeOffset > -1;
	};
	DirectoryRecord.prototype.getRockRidgeOffset = function getRockRidgeOffset () {
	    return this._rockRidgeOffset;
	};
	/**
	 * !!ONLY VALID ON ROOT NODE!!
	 * Checks if Rock Ridge is enabled, and sets the offset.
	 */
	DirectoryRecord.prototype.rootCheckForRockRidge = function rootCheckForRockRidge (isoData) {
	    var dir = this.getDirectory(isoData);
	    this._rockRidgeOffset = dir.getDotEntry(isoData)._getRockRidgeOffset(isoData);
	    if (this._rockRidgeOffset > -1) {
	        // Wipe out directory. Start over with RR knowledge.
	        this._fileOrDir = null;
	    }
	};
	DirectoryRecord.prototype.length = function length () {
	    return this._data[0];
	};
	DirectoryRecord.prototype.extendedAttributeRecordLength = function extendedAttributeRecordLength () {
	    return this._data[1];
	};
	DirectoryRecord.prototype.lba = function lba () {
	    return this._data.readUInt32LE(2) * 2048;
	};
	DirectoryRecord.prototype.dataLength = function dataLength () {
	    return this._data.readUInt32LE(10);
	};
	DirectoryRecord.prototype.recordingDate = function recordingDate () {
	    return getShortFormDate(this._data, 18);
	};
	DirectoryRecord.prototype.fileFlags = function fileFlags () {
	    return this._data[25];
	};
	DirectoryRecord.prototype.fileUnitSize = function fileUnitSize () {
	    return this._data[26];
	};
	DirectoryRecord.prototype.interleaveGapSize = function interleaveGapSize () {
	    return this._data[27];
	};
	DirectoryRecord.prototype.volumeSequenceNumber = function volumeSequenceNumber () {
	    return this._data.readUInt16LE(28);
	};
	DirectoryRecord.prototype.identifier = function identifier () {
	    return this._getString(33, this._data[32]);
	};
	DirectoryRecord.prototype.fileName = function fileName (isoData) {
	    if (this.hasRockRidge()) {
	        var fn = this._rockRidgeFilename(isoData);
	        if (fn !== null) {
	            return fn;
	        }
	    }
	    var ident = this.identifier();
	    if (this.isDirectory(isoData)) {
	        return ident;
	    }
	    // Files:
	    // - MUST have 0x2E (.) separating the name from the extension
	    // - MUST have 0x3B (;) separating the file name and extension from the version
	    // Gets expanded to two-byte char in Unicode directory records.
	    var versionSeparator = ident.indexOf(';');
	    if (versionSeparator === -1) {
	        // Some Joliet filenames lack the version separator, despite the standard
	        // specifying that it should be there.
	        return ident;
	    }
	    else if (ident[versionSeparator - 1] === '.') {
	        // Empty extension. Do not include '.' in the filename.
	        return ident.slice(0, versionSeparator - 1);
	    }
	    else {
	        // Include up to version separator.
	        return ident.slice(0, versionSeparator);
	    }
	};
	DirectoryRecord.prototype.isDirectory = function isDirectory (isoData) {
	    var rv = !!(this.fileFlags() & 2 /* Directory */);
	    // If it lacks the Directory flag, it may still be a directory if we've exceeded the directory
	    // depth limit. Rock Ridge marks these as files and adds a special attribute.
	    if (!rv && this.hasRockRidge()) {
	        rv = this.getSUEntries(isoData).filter(function (e) { return e instanceof CLEntry; }).length > 0;
	    }
	    return rv;
	};
	DirectoryRecord.prototype.isSymlink = function isSymlink (isoData) {
	    return this.hasRockRidge() && this.getSUEntries(isoData).filter(function (e) { return e instanceof SLEntry; }).length > 0;
	};
	DirectoryRecord.prototype.getSymlinkPath = function getSymlinkPath (isoData) {
	    var p = "";
	    var entries = this.getSUEntries(isoData);
	    var getStr = this._getGetString();
	    for (var i = 0, list = entries; i < list.length; i += 1) {
	        var entry = list[i];
	
	            if (entry instanceof SLEntry) {
	            var components = entry.componentRecords();
	            for (var i$1 = 0, list$1 = components; i$1 < list$1.length; i$1 += 1) {
	                var component = list$1[i$1];
	
	                    var flags = component.flags();
	                if (flags & 2 /* CURRENT */) {
	                    p += "./";
	                }
	                else if (flags & 4 /* PARENT */) {
	                    p += "../";
	                }
	                else if (flags & 8 /* ROOT */) {
	                    p += "/";
	                }
	                else {
	                    p += component.content(getStr);
	                    if (!(flags & 1 /* CONTINUE */)) {
	                        p += '/';
	                    }
	                }
	            }
	            if (!entry.continueFlag()) {
	                // We are done with this link.
	                break;
	            }
	        }
	    }
	    if (p.length > 1 && p[p.length - 1] === '/') {
	        // Trim trailing '/'.
	        return p.slice(0, p.length - 1);
	    }
	    else {
	        return p;
	    }
	};
	DirectoryRecord.prototype.getFile = function getFile (isoData) {
	    if (this.isDirectory(isoData)) {
	        throw new Error("Tried to get a File from a directory.");
	    }
	    if (this._fileOrDir === null) {
	        this._fileOrDir = isoData.slice(this.lba(), this.lba() + this.dataLength());
	    }
	    return this._fileOrDir;
	};
	DirectoryRecord.prototype.getDirectory = function getDirectory (isoData) {
	    if (!this.isDirectory(isoData)) {
	        throw new Error("Tried to get a Directory from a file.");
	    }
	    if (this._fileOrDir === null) {
	        this._fileOrDir = this._constructDirectory(isoData);
	    }
	    return this._fileOrDir;
	};
	DirectoryRecord.prototype.getSUEntries = function getSUEntries (isoData) {
	    if (!this._suEntries) {
	        this._constructSUEntries(isoData);
	    }
	    return this._suEntries;
	};
	DirectoryRecord.prototype._rockRidgeFilename = function _rockRidgeFilename (isoData) {
	    var nmEntries = this.getSUEntries(isoData).filter(function (e) { return e instanceof NMEntry; });
	    if (nmEntries.length === 0 || nmEntries[0].flags() & (2 /* CURRENT */ | 4 /* PARENT */)) {
	        return null;
	    }
	    var str = '';
	    var getString = this._getGetString();
	    for (var i = 0, list = nmEntries; i < list.length; i += 1) {
	        var e = list[i];
	
	            str += e.name(getString);
	        if (!(e.flags() & 1 /* CONTINUE */)) {
	            break;
	        }
	    }
	    return str;
	};
	DirectoryRecord.prototype._constructSUEntries = function _constructSUEntries (isoData) {
	    var i = 33 + this._data[32];
	    if (i % 2 === 1) {
	        // Skip padding field.
	        i++;
	    }
	    i += this._rockRidgeOffset;
	    this._suEntries = constructSystemUseEntries(this._data, i, this.length(), isoData);
	};
	/**
	 * !!ONLY VALID ON FIRST ENTRY OF ROOT DIRECTORY!!
	 * Returns -1 if rock ridge is not enabled. Otherwise, returns the offset
	 * at which system use fields begin.
	 */
	DirectoryRecord.prototype._getRockRidgeOffset = function _getRockRidgeOffset (isoData) {
	    // In the worst case, we get some garbage SU entries.
	    // Fudge offset to 0 before proceeding.
	    this._rockRidgeOffset = 0;
	    var suEntries = this.getSUEntries(isoData);
	    if (suEntries.length > 0) {
	        var spEntry = suEntries[0];
	        if (spEntry instanceof SPEntry && spEntry.checkBytesPass()) {
	            // SUSP is in use.
	            for (var i = 1; i < suEntries.length; i++) {
	                var entry = suEntries[i];
	                if (entry instanceof RREntry || (entry instanceof EREntry && entry.extensionIdentifier() === rockRidgeIdentifier)) {
	                    // Rock Ridge is in use!
	                    return spEntry.bytesSkipped();
	                }
	            }
	        }
	    }
	    // Failed.
	    this._rockRidgeOffset = -1;
	    return -1;
	};
	/**
	 * @hidden
	 */
	var ISODirectoryRecord = (function (DirectoryRecord) {
	    function ISODirectoryRecord(data, rockRidgeOffset) {
	        DirectoryRecord.call(this, data, rockRidgeOffset);
	    }
	
	    if ( DirectoryRecord ) ISODirectoryRecord.__proto__ = DirectoryRecord;
	    ISODirectoryRecord.prototype = Object.create( DirectoryRecord && DirectoryRecord.prototype );
	    ISODirectoryRecord.prototype.constructor = ISODirectoryRecord;
	    ISODirectoryRecord.prototype._getString = function _getString (i, len) {
	        return getASCIIString(this._data, i, len);
	    };
	    ISODirectoryRecord.prototype._constructDirectory = function _constructDirectory (isoData) {
	        return new ISODirectory(this, isoData);
	    };
	    ISODirectoryRecord.prototype._getGetString = function _getGetString () {
	        return getASCIIString;
	    };
	
	    return ISODirectoryRecord;
	}(DirectoryRecord));
	/**
	 * @hidden
	 */
	var JolietDirectoryRecord = (function (DirectoryRecord) {
	    function JolietDirectoryRecord(data, rockRidgeOffset) {
	        DirectoryRecord.call(this, data, rockRidgeOffset);
	    }
	
	    if ( DirectoryRecord ) JolietDirectoryRecord.__proto__ = DirectoryRecord;
	    JolietDirectoryRecord.prototype = Object.create( DirectoryRecord && DirectoryRecord.prototype );
	    JolietDirectoryRecord.prototype.constructor = JolietDirectoryRecord;
	    JolietDirectoryRecord.prototype._getString = function _getString (i, len) {
	        return getJolietString(this._data, i, len);
	    };
	    JolietDirectoryRecord.prototype._constructDirectory = function _constructDirectory (isoData) {
	        return new JolietDirectory(this, isoData);
	    };
	    JolietDirectoryRecord.prototype._getGetString = function _getGetString () {
	        return getJolietString;
	    };
	
	    return JolietDirectoryRecord;
	}(DirectoryRecord));
	/**
	 * @hidden
	 */
	var SystemUseEntry = function SystemUseEntry(data) {
	    this._data = data;
	};
	SystemUseEntry.prototype.signatureWord = function signatureWord () {
	    return this._data.readUInt16BE(0);
	};
	SystemUseEntry.prototype.signatureWordString = function signatureWordString () {
	    return getASCIIString(this._data, 0, 2);
	};
	SystemUseEntry.prototype.length = function length () {
	    return this._data[2];
	};
	SystemUseEntry.prototype.suVersion = function suVersion () {
	    return this._data[3];
	};
	/**
	 * Continuation entry.
	 * @hidden
	 */
	var CEEntry = (function (SystemUseEntry) {
	    function CEEntry(data) {
	        SystemUseEntry.call(this, data);
	        this._entries = null;
	    }
	
	    if ( SystemUseEntry ) CEEntry.__proto__ = SystemUseEntry;
	    CEEntry.prototype = Object.create( SystemUseEntry && SystemUseEntry.prototype );
	    CEEntry.prototype.constructor = CEEntry;
	    /**
	     * Logical block address of the continuation area.
	     */
	    CEEntry.prototype.continuationLba = function continuationLba () {
	        return this._data.readUInt32LE(4);
	    };
	    /**
	     * Offset into the logical block.
	     */
	    CEEntry.prototype.continuationLbaOffset = function continuationLbaOffset () {
	        return this._data.readUInt32LE(12);
	    };
	    /**
	     * Length of the continuation area.
	     */
	    CEEntry.prototype.continuationLength = function continuationLength () {
	        return this._data.readUInt32LE(20);
	    };
	    CEEntry.prototype.getEntries = function getEntries (isoData) {
	        if (!this._entries) {
	            var start = this.continuationLba() * 2048 + this.continuationLbaOffset();
	            this._entries = constructSystemUseEntries(isoData, start, this.continuationLength(), isoData);
	        }
	        return this._entries;
	    };
	
	    return CEEntry;
	}(SystemUseEntry));
	/**
	 * Padding entry.
	 * @hidden
	 */
	var PDEntry = (function (SystemUseEntry) {
	    function PDEntry(data) {
	        SystemUseEntry.call(this, data);
	    }
	
	    if ( SystemUseEntry ) PDEntry.__proto__ = SystemUseEntry;
	    PDEntry.prototype = Object.create( SystemUseEntry && SystemUseEntry.prototype );
	    PDEntry.prototype.constructor = PDEntry;
	
	    return PDEntry;
	}(SystemUseEntry));
	/**
	 * Identifies that SUSP is in-use.
	 * @hidden
	 */
	var SPEntry = (function (SystemUseEntry) {
	    function SPEntry(data) {
	        SystemUseEntry.call(this, data);
	    }
	
	    if ( SystemUseEntry ) SPEntry.__proto__ = SystemUseEntry;
	    SPEntry.prototype = Object.create( SystemUseEntry && SystemUseEntry.prototype );
	    SPEntry.prototype.constructor = SPEntry;
	    SPEntry.prototype.checkBytesPass = function checkBytesPass () {
	        return this._data[4] === 0xBE && this._data[5] === 0xEF;
	    };
	    SPEntry.prototype.bytesSkipped = function bytesSkipped () {
	        return this._data[6];
	    };
	
	    return SPEntry;
	}(SystemUseEntry));
	/**
	 * Identifies the end of the SUSP entries.
	 * @hidden
	 */
	var STEntry = (function (SystemUseEntry) {
	    function STEntry(data) {
	        SystemUseEntry.call(this, data);
	    }
	
	    if ( SystemUseEntry ) STEntry.__proto__ = SystemUseEntry;
	    STEntry.prototype = Object.create( SystemUseEntry && SystemUseEntry.prototype );
	    STEntry.prototype.constructor = STEntry;
	
	    return STEntry;
	}(SystemUseEntry));
	/**
	 * Specifies system-specific extensions to SUSP.
	 * @hidden
	 */
	var EREntry = (function (SystemUseEntry) {
	    function EREntry(data) {
	        SystemUseEntry.call(this, data);
	    }
	
	    if ( SystemUseEntry ) EREntry.__proto__ = SystemUseEntry;
	    EREntry.prototype = Object.create( SystemUseEntry && SystemUseEntry.prototype );
	    EREntry.prototype.constructor = EREntry;
	    EREntry.prototype.identifierLength = function identifierLength () {
	        return this._data[4];
	    };
	    EREntry.prototype.descriptorLength = function descriptorLength () {
	        return this._data[5];
	    };
	    EREntry.prototype.sourceLength = function sourceLength () {
	        return this._data[6];
	    };
	    EREntry.prototype.extensionVersion = function extensionVersion () {
	        return this._data[7];
	    };
	    EREntry.prototype.extensionIdentifier = function extensionIdentifier () {
	        return getASCIIString(this._data, 8, this.identifierLength());
	    };
	    EREntry.prototype.extensionDescriptor = function extensionDescriptor () {
	        return getASCIIString(this._data, 8 + this.identifierLength(), this.descriptorLength());
	    };
	    EREntry.prototype.extensionSource = function extensionSource () {
	        return getASCIIString(this._data, 8 + this.identifierLength() + this.descriptorLength(), this.sourceLength());
	    };
	
	    return EREntry;
	}(SystemUseEntry));
	/**
	 * @hidden
	 */
	var ESEntry = (function (SystemUseEntry) {
	    function ESEntry(data) {
	        SystemUseEntry.call(this, data);
	    }
	
	    if ( SystemUseEntry ) ESEntry.__proto__ = SystemUseEntry;
	    ESEntry.prototype = Object.create( SystemUseEntry && SystemUseEntry.prototype );
	    ESEntry.prototype.constructor = ESEntry;
	    ESEntry.prototype.extensionSequence = function extensionSequence () {
	        return this._data[4];
	    };
	
	    return ESEntry;
	}(SystemUseEntry));
	/**
	 * RockRidge: Marks that RockRidge is in use [deprecated]
	 * @hidden
	 */
	var RREntry = (function (SystemUseEntry) {
	    function RREntry(data) {
	        SystemUseEntry.call(this, data);
	    }
	
	    if ( SystemUseEntry ) RREntry.__proto__ = SystemUseEntry;
	    RREntry.prototype = Object.create( SystemUseEntry && SystemUseEntry.prototype );
	    RREntry.prototype.constructor = RREntry;
	
	    return RREntry;
	}(SystemUseEntry));
	/**
	 * RockRidge: Records POSIX file attributes.
	 * @hidden
	 */
	var PXEntry = (function (SystemUseEntry) {
	    function PXEntry(data) {
	        SystemUseEntry.call(this, data);
	    }
	
	    if ( SystemUseEntry ) PXEntry.__proto__ = SystemUseEntry;
	    PXEntry.prototype = Object.create( SystemUseEntry && SystemUseEntry.prototype );
	    PXEntry.prototype.constructor = PXEntry;
	    PXEntry.prototype.mode = function mode () {
	        return this._data.readUInt32LE(4);
	    };
	    PXEntry.prototype.fileLinks = function fileLinks () {
	        return this._data.readUInt32LE(12);
	    };
	    PXEntry.prototype.uid = function uid () {
	        return this._data.readUInt32LE(20);
	    };
	    PXEntry.prototype.gid = function gid () {
	        return this._data.readUInt32LE(28);
	    };
	    PXEntry.prototype.inode = function inode () {
	        return this._data.readUInt32LE(36);
	    };
	
	    return PXEntry;
	}(SystemUseEntry));
	/**
	 * RockRidge: Records POSIX device number.
	 * @hidden
	 */
	var PNEntry = (function (SystemUseEntry) {
	    function PNEntry(data) {
	        SystemUseEntry.call(this, data);
	    }
	
	    if ( SystemUseEntry ) PNEntry.__proto__ = SystemUseEntry;
	    PNEntry.prototype = Object.create( SystemUseEntry && SystemUseEntry.prototype );
	    PNEntry.prototype.constructor = PNEntry;
	    PNEntry.prototype.devTHigh = function devTHigh () {
	        return this._data.readUInt32LE(4);
	    };
	    PNEntry.prototype.devTLow = function devTLow () {
	        return this._data.readUInt32LE(12);
	    };
	
	    return PNEntry;
	}(SystemUseEntry));
	/**
	 * RockRidge: Records symbolic link
	 * @hidden
	 */
	var SLEntry = (function (SystemUseEntry) {
	    function SLEntry(data) {
	        SystemUseEntry.call(this, data);
	    }
	
	    if ( SystemUseEntry ) SLEntry.__proto__ = SystemUseEntry;
	    SLEntry.prototype = Object.create( SystemUseEntry && SystemUseEntry.prototype );
	    SLEntry.prototype.constructor = SLEntry;
	    SLEntry.prototype.flags = function flags () {
	        return this._data[4];
	    };
	    SLEntry.prototype.continueFlag = function continueFlag () {
	        return this.flags() & 0x1;
	    };
	    SLEntry.prototype.componentRecords = function componentRecords () {
	        var this$1 = this;
	
	        var records = new Array();
	        var i = 5;
	        while (i < this.length()) {
	            var record = new SLComponentRecord(this$1._data.slice(i));
	            records.push(record);
	            i += record.length();
	        }
	        return records;
	    };
	
	    return SLEntry;
	}(SystemUseEntry));
	/**
	 * @hidden
	 */
	var SLComponentRecord = function SLComponentRecord(data) {
	    this._data = data;
	};
	SLComponentRecord.prototype.flags = function flags () {
	    return this._data[0];
	};
	SLComponentRecord.prototype.length = function length () {
	    return 2 + this.componentLength();
	};
	SLComponentRecord.prototype.componentLength = function componentLength () {
	    return this._data[1];
	};
	SLComponentRecord.prototype.content = function content (getString) {
	    return getString(this._data, 2, this.componentLength());
	};
	/**
	 * RockRidge: Records alternate file name
	 * @hidden
	 */
	var NMEntry = (function (SystemUseEntry) {
	    function NMEntry(data) {
	        SystemUseEntry.call(this, data);
	    }
	
	    if ( SystemUseEntry ) NMEntry.__proto__ = SystemUseEntry;
	    NMEntry.prototype = Object.create( SystemUseEntry && SystemUseEntry.prototype );
	    NMEntry.prototype.constructor = NMEntry;
	    NMEntry.prototype.flags = function flags () {
	        return this._data[4];
	    };
	    NMEntry.prototype.name = function name (getString) {
	        return getString(this._data, 5, this.length() - 5);
	    };
	
	    return NMEntry;
	}(SystemUseEntry));
	/**
	 * RockRidge: Records child link
	 * @hidden
	 */
	var CLEntry = (function (SystemUseEntry) {
	    function CLEntry(data) {
	        SystemUseEntry.call(this, data);
	    }
	
	    if ( SystemUseEntry ) CLEntry.__proto__ = SystemUseEntry;
	    CLEntry.prototype = Object.create( SystemUseEntry && SystemUseEntry.prototype );
	    CLEntry.prototype.constructor = CLEntry;
	    CLEntry.prototype.childDirectoryLba = function childDirectoryLba () {
	        return this._data.readUInt32LE(4);
	    };
	
	    return CLEntry;
	}(SystemUseEntry));
	/**
	 * RockRidge: Records parent link.
	 * @hidden
	 */
	var PLEntry = (function (SystemUseEntry) {
	    function PLEntry(data) {
	        SystemUseEntry.call(this, data);
	    }
	
	    if ( SystemUseEntry ) PLEntry.__proto__ = SystemUseEntry;
	    PLEntry.prototype = Object.create( SystemUseEntry && SystemUseEntry.prototype );
	    PLEntry.prototype.constructor = PLEntry;
	    PLEntry.prototype.parentDirectoryLba = function parentDirectoryLba () {
	        return this._data.readUInt32LE(4);
	    };
	
	    return PLEntry;
	}(SystemUseEntry));
	/**
	 * RockRidge: Records relocated directory.
	 * @hidden
	 */
	var REEntry = (function (SystemUseEntry) {
	    function REEntry(data) {
	        SystemUseEntry.call(this, data);
	    }
	
	    if ( SystemUseEntry ) REEntry.__proto__ = SystemUseEntry;
	    REEntry.prototype = Object.create( SystemUseEntry && SystemUseEntry.prototype );
	    REEntry.prototype.constructor = REEntry;
	
	    return REEntry;
	}(SystemUseEntry));
	/**
	 * RockRidge: Records file timestamps
	 * @hidden
	 */
	var TFEntry = (function (SystemUseEntry) {
	    function TFEntry(data) {
	        SystemUseEntry.call(this, data);
	    }
	
	    if ( SystemUseEntry ) TFEntry.__proto__ = SystemUseEntry;
	    TFEntry.prototype = Object.create( SystemUseEntry && SystemUseEntry.prototype );
	    TFEntry.prototype.constructor = TFEntry;
	    TFEntry.prototype.flags = function flags () {
	        return this._data[4];
	    };
	    TFEntry.prototype.creation = function creation () {
	        if (this.flags() & 1 /* CREATION */) {
	            if (this._longFormDates()) {
	                return getDate(this._data, 5);
	            }
	            else {
	                return getShortFormDate(this._data, 5);
	            }
	        }
	        else {
	            return null;
	        }
	    };
	    TFEntry.prototype.modify = function modify () {
	        if (this.flags() & 2 /* MODIFY */) {
	            var previousDates = (this.flags() & 1 /* CREATION */) ? 1 : 0;
	            if (this._longFormDates) {
	                return getDate(this._data, 5 + (previousDates * 17));
	            }
	            else {
	                return getShortFormDate(this._data, 5 + (previousDates * 7));
	            }
	        }
	        else {
	            return null;
	        }
	    };
	    TFEntry.prototype.access = function access () {
	        if (this.flags() & 4 /* ACCESS */) {
	            var previousDates = (this.flags() & 1 /* CREATION */) ? 1 : 0;
	            previousDates += (this.flags() & 2 /* MODIFY */) ? 1 : 0;
	            if (this._longFormDates) {
	                return getDate(this._data, 5 + (previousDates * 17));
	            }
	            else {
	                return getShortFormDate(this._data, 5 + (previousDates * 7));
	            }
	        }
	        else {
	            return null;
	        }
	    };
	    TFEntry.prototype.backup = function backup () {
	        if (this.flags() & 16 /* BACKUP */) {
	            var previousDates = (this.flags() & 1 /* CREATION */) ? 1 : 0;
	            previousDates += (this.flags() & 2 /* MODIFY */) ? 1 : 0;
	            previousDates += (this.flags() & 4 /* ACCESS */) ? 1 : 0;
	            if (this._longFormDates) {
	                return getDate(this._data, 5 + (previousDates * 17));
	            }
	            else {
	                return getShortFormDate(this._data, 5 + (previousDates * 7));
	            }
	        }
	        else {
	            return null;
	        }
	    };
	    TFEntry.prototype.expiration = function expiration () {
	        if (this.flags() & 32 /* EXPIRATION */) {
	            var previousDates = (this.flags() & 1 /* CREATION */) ? 1 : 0;
	            previousDates += (this.flags() & 2 /* MODIFY */) ? 1 : 0;
	            previousDates += (this.flags() & 4 /* ACCESS */) ? 1 : 0;
	            previousDates += (this.flags() & 16 /* BACKUP */) ? 1 : 0;
	            if (this._longFormDates) {
	                return getDate(this._data, 5 + (previousDates * 17));
	            }
	            else {
	                return getShortFormDate(this._data, 5 + (previousDates * 7));
	            }
	        }
	        else {
	            return null;
	        }
	    };
	    TFEntry.prototype.effective = function effective () {
	        if (this.flags() & 64 /* EFFECTIVE */) {
	            var previousDates = (this.flags() & 1 /* CREATION */) ? 1 : 0;
	            previousDates += (this.flags() & 2 /* MODIFY */) ? 1 : 0;
	            previousDates += (this.flags() & 4 /* ACCESS */) ? 1 : 0;
	            previousDates += (this.flags() & 16 /* BACKUP */) ? 1 : 0;
	            previousDates += (this.flags() & 32 /* EXPIRATION */) ? 1 : 0;
	            if (this._longFormDates) {
	                return getDate(this._data, 5 + (previousDates * 17));
	            }
	            else {
	                return getShortFormDate(this._data, 5 + (previousDates * 7));
	            }
	        }
	        else {
	            return null;
	        }
	    };
	    TFEntry.prototype._longFormDates = function _longFormDates () {
	        return !!(this.flags() && 128 /* LONG_FORM */);
	    };
	
	    return TFEntry;
	}(SystemUseEntry));
	/**
	 * RockRidge: File data in sparse format.
	 * @hidden
	 */
	var SFEntry = (function (SystemUseEntry) {
	    function SFEntry(data) {
	        SystemUseEntry.call(this, data);
	    }
	
	    if ( SystemUseEntry ) SFEntry.__proto__ = SystemUseEntry;
	    SFEntry.prototype = Object.create( SystemUseEntry && SystemUseEntry.prototype );
	    SFEntry.prototype.constructor = SFEntry;
	    SFEntry.prototype.virtualSizeHigh = function virtualSizeHigh () {
	        return this._data.readUInt32LE(4);
	    };
	    SFEntry.prototype.virtualSizeLow = function virtualSizeLow () {
	        return this._data.readUInt32LE(12);
	    };
	    SFEntry.prototype.tableDepth = function tableDepth () {
	        return this._data[20];
	    };
	
	    return SFEntry;
	}(SystemUseEntry));
	/**
	 * @hidden
	 */
	var Directory = function Directory(record, isoData) {
	    var this$1 = this;
	
	    this._fileList = [];
	    this._fileMap = {};
	    this._record = record;
	    var i = record.lba();
	    var iLimit = i + record.dataLength();
	    if (!(record.fileFlags() & 2 /* Directory */)) {
	        // Must have a CL entry.
	        var cl = record.getSUEntries(isoData).filter(function (e) { return e instanceof CLEntry; })[0];
	        i = cl.childDirectoryLba() * 2048;
	        iLimit = Infinity;
	    }
	    while (i < iLimit) {
	        var len = isoData[i];
	        // Zero-padding between sectors.
	        // TODO: Could optimize this to seek to nearest-sector upon
	        // seeing a 0.
	        if (len === 0) {
	            i++;
	            continue;
	        }
	        var r = this$1._constructDirectoryRecord(isoData.slice(i));
	        var fname = r.fileName(isoData);
	        // Skip '.' and '..' entries.
	        if (fname !== '\u0000' && fname !== '\u0001') {
	            // Skip relocated entries.
	            if (!r.hasRockRidge() || r.getSUEntries(isoData).filter(function (e) { return e instanceof REEntry; }).length === 0) {
	                this$1._fileMap[fname] = r;
	                this$1._fileList.push(fname);
	            }
	        }
	        else if (iLimit === Infinity) {
	            // First entry contains needed data.
	            iLimit = i + r.dataLength();
	        }
	        i += r.length();
	    }
	};
	/**
	 * Get the record with the given name.
	 * Returns undefined if not present.
	 */
	Directory.prototype.getRecord = function getRecord (name) {
	    return this._fileMap[name];
	};
	Directory.prototype.getFileList = function getFileList () {
	    return this._fileList;
	};
	Directory.prototype.getDotEntry = function getDotEntry (isoData) {
	    return this._constructDirectoryRecord(isoData.slice(this._record.lba()));
	};
	/**
	 * @hidden
	 */
	var ISODirectory = (function (Directory) {
	    function ISODirectory(record, isoData) {
	        Directory.call(this, record, isoData);
	    }
	
	    if ( Directory ) ISODirectory.__proto__ = Directory;
	    ISODirectory.prototype = Object.create( Directory && Directory.prototype );
	    ISODirectory.prototype.constructor = ISODirectory;
	    ISODirectory.prototype._constructDirectoryRecord = function _constructDirectoryRecord (data) {
	        return new ISODirectoryRecord(data, this._record.getRockRidgeOffset());
	    };
	
	    return ISODirectory;
	}(Directory));
	/**
	 * @hidden
	 */
	var JolietDirectory = (function (Directory) {
	    function JolietDirectory(record, isoData) {
	        Directory.call(this, record, isoData);
	    }
	
	    if ( Directory ) JolietDirectory.__proto__ = Directory;
	    JolietDirectory.prototype = Object.create( Directory && Directory.prototype );
	    JolietDirectory.prototype.constructor = JolietDirectory;
	    JolietDirectory.prototype._constructDirectoryRecord = function _constructDirectoryRecord (data) {
	        return new JolietDirectoryRecord(data, this._record.getRockRidgeOffset());
	    };
	
	    return JolietDirectory;
	}(Directory));
	/**
	 * Mounts an ISO file as a read-only file system.
	 *
	 * Supports:
	 * * Vanilla ISO9660 ISOs
	 * * Microsoft Joliet and Rock Ridge extensions to the ISO9660 standard
	 */
	var IsoFS = (function (SynchronousFileSystem$$1) {
	    function IsoFS(data, name, deprecateMsg) {
	        var this$1 = this;
	        if ( name === void 0 ) name = "";
	        if ( deprecateMsg === void 0 ) deprecateMsg = true;
	
	        SynchronousFileSystem$$1.call(this);
	        this._data = data;
	        deprecationMessage(deprecateMsg, IsoFS.Name, { data: "ISO data as a Buffer", name: name });
	        // Skip first 16 sectors.
	        var vdTerminatorFound = false;
	        var i = 16 * 2048;
	        var candidateVDs = new Array();
	        while (!vdTerminatorFound) {
	            var slice = data.slice(i);
	            var vd = new VolumeDescriptor(slice);
	            switch (vd.type()) {
	                case 1 /* PrimaryVolumeDescriptor */:
	                    candidateVDs.push(new PrimaryVolumeDescriptor(slice));
	                    break;
	                case 2 /* SupplementaryVolumeDescriptor */:
	                    candidateVDs.push(new SupplementaryVolumeDescriptor(slice));
	                    break;
	                case 255 /* VolumeDescriptorSetTerminator */:
	                    vdTerminatorFound = true;
	                    break;
	            }
	            i += 2048;
	        }
	        if (candidateVDs.length === 0) {
	            throw new ApiError(ErrorCode.EIO, "Unable to find a suitable volume descriptor.");
	        }
	        candidateVDs.forEach(function (v) {
	            // Take an SVD over a PVD.
	            if (!this$1._pvd || this$1._pvd.type() !== 2 /* SupplementaryVolumeDescriptor */) {
	                this$1._pvd = v;
	            }
	        });
	        this._root = this._pvd.rootDirectoryEntry(data);
	        this._name = name;
	    }
	
	    if ( SynchronousFileSystem$$1 ) IsoFS.__proto__ = SynchronousFileSystem$$1;
	    IsoFS.prototype = Object.create( SynchronousFileSystem$$1 && SynchronousFileSystem$$1.prototype );
	    IsoFS.prototype.constructor = IsoFS;
	    /**
	     * Creates an IsoFS instance with the given options.
	     */
	    IsoFS.Create = function Create (opts, cb) {
	        var fs;
	        var e;
	        try {
	            fs = new IsoFS(opts.data, opts.name, false);
	        }
	        catch (e) {
	            e = e;
	        }
	        finally {
	            cb(e, fs);
	        }
	    };
	    IsoFS.isAvailable = function isAvailable () {
	        return true;
	    };
	    IsoFS.prototype.getName = function getName () {
	        var name = "IsoFS" + (this._name) + (this._pvd ? ("-" + (this._pvd.name())) : '');
	        if (this._root && this._root.hasRockRidge()) {
	            name += "-RockRidge";
	        }
	        return name;
	    };
	    IsoFS.prototype.diskSpace = function diskSpace (path$$1, cb) {
	        // Read-only file system.
	        cb(this._data.length, 0);
	    };
	    IsoFS.prototype.isReadOnly = function isReadOnly () {
	        return true;
	    };
	    IsoFS.prototype.supportsLinks = function supportsLinks () {
	        return false;
	    };
	    IsoFS.prototype.supportsProps = function supportsProps () {
	        return false;
	    };
	    IsoFS.prototype.supportsSynch = function supportsSynch () {
	        return true;
	    };
	    IsoFS.prototype.statSync = function statSync (p, isLstat) {
	        var record = this._getDirectoryRecord(p);
	        if (record === null) {
	            throw ApiError.ENOENT(p);
	        }
	        return this._getStats(p, record);
	    };
	    IsoFS.prototype.openSync = function openSync (p, flags, mode) {
	        // INVARIANT: Cannot write to RO file systems.
	        if (flags.isWriteable()) {
	            throw new ApiError(ErrorCode.EPERM, p);
	        }
	        // Check if the path exists, and is a file.
	        var record = this._getDirectoryRecord(p);
	        if (!record) {
	            throw ApiError.ENOENT(p);
	        }
	        else if (record.isSymlink(this._data)) {
	            return this.openSync(path.resolve(p, record.getSymlinkPath(this._data)), flags, mode);
	        }
	        else if (!record.isDirectory(this._data)) {
	            var data = record.getFile(this._data);
	            var stats = this._getStats(p, record);
	            switch (flags.pathExistsAction()) {
	                case ActionType.THROW_EXCEPTION:
	                case ActionType.TRUNCATE_FILE:
	                    throw ApiError.EEXIST(p);
	                case ActionType.NOP:
	                    return new NoSyncFile(this, p, flags, stats, data);
	                default:
	                    throw new ApiError(ErrorCode.EINVAL, 'Invalid FileMode object.');
	            }
	        }
	        else {
	            throw ApiError.EISDIR(p);
	        }
	    };
	    IsoFS.prototype.readdirSync = function readdirSync (path$$1) {
	        // Check if it exists.
	        var record = this._getDirectoryRecord(path$$1);
	        if (!record) {
	            throw ApiError.ENOENT(path$$1);
	        }
	        else if (record.isDirectory(this._data)) {
	            return record.getDirectory(this._data).getFileList().slice(0);
	        }
	        else {
	            throw ApiError.ENOTDIR(path$$1);
	        }
	    };
	    /**
	     * Specially-optimized readfile.
	     */
	    IsoFS.prototype.readFileSync = function readFileSync (fname, encoding, flag) {
	        // Get file.
	        var fd = this.openSync(fname, flag, 0x1a4);
	        try {
	            var fdCast = fd;
	            var fdBuff = fdCast.getBuffer();
	            if (encoding === null) {
	                return copyingSlice(fdBuff);
	            }
	            return fdBuff.toString(encoding);
	        }
	        finally {
	            fd.closeSync();
	        }
	    };
	    IsoFS.prototype._getDirectoryRecord = function _getDirectoryRecord (path$$1) {
	        var this$1 = this;
	
	        // Special case.
	        if (path$$1 === '/') {
	            return this._root;
	        }
	        var components = path$$1.split('/').slice(1);
	        var dir = this._root;
	        for (var i = 0, list = components; i < list.length; i += 1) {
	            var component = list[i];
	
	            if (dir.isDirectory(this$1._data)) {
	                dir = dir.getDirectory(this$1._data).getRecord(component);
	                if (!dir) {
	                    return null;
	                }
	            }
	            else {
	                return null;
	            }
	        }
	        return dir;
	    };
	    IsoFS.prototype._getStats = function _getStats (p, record) {
	        if (record.isSymlink(this._data)) {
	            var newP = path.resolve(p, record.getSymlinkPath(this._data));
	            var dirRec = this._getDirectoryRecord(newP);
	            if (!dirRec) {
	                return null;
	            }
	            return this._getStats(newP, dirRec);
	        }
	        else {
	            var len = record.dataLength();
	            var mode = 0x16D;
	            var date = record.recordingDate();
	            var atime = date;
	            var mtime = date;
	            var ctime = date;
	            if (record.hasRockRidge()) {
	                var entries = record.getSUEntries(this._data);
	                for (var i = 0, list = entries; i < list.length; i += 1) {
	                    var entry = list[i];
	
	                    if (entry instanceof PXEntry) {
	                        mode = entry.mode();
	                    }
	                    else if (entry instanceof TFEntry) {
	                        var flags = entry.flags();
	                        if (flags & 4 /* ACCESS */) {
	                            atime = entry.access();
	                        }
	                        if (flags & 2 /* MODIFY */) {
	                            mtime = entry.modify();
	                        }
	                        if (flags & 1 /* CREATION */) {
	                            ctime = entry.creation();
	                        }
	                    }
	                }
	            }
	            // Mask out writeable flags. This is a RO file system.
	            mode = mode & 0x16D;
	            return new Stats(record.isDirectory(this._data) ? FileType.DIRECTORY : FileType.FILE, len, mode, atime, mtime, ctime);
	        }
	    };
	
	    return IsoFS;
	}(SynchronousFileSystem));
	
	IsoFS.Name = "IsoFS";
	IsoFS.Options = {
	    data: {
	        type: "object",
	        description: "The ISO file in a buffer",
	        validator: bufferValidator
	    }
	};
	
	// Monkey-patch `Create` functions to check options before file system initialization.
	[AsyncMirror, DropboxFileSystem, EmscriptenFileSystem, FolderAdapter, HTML5FS, InMemoryFileSystem, IndexedDBFileSystem, IsoFS, LocalStorageFileSystem, MountableFileSystem, OverlayFS, WorkerFS, XmlHttpRequest, ZipFS].forEach(function (fsType) {
	    var create = fsType.Create;
	    fsType.Create = function (opts, cb) {
	        var oneArg = typeof (opts) === "function";
	        var normalizedCb = oneArg ? opts : cb;
	        var normalizedOpts = oneArg ? {} : opts;
	        function wrappedCb(e) {
	            if (e) {
	                normalizedCb(e);
	            }
	            else {
	                create.call(fsType, normalizedOpts, normalizedCb);
	            }
	        }
	        checkOptions(fsType, normalizedOpts, wrappedCb);
	    };
	});
	/**
	 * @hidden
	 */
	var Backends = { AsyncMirror: AsyncMirror, Dropbox: DropboxFileSystem, Emscripten: EmscriptenFileSystem, FolderAdapter: FolderAdapter, HTML5FS: HTML5FS, InMemory: InMemoryFileSystem, IndexedDB: IndexedDBFileSystem, IsoFS: IsoFS, LocalStorage: LocalStorageFileSystem, MountableFileSystem: MountableFileSystem, OverlayFS: OverlayFS, WorkerFS: WorkerFS, XmlHttpRequest: XmlHttpRequest, ZipFS: ZipFS };
	
	/**
	 * BrowserFS's main module. This is exposed in the browser via the BrowserFS global.
	 * Due to limitations in typedoc, we document these functions in ./typedoc.ts.
	 */
	if (process['initializeTTYs']) {
	    process['initializeTTYs']();
	}
	/**
	 * Installs BFSRequire as global `require`, a Node Buffer polyfill as the global `Buffer` variable,
	 * and a Node process polyfill as the global `process` variable.
	 */
	function install(obj) {
	    obj.Buffer = Buffer;
	    obj.process = process;
	    var oldRequire = obj.require ? obj.require : null;
	    // Monkey-patch require for Node-style code.
	    obj.require = function (arg) {
	        var rv = BFSRequire(arg);
	        if (!rv) {
	            return oldRequire.apply(null, Array.prototype.slice.call(arguments, 0));
	        }
	        else {
	            return rv;
	        }
	    };
	}
	/**
	 * @hidden
	 */
	function registerFileSystem(name, fs) {
	    Backends[name] = fs;
	}
	function BFSRequire(module) {
	    switch (module) {
	        case 'fs':
	            return _fsMock;
	        case 'path':
	            return path;
	        case 'buffer':
	            // The 'buffer' module has 'Buffer' as a property.
	            return buffer;
	        case 'process':
	            return process;
	        case 'bfs_utils':
	            return BFSUtils;
	        default:
	            return Backends[module];
	    }
	}
	/**
	 * Initializes BrowserFS with the given root file system.
	 */
	function initialize(rootfs) {
	    return _fsMock.initialize(rootfs);
	}
	/**
	 * Creates a file system with the given configuration, and initializes BrowserFS with it.
	 * See the FileSystemConfiguration type for more info on the configuration object.
	 */
	function configure(config, cb) {
	    getFileSystem(config, function (e, fs) {
	        if (fs) {
	            initialize(fs);
	            cb();
	        }
	        else {
	            cb(e);
	        }
	    });
	}
	/**
	 * Retrieve a file system with the given configuration.
	 * @param config A FileSystemConfiguration object. See FileSystemConfiguration for details.
	 * @param cb Called when the file system is constructed, or when an error occurs.
	 */
	function getFileSystem(config, cb) {
	    var fsName = config['fs'];
	    if (!fsName) {
	        return cb(new ApiError(ErrorCode.EPERM, 'Missing "fs" property on configuration object.'));
	    }
	    var options = config['options'];
	    var waitCount = 0;
	    var called = false;
	    function finish() {
	        if (!called) {
	            called = true;
	            var fsc = Backends[fsName];
	            if (!fsc) {
	                cb(new ApiError(ErrorCode.EPERM, ("File system " + fsName + " is not available in BrowserFS.")));
	            }
	            else {
	                fsc.Create(options, cb);
	            }
	        }
	    }
	    if (options !== null && typeof (options) === "object") {
	        var finishedIterating = false;
	        var props = Object.keys(options).filter(function (k) { return k !== 'fs'; });
	        // Check recursively if other fields have 'fs' properties.
	        props.forEach(function (p) {
	            var d = options[p];
	            if (d !== null && typeof (d) === "object" && d['fs']) {
	                waitCount++;
	                getFileSystem(d, function (e, fs) {
	                    waitCount--;
	                    if (e) {
	                        if (called) {
	                            return;
	                        }
	                        called = true;
	                        cb(e);
	                    }
	                    else {
	                        options[p] = fs;
	                        if (waitCount === 0 && finishedIterating) {
	                            finish();
	                        }
	                    }
	                });
	            }
	        });
	        finishedIterating = true;
	    }
	    if (waitCount === 0) {
	        finish();
	    }
	}
	
	/**
	 * BrowserFS's main entry point.
	 * It installs all of the needed polyfills, and requires() the main module.
	 */
	// IE substr does not support negative indices
	if ('ab'.substr(-1) !== 'b') {
	    String.prototype.substr = function (substr) {
	        return function (start, length) {
	            // did we get a negative start, calculate how much it is from the
	            // beginning of the string
	            if (start < 0) {
	                start = this.length + start;
	            }
	            // call the original function
	            return substr.call(this, start, length);
	        };
	    }(String.prototype.substr);
	}
	// Polyfill for Uint8Array.prototype.slice.
	// Safari and some other browsers do not define it.
	if (typeof (ArrayBuffer) !== 'undefined' && typeof (Uint8Array) !== 'undefined') {
	    if (!Uint8Array.prototype['slice']) {
	        Uint8Array.prototype.slice = function (start, end) {
	            if ( start === void 0 ) start = 0;
	            if ( end === void 0 ) end = this.length;
	
	            var self = this;
	            if (start < 0) {
	                start = this.length + start;
	                if (start < 0) {
	                    start = 0;
	                }
	            }
	            if (end < 0) {
	                end = this.length + end;
	                if (end < 0) {
	                    end = 0;
	                }
	            }
	            if (end < start) {
	                end = start;
	            }
	            return new Uint8Array(self.buffer, self.byteOffset + start, end - start);
	        };
	    }
	}
	
	exports.install = install;
	exports.registerFileSystem = registerFileSystem;
	exports.BFSRequire = BFSRequire;
	exports.initialize = initialize;
	exports.configure = configure;
	exports.getFileSystem = getFileSystem;
	exports.EmscriptenFS = BFSEmscriptenFS;
	exports.FileSystem = Backends;
	exports.Errors = api_error;
	exports.setImmediate = setImmediate$3;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1), (function() { return this; }()), __webpack_require__(5)(module), __webpack_require__(6)))

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(2).Buffer;


/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {/*!
	 * The buffer module from node.js, for the browser.
	 *
	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
	 * @license  MIT
	 */
	/* eslint-disable no-proto */
	
	'use strict'
	
	var base64 = __webpack_require__(3)
	var ieee754 = __webpack_require__(4)
	
	exports.Buffer = Buffer
	exports.SlowBuffer = SlowBuffer
	exports.INSPECT_MAX_BYTES = 50
	
	var K_MAX_LENGTH = 0x7fffffff
	exports.kMaxLength = K_MAX_LENGTH
	
	/**
	 * If `Buffer.TYPED_ARRAY_SUPPORT`:
	 *   === true    Use Uint8Array implementation (fastest)
	 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
	 *               implementation (most compatible, even IE6)
	 *
	 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
	 * Opera 11.6+, iOS 4.2+.
	 *
	 * We report that the browser does not support typed arrays if the are not subclassable
	 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
	 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
	 * for __proto__ and has a buggy typed array implementation.
	 */
	Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()
	
	if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
	    typeof console.error === 'function') {
	  console.error(
	    'This browser lacks typed array (Uint8Array) support which is required by ' +
	    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
	  )
	}
	
	function typedArraySupport () {
	  // Can typed array instances can be augmented?
	  try {
	    var arr = new Uint8Array(1)
	    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
	    return arr.foo() === 42
	  } catch (e) {
	    return false
	  }
	}
	
	function createBuffer (length) {
	  if (length > K_MAX_LENGTH) {
	    throw new RangeError('Invalid typed array length')
	  }
	  // Return an augmented `Uint8Array` instance
	  var buf = new Uint8Array(length)
	  buf.__proto__ = Buffer.prototype
	  return buf
	}
	
	/**
	 * The Buffer constructor returns instances of `Uint8Array` that have their
	 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
	 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
	 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
	 * returns a single octet.
	 *
	 * The `Uint8Array` prototype remains unmodified.
	 */
	
	function Buffer (arg, encodingOrOffset, length) {
	  // Common case.
	  if (typeof arg === 'number') {
	    if (typeof encodingOrOffset === 'string') {
	      throw new Error(
	        'If encoding is specified then the first argument must be a string'
	      )
	    }
	    return allocUnsafe(arg)
	  }
	  return from(arg, encodingOrOffset, length)
	}
	
	// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
	if (typeof Symbol !== 'undefined' && Symbol.species &&
	    Buffer[Symbol.species] === Buffer) {
	  Object.defineProperty(Buffer, Symbol.species, {
	    value: null,
	    configurable: true,
	    enumerable: false,
	    writable: false
	  })
	}
	
	Buffer.poolSize = 8192 // not used by this implementation
	
	function from (value, encodingOrOffset, length) {
	  if (typeof value === 'number') {
	    throw new TypeError('"value" argument must not be a number')
	  }
	
	  if (isArrayBuffer(value)) {
	    return fromArrayBuffer(value, encodingOrOffset, length)
	  }
	
	  if (typeof value === 'string') {
	    return fromString(value, encodingOrOffset)
	  }
	
	  return fromObject(value)
	}
	
	/**
	 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
	 * if value is a number.
	 * Buffer.from(str[, encoding])
	 * Buffer.from(array)
	 * Buffer.from(buffer)
	 * Buffer.from(arrayBuffer[, byteOffset[, length]])
	 **/
	Buffer.from = function (value, encodingOrOffset, length) {
	  return from(value, encodingOrOffset, length)
	}
	
	// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
	// https://github.com/feross/buffer/pull/148
	Buffer.prototype.__proto__ = Uint8Array.prototype
	Buffer.__proto__ = Uint8Array
	
	function assertSize (size) {
	  if (typeof size !== 'number') {
	    throw new TypeError('"size" argument must be a number')
	  } else if (size < 0) {
	    throw new RangeError('"size" argument must not be negative')
	  }
	}
	
	function alloc (size, fill, encoding) {
	  assertSize(size)
	  if (size <= 0) {
	    return createBuffer(size)
	  }
	  if (fill !== undefined) {
	    // Only pay attention to encoding if it's a string. This
	    // prevents accidentally sending in a number that would
	    // be interpretted as a start offset.
	    return typeof encoding === 'string'
	      ? createBuffer(size).fill(fill, encoding)
	      : createBuffer(size).fill(fill)
	  }
	  return createBuffer(size)
	}
	
	/**
	 * Creates a new filled Buffer instance.
	 * alloc(size[, fill[, encoding]])
	 **/
	Buffer.alloc = function (size, fill, encoding) {
	  return alloc(size, fill, encoding)
	}
	
	function allocUnsafe (size) {
	  assertSize(size)
	  return createBuffer(size < 0 ? 0 : checked(size) | 0)
	}
	
	/**
	 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
	 * */
	Buffer.allocUnsafe = function (size) {
	  return allocUnsafe(size)
	}
	/**
	 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
	 */
	Buffer.allocUnsafeSlow = function (size) {
	  return allocUnsafe(size)
	}
	
	function fromString (string, encoding) {
	  if (typeof encoding !== 'string' || encoding === '') {
	    encoding = 'utf8'
	  }
	
	  if (!Buffer.isEncoding(encoding)) {
	    throw new TypeError('"encoding" must be a valid string encoding')
	  }
	
	  var length = byteLength(string, encoding) | 0
	  var buf = createBuffer(length)
	
	  var actual = buf.write(string, encoding)
	
	  if (actual !== length) {
	    // Writing a hex string, for example, that contains invalid characters will
	    // cause everything after the first invalid character to be ignored. (e.g.
	    // 'abxxcd' will be treated as 'ab')
	    buf = buf.slice(0, actual)
	  }
	
	  return buf
	}
	
	function fromArrayLike (array) {
	  var length = array.length < 0 ? 0 : checked(array.length) | 0
	  var buf = createBuffer(length)
	  for (var i = 0; i < length; i += 1) {
	    buf[i] = array[i] & 255
	  }
	  return buf
	}
	
	function fromArrayBuffer (array, byteOffset, length) {
	  if (byteOffset < 0 || array.byteLength < byteOffset) {
	    throw new RangeError('\'offset\' is out of bounds')
	  }
	
	  if (array.byteLength < byteOffset + (length || 0)) {
	    throw new RangeError('\'length\' is out of bounds')
	  }
	
	  var buf
	  if (byteOffset === undefined && length === undefined) {
	    buf = new Uint8Array(array)
	  } else if (length === undefined) {
	    buf = new Uint8Array(array, byteOffset)
	  } else {
	    buf = new Uint8Array(array, byteOffset, length)
	  }
	
	  // Return an augmented `Uint8Array` instance
	  buf.__proto__ = Buffer.prototype
	  return buf
	}
	
	function fromObject (obj) {
	  if (Buffer.isBuffer(obj)) {
	    var len = checked(obj.length) | 0
	    var buf = createBuffer(len)
	
	    if (buf.length === 0) {
	      return buf
	    }
	
	    obj.copy(buf, 0, 0, len)
	    return buf
	  }
	
	  if (obj) {
	    if (isArrayBufferView(obj) || 'length' in obj) {
	      if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
	        return createBuffer(0)
	      }
	      return fromArrayLike(obj)
	    }
	
	    if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
	      return fromArrayLike(obj.data)
	    }
	  }
	
	  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
	}
	
	function checked (length) {
	  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
	  // length is NaN (which is otherwise coerced to zero.)
	  if (length >= K_MAX_LENGTH) {
	    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
	                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
	  }
	  return length | 0
	}
	
	function SlowBuffer (length) {
	  if (+length != length) { // eslint-disable-line eqeqeq
	    length = 0
	  }
	  return Buffer.alloc(+length)
	}
	
	Buffer.isBuffer = function isBuffer (b) {
	  return b != null && b._isBuffer === true
	}
	
	Buffer.compare = function compare (a, b) {
	  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
	    throw new TypeError('Arguments must be Buffers')
	  }
	
	  if (a === b) return 0
	
	  var x = a.length
	  var y = b.length
	
	  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
	    if (a[i] !== b[i]) {
	      x = a[i]
	      y = b[i]
	      break
	    }
	  }
	
	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	}
	
	Buffer.isEncoding = function isEncoding (encoding) {
	  switch (String(encoding).toLowerCase()) {
	    case 'hex':
	    case 'utf8':
	    case 'utf-8':
	    case 'ascii':
	    case 'latin1':
	    case 'binary':
	    case 'base64':
	    case 'ucs2':
	    case 'ucs-2':
	    case 'utf16le':
	    case 'utf-16le':
	      return true
	    default:
	      return false
	  }
	}
	
	Buffer.concat = function concat (list, length) {
	  if (!Array.isArray(list)) {
	    throw new TypeError('"list" argument must be an Array of Buffers')
	  }
	
	  if (list.length === 0) {
	    return Buffer.alloc(0)
	  }
	
	  var i
	  if (length === undefined) {
	    length = 0
	    for (i = 0; i < list.length; ++i) {
	      length += list[i].length
	    }
	  }
	
	  var buffer = Buffer.allocUnsafe(length)
	  var pos = 0
	  for (i = 0; i < list.length; ++i) {
	    var buf = list[i]
	    if (!Buffer.isBuffer(buf)) {
	      throw new TypeError('"list" argument must be an Array of Buffers')
	    }
	    buf.copy(buffer, pos)
	    pos += buf.length
	  }
	  return buffer
	}
	
	function byteLength (string, encoding) {
	  if (Buffer.isBuffer(string)) {
	    return string.length
	  }
	  if (isArrayBufferView(string) || isArrayBuffer(string)) {
	    return string.byteLength
	  }
	  if (typeof string !== 'string') {
	    string = '' + string
	  }
	
	  var len = string.length
	  if (len === 0) return 0
	
	  // Use a for loop to avoid recursion
	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'ascii':
	      case 'latin1':
	      case 'binary':
	        return len
	      case 'utf8':
	      case 'utf-8':
	      case undefined:
	        return utf8ToBytes(string).length
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return len * 2
	      case 'hex':
	        return len >>> 1
	      case 'base64':
	        return base64ToBytes(string).length
	      default:
	        if (loweredCase) return utf8ToBytes(string).length // assume utf8
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	Buffer.byteLength = byteLength
	
	function slowToString (encoding, start, end) {
	  var loweredCase = false
	
	  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
	  // property of a typed array.
	
	  // This behaves neither like String nor Uint8Array in that we set start/end
	  // to their upper/lower bounds if the value passed is out of range.
	  // undefined is handled specially as per ECMA-262 6th Edition,
	  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
	  if (start === undefined || start < 0) {
	    start = 0
	  }
	  // Return early if start > this.length. Done here to prevent potential uint32
	  // coercion fail below.
	  if (start > this.length) {
	    return ''
	  }
	
	  if (end === undefined || end > this.length) {
	    end = this.length
	  }
	
	  if (end <= 0) {
	    return ''
	  }
	
	  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
	  end >>>= 0
	  start >>>= 0
	
	  if (end <= start) {
	    return ''
	  }
	
	  if (!encoding) encoding = 'utf8'
	
	  while (true) {
	    switch (encoding) {
	      case 'hex':
	        return hexSlice(this, start, end)
	
	      case 'utf8':
	      case 'utf-8':
	        return utf8Slice(this, start, end)
	
	      case 'ascii':
	        return asciiSlice(this, start, end)
	
	      case 'latin1':
	      case 'binary':
	        return latin1Slice(this, start, end)
	
	      case 'base64':
	        return base64Slice(this, start, end)
	
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return utf16leSlice(this, start, end)
	
	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = (encoding + '').toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	
	// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
	// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
	// reliably in a browserify context because there could be multiple different
	// copies of the 'buffer' package in use. This method works even for Buffer
	// instances that were created from another copy of the `buffer` package.
	// See: https://github.com/feross/buffer/issues/154
	Buffer.prototype._isBuffer = true
	
	function swap (b, n, m) {
	  var i = b[n]
	  b[n] = b[m]
	  b[m] = i
	}
	
	Buffer.prototype.swap16 = function swap16 () {
	  var len = this.length
	  if (len % 2 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 16-bits')
	  }
	  for (var i = 0; i < len; i += 2) {
	    swap(this, i, i + 1)
	  }
	  return this
	}
	
	Buffer.prototype.swap32 = function swap32 () {
	  var len = this.length
	  if (len % 4 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 32-bits')
	  }
	  for (var i = 0; i < len; i += 4) {
	    swap(this, i, i + 3)
	    swap(this, i + 1, i + 2)
	  }
	  return this
	}
	
	Buffer.prototype.swap64 = function swap64 () {
	  var len = this.length
	  if (len % 8 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 64-bits')
	  }
	  for (var i = 0; i < len; i += 8) {
	    swap(this, i, i + 7)
	    swap(this, i + 1, i + 6)
	    swap(this, i + 2, i + 5)
	    swap(this, i + 3, i + 4)
	  }
	  return this
	}
	
	Buffer.prototype.toString = function toString () {
	  var length = this.length
	  if (length === 0) return ''
	  if (arguments.length === 0) return utf8Slice(this, 0, length)
	  return slowToString.apply(this, arguments)
	}
	
	Buffer.prototype.equals = function equals (b) {
	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return true
	  return Buffer.compare(this, b) === 0
	}
	
	Buffer.prototype.inspect = function inspect () {
	  var str = ''
	  var max = exports.INSPECT_MAX_BYTES
	  if (this.length > 0) {
	    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
	    if (this.length > max) str += ' ... '
	  }
	  return '<Buffer ' + str + '>'
	}
	
	Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
	  if (!Buffer.isBuffer(target)) {
	    throw new TypeError('Argument must be a Buffer')
	  }
	
	  if (start === undefined) {
	    start = 0
	  }
	  if (end === undefined) {
	    end = target ? target.length : 0
	  }
	  if (thisStart === undefined) {
	    thisStart = 0
	  }
	  if (thisEnd === undefined) {
	    thisEnd = this.length
	  }
	
	  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
	    throw new RangeError('out of range index')
	  }
	
	  if (thisStart >= thisEnd && start >= end) {
	    return 0
	  }
	  if (thisStart >= thisEnd) {
	    return -1
	  }
	  if (start >= end) {
	    return 1
	  }
	
	  start >>>= 0
	  end >>>= 0
	  thisStart >>>= 0
	  thisEnd >>>= 0
	
	  if (this === target) return 0
	
	  var x = thisEnd - thisStart
	  var y = end - start
	  var len = Math.min(x, y)
	
	  var thisCopy = this.slice(thisStart, thisEnd)
	  var targetCopy = target.slice(start, end)
	
	  for (var i = 0; i < len; ++i) {
	    if (thisCopy[i] !== targetCopy[i]) {
	      x = thisCopy[i]
	      y = targetCopy[i]
	      break
	    }
	  }
	
	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	}
	
	// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
	// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
	//
	// Arguments:
	// - buffer - a Buffer to search
	// - val - a string, Buffer, or number
	// - byteOffset - an index into `buffer`; will be clamped to an int32
	// - encoding - an optional encoding, relevant is val is a string
	// - dir - true for indexOf, false for lastIndexOf
	function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
	  // Empty buffer means no match
	  if (buffer.length === 0) return -1
	
	  // Normalize byteOffset
	  if (typeof byteOffset === 'string') {
	    encoding = byteOffset
	    byteOffset = 0
	  } else if (byteOffset > 0x7fffffff) {
	    byteOffset = 0x7fffffff
	  } else if (byteOffset < -0x80000000) {
	    byteOffset = -0x80000000
	  }
	  byteOffset = +byteOffset  // Coerce to Number.
	  if (numberIsNaN(byteOffset)) {
	    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
	    byteOffset = dir ? 0 : (buffer.length - 1)
	  }
	
	  // Normalize byteOffset: negative offsets start from the end of the buffer
	  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
	  if (byteOffset >= buffer.length) {
	    if (dir) return -1
	    else byteOffset = buffer.length - 1
	  } else if (byteOffset < 0) {
	    if (dir) byteOffset = 0
	    else return -1
	  }
	
	  // Normalize val
	  if (typeof val === 'string') {
	    val = Buffer.from(val, encoding)
	  }
	
	  // Finally, search either indexOf (if dir is true) or lastIndexOf
	  if (Buffer.isBuffer(val)) {
	    // Special case: looking for empty string/buffer always fails
	    if (val.length === 0) {
	      return -1
	    }
	    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
	  } else if (typeof val === 'number') {
	    val = val & 0xFF // Search for a byte value [0-255]
	    if (typeof Uint8Array.prototype.indexOf === 'function') {
	      if (dir) {
	        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
	      } else {
	        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
	      }
	    }
	    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
	  }
	
	  throw new TypeError('val must be string, number or Buffer')
	}
	
	function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
	  var indexSize = 1
	  var arrLength = arr.length
	  var valLength = val.length
	
	  if (encoding !== undefined) {
	    encoding = String(encoding).toLowerCase()
	    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
	        encoding === 'utf16le' || encoding === 'utf-16le') {
	      if (arr.length < 2 || val.length < 2) {
	        return -1
	      }
	      indexSize = 2
	      arrLength /= 2
	      valLength /= 2
	      byteOffset /= 2
	    }
	  }
	
	  function read (buf, i) {
	    if (indexSize === 1) {
	      return buf[i]
	    } else {
	      return buf.readUInt16BE(i * indexSize)
	    }
	  }
	
	  var i
	  if (dir) {
	    var foundIndex = -1
	    for (i = byteOffset; i < arrLength; i++) {
	      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
	        if (foundIndex === -1) foundIndex = i
	        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
	      } else {
	        if (foundIndex !== -1) i -= i - foundIndex
	        foundIndex = -1
	      }
	    }
	  } else {
	    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
	    for (i = byteOffset; i >= 0; i--) {
	      var found = true
	      for (var j = 0; j < valLength; j++) {
	        if (read(arr, i + j) !== read(val, j)) {
	          found = false
	          break
	        }
	      }
	      if (found) return i
	    }
	  }
	
	  return -1
	}
	
	Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
	  return this.indexOf(val, byteOffset, encoding) !== -1
	}
	
	Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
	  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
	}
	
	Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
	  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
	}
	
	function hexWrite (buf, string, offset, length) {
	  offset = Number(offset) || 0
	  var remaining = buf.length - offset
	  if (!length) {
	    length = remaining
	  } else {
	    length = Number(length)
	    if (length > remaining) {
	      length = remaining
	    }
	  }
	
	  // must be an even number of digits
	  var strLen = string.length
	  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')
	
	  if (length > strLen / 2) {
	    length = strLen / 2
	  }
	  for (var i = 0; i < length; ++i) {
	    var parsed = parseInt(string.substr(i * 2, 2), 16)
	    if (numberIsNaN(parsed)) return i
	    buf[offset + i] = parsed
	  }
	  return i
	}
	
	function utf8Write (buf, string, offset, length) {
	  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
	}
	
	function asciiWrite (buf, string, offset, length) {
	  return blitBuffer(asciiToBytes(string), buf, offset, length)
	}
	
	function latin1Write (buf, string, offset, length) {
	  return asciiWrite(buf, string, offset, length)
	}
	
	function base64Write (buf, string, offset, length) {
	  return blitBuffer(base64ToBytes(string), buf, offset, length)
	}
	
	function ucs2Write (buf, string, offset, length) {
	  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
	}
	
	Buffer.prototype.write = function write (string, offset, length, encoding) {
	  // Buffer#write(string)
	  if (offset === undefined) {
	    encoding = 'utf8'
	    length = this.length
	    offset = 0
	  // Buffer#write(string, encoding)
	  } else if (length === undefined && typeof offset === 'string') {
	    encoding = offset
	    length = this.length
	    offset = 0
	  // Buffer#write(string, offset[, length][, encoding])
	  } else if (isFinite(offset)) {
	    offset = offset >>> 0
	    if (isFinite(length)) {
	      length = length >>> 0
	      if (encoding === undefined) encoding = 'utf8'
	    } else {
	      encoding = length
	      length = undefined
	    }
	  } else {
	    throw new Error(
	      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
	    )
	  }
	
	  var remaining = this.length - offset
	  if (length === undefined || length > remaining) length = remaining
	
	  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
	    throw new RangeError('Attempt to write outside buffer bounds')
	  }
	
	  if (!encoding) encoding = 'utf8'
	
	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'hex':
	        return hexWrite(this, string, offset, length)
	
	      case 'utf8':
	      case 'utf-8':
	        return utf8Write(this, string, offset, length)
	
	      case 'ascii':
	        return asciiWrite(this, string, offset, length)
	
	      case 'latin1':
	      case 'binary':
	        return latin1Write(this, string, offset, length)
	
	      case 'base64':
	        // Warning: maxLength not taken into account in base64Write
	        return base64Write(this, string, offset, length)
	
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return ucs2Write(this, string, offset, length)
	
	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	
	Buffer.prototype.toJSON = function toJSON () {
	  return {
	    type: 'Buffer',
	    data: Array.prototype.slice.call(this._arr || this, 0)
	  }
	}
	
	function base64Slice (buf, start, end) {
	  if (start === 0 && end === buf.length) {
	    return base64.fromByteArray(buf)
	  } else {
	    return base64.fromByteArray(buf.slice(start, end))
	  }
	}
	
	function utf8Slice (buf, start, end) {
	  end = Math.min(buf.length, end)
	  var res = []
	
	  var i = start
	  while (i < end) {
	    var firstByte = buf[i]
	    var codePoint = null
	    var bytesPerSequence = (firstByte > 0xEF) ? 4
	      : (firstByte > 0xDF) ? 3
	      : (firstByte > 0xBF) ? 2
	      : 1
	
	    if (i + bytesPerSequence <= end) {
	      var secondByte, thirdByte, fourthByte, tempCodePoint
	
	      switch (bytesPerSequence) {
	        case 1:
	          if (firstByte < 0x80) {
	            codePoint = firstByte
	          }
	          break
	        case 2:
	          secondByte = buf[i + 1]
	          if ((secondByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
	            if (tempCodePoint > 0x7F) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 3:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
	            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 4:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          fourthByte = buf[i + 3]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
	            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
	              codePoint = tempCodePoint
	            }
	          }
	      }
	    }
	
	    if (codePoint === null) {
	      // we did not generate a valid codePoint so insert a
	      // replacement char (U+FFFD) and advance only 1 byte
	      codePoint = 0xFFFD
	      bytesPerSequence = 1
	    } else if (codePoint > 0xFFFF) {
	      // encode to utf16 (surrogate pair dance)
	      codePoint -= 0x10000
	      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
	      codePoint = 0xDC00 | codePoint & 0x3FF
	    }
	
	    res.push(codePoint)
	    i += bytesPerSequence
	  }
	
	  return decodeCodePointsArray(res)
	}
	
	// Based on http://stackoverflow.com/a/22747272/680742, the browser with
	// the lowest limit is Chrome, with 0x10000 args.
	// We go 1 magnitude less, for safety
	var MAX_ARGUMENTS_LENGTH = 0x1000
	
	function decodeCodePointsArray (codePoints) {
	  var len = codePoints.length
	  if (len <= MAX_ARGUMENTS_LENGTH) {
	    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
	  }
	
	  // Decode in chunks to avoid "call stack size exceeded".
	  var res = ''
	  var i = 0
	  while (i < len) {
	    res += String.fromCharCode.apply(
	      String,
	      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
	    )
	  }
	  return res
	}
	
	function asciiSlice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)
	
	  for (var i = start; i < end; ++i) {
	    ret += String.fromCharCode(buf[i] & 0x7F)
	  }
	  return ret
	}
	
	function latin1Slice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)
	
	  for (var i = start; i < end; ++i) {
	    ret += String.fromCharCode(buf[i])
	  }
	  return ret
	}
	
	function hexSlice (buf, start, end) {
	  var len = buf.length
	
	  if (!start || start < 0) start = 0
	  if (!end || end < 0 || end > len) end = len
	
	  var out = ''
	  for (var i = start; i < end; ++i) {
	    out += toHex(buf[i])
	  }
	  return out
	}
	
	function utf16leSlice (buf, start, end) {
	  var bytes = buf.slice(start, end)
	  var res = ''
	  for (var i = 0; i < bytes.length; i += 2) {
	    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
	  }
	  return res
	}
	
	Buffer.prototype.slice = function slice (start, end) {
	  var len = this.length
	  start = ~~start
	  end = end === undefined ? len : ~~end
	
	  if (start < 0) {
	    start += len
	    if (start < 0) start = 0
	  } else if (start > len) {
	    start = len
	  }
	
	  if (end < 0) {
	    end += len
	    if (end < 0) end = 0
	  } else if (end > len) {
	    end = len
	  }
	
	  if (end < start) end = start
	
	  var newBuf = this.subarray(start, end)
	  // Return an augmented `Uint8Array` instance
	  newBuf.__proto__ = Buffer.prototype
	  return newBuf
	}
	
	/*
	 * Need to make sure that buffer isn't trying to write out of bounds.
	 */
	function checkOffset (offset, ext, length) {
	  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
	  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
	}
	
	Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
	  offset = offset >>> 0
	  byteLength = byteLength >>> 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }
	
	  return val
	}
	
	Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
	  offset = offset >>> 0
	  byteLength = byteLength >>> 0
	  if (!noAssert) {
	    checkOffset(offset, byteLength, this.length)
	  }
	
	  var val = this[offset + --byteLength]
	  var mul = 1
	  while (byteLength > 0 && (mul *= 0x100)) {
	    val += this[offset + --byteLength] * mul
	  }
	
	  return val
	}
	
	Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
	  offset = offset >>> 0
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  return this[offset]
	}
	
	Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
	  offset = offset >>> 0
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return this[offset] | (this[offset + 1] << 8)
	}
	
	Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
	  offset = offset >>> 0
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return (this[offset] << 8) | this[offset + 1]
	}
	
	Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
	  offset = offset >>> 0
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return ((this[offset]) |
	      (this[offset + 1] << 8) |
	      (this[offset + 2] << 16)) +
	      (this[offset + 3] * 0x1000000)
	}
	
	Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
	  offset = offset >>> 0
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return (this[offset] * 0x1000000) +
	    ((this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    this[offset + 3])
	}
	
	Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
	  offset = offset >>> 0
	  byteLength = byteLength >>> 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }
	  mul *= 0x80
	
	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)
	
	  return val
	}
	
	Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
	  offset = offset >>> 0
	  byteLength = byteLength >>> 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
	  var i = byteLength
	  var mul = 1
	  var val = this[offset + --i]
	  while (i > 0 && (mul *= 0x100)) {
	    val += this[offset + --i] * mul
	  }
	  mul *= 0x80
	
	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)
	
	  return val
	}
	
	Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
	  offset = offset >>> 0
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  if (!(this[offset] & 0x80)) return (this[offset])
	  return ((0xff - this[offset] + 1) * -1)
	}
	
	Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
	  offset = offset >>> 0
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset] | (this[offset + 1] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}
	
	Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
	  offset = offset >>> 0
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset + 1] | (this[offset] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}
	
	Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
	  offset = offset >>> 0
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return (this[offset]) |
	    (this[offset + 1] << 8) |
	    (this[offset + 2] << 16) |
	    (this[offset + 3] << 24)
	}
	
	Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
	  offset = offset >>> 0
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return (this[offset] << 24) |
	    (this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    (this[offset + 3])
	}
	
	Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
	  offset = offset >>> 0
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, true, 23, 4)
	}
	
	Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
	  offset = offset >>> 0
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, false, 23, 4)
	}
	
	Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
	  offset = offset >>> 0
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, true, 52, 8)
	}
	
	Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
	  offset = offset >>> 0
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, false, 52, 8)
	}
	
	function checkInt (buf, value, offset, ext, max, min) {
	  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
	  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('Index out of range')
	}
	
	Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset >>> 0
	  byteLength = byteLength >>> 0
	  if (!noAssert) {
	    var maxBytes = Math.pow(2, 8 * byteLength) - 1
	    checkInt(this, value, offset, byteLength, maxBytes, 0)
	  }
	
	  var mul = 1
	  var i = 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset >>> 0
	  byteLength = byteLength >>> 0
	  if (!noAssert) {
	    var maxBytes = Math.pow(2, 8 * byteLength) - 1
	    checkInt(this, value, offset, byteLength, maxBytes, 0)
	  }
	
	  var i = byteLength - 1
	  var mul = 1
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset >>> 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
	  this[offset] = (value & 0xff)
	  return offset + 1
	}
	
	Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset >>> 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  this[offset] = (value & 0xff)
	  this[offset + 1] = (value >>> 8)
	  return offset + 2
	}
	
	Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset >>> 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  this[offset] = (value >>> 8)
	  this[offset + 1] = (value & 0xff)
	  return offset + 2
	}
	
	Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset >>> 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  this[offset + 3] = (value >>> 24)
	  this[offset + 2] = (value >>> 16)
	  this[offset + 1] = (value >>> 8)
	  this[offset] = (value & 0xff)
	  return offset + 4
	}
	
	Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset >>> 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  this[offset] = (value >>> 24)
	  this[offset + 1] = (value >>> 16)
	  this[offset + 2] = (value >>> 8)
	  this[offset + 3] = (value & 0xff)
	  return offset + 4
	}
	
	Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset >>> 0
	  if (!noAssert) {
	    var limit = Math.pow(2, (8 * byteLength) - 1)
	
	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }
	
	  var i = 0
	  var mul = 1
	  var sub = 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
	      sub = 1
	    }
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset >>> 0
	  if (!noAssert) {
	    var limit = Math.pow(2, (8 * byteLength) - 1)
	
	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }
	
	  var i = byteLength - 1
	  var mul = 1
	  var sub = 0
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
	      sub = 1
	    }
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset >>> 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
	  if (value < 0) value = 0xff + value + 1
	  this[offset] = (value & 0xff)
	  return offset + 1
	}
	
	Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset >>> 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  this[offset] = (value & 0xff)
	  this[offset + 1] = (value >>> 8)
	  return offset + 2
	}
	
	Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset >>> 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  this[offset] = (value >>> 8)
	  this[offset + 1] = (value & 0xff)
	  return offset + 2
	}
	
	Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset >>> 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  this[offset] = (value & 0xff)
	  this[offset + 1] = (value >>> 8)
	  this[offset + 2] = (value >>> 16)
	  this[offset + 3] = (value >>> 24)
	  return offset + 4
	}
	
	Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset >>> 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (value < 0) value = 0xffffffff + value + 1
	  this[offset] = (value >>> 24)
	  this[offset + 1] = (value >>> 16)
	  this[offset + 2] = (value >>> 8)
	  this[offset + 3] = (value & 0xff)
	  return offset + 4
	}
	
	function checkIEEE754 (buf, value, offset, ext, max, min) {
	  if (offset + ext > buf.length) throw new RangeError('Index out of range')
	  if (offset < 0) throw new RangeError('Index out of range')
	}
	
	function writeFloat (buf, value, offset, littleEndian, noAssert) {
	  value = +value
	  offset = offset >>> 0
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 23, 4)
	  return offset + 4
	}
	
	Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, true, noAssert)
	}
	
	Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, false, noAssert)
	}
	
	function writeDouble (buf, value, offset, littleEndian, noAssert) {
	  value = +value
	  offset = offset >>> 0
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 52, 8)
	  return offset + 8
	}
	
	Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, true, noAssert)
	}
	
	Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, false, noAssert)
	}
	
	// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
	Buffer.prototype.copy = function copy (target, targetStart, start, end) {
	  if (!start) start = 0
	  if (!end && end !== 0) end = this.length
	  if (targetStart >= target.length) targetStart = target.length
	  if (!targetStart) targetStart = 0
	  if (end > 0 && end < start) end = start
	
	  // Copy 0 bytes; we're done
	  if (end === start) return 0
	  if (target.length === 0 || this.length === 0) return 0
	
	  // Fatal error conditions
	  if (targetStart < 0) {
	    throw new RangeError('targetStart out of bounds')
	  }
	  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
	  if (end < 0) throw new RangeError('sourceEnd out of bounds')
	
	  // Are we oob?
	  if (end > this.length) end = this.length
	  if (target.length - targetStart < end - start) {
	    end = target.length - targetStart + start
	  }
	
	  var len = end - start
	  var i
	
	  if (this === target && start < targetStart && targetStart < end) {
	    // descending copy from end
	    for (i = len - 1; i >= 0; --i) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else if (len < 1000) {
	    // ascending copy from start
	    for (i = 0; i < len; ++i) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else {
	    Uint8Array.prototype.set.call(
	      target,
	      this.subarray(start, start + len),
	      targetStart
	    )
	  }
	
	  return len
	}
	
	// Usage:
	//    buffer.fill(number[, offset[, end]])
	//    buffer.fill(buffer[, offset[, end]])
	//    buffer.fill(string[, offset[, end]][, encoding])
	Buffer.prototype.fill = function fill (val, start, end, encoding) {
	  // Handle string cases:
	  if (typeof val === 'string') {
	    if (typeof start === 'string') {
	      encoding = start
	      start = 0
	      end = this.length
	    } else if (typeof end === 'string') {
	      encoding = end
	      end = this.length
	    }
	    if (val.length === 1) {
	      var code = val.charCodeAt(0)
	      if (code < 256) {
	        val = code
	      }
	    }
	    if (encoding !== undefined && typeof encoding !== 'string') {
	      throw new TypeError('encoding must be a string')
	    }
	    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
	      throw new TypeError('Unknown encoding: ' + encoding)
	    }
	  } else if (typeof val === 'number') {
	    val = val & 255
	  }
	
	  // Invalid ranges are not set to a default, so can range check early.
	  if (start < 0 || this.length < start || this.length < end) {
	    throw new RangeError('Out of range index')
	  }
	
	  if (end <= start) {
	    return this
	  }
	
	  start = start >>> 0
	  end = end === undefined ? this.length : end >>> 0
	
	  if (!val) val = 0
	
	  var i
	  if (typeof val === 'number') {
	    for (i = start; i < end; ++i) {
	      this[i] = val
	    }
	  } else {
	    var bytes = Buffer.isBuffer(val)
	      ? val
	      : new Buffer(val, encoding)
	    var len = bytes.length
	    for (i = 0; i < end - start; ++i) {
	      this[i + start] = bytes[i % len]
	    }
	  }
	
	  return this
	}
	
	// HELPER FUNCTIONS
	// ================
	
	var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g
	
	function base64clean (str) {
	  // Node strips out invalid characters like \n and \t from the string, base64-js does not
	  str = str.trim().replace(INVALID_BASE64_RE, '')
	  // Node converts strings with length < 2 to ''
	  if (str.length < 2) return ''
	  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
	  while (str.length % 4 !== 0) {
	    str = str + '='
	  }
	  return str
	}
	
	function toHex (n) {
	  if (n < 16) return '0' + n.toString(16)
	  return n.toString(16)
	}
	
	function utf8ToBytes (string, units) {
	  units = units || Infinity
	  var codePoint
	  var length = string.length
	  var leadSurrogate = null
	  var bytes = []
	
	  for (var i = 0; i < length; ++i) {
	    codePoint = string.charCodeAt(i)
	
	    // is surrogate component
	    if (codePoint > 0xD7FF && codePoint < 0xE000) {
	      // last char was a lead
	      if (!leadSurrogate) {
	        // no lead yet
	        if (codePoint > 0xDBFF) {
	          // unexpected trail
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        } else if (i + 1 === length) {
	          // unpaired lead
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        }
	
	        // valid lead
	        leadSurrogate = codePoint
	
	        continue
	      }
	
	      // 2 leads in a row
	      if (codePoint < 0xDC00) {
	        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	        leadSurrogate = codePoint
	        continue
	      }
	
	      // valid surrogate pair
	      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
	    } else if (leadSurrogate) {
	      // valid bmp char, but last char was a lead
	      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	    }
	
	    leadSurrogate = null
	
	    // encode utf8
	    if (codePoint < 0x80) {
	      if ((units -= 1) < 0) break
	      bytes.push(codePoint)
	    } else if (codePoint < 0x800) {
	      if ((units -= 2) < 0) break
	      bytes.push(
	        codePoint >> 0x6 | 0xC0,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x10000) {
	      if ((units -= 3) < 0) break
	      bytes.push(
	        codePoint >> 0xC | 0xE0,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x110000) {
	      if ((units -= 4) < 0) break
	      bytes.push(
	        codePoint >> 0x12 | 0xF0,
	        codePoint >> 0xC & 0x3F | 0x80,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else {
	      throw new Error('Invalid code point')
	    }
	  }
	
	  return bytes
	}
	
	function asciiToBytes (str) {
	  var byteArray = []
	  for (var i = 0; i < str.length; ++i) {
	    // Node's code seems to be doing this and not & 0x7F..
	    byteArray.push(str.charCodeAt(i) & 0xFF)
	  }
	  return byteArray
	}
	
	function utf16leToBytes (str, units) {
	  var c, hi, lo
	  var byteArray = []
	  for (var i = 0; i < str.length; ++i) {
	    if ((units -= 2) < 0) break
	
	    c = str.charCodeAt(i)
	    hi = c >> 8
	    lo = c % 256
	    byteArray.push(lo)
	    byteArray.push(hi)
	  }
	
	  return byteArray
	}
	
	function base64ToBytes (str) {
	  return base64.toByteArray(base64clean(str))
	}
	
	function blitBuffer (src, dst, offset, length) {
	  for (var i = 0; i < length; ++i) {
	    if ((i + offset >= dst.length) || (i >= src.length)) break
	    dst[i + offset] = src[i]
	  }
	  return i
	}
	
	// ArrayBuffers from another context (i.e. an iframe) do not pass the `instanceof` check
	// but they should be treated as valid. See: https://github.com/feross/buffer/issues/166
	function isArrayBuffer (obj) {
	  return obj instanceof ArrayBuffer ||
	    (obj != null && obj.constructor != null && obj.constructor.name === 'ArrayBuffer' &&
	      typeof obj.byteLength === 'number')
	}
	
	// Node 0.10 supports `ArrayBuffer` but lacks `ArrayBuffer.isView`
	function isArrayBufferView (obj) {
	  return (typeof ArrayBuffer.isView === 'function') && ArrayBuffer.isView(obj)
	}
	
	function numberIsNaN (obj) {
	  return obj !== obj // eslint-disable-line no-self-compare
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 3 */
/***/ function(module, exports) {

	'use strict'
	
	exports.byteLength = byteLength
	exports.toByteArray = toByteArray
	exports.fromByteArray = fromByteArray
	
	var lookup = []
	var revLookup = []
	var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array
	
	var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
	for (var i = 0, len = code.length; i < len; ++i) {
	  lookup[i] = code[i]
	  revLookup[code.charCodeAt(i)] = i
	}
	
	revLookup['-'.charCodeAt(0)] = 62
	revLookup['_'.charCodeAt(0)] = 63
	
	function placeHoldersCount (b64) {
	  var len = b64.length
	  if (len % 4 > 0) {
	    throw new Error('Invalid string. Length must be a multiple of 4')
	  }
	
	  // the number of equal signs (place holders)
	  // if there are two placeholders, than the two characters before it
	  // represent one byte
	  // if there is only one, then the three characters before it represent 2 bytes
	  // this is just a cheap hack to not do indexOf twice
	  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0
	}
	
	function byteLength (b64) {
	  // base64 is 4/3 + up to two characters of the original data
	  return b64.length * 3 / 4 - placeHoldersCount(b64)
	}
	
	function toByteArray (b64) {
	  var i, j, l, tmp, placeHolders, arr
	  var len = b64.length
	  placeHolders = placeHoldersCount(b64)
	
	  arr = new Arr(len * 3 / 4 - placeHolders)
	
	  // if there are placeholders, only get up to the last complete 4 chars
	  l = placeHolders > 0 ? len - 4 : len
	
	  var L = 0
	
	  for (i = 0, j = 0; i < l; i += 4, j += 3) {
	    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
	    arr[L++] = (tmp >> 16) & 0xFF
	    arr[L++] = (tmp >> 8) & 0xFF
	    arr[L++] = tmp & 0xFF
	  }
	
	  if (placeHolders === 2) {
	    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
	    arr[L++] = tmp & 0xFF
	  } else if (placeHolders === 1) {
	    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
	    arr[L++] = (tmp >> 8) & 0xFF
	    arr[L++] = tmp & 0xFF
	  }
	
	  return arr
	}
	
	function tripletToBase64 (num) {
	  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
	}
	
	function encodeChunk (uint8, start, end) {
	  var tmp
	  var output = []
	  for (var i = start; i < end; i += 3) {
	    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
	    output.push(tripletToBase64(tmp))
	  }
	  return output.join('')
	}
	
	function fromByteArray (uint8) {
	  var tmp
	  var len = uint8.length
	  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
	  var output = ''
	  var parts = []
	  var maxChunkLength = 16383 // must be multiple of 3
	
	  // go through the array every three bytes, we'll deal with trailing stuff later
	  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
	    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
	  }
	
	  // pad the end with zeros, but make sure to not forget the extra bytes
	  if (extraBytes === 1) {
	    tmp = uint8[len - 1]
	    output += lookup[tmp >> 2]
	    output += lookup[(tmp << 4) & 0x3F]
	    output += '=='
	  } else if (extraBytes === 2) {
	    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
	    output += lookup[tmp >> 10]
	    output += lookup[(tmp >> 4) & 0x3F]
	    output += lookup[(tmp << 2) & 0x3F]
	    output += '='
	  }
	
	  parts.push(output)
	
	  return parts.join('')
	}


/***/ },
/* 4 */
/***/ function(module, exports) {

	exports.read = function (buffer, offset, isLE, mLen, nBytes) {
	  var e, m
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var nBits = -7
	  var i = isLE ? (nBytes - 1) : 0
	  var d = isLE ? -1 : 1
	  var s = buffer[offset + i]
	
	  i += d
	
	  e = s & ((1 << (-nBits)) - 1)
	  s >>= (-nBits)
	  nBits += eLen
	  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}
	
	  m = e & ((1 << (-nBits)) - 1)
	  e >>= (-nBits)
	  nBits += mLen
	  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}
	
	  if (e === 0) {
	    e = 1 - eBias
	  } else if (e === eMax) {
	    return m ? NaN : ((s ? -1 : 1) * Infinity)
	  } else {
	    m = m + Math.pow(2, mLen)
	    e = e - eBias
	  }
	  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
	}
	
	exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
	  var e, m, c
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
	  var i = isLE ? 0 : (nBytes - 1)
	  var d = isLE ? 1 : -1
	  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0
	
	  value = Math.abs(value)
	
	  if (isNaN(value) || value === Infinity) {
	    m = isNaN(value) ? 1 : 0
	    e = eMax
	  } else {
	    e = Math.floor(Math.log(value) / Math.LN2)
	    if (value * (c = Math.pow(2, -e)) < 1) {
	      e--
	      c *= 2
	    }
	    if (e + eBias >= 1) {
	      value += rt / c
	    } else {
	      value += rt * Math.pow(2, 1 - eBias)
	    }
	    if (value * c >= 2) {
	      e++
	      c /= 2
	    }
	
	    if (e + eBias >= eMax) {
	      m = 0
	      e = eMax
	    } else if (e + eBias >= 1) {
	      m = (value * c - 1) * Math.pow(2, mLen)
	      e = e + eBias
	    } else {
	      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
	      e = 0
	    }
	  }
	
	  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}
	
	  e = (e << mLen) | m
	  eLen += mLen
	  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}
	
	  buffer[offset + i - d] |= s * 128
	}


/***/ },
/* 5 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Process = __webpack_require__(7);
	var process = new Process(), processProxy = {};
	function defineKey(key) {
	    if (processProxy[key]) {
	        // Probably a builtin Object property we don't care about.
	        return;
	    }
	    if (typeof process[key] === 'function') {
	        processProxy[key] = function () {
	            return process[key].apply(process, arguments);
	        };
	    }
	    else {
	        processProxy[key] = process[key];
	    }
	}
	for (var key in process) {
	    // Don't check if process.hasOwnProperty; we want to also expose objects
	    // up the prototype hierarchy.
	    defineKey(key);
	}
	// Special key: Ensure we update public-facing values of stdin/stdout/stderr.
	processProxy.initializeTTYs = function () {
	    if (process.stdin === null) {
	        process.initializeTTYs();
	        processProxy.stdin = process.stdin;
	        processProxy.stdout = process.stdout;
	        processProxy.stderr = process.stderr;
	    }
	};
	process.nextTick(function () {
	    processProxy.initializeTTYs();
	});
	module.exports = processProxy;


/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(__dirname) {"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var events = __webpack_require__(8);
	// Path depends on process. Avoid a circular reference by dynamically including path when we need it.
	var path = null;
	var Item = (function () {
	    function Item(fun, array) {
	        this.fun = fun;
	        this.array = array;
	    }
	    Item.prototype.run = function () {
	        this.fun.apply(null, this.array);
	    };
	    return Item;
	}());
	/**
	 * Contains a queue of Items for process.nextTick.
	 * Inspired by node-process: https://github.com/defunctzombie/node-process
	 */
	var NextTickQueue = (function () {
	    function NextTickQueue() {
	        this._queue = [];
	        this._draining = false;
	        // Used/assigned by the drainQueue function.
	        this._currentQueue = null;
	        this._queueIndex = -1;
	    }
	    NextTickQueue.prototype.push = function (item) {
	        var _this = this;
	        if (this._queue.push(item) === 1 && !this._draining) {
	            setTimeout(function () { return _this._drainQueue(); }, 0);
	        }
	    };
	    NextTickQueue.prototype._cleanUpNextTick = function () {
	        this._draining = false;
	        if (this._currentQueue && this._currentQueue.length) {
	            this._queue = this._currentQueue.concat(this._queue);
	        }
	        else {
	            this._queueIndex = -1;
	        }
	        if (this._queue.length) {
	            this._drainQueue();
	        }
	    };
	    NextTickQueue.prototype._drainQueue = function () {
	        var _this = this;
	        if (this._draining) {
	            return;
	        }
	        // If an Item throws an unhandled exception, this function will clean things up.
	        var timeout = setTimeout(function () { return _this._cleanUpNextTick(); });
	        this._draining = true;
	        var len = this._queue.length;
	        while (len) {
	            this._currentQueue = this._queue;
	            this._queue = [];
	            while (++this._queueIndex < len) {
	                if (this._currentQueue) {
	                    this._currentQueue[this._queueIndex].run();
	                }
	            }
	            this._queueIndex = -1;
	            len = this._queue.length;
	        }
	        this._currentQueue = null;
	        this._draining = false;
	        clearTimeout(timeout);
	    };
	    return NextTickQueue;
	}());
	/**
	 * Partial implementation of Node's `process` module.
	 * We implement the portions that are relevant for the filesystem.
	 * @see http://nodejs.org/api/process.html
	 * @class
	 */
	var Process = (function (_super) {
	    __extends(Process, _super);
	    function Process() {
	        _super.apply(this, arguments);
	        this.startTime = Date.now();
	        this._cwd = '/';
	        /**
	         * Returns what platform you are running on.
	         * @return [String]
	         */
	        this.platform = 'browser';
	        this.argv = [];
	        this.execArgv = [];
	        this.stdout = null;
	        this.stderr = null;
	        this.stdin = null;
	        this.domain = null;
	        this._queue = new NextTickQueue();
	        this.execPath = __dirname;
	        this.env = {};
	        this.exitCode = 0;
	        this._gid = 1;
	        this._uid = 1;
	        this.version = 'v5.0';
	        this.versions = {
	            http_parser: '0.0',
	            node: '5.0',
	            v8: '0.0',
	            uv: '0.0',
	            zlib: '0.0',
	            ares: '0.0',
	            icu: '0.0',
	            modules: '0',
	            openssl: '0.0'
	        };
	        this.config = {
	            target_defaults: { cflags: [],
	                default_configuration: 'Release',
	                defines: [],
	                include_dirs: [],
	                libraries: [] },
	            variables: { clang: 0,
	                host_arch: 'x32',
	                node_install_npm: false,
	                node_install_waf: false,
	                node_prefix: '',
	                node_shared_cares: false,
	                node_shared_http_parser: false,
	                node_shared_libuv: false,
	                node_shared_zlib: false,
	                node_shared_v8: false,
	                node_use_dtrace: false,
	                node_use_etw: false,
	                node_use_openssl: false,
	                node_shared_openssl: false,
	                strict_aliasing: false,
	                target_arch: 'x32',
	                v8_use_snapshot: false,
	                v8_no_strict_aliasing: 0,
	                visibility: '' } };
	        this.pid = (Math.random() * 1000) | 0;
	        this.title = 'node';
	        this.arch = 'x32';
	        this._mask = 18;
	        // Undefined in main thread. Worker-only.
	        this.connected = undefined;
	    }
	    /**
	     * Changes the current working directory.
	     *
	     * **Note**: BrowserFS does not validate that the directory actually exists.
	     *
	     * @example Usage example
	     *   console.log('Starting directory: ' + process.cwd());
	     *   process.chdir('/tmp');
	     *   console.log('New directory: ' + process.cwd());
	     * @param [String] dir The directory to change to.
	     */
	    Process.prototype.chdir = function (dir) {
	        // XXX: Circular dependency hack.
	        if (path === null) {
	            path = __webpack_require__(9);
	        }
	        this._cwd = path.resolve(dir);
	    };
	    /**
	     * Returns the current working directory.
	     * @example Usage example
	     *   console.log('Current directory: ' + process.cwd());
	     * @return [String] The current working directory.
	     */
	    Process.prototype.cwd = function () {
	        return this._cwd;
	    };
	    /**
	     * Number of seconds BrowserFS has been running.
	     * @return [Number]
	     */
	    Process.prototype.uptime = function () {
	        return ((Date.now() - this.startTime) / 1000) | 0;
	    };
	    Process.prototype.nextTick = function (fun) {
	        var args = [];
	        for (var _i = 1; _i < arguments.length; _i++) {
	            args[_i - 1] = arguments[_i];
	        }
	        this._queue.push(new Item(fun, args));
	    };
	    Process.prototype.abort = function () {
	        this.emit('abort');
	    };
	    Process.prototype.exit = function (code) {
	        this.exitCode = code;
	        this.emit('exit', [code]);
	    };
	    Process.prototype.getgid = function () {
	        return this._gid;
	    };
	    Process.prototype.setgid = function (gid) {
	        if (typeof gid === 'number') {
	            this._gid = gid;
	        }
	        else {
	            this._gid = 1;
	        }
	    };
	    Process.prototype.getuid = function () {
	        return this._uid;
	    };
	    Process.prototype.setuid = function (uid) {
	        if (typeof uid === 'number') {
	            this._uid = uid;
	        }
	        else {
	            this._uid = 1;
	        }
	    };
	    Process.prototype.kill = function (pid, signal) {
	        this.emit('kill', [pid, signal]);
	    };
	    Process.prototype.memoryUsage = function () {
	        return { rss: 0, heapTotal: 0, heapUsed: 0 };
	    };
	    Process.prototype.umask = function (mask) {
	        if (mask === void 0) { mask = this._mask; }
	        var oldMask = this._mask;
	        this._mask = mask;
	        this.emit('umask', [mask]);
	        return oldMask;
	    };
	    Process.prototype.hrtime = function () {
	        var timeinfo;
	        if (typeof performance !== 'undefined') {
	            timeinfo = performance.now();
	        }
	        else if (Date['now']) {
	            timeinfo = Date.now();
	        }
	        else {
	            timeinfo = (new Date()).getTime();
	        }
	        var secs = (timeinfo / 1000) | 0;
	        timeinfo -= secs * 1000;
	        timeinfo = (timeinfo * 1000000) | 0;
	        return [secs, timeinfo];
	    };
	    /**
	     * [BFS only] Initialize the TTY devices.
	     */
	    Process.prototype.initializeTTYs = function () {
	        // Guard against multiple invocations.
	        if (this.stdout === null) {
	            var TTY = __webpack_require__(10);
	            this.stdout = new TTY();
	            this.stderr = new TTY();
	            this.stdin = new TTY();
	        }
	    };
	    /**
	     * Worker-only function; irrelevant here.
	     */
	    Process.prototype.disconnect = function () {
	    };
	    return Process;
	}(events.EventEmitter));
	module.exports = Process;
	
	/* WEBPACK VAR INJECTION */}.call(exports, "/"))

/***/ },
/* 8 */
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	function EventEmitter() {
	  this._events = this._events || {};
	  this._maxListeners = this._maxListeners || undefined;
	}
	module.exports = EventEmitter;
	
	// Backwards-compat with node 0.10.x
	EventEmitter.EventEmitter = EventEmitter;
	
	EventEmitter.prototype._events = undefined;
	EventEmitter.prototype._maxListeners = undefined;
	
	// By default EventEmitters will print a warning if more than 10 listeners are
	// added to it. This is a useful default which helps finding memory leaks.
	EventEmitter.defaultMaxListeners = 10;
	
	// Obviously not all Emitters should be limited to 10. This function allows
	// that to be increased. Set to zero for unlimited.
	EventEmitter.prototype.setMaxListeners = function(n) {
	  if (!isNumber(n) || n < 0 || isNaN(n))
	    throw TypeError('n must be a positive number');
	  this._maxListeners = n;
	  return this;
	};
	
	EventEmitter.prototype.emit = function(type) {
	  var er, handler, len, args, i, listeners;
	
	  if (!this._events)
	    this._events = {};
	
	  // If there is no 'error' event listener then throw.
	  if (type === 'error') {
	    if (!this._events.error ||
	        (isObject(this._events.error) && !this._events.error.length)) {
	      er = arguments[1];
	      if (er instanceof Error) {
	        throw er; // Unhandled 'error' event
	      } else {
	        // At least give some kind of context to the user
	        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
	        err.context = er;
	        throw err;
	      }
	    }
	  }
	
	  handler = this._events[type];
	
	  if (isUndefined(handler))
	    return false;
	
	  if (isFunction(handler)) {
	    switch (arguments.length) {
	      // fast cases
	      case 1:
	        handler.call(this);
	        break;
	      case 2:
	        handler.call(this, arguments[1]);
	        break;
	      case 3:
	        handler.call(this, arguments[1], arguments[2]);
	        break;
	      // slower
	      default:
	        args = Array.prototype.slice.call(arguments, 1);
	        handler.apply(this, args);
	    }
	  } else if (isObject(handler)) {
	    args = Array.prototype.slice.call(arguments, 1);
	    listeners = handler.slice();
	    len = listeners.length;
	    for (i = 0; i < len; i++)
	      listeners[i].apply(this, args);
	  }
	
	  return true;
	};
	
	EventEmitter.prototype.addListener = function(type, listener) {
	  var m;
	
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  if (!this._events)
	    this._events = {};
	
	  // To avoid recursion in the case that type === "newListener"! Before
	  // adding it to the listeners, first emit "newListener".
	  if (this._events.newListener)
	    this.emit('newListener', type,
	              isFunction(listener.listener) ?
	              listener.listener : listener);
	
	  if (!this._events[type])
	    // Optimize the case of one listener. Don't need the extra array object.
	    this._events[type] = listener;
	  else if (isObject(this._events[type]))
	    // If we've already got an array, just append.
	    this._events[type].push(listener);
	  else
	    // Adding the second element, need to change to array.
	    this._events[type] = [this._events[type], listener];
	
	  // Check for listener leak
	  if (isObject(this._events[type]) && !this._events[type].warned) {
	    if (!isUndefined(this._maxListeners)) {
	      m = this._maxListeners;
	    } else {
	      m = EventEmitter.defaultMaxListeners;
	    }
	
	    if (m && m > 0 && this._events[type].length > m) {
	      this._events[type].warned = true;
	      console.error('(node) warning: possible EventEmitter memory ' +
	                    'leak detected. %d listeners added. ' +
	                    'Use emitter.setMaxListeners() to increase limit.',
	                    this._events[type].length);
	      if (typeof console.trace === 'function') {
	        // not supported in IE 10
	        console.trace();
	      }
	    }
	  }
	
	  return this;
	};
	
	EventEmitter.prototype.on = EventEmitter.prototype.addListener;
	
	EventEmitter.prototype.once = function(type, listener) {
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  var fired = false;
	
	  function g() {
	    this.removeListener(type, g);
	
	    if (!fired) {
	      fired = true;
	      listener.apply(this, arguments);
	    }
	  }
	
	  g.listener = listener;
	  this.on(type, g);
	
	  return this;
	};
	
	// emits a 'removeListener' event iff the listener was removed
	EventEmitter.prototype.removeListener = function(type, listener) {
	  var list, position, length, i;
	
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  if (!this._events || !this._events[type])
	    return this;
	
	  list = this._events[type];
	  length = list.length;
	  position = -1;
	
	  if (list === listener ||
	      (isFunction(list.listener) && list.listener === listener)) {
	    delete this._events[type];
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	
	  } else if (isObject(list)) {
	    for (i = length; i-- > 0;) {
	      if (list[i] === listener ||
	          (list[i].listener && list[i].listener === listener)) {
	        position = i;
	        break;
	      }
	    }
	
	    if (position < 0)
	      return this;
	
	    if (list.length === 1) {
	      list.length = 0;
	      delete this._events[type];
	    } else {
	      list.splice(position, 1);
	    }
	
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	  }
	
	  return this;
	};
	
	EventEmitter.prototype.removeAllListeners = function(type) {
	  var key, listeners;
	
	  if (!this._events)
	    return this;
	
	  // not listening for removeListener, no need to emit
	  if (!this._events.removeListener) {
	    if (arguments.length === 0)
	      this._events = {};
	    else if (this._events[type])
	      delete this._events[type];
	    return this;
	  }
	
	  // emit removeListener for all listeners on all events
	  if (arguments.length === 0) {
	    for (key in this._events) {
	      if (key === 'removeListener') continue;
	      this.removeAllListeners(key);
	    }
	    this.removeAllListeners('removeListener');
	    this._events = {};
	    return this;
	  }
	
	  listeners = this._events[type];
	
	  if (isFunction(listeners)) {
	    this.removeListener(type, listeners);
	  } else if (listeners) {
	    // LIFO order
	    while (listeners.length)
	      this.removeListener(type, listeners[listeners.length - 1]);
	  }
	  delete this._events[type];
	
	  return this;
	};
	
	EventEmitter.prototype.listeners = function(type) {
	  var ret;
	  if (!this._events || !this._events[type])
	    ret = [];
	  else if (isFunction(this._events[type]))
	    ret = [this._events[type]];
	  else
	    ret = this._events[type].slice();
	  return ret;
	};
	
	EventEmitter.prototype.listenerCount = function(type) {
	  if (this._events) {
	    var evlistener = this._events[type];
	
	    if (isFunction(evlistener))
	      return 1;
	    else if (evlistener)
	      return evlistener.length;
	  }
	  return 0;
	};
	
	EventEmitter.listenerCount = function(emitter, type) {
	  return emitter.listenerCount(type);
	};
	
	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	
	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	
	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	
	function isUndefined(arg) {
	  return arg === void 0;
	}


/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {"use strict";
	// Split a filename into [root, dir, basename, ext], unix version
	// 'root' is just a slash, or nothing.
	var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
	function posixSplitPath(filename) {
	    var out = splitPathRe.exec(filename);
	    out.shift();
	    return out;
	}
	/**
	 * Emulates Node's `path` module. This module contains utilities for handling and
	 * transforming file paths. **All** of these methods perform only string
	 * transformations. The file system is not consulted to check whether paths are
	 * valid.
	 * @see http://nodejs.org/api/path.html
	 * @class
	 */
	var path = (function () {
	    function path() {
	    }
	    /**
	     * Normalize a string path, taking care of '..' and '.' parts.
	     *
	     * When multiple slashes are found, they're replaced by a single one; when the path contains a trailing slash, it is preserved. On Windows backslashes are used.
	     * @example Usage example
	     *   path.normalize('/foo/bar//baz/asdf/quux/..')
	     *   // returns
	     *   '/foo/bar/baz/asdf'
	     * @param [String] p The path to normalize.
	     * @return [String]
	     */
	    path.normalize = function (p) {
	        // Special case: '' -> '.'
	        if (p === '') {
	            p = '.';
	        }
	        // It's very important to know if the path is relative or not, since it
	        // changes how we process .. and reconstruct the split string.
	        var absolute = p.charAt(0) === path.sep;
	        // Remove repeated //s
	        p = path._removeDuplicateSeps(p);
	        // Try to remove as many '../' as possible, and remove '.' completely.
	        var components = p.split(path.sep);
	        var goodComponents = [];
	        for (var idx = 0; idx < components.length; idx++) {
	            var c = components[idx];
	            if (c === '.') {
	                continue;
	            }
	            else if (c === '..' && (absolute || (!absolute && goodComponents.length > 0 && goodComponents[0] !== '..'))) {
	                // In the absolute case: Path is relative to root, so we may pop even if
	                // goodComponents is empty (e.g. /../ => /)
	                // In the relative case: We're getting rid of a directory that preceded
	                // it (e.g. /foo/../bar -> /bar)
	                goodComponents.pop();
	            }
	            else {
	                goodComponents.push(c);
	            }
	        }
	        // Add in '.' when it's a relative path with no other nonempty components.
	        // Possible results: '.' and './' (input: [''] or [])
	        // @todo Can probably simplify this logic.
	        if (!absolute && goodComponents.length < 2) {
	            switch (goodComponents.length) {
	                case 1:
	                    if (goodComponents[0] === '') {
	                        goodComponents.unshift('.');
	                    }
	                    break;
	                default:
	                    goodComponents.push('.');
	            }
	        }
	        p = goodComponents.join(path.sep);
	        if (absolute && p.charAt(0) !== path.sep) {
	            p = path.sep + p;
	        }
	        return p;
	    };
	    /**
	     * Join all arguments together and normalize the resulting path.
	     *
	     * Arguments must be strings.
	     * @example Usage
	     *   path.join('/foo', 'bar', 'baz/asdf', 'quux', '..')
	     *   // returns
	     *   '/foo/bar/baz/asdf'
	     *
	     *   path.join('foo', {}, 'bar')
	     *   // throws exception
	     *   TypeError: Arguments to path.join must be strings
	     * @param [String,...] paths Each component of the path
	     * @return [String]
	     */
	    path.join = function () {
	        var paths = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            paths[_i - 0] = arguments[_i];
	        }
	        // Required: Prune any non-strings from the path. I also prune empty segments
	        // so we can do a simple join of the array.
	        var processed = [];
	        for (var i = 0; i < paths.length; i++) {
	            var segment = paths[i];
	            if (typeof segment !== 'string') {
	                throw new TypeError("Invalid argument type to path.join: " + (typeof segment));
	            }
	            else if (segment !== '') {
	                processed.push(segment);
	            }
	        }
	        return path.normalize(processed.join(path.sep));
	    };
	    /**
	     * Resolves to to an absolute path.
	     *
	     * If to isn't already absolute from arguments are prepended in right to left
	     * order, until an absolute path is found. If after using all from paths still
	     * no absolute path is found, the current working directory is used as well.
	     * The resulting path is normalized, and trailing slashes are removed unless
	     * the path gets resolved to the root directory. Non-string arguments are
	     * ignored.
	     *
	     * Another way to think of it is as a sequence of cd commands in a shell.
	     *
	     *     path.resolve('foo/bar', '/tmp/file/', '..', 'a/../subfile')
	     *
	     * Is similar to:
	     *
	     *     cd foo/bar
	     *     cd /tmp/file/
	     *     cd ..
	     *     cd a/../subfile
	     *     pwd
	     *
	     * The difference is that the different paths don't need to exist and may also
	     * be files.
	     * @example Usage example
	     *   path.resolve('/foo/bar', './baz')
	     *   // returns
	     *   '/foo/bar/baz'
	     *
	     *   path.resolve('/foo/bar', '/tmp/file/')
	     *   // returns
	     *   '/tmp/file'
	     *
	     *   path.resolve('wwwroot', 'static_files/png/', '../gif/image.gif')
	     *   // if currently in /home/myself/node, it returns
	     *   '/home/myself/node/wwwroot/static_files/gif/image.gif'
	     * @param [String,...] paths
	     * @return [String]
	     */
	    path.resolve = function () {
	        var paths = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            paths[_i - 0] = arguments[_i];
	        }
	        // Monitor for invalid paths, throw out empty paths, and look for the *last*
	        // absolute path that we see.
	        var processed = [];
	        for (var i = 0; i < paths.length; i++) {
	            var p = paths[i];
	            if (typeof p !== 'string') {
	                throw new TypeError("Invalid argument type to path.join: " + (typeof p));
	            }
	            else if (p !== '') {
	                // Remove anything that has occurred before this absolute path, as it
	                // doesn't matter.
	                if (p.charAt(0) === path.sep) {
	                    processed = [];
	                }
	                processed.push(p);
	            }
	        }
	        // Special: Remove trailing slash unless it's the root
	        var resolved = path.normalize(processed.join(path.sep));
	        if (resolved.length > 1 && resolved.charAt(resolved.length - 1) === path.sep) {
	            return resolved.substr(0, resolved.length - 1);
	        }
	        // Special: If it doesn't start with '/', it's relative and we need to append
	        // the current directory.
	        if (resolved.charAt(0) !== path.sep) {
	            // Remove ./, since we're going to append the current directory.
	            if (resolved.charAt(0) === '.' && (resolved.length === 1 || resolved.charAt(1) === path.sep)) {
	                resolved = resolved.length === 1 ? '' : resolved.substr(2);
	            }
	            // Append the current directory, which *must* be an absolute path.
	            var cwd = process.cwd();
	            if (resolved !== '') {
	                // cwd will never end in a /... unless it's the root.
	                resolved = this.normalize(cwd + (cwd !== '/' ? path.sep : '') + resolved);
	            }
	            else {
	                resolved = cwd;
	            }
	        }
	        return resolved;
	    };
	    /**
	     * Solve the relative path from from to to.
	     *
	     * At times we have two absolute paths, and we need to derive the relative path
	     * from one to the other. This is actually the reverse transform of
	     * path.resolve, which means we see that:
	     *
	     *    path.resolve(from, path.relative(from, to)) == path.resolve(to)
	     *
	     * @example Usage example
	     *   path.relative('C:\\orandea\\test\\aaa', 'C:\\orandea\\impl\\bbb')
	     *   // returns
	     *   '..\\..\\impl\\bbb'
	     *
	     *   path.relative('/data/orandea/test/aaa', '/data/orandea/impl/bbb')
	     *   // returns
	     *   '../../impl/bbb'
	     * @param [String] from
	     * @param [String] to
	     * @return [String]
	     */
	    path.relative = function (from, to) {
	        var i;
	        // Alright. Let's resolve these two to absolute paths and remove any
	        // weirdness.
	        from = path.resolve(from);
	        to = path.resolve(to);
	        var fromSegs = from.split(path.sep);
	        var toSegs = to.split(path.sep);
	        // Remove the first segment on both, as it's '' (both are absolute paths)
	        toSegs.shift();
	        fromSegs.shift();
	        // There are two segments to this path:
	        // * Going *up* the directory hierarchy with '..'
	        // * Going *down* the directory hierarchy with foo/baz/bat.
	        var upCount = 0;
	        var downSegs = [];
	        // Figure out how many things in 'from' are shared with 'to'.
	        for (i = 0; i < fromSegs.length; i++) {
	            var seg = fromSegs[i];
	            if (seg === toSegs[i]) {
	                continue;
	            }
	            // The rest of 'from', including the current element, indicates how many
	            // directories we need to go up.
	            upCount = fromSegs.length - i;
	            break;
	        }
	        // The rest of 'to' indicates where we need to change to. We place this
	        // outside of the loop, as toSegs.length may be greater than fromSegs.length.
	        downSegs = toSegs.slice(i);
	        // Special case: If 'from' is '/'
	        if (fromSegs.length === 1 && fromSegs[0] === '') {
	            upCount = 0;
	        }
	        // upCount can't be greater than the number of fromSegs
	        // (cd .. from / is still /)
	        if (upCount > fromSegs.length) {
	            upCount = fromSegs.length;
	        }
	        // Create the final string!
	        var rv = '';
	        for (i = 0; i < upCount; i++) {
	            rv += '../';
	        }
	        rv += downSegs.join(path.sep);
	        // Special case: Remove trailing '/'. Happens if it's all up and no down.
	        if (rv.length > 1 && rv.charAt(rv.length - 1) === path.sep) {
	            rv = rv.substr(0, rv.length - 1);
	        }
	        return rv;
	    };
	    /**
	     * Return the directory name of a path. Similar to the Unix `dirname` command.
	     *
	     * Note that BrowserFS does not validate if the path is actually a valid
	     * directory.
	     * @example Usage example
	     *   path.dirname('/foo/bar/baz/asdf/quux')
	     *   // returns
	     *   '/foo/bar/baz/asdf'
	     * @param [String] p The path to get the directory name of.
	     * @return [String]
	     */
	    path.dirname = function (p) {
	        // We get rid of //, but we don't modify anything else (e.g. any extraneous .
	        // and ../ are kept intact)
	        p = path._removeDuplicateSeps(p);
	        var absolute = p.charAt(0) === path.sep;
	        var sections = p.split(path.sep);
	        // Do 1 if it's /foo/bar, 2 if it's /foo/bar/
	        if (sections.pop() === '' && sections.length > 0) {
	            sections.pop();
	        }
	        // # of sections needs to be > 1 if absolute, since the first section is '' for '/'.
	        // If not absolute, the first section is the first part of the path, and is OK
	        // to return.
	        if (sections.length > 1 || (sections.length === 1 && !absolute)) {
	            return sections.join(path.sep);
	        }
	        else if (absolute) {
	            return path.sep;
	        }
	        else {
	            return '.';
	        }
	    };
	    /**
	     * Return the last portion of a path. Similar to the Unix basename command.
	     * @example Usage example
	     *   path.basename('/foo/bar/baz/asdf/quux.html')
	     *   // returns
	     *   'quux.html'
	     *
	     *   path.basename('/foo/bar/baz/asdf/quux.html', '.html')
	     *   // returns
	     *   'quux'
	     * @param [String] p
	     * @param [String?] ext
	     * @return [String]
	     */
	    path.basename = function (p, ext) {
	        if (ext === void 0) { ext = ""; }
	        // Special case: Normalize will modify this to '.'
	        if (p === '') {
	            return p;
	        }
	        // Normalize the string first to remove any weirdness.
	        p = path.normalize(p);
	        // Get the last part of the string.
	        var sections = p.split(path.sep);
	        var lastPart = sections[sections.length - 1];
	        // Special case: If it's empty, then we have a string like so: foo/
	        // Meaning, 'foo' is guaranteed to be a directory.
	        if (lastPart === '' && sections.length > 1) {
	            return sections[sections.length - 2];
	        }
	        // Remove the extension, if need be.
	        if (ext.length > 0) {
	            var lastPartExt = lastPart.substr(lastPart.length - ext.length);
	            if (lastPartExt === ext) {
	                return lastPart.substr(0, lastPart.length - ext.length);
	            }
	        }
	        return lastPart;
	    };
	    /**
	     * Return the extension of the path, from the last '.' to end of string in the
	     * last portion of the path. If there is no '.' in the last portion of the path
	     * or the first character of it is '.', then it returns an empty string.
	     * @example Usage example
	     *   path.extname('index.html')
	     *   // returns
	     *   '.html'
	     *
	     *   path.extname('index.')
	     *   // returns
	     *   '.'
	     *
	     *   path.extname('index')
	     *   // returns
	     *   ''
	     * @param [String] p
	     * @return [String]
	     */
	    path.extname = function (p) {
	        p = path.normalize(p);
	        var sections = p.split(path.sep);
	        p = sections.pop();
	        // Special case: foo/file.ext/ should return '.ext'
	        if (p === '' && sections.length > 0) {
	            p = sections.pop();
	        }
	        if (p === '..') {
	            return '';
	        }
	        var i = p.lastIndexOf('.');
	        if (i === -1 || i === 0) {
	            return '';
	        }
	        return p.substr(i);
	    };
	    /**
	     * Checks if the given path is an absolute path.
	     *
	     * Despite not being documented, this is a tested part of Node's path API.
	     * @param [String] p
	     * @return [Boolean] True if the path appears to be an absolute path.
	     */
	    path.isAbsolute = function (p) {
	        return p.length > 0 && p.charAt(0) === path.sep;
	    };
	    /**
	     * Unknown. Undocumented.
	     */
	    path._makeLong = function (p) {
	        return p;
	    };
	    /**
	     * Returns an object from a path string.
	     */
	    path.parse = function (p) {
	        var allParts = posixSplitPath(p);
	        return {
	            root: allParts[0],
	            dir: allParts[0] + allParts[1].slice(0, -1),
	            base: allParts[2],
	            ext: allParts[3],
	            name: allParts[2].slice(0, allParts[2].length - allParts[3].length)
	        };
	    };
	    path.format = function (pathObject) {
	        if (pathObject === null || typeof pathObject !== 'object') {
	            throw new TypeError("Parameter 'pathObject' must be an object, not " + typeof pathObject);
	        }
	        var root = pathObject.root || '';
	        if (typeof root !== 'string') {
	            throw new TypeError("'pathObject.root' must be a string or undefined, not " +
	                typeof pathObject.root);
	        }
	        var dir = pathObject.dir ? pathObject.dir + path.sep : '';
	        var base = pathObject.base || '';
	        return dir + base;
	    };
	    path._removeDuplicateSeps = function (p) {
	        p = p.replace(this._replaceRegex, this.sep);
	        return p;
	    };
	    // The platform-specific file separator. BrowserFS uses `/`.
	    path.sep = '/';
	    path._replaceRegex = new RegExp("//+", 'g');
	    // The platform-specific path delimiter. BrowserFS uses `:`.
	    path.delimiter = ':';
	    path.posix = path;
	    // XXX: Typing hack. We don't actually support win32.
	    path.win32 = path;
	    return path;
	}());
	var _ = path;
	module.exports = path;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)))

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var stream = __webpack_require__(11);
	var TTY = (function (_super) {
	    __extends(TTY, _super);
	    function TTY() {
	        _super.call(this);
	        this.isRaw = false;
	        this.columns = 80;
	        this.rows = 120;
	        this.isTTY = true;
	        this._bufferedWrites = [];
	        this._waitingForWrites = false;
	    }
	    /**
	     * Toggle raw mode.
	     */
	    TTY.prototype.setRawMode = function (mode) {
	        if (this.isRaw !== mode) {
	            this.isRaw = mode;
	            // [BFS] TTY implementations can use this to change their event emitting
	            //       patterns.
	            this.emit('modeChange');
	        }
	    };
	    /**
	     * [BFS] Update the number of columns available on the terminal.
	     */
	    TTY.prototype.changeColumns = function (columns) {
	        if (columns !== this.columns) {
	            this.columns = columns;
	            // Resize event.
	            this.emit('resize');
	        }
	    };
	    /**
	     * [BFS] Update the number of rows available on the terminal.
	     */
	    TTY.prototype.changeRows = function (rows) {
	        if (rows !== this.rows) {
	            this.rows = rows;
	            // Resize event.
	            this.emit('resize');
	        }
	    };
	    /**
	     * Returns 'true' if the given object is a TTY.
	     */
	    TTY.isatty = function (fd) {
	        return fd && fd instanceof TTY;
	    };
	    TTY.prototype._write = function (chunk, encoding, cb) {
	        var error;
	        try {
	            var data;
	            if (typeof (chunk) === 'string') {
	                data = new Buffer(chunk, encoding);
	            }
	            else {
	                data = chunk;
	            }
	            this._bufferedWrites.push(data);
	            if (this._waitingForWrites) {
	                this._read(1024);
	            }
	        }
	        catch (e) {
	            error = e;
	        }
	        finally {
	            cb(error);
	        }
	    };
	    TTY.prototype._read = function (size) {
	        // Size is advisory -- we can ignore it.
	        if (this._bufferedWrites.length === 0) {
	            this._waitingForWrites = true;
	        }
	        else {
	            while (this._bufferedWrites.length > 0) {
	                this._waitingForWrites = this.push(this._bufferedWrites.shift());
	                if (!this._waitingForWrites) {
	                    break;
	                }
	            }
	        }
	    };
	    return TTY;
	}(stream.Duplex));
	module.exports = TTY;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	module.exports = Stream;
	
	var EE = __webpack_require__(8).EventEmitter;
	var inherits = __webpack_require__(12);
	
	inherits(Stream, EE);
	Stream.Readable = __webpack_require__(13);
	Stream.Writable = __webpack_require__(27);
	Stream.Duplex = __webpack_require__(28);
	Stream.Transform = __webpack_require__(29);
	Stream.PassThrough = __webpack_require__(30);
	
	// Backwards-compat with node 0.4.x
	Stream.Stream = Stream;
	
	
	
	// old-style streams.  Note that the pipe method (the only relevant
	// part of this class) is overridden in the Readable class.
	
	function Stream() {
	  EE.call(this);
	}
	
	Stream.prototype.pipe = function(dest, options) {
	  var source = this;
	
	  function ondata(chunk) {
	    if (dest.writable) {
	      if (false === dest.write(chunk) && source.pause) {
	        source.pause();
	      }
	    }
	  }
	
	  source.on('data', ondata);
	
	  function ondrain() {
	    if (source.readable && source.resume) {
	      source.resume();
	    }
	  }
	
	  dest.on('drain', ondrain);
	
	  // If the 'end' option is not supplied, dest.end() will be called when
	  // source gets the 'end' or 'close' events.  Only dest.end() once.
	  if (!dest._isStdio && (!options || options.end !== false)) {
	    source.on('end', onend);
	    source.on('close', onclose);
	  }
	
	  var didOnEnd = false;
	  function onend() {
	    if (didOnEnd) return;
	    didOnEnd = true;
	
	    dest.end();
	  }
	
	
	  function onclose() {
	    if (didOnEnd) return;
	    didOnEnd = true;
	
	    if (typeof dest.destroy === 'function') dest.destroy();
	  }
	
	  // don't leave dangling pipes when there are errors.
	  function onerror(er) {
	    cleanup();
	    if (EE.listenerCount(this, 'error') === 0) {
	      throw er; // Unhandled stream error in pipe.
	    }
	  }
	
	  source.on('error', onerror);
	  dest.on('error', onerror);
	
	  // remove all the event listeners that were added.
	  function cleanup() {
	    source.removeListener('data', ondata);
	    dest.removeListener('drain', ondrain);
	
	    source.removeListener('end', onend);
	    source.removeListener('close', onclose);
	
	    source.removeListener('error', onerror);
	    dest.removeListener('error', onerror);
	
	    source.removeListener('end', cleanup);
	    source.removeListener('close', cleanup);
	
	    dest.removeListener('close', cleanup);
	  }
	
	  source.on('end', cleanup);
	  source.on('close', cleanup);
	
	  dest.on('close', cleanup);
	
	  dest.emit('pipe', source);
	
	  // Allow for unix-like usage: A.pipe(B).pipe(C)
	  return dest;
	};


/***/ },
/* 12 */
/***/ function(module, exports) {

	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    var TempCtor = function () {}
	    TempCtor.prototype = superCtor.prototype
	    ctor.prototype = new TempCtor()
	    ctor.prototype.constructor = ctor
	  }
	}


/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {var Stream = (function (){
	  try {
	    return __webpack_require__(11); // hack to fix a circular dependency issue when used with browserify
	  } catch(_){}
	}());
	exports = module.exports = __webpack_require__(14);
	exports.Stream = Stream || exports;
	exports.Readable = exports;
	exports.Writable = __webpack_require__(22);
	exports.Duplex = __webpack_require__(21);
	exports.Transform = __webpack_require__(25);
	exports.PassThrough = __webpack_require__(26);
	
	if (!process.browser && process.env.READABLE_STREAM === 'disable' && Stream) {
	  module.exports = Stream;
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)))

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	module.exports = Readable;
	
	/*<replacement>*/
	var processNextTick = __webpack_require__(15);
	/*</replacement>*/
	
	/*<replacement>*/
	var isArray = __webpack_require__(16);
	/*</replacement>*/
	
	/*<replacement>*/
	var Duplex;
	/*</replacement>*/
	
	Readable.ReadableState = ReadableState;
	
	/*<replacement>*/
	var EE = __webpack_require__(8).EventEmitter;
	
	var EElistenerCount = function (emitter, type) {
	  return emitter.listeners(type).length;
	};
	/*</replacement>*/
	
	/*<replacement>*/
	var Stream;
	(function () {
	  try {
	    Stream = __webpack_require__(11);
	  } catch (_) {} finally {
	    if (!Stream) Stream = __webpack_require__(8).EventEmitter;
	  }
	})();
	/*</replacement>*/
	
	var Buffer = __webpack_require__(2).Buffer;
	/*<replacement>*/
	var bufferShim = __webpack_require__(17);
	/*</replacement>*/
	
	/*<replacement>*/
	var util = __webpack_require__(18);
	util.inherits = __webpack_require__(12);
	/*</replacement>*/
	
	/*<replacement>*/
	var debugUtil = __webpack_require__(19);
	var debug = void 0;
	if (debugUtil && debugUtil.debuglog) {
	  debug = debugUtil.debuglog('stream');
	} else {
	  debug = function () {};
	}
	/*</replacement>*/
	
	var BufferList = __webpack_require__(20);
	var StringDecoder;
	
	util.inherits(Readable, Stream);
	
	function prependListener(emitter, event, fn) {
	  // Sadly this is not cacheable as some libraries bundle their own
	  // event emitter implementation with them.
	  if (typeof emitter.prependListener === 'function') {
	    return emitter.prependListener(event, fn);
	  } else {
	    // This is a hack to make sure that our error handler is attached before any
	    // userland ones.  NEVER DO THIS. This is here only because this code needs
	    // to continue to work with older versions of Node.js that do not include
	    // the prependListener() method. The goal is to eventually remove this hack.
	    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
	  }
	}
	
	function ReadableState(options, stream) {
	  Duplex = Duplex || __webpack_require__(21);
	
	  options = options || {};
	
	  // object stream flag. Used to make read(n) ignore n and to
	  // make all the buffer merging and length checks go away
	  this.objectMode = !!options.objectMode;
	
	  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
	
	  // the point at which it stops calling _read() to fill the buffer
	  // Note: 0 is a valid value, means "don't call _read preemptively ever"
	  var hwm = options.highWaterMark;
	  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
	  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
	
	  // cast to ints.
	  this.highWaterMark = ~~this.highWaterMark;
	
	  // A linked list is used to store data chunks instead of an array because the
	  // linked list can remove elements from the beginning faster than
	  // array.shift()
	  this.buffer = new BufferList();
	  this.length = 0;
	  this.pipes = null;
	  this.pipesCount = 0;
	  this.flowing = null;
	  this.ended = false;
	  this.endEmitted = false;
	  this.reading = false;
	
	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, because any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;
	
	  // whenever we return null, then we set a flag to say
	  // that we're awaiting a 'readable' event emission.
	  this.needReadable = false;
	  this.emittedReadable = false;
	  this.readableListening = false;
	  this.resumeScheduled = false;
	
	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';
	
	  // when piping, we only care about 'readable' events that happen
	  // after read()ing all the bytes and not getting any pushback.
	  this.ranOut = false;
	
	  // the number of writers that are awaiting a drain event in .pipe()s
	  this.awaitDrain = 0;
	
	  // if true, a maybeReadMore has been scheduled
	  this.readingMore = false;
	
	  this.decoder = null;
	  this.encoding = null;
	  if (options.encoding) {
	    if (!StringDecoder) StringDecoder = __webpack_require__(24).StringDecoder;
	    this.decoder = new StringDecoder(options.encoding);
	    this.encoding = options.encoding;
	  }
	}
	
	function Readable(options) {
	  Duplex = Duplex || __webpack_require__(21);
	
	  if (!(this instanceof Readable)) return new Readable(options);
	
	  this._readableState = new ReadableState(options, this);
	
	  // legacy
	  this.readable = true;
	
	  if (options && typeof options.read === 'function') this._read = options.read;
	
	  Stream.call(this);
	}
	
	// Manually shove something into the read() buffer.
	// This returns true if the highWaterMark has not been hit yet,
	// similar to how Writable.write() returns true if you should
	// write() some more.
	Readable.prototype.push = function (chunk, encoding) {
	  var state = this._readableState;
	
	  if (!state.objectMode && typeof chunk === 'string') {
	    encoding = encoding || state.defaultEncoding;
	    if (encoding !== state.encoding) {
	      chunk = bufferShim.from(chunk, encoding);
	      encoding = '';
	    }
	  }
	
	  return readableAddChunk(this, state, chunk, encoding, false);
	};
	
	// Unshift should *always* be something directly out of read()
	Readable.prototype.unshift = function (chunk) {
	  var state = this._readableState;
	  return readableAddChunk(this, state, chunk, '', true);
	};
	
	Readable.prototype.isPaused = function () {
	  return this._readableState.flowing === false;
	};
	
	function readableAddChunk(stream, state, chunk, encoding, addToFront) {
	  var er = chunkInvalid(state, chunk);
	  if (er) {
	    stream.emit('error', er);
	  } else if (chunk === null) {
	    state.reading = false;
	    onEofChunk(stream, state);
	  } else if (state.objectMode || chunk && chunk.length > 0) {
	    if (state.ended && !addToFront) {
	      var e = new Error('stream.push() after EOF');
	      stream.emit('error', e);
	    } else if (state.endEmitted && addToFront) {
	      var _e = new Error('stream.unshift() after end event');
	      stream.emit('error', _e);
	    } else {
	      var skipAdd;
	      if (state.decoder && !addToFront && !encoding) {
	        chunk = state.decoder.write(chunk);
	        skipAdd = !state.objectMode && chunk.length === 0;
	      }
	
	      if (!addToFront) state.reading = false;
	
	      // Don't add to the buffer if we've decoded to an empty string chunk and
	      // we're not in object mode
	      if (!skipAdd) {
	        // if we want the data now, just emit it.
	        if (state.flowing && state.length === 0 && !state.sync) {
	          stream.emit('data', chunk);
	          stream.read(0);
	        } else {
	          // update the buffer info.
	          state.length += state.objectMode ? 1 : chunk.length;
	          if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
	
	          if (state.needReadable) emitReadable(stream);
	        }
	      }
	
	      maybeReadMore(stream, state);
	    }
	  } else if (!addToFront) {
	    state.reading = false;
	  }
	
	  return needMoreData(state);
	}
	
	// if it's past the high water mark, we can push in some more.
	// Also, if we have no data yet, we can stand some
	// more bytes.  This is to work around cases where hwm=0,
	// such as the repl.  Also, if the push() triggered a
	// readable event, and the user called read(largeNumber) such that
	// needReadable was set, then we ought to push more, so that another
	// 'readable' event will be triggered.
	function needMoreData(state) {
	  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
	}
	
	// backwards compatibility.
	Readable.prototype.setEncoding = function (enc) {
	  if (!StringDecoder) StringDecoder = __webpack_require__(24).StringDecoder;
	  this._readableState.decoder = new StringDecoder(enc);
	  this._readableState.encoding = enc;
	  return this;
	};
	
	// Don't raise the hwm > 8MB
	var MAX_HWM = 0x800000;
	function computeNewHighWaterMark(n) {
	  if (n >= MAX_HWM) {
	    n = MAX_HWM;
	  } else {
	    // Get the next highest power of 2 to prevent increasing hwm excessively in
	    // tiny amounts
	    n--;
	    n |= n >>> 1;
	    n |= n >>> 2;
	    n |= n >>> 4;
	    n |= n >>> 8;
	    n |= n >>> 16;
	    n++;
	  }
	  return n;
	}
	
	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function howMuchToRead(n, state) {
	  if (n <= 0 || state.length === 0 && state.ended) return 0;
	  if (state.objectMode) return 1;
	  if (n !== n) {
	    // Only flow one buffer at a time
	    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
	  }
	  // If we're asking for more than the current hwm, then raise the hwm.
	  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
	  if (n <= state.length) return n;
	  // Don't have enough
	  if (!state.ended) {
	    state.needReadable = true;
	    return 0;
	  }
	  return state.length;
	}
	
	// you can override either this method, or the async _read(n) below.
	Readable.prototype.read = function (n) {
	  debug('read', n);
	  n = parseInt(n, 10);
	  var state = this._readableState;
	  var nOrig = n;
	
	  if (n !== 0) state.emittedReadable = false;
	
	  // if we're doing read(0) to trigger a readable event, but we
	  // already have a bunch of data in the buffer, then just trigger
	  // the 'readable' event and move on.
	  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
	    debug('read: emitReadable', state.length, state.ended);
	    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
	    return null;
	  }
	
	  n = howMuchToRead(n, state);
	
	  // if we've ended, and we're now clear, then finish it up.
	  if (n === 0 && state.ended) {
	    if (state.length === 0) endReadable(this);
	    return null;
	  }
	
	  // All the actual chunk generation logic needs to be
	  // *below* the call to _read.  The reason is that in certain
	  // synthetic stream cases, such as passthrough streams, _read
	  // may be a completely synchronous operation which may change
	  // the state of the read buffer, providing enough data when
	  // before there was *not* enough.
	  //
	  // So, the steps are:
	  // 1. Figure out what the state of things will be after we do
	  // a read from the buffer.
	  //
	  // 2. If that resulting state will trigger a _read, then call _read.
	  // Note that this may be asynchronous, or synchronous.  Yes, it is
	  // deeply ugly to write APIs this way, but that still doesn't mean
	  // that the Readable class should behave improperly, as streams are
	  // designed to be sync/async agnostic.
	  // Take note if the _read call is sync or async (ie, if the read call
	  // has returned yet), so that we know whether or not it's safe to emit
	  // 'readable' etc.
	  //
	  // 3. Actually pull the requested chunks out of the buffer and return.
	
	  // if we need a readable event, then we need to do some reading.
	  var doRead = state.needReadable;
	  debug('need readable', doRead);
	
	  // if we currently have less than the highWaterMark, then also read some
	  if (state.length === 0 || state.length - n < state.highWaterMark) {
	    doRead = true;
	    debug('length less than watermark', doRead);
	  }
	
	  // however, if we've ended, then there's no point, and if we're already
	  // reading, then it's unnecessary.
	  if (state.ended || state.reading) {
	    doRead = false;
	    debug('reading or ended', doRead);
	  } else if (doRead) {
	    debug('do read');
	    state.reading = true;
	    state.sync = true;
	    // if the length is currently zero, then we *need* a readable event.
	    if (state.length === 0) state.needReadable = true;
	    // call internal read method
	    this._read(state.highWaterMark);
	    state.sync = false;
	    // If _read pushed data synchronously, then `reading` will be false,
	    // and we need to re-evaluate how much data we can return to the user.
	    if (!state.reading) n = howMuchToRead(nOrig, state);
	  }
	
	  var ret;
	  if (n > 0) ret = fromList(n, state);else ret = null;
	
	  if (ret === null) {
	    state.needReadable = true;
	    n = 0;
	  } else {
	    state.length -= n;
	  }
	
	  if (state.length === 0) {
	    // If we have nothing in the buffer, then we want to know
	    // as soon as we *do* get something into the buffer.
	    if (!state.ended) state.needReadable = true;
	
	    // If we tried to read() past the EOF, then emit end on the next tick.
	    if (nOrig !== n && state.ended) endReadable(this);
	  }
	
	  if (ret !== null) this.emit('data', ret);
	
	  return ret;
	};
	
	function chunkInvalid(state, chunk) {
	  var er = null;
	  if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== null && chunk !== undefined && !state.objectMode) {
	    er = new TypeError('Invalid non-string/buffer chunk');
	  }
	  return er;
	}
	
	function onEofChunk(stream, state) {
	  if (state.ended) return;
	  if (state.decoder) {
	    var chunk = state.decoder.end();
	    if (chunk && chunk.length) {
	      state.buffer.push(chunk);
	      state.length += state.objectMode ? 1 : chunk.length;
	    }
	  }
	  state.ended = true;
	
	  // emit 'readable' now to make sure it gets picked up.
	  emitReadable(stream);
	}
	
	// Don't emit readable right away in sync mode, because this can trigger
	// another read() call => stack overflow.  This way, it might trigger
	// a nextTick recursion warning, but that's not so bad.
	function emitReadable(stream) {
	  var state = stream._readableState;
	  state.needReadable = false;
	  if (!state.emittedReadable) {
	    debug('emitReadable', state.flowing);
	    state.emittedReadable = true;
	    if (state.sync) processNextTick(emitReadable_, stream);else emitReadable_(stream);
	  }
	}
	
	function emitReadable_(stream) {
	  debug('emit readable');
	  stream.emit('readable');
	  flow(stream);
	}
	
	// at this point, the user has presumably seen the 'readable' event,
	// and called read() to consume some data.  that may have triggered
	// in turn another _read(n) call, in which case reading = true if
	// it's in progress.
	// However, if we're not ended, or reading, and the length < hwm,
	// then go ahead and try to read some more preemptively.
	function maybeReadMore(stream, state) {
	  if (!state.readingMore) {
	    state.readingMore = true;
	    processNextTick(maybeReadMore_, stream, state);
	  }
	}
	
	function maybeReadMore_(stream, state) {
	  var len = state.length;
	  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
	    debug('maybeReadMore read 0');
	    stream.read(0);
	    if (len === state.length)
	      // didn't get any data, stop spinning.
	      break;else len = state.length;
	  }
	  state.readingMore = false;
	}
	
	// abstract method.  to be overridden in specific implementation classes.
	// call cb(er, data) where data is <= n in length.
	// for virtual (non-string, non-buffer) streams, "length" is somewhat
	// arbitrary, and perhaps not very meaningful.
	Readable.prototype._read = function (n) {
	  this.emit('error', new Error('_read() is not implemented'));
	};
	
	Readable.prototype.pipe = function (dest, pipeOpts) {
	  var src = this;
	  var state = this._readableState;
	
	  switch (state.pipesCount) {
	    case 0:
	      state.pipes = dest;
	      break;
	    case 1:
	      state.pipes = [state.pipes, dest];
	      break;
	    default:
	      state.pipes.push(dest);
	      break;
	  }
	  state.pipesCount += 1;
	  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
	
	  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
	
	  var endFn = doEnd ? onend : cleanup;
	  if (state.endEmitted) processNextTick(endFn);else src.once('end', endFn);
	
	  dest.on('unpipe', onunpipe);
	  function onunpipe(readable) {
	    debug('onunpipe');
	    if (readable === src) {
	      cleanup();
	    }
	  }
	
	  function onend() {
	    debug('onend');
	    dest.end();
	  }
	
	  // when the dest drains, it reduces the awaitDrain counter
	  // on the source.  This would be more elegant with a .once()
	  // handler in flow(), but adding and removing repeatedly is
	  // too slow.
	  var ondrain = pipeOnDrain(src);
	  dest.on('drain', ondrain);
	
	  var cleanedUp = false;
	  function cleanup() {
	    debug('cleanup');
	    // cleanup event handlers once the pipe is broken
	    dest.removeListener('close', onclose);
	    dest.removeListener('finish', onfinish);
	    dest.removeListener('drain', ondrain);
	    dest.removeListener('error', onerror);
	    dest.removeListener('unpipe', onunpipe);
	    src.removeListener('end', onend);
	    src.removeListener('end', cleanup);
	    src.removeListener('data', ondata);
	
	    cleanedUp = true;
	
	    // if the reader is waiting for a drain event from this
	    // specific writer, then it would cause it to never start
	    // flowing again.
	    // So, if this is awaiting a drain, then we just call it now.
	    // If we don't know, then assume that we are waiting for one.
	    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
	  }
	
	  // If the user pushes more data while we're writing to dest then we'll end up
	  // in ondata again. However, we only want to increase awaitDrain once because
	  // dest will only emit one 'drain' event for the multiple writes.
	  // => Introduce a guard on increasing awaitDrain.
	  var increasedAwaitDrain = false;
	  src.on('data', ondata);
	  function ondata(chunk) {
	    debug('ondata');
	    increasedAwaitDrain = false;
	    var ret = dest.write(chunk);
	    if (false === ret && !increasedAwaitDrain) {
	      // If the user unpiped during `dest.write()`, it is possible
	      // to get stuck in a permanently paused state if that write
	      // also returned false.
	      // => Check whether `dest` is still a piping destination.
	      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
	        debug('false write response, pause', src._readableState.awaitDrain);
	        src._readableState.awaitDrain++;
	        increasedAwaitDrain = true;
	      }
	      src.pause();
	    }
	  }
	
	  // if the dest has an error, then stop piping into it.
	  // however, don't suppress the throwing behavior for this.
	  function onerror(er) {
	    debug('onerror', er);
	    unpipe();
	    dest.removeListener('error', onerror);
	    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
	  }
	
	  // Make sure our error handler is attached before userland ones.
	  prependListener(dest, 'error', onerror);
	
	  // Both close and finish should trigger unpipe, but only once.
	  function onclose() {
	    dest.removeListener('finish', onfinish);
	    unpipe();
	  }
	  dest.once('close', onclose);
	  function onfinish() {
	    debug('onfinish');
	    dest.removeListener('close', onclose);
	    unpipe();
	  }
	  dest.once('finish', onfinish);
	
	  function unpipe() {
	    debug('unpipe');
	    src.unpipe(dest);
	  }
	
	  // tell the dest that it's being piped to
	  dest.emit('pipe', src);
	
	  // start the flow if it hasn't been started already.
	  if (!state.flowing) {
	    debug('pipe resume');
	    src.resume();
	  }
	
	  return dest;
	};
	
	function pipeOnDrain(src) {
	  return function () {
	    var state = src._readableState;
	    debug('pipeOnDrain', state.awaitDrain);
	    if (state.awaitDrain) state.awaitDrain--;
	    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
	      state.flowing = true;
	      flow(src);
	    }
	  };
	}
	
	Readable.prototype.unpipe = function (dest) {
	  var state = this._readableState;
	
	  // if we're not piping anywhere, then do nothing.
	  if (state.pipesCount === 0) return this;
	
	  // just one destination.  most common case.
	  if (state.pipesCount === 1) {
	    // passed in one, but it's not the right one.
	    if (dest && dest !== state.pipes) return this;
	
	    if (!dest) dest = state.pipes;
	
	    // got a match.
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;
	    if (dest) dest.emit('unpipe', this);
	    return this;
	  }
	
	  // slow case. multiple pipe destinations.
	
	  if (!dest) {
	    // remove all.
	    var dests = state.pipes;
	    var len = state.pipesCount;
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;
	
	    for (var i = 0; i < len; i++) {
	      dests[i].emit('unpipe', this);
	    }return this;
	  }
	
	  // try to find the right one.
	  var index = indexOf(state.pipes, dest);
	  if (index === -1) return this;
	
	  state.pipes.splice(index, 1);
	  state.pipesCount -= 1;
	  if (state.pipesCount === 1) state.pipes = state.pipes[0];
	
	  dest.emit('unpipe', this);
	
	  return this;
	};
	
	// set up data events if they are asked for
	// Ensure readable listeners eventually get something
	Readable.prototype.on = function (ev, fn) {
	  var res = Stream.prototype.on.call(this, ev, fn);
	
	  if (ev === 'data') {
	    // Start flowing on next tick if stream isn't explicitly paused
	    if (this._readableState.flowing !== false) this.resume();
	  } else if (ev === 'readable') {
	    var state = this._readableState;
	    if (!state.endEmitted && !state.readableListening) {
	      state.readableListening = state.needReadable = true;
	      state.emittedReadable = false;
	      if (!state.reading) {
	        processNextTick(nReadingNextTick, this);
	      } else if (state.length) {
	        emitReadable(this, state);
	      }
	    }
	  }
	
	  return res;
	};
	Readable.prototype.addListener = Readable.prototype.on;
	
	function nReadingNextTick(self) {
	  debug('readable nexttick read 0');
	  self.read(0);
	}
	
	// pause() and resume() are remnants of the legacy readable stream API
	// If the user uses them, then switch into old mode.
	Readable.prototype.resume = function () {
	  var state = this._readableState;
	  if (!state.flowing) {
	    debug('resume');
	    state.flowing = true;
	    resume(this, state);
	  }
	  return this;
	};
	
	function resume(stream, state) {
	  if (!state.resumeScheduled) {
	    state.resumeScheduled = true;
	    processNextTick(resume_, stream, state);
	  }
	}
	
	function resume_(stream, state) {
	  if (!state.reading) {
	    debug('resume read 0');
	    stream.read(0);
	  }
	
	  state.resumeScheduled = false;
	  state.awaitDrain = 0;
	  stream.emit('resume');
	  flow(stream);
	  if (state.flowing && !state.reading) stream.read(0);
	}
	
	Readable.prototype.pause = function () {
	  debug('call pause flowing=%j', this._readableState.flowing);
	  if (false !== this._readableState.flowing) {
	    debug('pause');
	    this._readableState.flowing = false;
	    this.emit('pause');
	  }
	  return this;
	};
	
	function flow(stream) {
	  var state = stream._readableState;
	  debug('flow', state.flowing);
	  while (state.flowing && stream.read() !== null) {}
	}
	
	// wrap an old-style stream as the async data source.
	// This is *not* part of the readable stream interface.
	// It is an ugly unfortunate mess of history.
	Readable.prototype.wrap = function (stream) {
	  var state = this._readableState;
	  var paused = false;
	
	  var self = this;
	  stream.on('end', function () {
	    debug('wrapped end');
	    if (state.decoder && !state.ended) {
	      var chunk = state.decoder.end();
	      if (chunk && chunk.length) self.push(chunk);
	    }
	
	    self.push(null);
	  });
	
	  stream.on('data', function (chunk) {
	    debug('wrapped data');
	    if (state.decoder) chunk = state.decoder.write(chunk);
	
	    // don't skip over falsy values in objectMode
	    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;
	
	    var ret = self.push(chunk);
	    if (!ret) {
	      paused = true;
	      stream.pause();
	    }
	  });
	
	  // proxy all the other methods.
	  // important when wrapping filters and duplexes.
	  for (var i in stream) {
	    if (this[i] === undefined && typeof stream[i] === 'function') {
	      this[i] = function (method) {
	        return function () {
	          return stream[method].apply(stream, arguments);
	        };
	      }(i);
	    }
	  }
	
	  // proxy certain important events.
	  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
	  forEach(events, function (ev) {
	    stream.on(ev, self.emit.bind(self, ev));
	  });
	
	  // when we try to consume some more bytes, simply unpause the
	  // underlying stream.
	  self._read = function (n) {
	    debug('wrapped _read', n);
	    if (paused) {
	      paused = false;
	      stream.resume();
	    }
	  };
	
	  return self;
	};
	
	// exposed for testing purposes only.
	Readable._fromList = fromList;
	
	// Pluck off n bytes from an array of buffers.
	// Length is the combined lengths of all the buffers in the list.
	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function fromList(n, state) {
	  // nothing buffered
	  if (state.length === 0) return null;
	
	  var ret;
	  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
	    // read it all, truncate the list
	    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
	    state.buffer.clear();
	  } else {
	    // read part of list
	    ret = fromListPartial(n, state.buffer, state.decoder);
	  }
	
	  return ret;
	}
	
	// Extracts only enough buffered data to satisfy the amount requested.
	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function fromListPartial(n, list, hasStrings) {
	  var ret;
	  if (n < list.head.data.length) {
	    // slice is the same for buffers and strings
	    ret = list.head.data.slice(0, n);
	    list.head.data = list.head.data.slice(n);
	  } else if (n === list.head.data.length) {
	    // first chunk is a perfect match
	    ret = list.shift();
	  } else {
	    // result spans more than one buffer
	    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
	  }
	  return ret;
	}
	
	// Copies a specified amount of characters from the list of buffered data
	// chunks.
	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function copyFromBufferString(n, list) {
	  var p = list.head;
	  var c = 1;
	  var ret = p.data;
	  n -= ret.length;
	  while (p = p.next) {
	    var str = p.data;
	    var nb = n > str.length ? str.length : n;
	    if (nb === str.length) ret += str;else ret += str.slice(0, n);
	    n -= nb;
	    if (n === 0) {
	      if (nb === str.length) {
	        ++c;
	        if (p.next) list.head = p.next;else list.head = list.tail = null;
	      } else {
	        list.head = p;
	        p.data = str.slice(nb);
	      }
	      break;
	    }
	    ++c;
	  }
	  list.length -= c;
	  return ret;
	}
	
	// Copies a specified amount of bytes from the list of buffered data chunks.
	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function copyFromBuffer(n, list) {
	  var ret = bufferShim.allocUnsafe(n);
	  var p = list.head;
	  var c = 1;
	  p.data.copy(ret);
	  n -= p.data.length;
	  while (p = p.next) {
	    var buf = p.data;
	    var nb = n > buf.length ? buf.length : n;
	    buf.copy(ret, ret.length - n, 0, nb);
	    n -= nb;
	    if (n === 0) {
	      if (nb === buf.length) {
	        ++c;
	        if (p.next) list.head = p.next;else list.head = list.tail = null;
	      } else {
	        list.head = p;
	        p.data = buf.slice(nb);
	      }
	      break;
	    }
	    ++c;
	  }
	  list.length -= c;
	  return ret;
	}
	
	function endReadable(stream) {
	  var state = stream._readableState;
	
	  // If we get here before consuming all the bytes, then that is a
	  // bug in node.  Should never happen.
	  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');
	
	  if (!state.endEmitted) {
	    state.ended = true;
	    processNextTick(endReadableNT, state, stream);
	  }
	}
	
	function endReadableNT(state, stream) {
	  // Check that we didn't get one last unshift.
	  if (!state.endEmitted && state.length === 0) {
	    state.endEmitted = true;
	    stream.readable = false;
	    stream.emit('end');
	  }
	}
	
	function forEach(xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}
	
	function indexOf(xs, x) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    if (xs[i] === x) return i;
	  }
	  return -1;
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)))

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	if (!process.version ||
	    process.version.indexOf('v0.') === 0 ||
	    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
	  module.exports = nextTick;
	} else {
	  module.exports = process.nextTick;
	}
	
	function nextTick(fn, arg1, arg2, arg3) {
	  if (typeof fn !== 'function') {
	    throw new TypeError('"callback" argument must be a function');
	  }
	  var len = arguments.length;
	  var args, i;
	  switch (len) {
	  case 0:
	  case 1:
	    return process.nextTick(fn);
	  case 2:
	    return process.nextTick(function afterTickOne() {
	      fn.call(null, arg1);
	    });
	  case 3:
	    return process.nextTick(function afterTickTwo() {
	      fn.call(null, arg1, arg2);
	    });
	  case 4:
	    return process.nextTick(function afterTickThree() {
	      fn.call(null, arg1, arg2, arg3);
	    });
	  default:
	    args = new Array(len - 1);
	    i = 0;
	    while (i < args.length) {
	      args[i++] = arguments[i];
	    }
	    return process.nextTick(function afterTick() {
	      fn.apply(null, args);
	    });
	  }
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)))

/***/ },
/* 16 */
/***/ function(module, exports) {

	var toString = {}.toString;
	
	module.exports = Array.isArray || function (arr) {
	  return toString.call(arr) == '[object Array]';
	};


/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	var buffer = __webpack_require__(2);
	var Buffer = buffer.Buffer;
	var SlowBuffer = buffer.SlowBuffer;
	var MAX_LEN = buffer.kMaxLength || 2147483647;
	exports.alloc = function alloc(size, fill, encoding) {
	  if (typeof Buffer.alloc === 'function') {
	    return Buffer.alloc(size, fill, encoding);
	  }
	  if (typeof encoding === 'number') {
	    throw new TypeError('encoding must not be number');
	  }
	  if (typeof size !== 'number') {
	    throw new TypeError('size must be a number');
	  }
	  if (size > MAX_LEN) {
	    throw new RangeError('size is too large');
	  }
	  var enc = encoding;
	  var _fill = fill;
	  if (_fill === undefined) {
	    enc = undefined;
	    _fill = 0;
	  }
	  var buf = new Buffer(size);
	  if (typeof _fill === 'string') {
	    var fillBuf = new Buffer(_fill, enc);
	    var flen = fillBuf.length;
	    var i = -1;
	    while (++i < size) {
	      buf[i] = fillBuf[i % flen];
	    }
	  } else {
	    buf.fill(_fill);
	  }
	  return buf;
	}
	exports.allocUnsafe = function allocUnsafe(size) {
	  if (typeof Buffer.allocUnsafe === 'function') {
	    return Buffer.allocUnsafe(size);
	  }
	  if (typeof size !== 'number') {
	    throw new TypeError('size must be a number');
	  }
	  if (size > MAX_LEN) {
	    throw new RangeError('size is too large');
	  }
	  return new Buffer(size);
	}
	exports.from = function from(value, encodingOrOffset, length) {
	  if (typeof Buffer.from === 'function' && (!global.Uint8Array || Uint8Array.from !== Buffer.from)) {
	    return Buffer.from(value, encodingOrOffset, length);
	  }
	  if (typeof value === 'number') {
	    throw new TypeError('"value" argument must not be a number');
	  }
	  if (typeof value === 'string') {
	    return new Buffer(value, encodingOrOffset);
	  }
	  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
	    var offset = encodingOrOffset;
	    if (arguments.length === 1) {
	      return new Buffer(value);
	    }
	    if (typeof offset === 'undefined') {
	      offset = 0;
	    }
	    var len = length;
	    if (typeof len === 'undefined') {
	      len = value.byteLength - offset;
	    }
	    if (offset >= value.byteLength) {
	      throw new RangeError('\'offset\' is out of bounds');
	    }
	    if (len > value.byteLength - offset) {
	      throw new RangeError('\'length\' is out of bounds');
	    }
	    return new Buffer(value.slice(offset, offset + len));
	  }
	  if (Buffer.isBuffer(value)) {
	    var out = new Buffer(value.length);
	    value.copy(out, 0, 0, value.length);
	    return out;
	  }
	  if (value) {
	    if (Array.isArray(value) || (typeof ArrayBuffer !== 'undefined' && value.buffer instanceof ArrayBuffer) || 'length' in value) {
	      return new Buffer(value);
	    }
	    if (value.type === 'Buffer' && Array.isArray(value.data)) {
	      return new Buffer(value.data);
	    }
	  }
	
	  throw new TypeError('First argument must be a string, Buffer, ' + 'ArrayBuffer, Array, or array-like object.');
	}
	exports.allocUnsafeSlow = function allocUnsafeSlow(size) {
	  if (typeof Buffer.allocUnsafeSlow === 'function') {
	    return Buffer.allocUnsafeSlow(size);
	  }
	  if (typeof size !== 'number') {
	    throw new TypeError('size must be a number');
	  }
	  if (size >= MAX_LEN) {
	    throw new RangeError('size is too large');
	  }
	  return new SlowBuffer(size);
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.
	
	function isArray(arg) {
	  if (Array.isArray) {
	    return Array.isArray(arg);
	  }
	  return objectToString(arg) === '[object Array]';
	}
	exports.isArray = isArray;
	
	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}
	exports.isBoolean = isBoolean;
	
	function isNull(arg) {
	  return arg === null;
	}
	exports.isNull = isNull;
	
	function isNullOrUndefined(arg) {
	  return arg == null;
	}
	exports.isNullOrUndefined = isNullOrUndefined;
	
	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	exports.isNumber = isNumber;
	
	function isString(arg) {
	  return typeof arg === 'string';
	}
	exports.isString = isString;
	
	function isSymbol(arg) {
	  return typeof arg === 'symbol';
	}
	exports.isSymbol = isSymbol;
	
	function isUndefined(arg) {
	  return arg === void 0;
	}
	exports.isUndefined = isUndefined;
	
	function isRegExp(re) {
	  return objectToString(re) === '[object RegExp]';
	}
	exports.isRegExp = isRegExp;
	
	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	exports.isObject = isObject;
	
	function isDate(d) {
	  return objectToString(d) === '[object Date]';
	}
	exports.isDate = isDate;
	
	function isError(e) {
	  return (objectToString(e) === '[object Error]' || e instanceof Error);
	}
	exports.isError = isError;
	
	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	exports.isFunction = isFunction;
	
	function isPrimitive(arg) {
	  return arg === null ||
	         typeof arg === 'boolean' ||
	         typeof arg === 'number' ||
	         typeof arg === 'string' ||
	         typeof arg === 'symbol' ||  // ES6 symbol
	         typeof arg === 'undefined';
	}
	exports.isPrimitive = isPrimitive;
	
	exports.isBuffer = Buffer.isBuffer;
	
	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 19 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var Buffer = __webpack_require__(2).Buffer;
	/*<replacement>*/
	var bufferShim = __webpack_require__(17);
	/*</replacement>*/
	
	module.exports = BufferList;
	
	function BufferList() {
	  this.head = null;
	  this.tail = null;
	  this.length = 0;
	}
	
	BufferList.prototype.push = function (v) {
	  var entry = { data: v, next: null };
	  if (this.length > 0) this.tail.next = entry;else this.head = entry;
	  this.tail = entry;
	  ++this.length;
	};
	
	BufferList.prototype.unshift = function (v) {
	  var entry = { data: v, next: this.head };
	  if (this.length === 0) this.tail = entry;
	  this.head = entry;
	  ++this.length;
	};
	
	BufferList.prototype.shift = function () {
	  if (this.length === 0) return;
	  var ret = this.head.data;
	  if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
	  --this.length;
	  return ret;
	};
	
	BufferList.prototype.clear = function () {
	  this.head = this.tail = null;
	  this.length = 0;
	};
	
	BufferList.prototype.join = function (s) {
	  if (this.length === 0) return '';
	  var p = this.head;
	  var ret = '' + p.data;
	  while (p = p.next) {
	    ret += s + p.data;
	  }return ret;
	};
	
	BufferList.prototype.concat = function (n) {
	  if (this.length === 0) return bufferShim.alloc(0);
	  if (this.length === 1) return this.head.data;
	  var ret = bufferShim.allocUnsafe(n >>> 0);
	  var p = this.head;
	  var i = 0;
	  while (p) {
	    p.data.copy(ret, i);
	    i += p.data.length;
	    p = p.next;
	  }
	  return ret;
	};

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	// a duplex stream is just a stream that is both readable and writable.
	// Since JS doesn't have multiple prototypal inheritance, this class
	// prototypally inherits from Readable, and then parasitically from
	// Writable.
	
	'use strict';
	
	/*<replacement>*/
	
	var objectKeys = Object.keys || function (obj) {
	  var keys = [];
	  for (var key in obj) {
	    keys.push(key);
	  }return keys;
	};
	/*</replacement>*/
	
	module.exports = Duplex;
	
	/*<replacement>*/
	var processNextTick = __webpack_require__(15);
	/*</replacement>*/
	
	/*<replacement>*/
	var util = __webpack_require__(18);
	util.inherits = __webpack_require__(12);
	/*</replacement>*/
	
	var Readable = __webpack_require__(14);
	var Writable = __webpack_require__(22);
	
	util.inherits(Duplex, Readable);
	
	var keys = objectKeys(Writable.prototype);
	for (var v = 0; v < keys.length; v++) {
	  var method = keys[v];
	  if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
	}
	
	function Duplex(options) {
	  if (!(this instanceof Duplex)) return new Duplex(options);
	
	  Readable.call(this, options);
	  Writable.call(this, options);
	
	  if (options && options.readable === false) this.readable = false;
	
	  if (options && options.writable === false) this.writable = false;
	
	  this.allowHalfOpen = true;
	  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;
	
	  this.once('end', onend);
	}
	
	// the no-half-open enforcer
	function onend() {
	  // if we allow half-open state, or if the writable side ended,
	  // then we're ok.
	  if (this.allowHalfOpen || this._writableState.ended) return;
	
	  // no more data can be written.
	  // But allow more writes to happen in this tick.
	  processNextTick(onEndNT, this);
	}
	
	function onEndNT(self) {
	  self.end();
	}
	
	function forEach(xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// A bit simpler than readable streams.
	// Implement an async ._write(chunk, encoding, cb), and it'll handle all
	// the drain event emission and buffering.
	
	'use strict';
	
	module.exports = Writable;
	
	/*<replacement>*/
	var processNextTick = __webpack_require__(15);
	/*</replacement>*/
	
	/*<replacement>*/
	var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : processNextTick;
	/*</replacement>*/
	
	/*<replacement>*/
	var Duplex;
	/*</replacement>*/
	
	Writable.WritableState = WritableState;
	
	/*<replacement>*/
	var util = __webpack_require__(18);
	util.inherits = __webpack_require__(12);
	/*</replacement>*/
	
	/*<replacement>*/
	var internalUtil = {
	  deprecate: __webpack_require__(23)
	};
	/*</replacement>*/
	
	/*<replacement>*/
	var Stream;
	(function () {
	  try {
	    Stream = __webpack_require__(11);
	  } catch (_) {} finally {
	    if (!Stream) Stream = __webpack_require__(8).EventEmitter;
	  }
	})();
	/*</replacement>*/
	
	var Buffer = __webpack_require__(2).Buffer;
	/*<replacement>*/
	var bufferShim = __webpack_require__(17);
	/*</replacement>*/
	
	util.inherits(Writable, Stream);
	
	function nop() {}
	
	function WriteReq(chunk, encoding, cb) {
	  this.chunk = chunk;
	  this.encoding = encoding;
	  this.callback = cb;
	  this.next = null;
	}
	
	function WritableState(options, stream) {
	  Duplex = Duplex || __webpack_require__(21);
	
	  options = options || {};
	
	  // object stream flag to indicate whether or not this stream
	  // contains buffers or objects.
	  this.objectMode = !!options.objectMode;
	
	  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
	
	  // the point at which write() starts returning false
	  // Note: 0 is a valid value, means that we always return false if
	  // the entire buffer is not flushed immediately on write()
	  var hwm = options.highWaterMark;
	  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
	  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
	
	  // cast to ints.
	  this.highWaterMark = ~~this.highWaterMark;
	
	  // drain event flag.
	  this.needDrain = false;
	  // at the start of calling end()
	  this.ending = false;
	  // when end() has been called, and returned
	  this.ended = false;
	  // when 'finish' is emitted
	  this.finished = false;
	
	  // should we decode strings into buffers before passing to _write?
	  // this is here so that some node-core streams can optimize string
	  // handling at a lower level.
	  var noDecode = options.decodeStrings === false;
	  this.decodeStrings = !noDecode;
	
	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';
	
	  // not an actual buffer we keep track of, but a measurement
	  // of how much we're waiting to get pushed to some underlying
	  // socket or file.
	  this.length = 0;
	
	  // a flag to see when we're in the middle of a write.
	  this.writing = false;
	
	  // when true all writes will be buffered until .uncork() call
	  this.corked = 0;
	
	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, because any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;
	
	  // a flag to know if we're processing previously buffered items, which
	  // may call the _write() callback in the same tick, so that we don't
	  // end up in an overlapped onwrite situation.
	  this.bufferProcessing = false;
	
	  // the callback that's passed to _write(chunk,cb)
	  this.onwrite = function (er) {
	    onwrite(stream, er);
	  };
	
	  // the callback that the user supplies to write(chunk,encoding,cb)
	  this.writecb = null;
	
	  // the amount that is being written when _write is called.
	  this.writelen = 0;
	
	  this.bufferedRequest = null;
	  this.lastBufferedRequest = null;
	
	  // number of pending user-supplied write callbacks
	  // this must be 0 before 'finish' can be emitted
	  this.pendingcb = 0;
	
	  // emit prefinish if the only thing we're waiting for is _write cbs
	  // This is relevant for synchronous Transform streams
	  this.prefinished = false;
	
	  // True if the error was already emitted and should not be thrown again
	  this.errorEmitted = false;
	
	  // count buffered requests
	  this.bufferedRequestCount = 0;
	
	  // allocate the first CorkedRequest, there is always
	  // one allocated and free to use, and we maintain at most two
	  this.corkedRequestsFree = new CorkedRequest(this);
	}
	
	WritableState.prototype.getBuffer = function getBuffer() {
	  var current = this.bufferedRequest;
	  var out = [];
	  while (current) {
	    out.push(current);
	    current = current.next;
	  }
	  return out;
	};
	
	(function () {
	  try {
	    Object.defineProperty(WritableState.prototype, 'buffer', {
	      get: internalUtil.deprecate(function () {
	        return this.getBuffer();
	      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.')
	    });
	  } catch (_) {}
	})();
	
	// Test _writableState for inheritance to account for Duplex streams,
	// whose prototype chain only points to Readable.
	var realHasInstance;
	if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
	  realHasInstance = Function.prototype[Symbol.hasInstance];
	  Object.defineProperty(Writable, Symbol.hasInstance, {
	    value: function (object) {
	      if (realHasInstance.call(this, object)) return true;
	
	      return object && object._writableState instanceof WritableState;
	    }
	  });
	} else {
	  realHasInstance = function (object) {
	    return object instanceof this;
	  };
	}
	
	function Writable(options) {
	  Duplex = Duplex || __webpack_require__(21);
	
	  // Writable ctor is applied to Duplexes, too.
	  // `realHasInstance` is necessary because using plain `instanceof`
	  // would return false, as no `_writableState` property is attached.
	
	  // Trying to use the custom `instanceof` for Writable here will also break the
	  // Node.js LazyTransform implementation, which has a non-trivial getter for
	  // `_writableState` that would lead to infinite recursion.
	  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
	    return new Writable(options);
	  }
	
	  this._writableState = new WritableState(options, this);
	
	  // legacy.
	  this.writable = true;
	
	  if (options) {
	    if (typeof options.write === 'function') this._write = options.write;
	
	    if (typeof options.writev === 'function') this._writev = options.writev;
	  }
	
	  Stream.call(this);
	}
	
	// Otherwise people can pipe Writable streams, which is just wrong.
	Writable.prototype.pipe = function () {
	  this.emit('error', new Error('Cannot pipe, not readable'));
	};
	
	function writeAfterEnd(stream, cb) {
	  var er = new Error('write after end');
	  // TODO: defer error events consistently everywhere, not just the cb
	  stream.emit('error', er);
	  processNextTick(cb, er);
	}
	
	// Checks that a user-supplied chunk is valid, especially for the particular
	// mode the stream is in. Currently this means that `null` is never accepted
	// and undefined/non-string values are only allowed in object mode.
	function validChunk(stream, state, chunk, cb) {
	  var valid = true;
	  var er = false;
	
	  if (chunk === null) {
	    er = new TypeError('May not write null values to stream');
	  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
	    er = new TypeError('Invalid non-string/buffer chunk');
	  }
	  if (er) {
	    stream.emit('error', er);
	    processNextTick(cb, er);
	    valid = false;
	  }
	  return valid;
	}
	
	Writable.prototype.write = function (chunk, encoding, cb) {
	  var state = this._writableState;
	  var ret = false;
	  var isBuf = Buffer.isBuffer(chunk);
	
	  if (typeof encoding === 'function') {
	    cb = encoding;
	    encoding = null;
	  }
	
	  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
	
	  if (typeof cb !== 'function') cb = nop;
	
	  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
	    state.pendingcb++;
	    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
	  }
	
	  return ret;
	};
	
	Writable.prototype.cork = function () {
	  var state = this._writableState;
	
	  state.corked++;
	};
	
	Writable.prototype.uncork = function () {
	  var state = this._writableState;
	
	  if (state.corked) {
	    state.corked--;
	
	    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
	  }
	};
	
	Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
	  // node::ParseEncoding() requires lower case.
	  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
	  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
	  this._writableState.defaultEncoding = encoding;
	  return this;
	};
	
	function decodeChunk(state, chunk, encoding) {
	  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
	    chunk = bufferShim.from(chunk, encoding);
	  }
	  return chunk;
	}
	
	// if we're already writing something, then just put this
	// in the queue, and wait our turn.  Otherwise, call _write
	// If we return false, then we need a drain event, so set that flag.
	function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
	  if (!isBuf) {
	    chunk = decodeChunk(state, chunk, encoding);
	    if (Buffer.isBuffer(chunk)) encoding = 'buffer';
	  }
	  var len = state.objectMode ? 1 : chunk.length;
	
	  state.length += len;
	
	  var ret = state.length < state.highWaterMark;
	  // we must ensure that previous needDrain will not be reset to false.
	  if (!ret) state.needDrain = true;
	
	  if (state.writing || state.corked) {
	    var last = state.lastBufferedRequest;
	    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
	    if (last) {
	      last.next = state.lastBufferedRequest;
	    } else {
	      state.bufferedRequest = state.lastBufferedRequest;
	    }
	    state.bufferedRequestCount += 1;
	  } else {
	    doWrite(stream, state, false, len, chunk, encoding, cb);
	  }
	
	  return ret;
	}
	
	function doWrite(stream, state, writev, len, chunk, encoding, cb) {
	  state.writelen = len;
	  state.writecb = cb;
	  state.writing = true;
	  state.sync = true;
	  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
	  state.sync = false;
	}
	
	function onwriteError(stream, state, sync, er, cb) {
	  --state.pendingcb;
	  if (sync) processNextTick(cb, er);else cb(er);
	
	  stream._writableState.errorEmitted = true;
	  stream.emit('error', er);
	}
	
	function onwriteStateUpdate(state) {
	  state.writing = false;
	  state.writecb = null;
	  state.length -= state.writelen;
	  state.writelen = 0;
	}
	
	function onwrite(stream, er) {
	  var state = stream._writableState;
	  var sync = state.sync;
	  var cb = state.writecb;
	
	  onwriteStateUpdate(state);
	
	  if (er) onwriteError(stream, state, sync, er, cb);else {
	    // Check if we're actually ready to finish, but don't emit yet
	    var finished = needFinish(state);
	
	    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
	      clearBuffer(stream, state);
	    }
	
	    if (sync) {
	      /*<replacement>*/
	      asyncWrite(afterWrite, stream, state, finished, cb);
	      /*</replacement>*/
	    } else {
	      afterWrite(stream, state, finished, cb);
	    }
	  }
	}
	
	function afterWrite(stream, state, finished, cb) {
	  if (!finished) onwriteDrain(stream, state);
	  state.pendingcb--;
	  cb();
	  finishMaybe(stream, state);
	}
	
	// Must force callback to be called on nextTick, so that we don't
	// emit 'drain' before the write() consumer gets the 'false' return
	// value, and has a chance to attach a 'drain' listener.
	function onwriteDrain(stream, state) {
	  if (state.length === 0 && state.needDrain) {
	    state.needDrain = false;
	    stream.emit('drain');
	  }
	}
	
	// if there's something in the buffer waiting, then process it
	function clearBuffer(stream, state) {
	  state.bufferProcessing = true;
	  var entry = state.bufferedRequest;
	
	  if (stream._writev && entry && entry.next) {
	    // Fast case, write everything using _writev()
	    var l = state.bufferedRequestCount;
	    var buffer = new Array(l);
	    var holder = state.corkedRequestsFree;
	    holder.entry = entry;
	
	    var count = 0;
	    while (entry) {
	      buffer[count] = entry;
	      entry = entry.next;
	      count += 1;
	    }
	
	    doWrite(stream, state, true, state.length, buffer, '', holder.finish);
	
	    // doWrite is almost always async, defer these to save a bit of time
	    // as the hot path ends with doWrite
	    state.pendingcb++;
	    state.lastBufferedRequest = null;
	    if (holder.next) {
	      state.corkedRequestsFree = holder.next;
	      holder.next = null;
	    } else {
	      state.corkedRequestsFree = new CorkedRequest(state);
	    }
	  } else {
	    // Slow case, write chunks one-by-one
	    while (entry) {
	      var chunk = entry.chunk;
	      var encoding = entry.encoding;
	      var cb = entry.callback;
	      var len = state.objectMode ? 1 : chunk.length;
	
	      doWrite(stream, state, false, len, chunk, encoding, cb);
	      entry = entry.next;
	      // if we didn't call the onwrite immediately, then
	      // it means that we need to wait until it does.
	      // also, that means that the chunk and cb are currently
	      // being processed, so move the buffer counter past them.
	      if (state.writing) {
	        break;
	      }
	    }
	
	    if (entry === null) state.lastBufferedRequest = null;
	  }
	
	  state.bufferedRequestCount = 0;
	  state.bufferedRequest = entry;
	  state.bufferProcessing = false;
	}
	
	Writable.prototype._write = function (chunk, encoding, cb) {
	  cb(new Error('_write() is not implemented'));
	};
	
	Writable.prototype._writev = null;
	
	Writable.prototype.end = function (chunk, encoding, cb) {
	  var state = this._writableState;
	
	  if (typeof chunk === 'function') {
	    cb = chunk;
	    chunk = null;
	    encoding = null;
	  } else if (typeof encoding === 'function') {
	    cb = encoding;
	    encoding = null;
	  }
	
	  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);
	
	  // .end() fully uncorks
	  if (state.corked) {
	    state.corked = 1;
	    this.uncork();
	  }
	
	  // ignore unnecessary end() calls.
	  if (!state.ending && !state.finished) endWritable(this, state, cb);
	};
	
	function needFinish(state) {
	  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
	}
	
	function prefinish(stream, state) {
	  if (!state.prefinished) {
	    state.prefinished = true;
	    stream.emit('prefinish');
	  }
	}
	
	function finishMaybe(stream, state) {
	  var need = needFinish(state);
	  if (need) {
	    if (state.pendingcb === 0) {
	      prefinish(stream, state);
	      state.finished = true;
	      stream.emit('finish');
	    } else {
	      prefinish(stream, state);
	    }
	  }
	  return need;
	}
	
	function endWritable(stream, state, cb) {
	  state.ending = true;
	  finishMaybe(stream, state);
	  if (cb) {
	    if (state.finished) processNextTick(cb);else stream.once('finish', cb);
	  }
	  state.ended = true;
	  stream.writable = false;
	}
	
	// It seems a linked list but it is not
	// there will be only 2 of these for each stream
	function CorkedRequest(state) {
	  var _this = this;
	
	  this.next = null;
	  this.entry = null;
	  this.finish = function (err) {
	    var entry = _this.entry;
	    _this.entry = null;
	    while (entry) {
	      var cb = entry.callback;
	      state.pendingcb--;
	      cb(err);
	      entry = entry.next;
	    }
	    if (state.corkedRequestsFree) {
	      state.corkedRequestsFree.next = _this;
	    } else {
	      state.corkedRequestsFree = _this;
	    }
	  };
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)))

/***/ },
/* 23 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {
	/**
	 * Module exports.
	 */
	
	module.exports = deprecate;
	
	/**
	 * Mark that a method should not be used.
	 * Returns a modified function which warns once by default.
	 *
	 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
	 *
	 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
	 * will throw an Error when invoked.
	 *
	 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
	 * will invoke `console.trace()` instead of `console.error()`.
	 *
	 * @param {Function} fn - the function to deprecate
	 * @param {String} msg - the string to print to the console when `fn` is invoked
	 * @returns {Function} a new "deprecated" version of `fn`
	 * @api public
	 */
	
	function deprecate (fn, msg) {
	  if (config('noDeprecation')) {
	    return fn;
	  }
	
	  var warned = false;
	  function deprecated() {
	    if (!warned) {
	      if (config('throwDeprecation')) {
	        throw new Error(msg);
	      } else if (config('traceDeprecation')) {
	        console.trace(msg);
	      } else {
	        console.warn(msg);
	      }
	      warned = true;
	    }
	    return fn.apply(this, arguments);
	  }
	
	  return deprecated;
	}
	
	/**
	 * Checks `localStorage` for boolean values for the given `name`.
	 *
	 * @param {String} name
	 * @returns {Boolean}
	 * @api private
	 */
	
	function config (name) {
	  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
	  try {
	    if (!global.localStorage) return false;
	  } catch (_) {
	    return false;
	  }
	  var val = global.localStorage[name];
	  if (null == val) return false;
	  return String(val).toLowerCase() === 'true';
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	var Buffer = __webpack_require__(2).Buffer;
	
	var isBufferEncoding = Buffer.isEncoding
	  || function(encoding) {
	       switch (encoding && encoding.toLowerCase()) {
	         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
	         default: return false;
	       }
	     }
	
	
	function assertEncoding(encoding) {
	  if (encoding && !isBufferEncoding(encoding)) {
	    throw new Error('Unknown encoding: ' + encoding);
	  }
	}
	
	// StringDecoder provides an interface for efficiently splitting a series of
	// buffers into a series of JS strings without breaking apart multi-byte
	// characters. CESU-8 is handled as part of the UTF-8 encoding.
	//
	// @TODO Handling all encodings inside a single object makes it very difficult
	// to reason about this code, so it should be split up in the future.
	// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
	// points as used by CESU-8.
	var StringDecoder = exports.StringDecoder = function(encoding) {
	  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
	  assertEncoding(encoding);
	  switch (this.encoding) {
	    case 'utf8':
	      // CESU-8 represents each of Surrogate Pair by 3-bytes
	      this.surrogateSize = 3;
	      break;
	    case 'ucs2':
	    case 'utf16le':
	      // UTF-16 represents each of Surrogate Pair by 2-bytes
	      this.surrogateSize = 2;
	      this.detectIncompleteChar = utf16DetectIncompleteChar;
	      break;
	    case 'base64':
	      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
	      this.surrogateSize = 3;
	      this.detectIncompleteChar = base64DetectIncompleteChar;
	      break;
	    default:
	      this.write = passThroughWrite;
	      return;
	  }
	
	  // Enough space to store all bytes of a single character. UTF-8 needs 4
	  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
	  this.charBuffer = new Buffer(6);
	  // Number of bytes received for the current incomplete multi-byte character.
	  this.charReceived = 0;
	  // Number of bytes expected for the current incomplete multi-byte character.
	  this.charLength = 0;
	};
	
	
	// write decodes the given buffer and returns it as JS string that is
	// guaranteed to not contain any partial multi-byte characters. Any partial
	// character found at the end of the buffer is buffered up, and will be
	// returned when calling write again with the remaining bytes.
	//
	// Note: Converting a Buffer containing an orphan surrogate to a String
	// currently works, but converting a String to a Buffer (via `new Buffer`, or
	// Buffer#write) will replace incomplete surrogates with the unicode
	// replacement character. See https://codereview.chromium.org/121173009/ .
	StringDecoder.prototype.write = function(buffer) {
	  var charStr = '';
	  // if our last write ended with an incomplete multibyte character
	  while (this.charLength) {
	    // determine how many remaining bytes this buffer has to offer for this char
	    var available = (buffer.length >= this.charLength - this.charReceived) ?
	        this.charLength - this.charReceived :
	        buffer.length;
	
	    // add the new bytes to the char buffer
	    buffer.copy(this.charBuffer, this.charReceived, 0, available);
	    this.charReceived += available;
	
	    if (this.charReceived < this.charLength) {
	      // still not enough chars in this buffer? wait for more ...
	      return '';
	    }
	
	    // remove bytes belonging to the current character from the buffer
	    buffer = buffer.slice(available, buffer.length);
	
	    // get the character that was split
	    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
	
	    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
	    var charCode = charStr.charCodeAt(charStr.length - 1);
	    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
	      this.charLength += this.surrogateSize;
	      charStr = '';
	      continue;
	    }
	    this.charReceived = this.charLength = 0;
	
	    // if there are no more bytes in this buffer, just emit our char
	    if (buffer.length === 0) {
	      return charStr;
	    }
	    break;
	  }
	
	  // determine and set charLength / charReceived
	  this.detectIncompleteChar(buffer);
	
	  var end = buffer.length;
	  if (this.charLength) {
	    // buffer the incomplete character bytes we got
	    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
	    end -= this.charReceived;
	  }
	
	  charStr += buffer.toString(this.encoding, 0, end);
	
	  var end = charStr.length - 1;
	  var charCode = charStr.charCodeAt(end);
	  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
	  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
	    var size = this.surrogateSize;
	    this.charLength += size;
	    this.charReceived += size;
	    this.charBuffer.copy(this.charBuffer, size, 0, size);
	    buffer.copy(this.charBuffer, 0, 0, size);
	    return charStr.substring(0, end);
	  }
	
	  // or just emit the charStr
	  return charStr;
	};
	
	// detectIncompleteChar determines if there is an incomplete UTF-8 character at
	// the end of the given buffer. If so, it sets this.charLength to the byte
	// length that character, and sets this.charReceived to the number of bytes
	// that are available for this character.
	StringDecoder.prototype.detectIncompleteChar = function(buffer) {
	  // determine how many bytes we have to check at the end of this buffer
	  var i = (buffer.length >= 3) ? 3 : buffer.length;
	
	  // Figure out if one of the last i bytes of our buffer announces an
	  // incomplete char.
	  for (; i > 0; i--) {
	    var c = buffer[buffer.length - i];
	
	    // See http://en.wikipedia.org/wiki/UTF-8#Description
	
	    // 110XXXXX
	    if (i == 1 && c >> 5 == 0x06) {
	      this.charLength = 2;
	      break;
	    }
	
	    // 1110XXXX
	    if (i <= 2 && c >> 4 == 0x0E) {
	      this.charLength = 3;
	      break;
	    }
	
	    // 11110XXX
	    if (i <= 3 && c >> 3 == 0x1E) {
	      this.charLength = 4;
	      break;
	    }
	  }
	  this.charReceived = i;
	};
	
	StringDecoder.prototype.end = function(buffer) {
	  var res = '';
	  if (buffer && buffer.length)
	    res = this.write(buffer);
	
	  if (this.charReceived) {
	    var cr = this.charReceived;
	    var buf = this.charBuffer;
	    var enc = this.encoding;
	    res += buf.slice(0, cr).toString(enc);
	  }
	
	  return res;
	};
	
	function passThroughWrite(buffer) {
	  return buffer.toString(this.encoding);
	}
	
	function utf16DetectIncompleteChar(buffer) {
	  this.charReceived = buffer.length % 2;
	  this.charLength = this.charReceived ? 2 : 0;
	}
	
	function base64DetectIncompleteChar(buffer) {
	  this.charReceived = buffer.length % 3;
	  this.charLength = this.charReceived ? 3 : 0;
	}


/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	// a transform stream is a readable/writable stream where you do
	// something with the data.  Sometimes it's called a "filter",
	// but that's not a great name for it, since that implies a thing where
	// some bits pass through, and others are simply ignored.  (That would
	// be a valid example of a transform, of course.)
	//
	// While the output is causally related to the input, it's not a
	// necessarily symmetric or synchronous transformation.  For example,
	// a zlib stream might take multiple plain-text writes(), and then
	// emit a single compressed chunk some time in the future.
	//
	// Here's how this works:
	//
	// The Transform stream has all the aspects of the readable and writable
	// stream classes.  When you write(chunk), that calls _write(chunk,cb)
	// internally, and returns false if there's a lot of pending writes
	// buffered up.  When you call read(), that calls _read(n) until
	// there's enough pending readable data buffered up.
	//
	// In a transform stream, the written data is placed in a buffer.  When
	// _read(n) is called, it transforms the queued up data, calling the
	// buffered _write cb's as it consumes chunks.  If consuming a single
	// written chunk would result in multiple output chunks, then the first
	// outputted bit calls the readcb, and subsequent chunks just go into
	// the read buffer, and will cause it to emit 'readable' if necessary.
	//
	// This way, back-pressure is actually determined by the reading side,
	// since _read has to be called to start processing a new chunk.  However,
	// a pathological inflate type of transform can cause excessive buffering
	// here.  For example, imagine a stream where every byte of input is
	// interpreted as an integer from 0-255, and then results in that many
	// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
	// 1kb of data being output.  In this case, you could write a very small
	// amount of input, and end up with a very large amount of output.  In
	// such a pathological inflating mechanism, there'd be no way to tell
	// the system to stop doing the transform.  A single 4MB write could
	// cause the system to run out of memory.
	//
	// However, even in such a pathological case, only a single written chunk
	// would be consumed, and then the rest would wait (un-transformed) until
	// the results of the previous transformed chunk were consumed.
	
	'use strict';
	
	module.exports = Transform;
	
	var Duplex = __webpack_require__(21);
	
	/*<replacement>*/
	var util = __webpack_require__(18);
	util.inherits = __webpack_require__(12);
	/*</replacement>*/
	
	util.inherits(Transform, Duplex);
	
	function TransformState(stream) {
	  this.afterTransform = function (er, data) {
	    return afterTransform(stream, er, data);
	  };
	
	  this.needTransform = false;
	  this.transforming = false;
	  this.writecb = null;
	  this.writechunk = null;
	  this.writeencoding = null;
	}
	
	function afterTransform(stream, er, data) {
	  var ts = stream._transformState;
	  ts.transforming = false;
	
	  var cb = ts.writecb;
	
	  if (!cb) return stream.emit('error', new Error('no writecb in Transform class'));
	
	  ts.writechunk = null;
	  ts.writecb = null;
	
	  if (data !== null && data !== undefined) stream.push(data);
	
	  cb(er);
	
	  var rs = stream._readableState;
	  rs.reading = false;
	  if (rs.needReadable || rs.length < rs.highWaterMark) {
	    stream._read(rs.highWaterMark);
	  }
	}
	
	function Transform(options) {
	  if (!(this instanceof Transform)) return new Transform(options);
	
	  Duplex.call(this, options);
	
	  this._transformState = new TransformState(this);
	
	  var stream = this;
	
	  // start out asking for a readable event once data is transformed.
	  this._readableState.needReadable = true;
	
	  // we have implemented the _read method, and done the other things
	  // that Readable wants before the first _read call, so unset the
	  // sync guard flag.
	  this._readableState.sync = false;
	
	  if (options) {
	    if (typeof options.transform === 'function') this._transform = options.transform;
	
	    if (typeof options.flush === 'function') this._flush = options.flush;
	  }
	
	  // When the writable side finishes, then flush out anything remaining.
	  this.once('prefinish', function () {
	    if (typeof this._flush === 'function') this._flush(function (er, data) {
	      done(stream, er, data);
	    });else done(stream);
	  });
	}
	
	Transform.prototype.push = function (chunk, encoding) {
	  this._transformState.needTransform = false;
	  return Duplex.prototype.push.call(this, chunk, encoding);
	};
	
	// This is the part where you do stuff!
	// override this function in implementation classes.
	// 'chunk' is an input chunk.
	//
	// Call `push(newChunk)` to pass along transformed output
	// to the readable side.  You may call 'push' zero or more times.
	//
	// Call `cb(err)` when you are done with this chunk.  If you pass
	// an error, then that'll put the hurt on the whole operation.  If you
	// never call cb(), then you'll never get another chunk.
	Transform.prototype._transform = function (chunk, encoding, cb) {
	  throw new Error('_transform() is not implemented');
	};
	
	Transform.prototype._write = function (chunk, encoding, cb) {
	  var ts = this._transformState;
	  ts.writecb = cb;
	  ts.writechunk = chunk;
	  ts.writeencoding = encoding;
	  if (!ts.transforming) {
	    var rs = this._readableState;
	    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
	  }
	};
	
	// Doesn't matter what the args are here.
	// _transform does all the work.
	// That we got here means that the readable side wants more data.
	Transform.prototype._read = function (n) {
	  var ts = this._transformState;
	
	  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
	    ts.transforming = true;
	    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
	  } else {
	    // mark that we need a transform, so that any data that comes in
	    // will get processed, now that we've asked for it.
	    ts.needTransform = true;
	  }
	};
	
	function done(stream, er, data) {
	  if (er) return stream.emit('error', er);
	
	  if (data !== null && data !== undefined) stream.push(data);
	
	  // if there's nothing in the write buffer, then that means
	  // that nothing more will ever be provided
	  var ws = stream._writableState;
	  var ts = stream._transformState;
	
	  if (ws.length) throw new Error('Calling transform done when ws.length != 0');
	
	  if (ts.transforming) throw new Error('Calling transform done when still transforming');
	
	  return stream.push(null);
	}

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	// a passthrough stream.
	// basically just the most minimal sort of Transform stream.
	// Every written chunk gets output as-is.
	
	'use strict';
	
	module.exports = PassThrough;
	
	var Transform = __webpack_require__(25);
	
	/*<replacement>*/
	var util = __webpack_require__(18);
	util.inherits = __webpack_require__(12);
	/*</replacement>*/
	
	util.inherits(PassThrough, Transform);
	
	function PassThrough(options) {
	  if (!(this instanceof PassThrough)) return new PassThrough(options);
	
	  Transform.call(this, options);
	}
	
	PassThrough.prototype._transform = function (chunk, encoding, cb) {
	  cb(null, chunk);
	};

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(22)


/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(21)


/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(25)


/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(26)


/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	
	var zlib_inflate = __webpack_require__(32);
	var utils        = __webpack_require__(33);
	var strings      = __webpack_require__(38);
	var c            = __webpack_require__(39);
	var msg          = __webpack_require__(40);
	var ZStream      = __webpack_require__(41);
	var GZheader     = __webpack_require__(42);
	
	var toString = Object.prototype.toString;
	
	/**
	 * class Inflate
	 *
	 * Generic JS-style wrapper for zlib calls. If you don't need
	 * streaming behaviour - use more simple functions: [[inflate]]
	 * and [[inflateRaw]].
	 **/
	
	/* internal
	 * inflate.chunks -> Array
	 *
	 * Chunks of output data, if [[Inflate#onData]] not overriden.
	 **/
	
	/**
	 * Inflate.result -> Uint8Array|Array|String
	 *
	 * Uncompressed result, generated by default [[Inflate#onData]]
	 * and [[Inflate#onEnd]] handlers. Filled after you push last chunk
	 * (call [[Inflate#push]] with `Z_FINISH` / `true` param) or if you
	 * push a chunk with explicit flush (call [[Inflate#push]] with
	 * `Z_SYNC_FLUSH` param).
	 **/
	
	/**
	 * Inflate.err -> Number
	 *
	 * Error code after inflate finished. 0 (Z_OK) on success.
	 * Should be checked if broken data possible.
	 **/
	
	/**
	 * Inflate.msg -> String
	 *
	 * Error message, if [[Inflate.err]] != 0
	 **/
	
	
	/**
	 * new Inflate(options)
	 * - options (Object): zlib inflate options.
	 *
	 * Creates new inflator instance with specified params. Throws exception
	 * on bad params. Supported options:
	 *
	 * - `windowBits`
	 * - `dictionary`
	 *
	 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
	 * for more information on these.
	 *
	 * Additional options, for internal needs:
	 *
	 * - `chunkSize` - size of generated data chunks (16K by default)
	 * - `raw` (Boolean) - do raw inflate
	 * - `to` (String) - if equal to 'string', then result will be converted
	 *   from utf8 to utf16 (javascript) string. When string output requested,
	 *   chunk length can differ from `chunkSize`, depending on content.
	 *
	 * By default, when no options set, autodetect deflate/gzip data format via
	 * wrapper header.
	 *
	 * ##### Example:
	 *
	 * ```javascript
	 * var pako = require('pako')
	 *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
	 *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
	 *
	 * var inflate = new pako.Inflate({ level: 3});
	 *
	 * inflate.push(chunk1, false);
	 * inflate.push(chunk2, true);  // true -> last chunk
	 *
	 * if (inflate.err) { throw new Error(inflate.err); }
	 *
	 * console.log(inflate.result);
	 * ```
	 **/
	function Inflate(options) {
	  if (!(this instanceof Inflate)) return new Inflate(options);
	
	  this.options = utils.assign({
	    chunkSize: 16384,
	    windowBits: 0,
	    to: ''
	  }, options || {});
	
	  var opt = this.options;
	
	  // Force window size for `raw` data, if not set directly,
	  // because we have no header for autodetect.
	  if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {
	    opt.windowBits = -opt.windowBits;
	    if (opt.windowBits === 0) { opt.windowBits = -15; }
	  }
	
	  // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate
	  if ((opt.windowBits >= 0) && (opt.windowBits < 16) &&
	      !(options && options.windowBits)) {
	    opt.windowBits += 32;
	  }
	
	  // Gzip header has no info about windows size, we can do autodetect only
	  // for deflate. So, if window size not set, force it to max when gzip possible
	  if ((opt.windowBits > 15) && (opt.windowBits < 48)) {
	    // bit 3 (16) -> gzipped data
	    // bit 4 (32) -> autodetect gzip/deflate
	    if ((opt.windowBits & 15) === 0) {
	      opt.windowBits |= 15;
	    }
	  }
	
	  this.err    = 0;      // error code, if happens (0 = Z_OK)
	  this.msg    = '';     // error message
	  this.ended  = false;  // used to avoid multiple onEnd() calls
	  this.chunks = [];     // chunks of compressed data
	
	  this.strm   = new ZStream();
	  this.strm.avail_out = 0;
	
	  var status  = zlib_inflate.inflateInit2(
	    this.strm,
	    opt.windowBits
	  );
	
	  if (status !== c.Z_OK) {
	    throw new Error(msg[status]);
	  }
	
	  this.header = new GZheader();
	
	  zlib_inflate.inflateGetHeader(this.strm, this.header);
	}
	
	/**
	 * Inflate#push(data[, mode]) -> Boolean
	 * - data (Uint8Array|Array|ArrayBuffer|String): input data
	 * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
	 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` meansh Z_FINISH.
	 *
	 * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with
	 * new output chunks. Returns `true` on success. The last data block must have
	 * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
	 * [[Inflate#onEnd]]. For interim explicit flushes (without ending the stream) you
	 * can use mode Z_SYNC_FLUSH, keeping the decompression context.
	 *
	 * On fail call [[Inflate#onEnd]] with error code and return false.
	 *
	 * We strongly recommend to use `Uint8Array` on input for best speed (output
	 * format is detected automatically). Also, don't skip last param and always
	 * use the same type in your code (boolean or number). That will improve JS speed.
	 *
	 * For regular `Array`-s make sure all elements are [0..255].
	 *
	 * ##### Example
	 *
	 * ```javascript
	 * push(chunk, false); // push one of data chunks
	 * ...
	 * push(chunk, true);  // push last chunk
	 * ```
	 **/
	Inflate.prototype.push = function (data, mode) {
	  var strm = this.strm;
	  var chunkSize = this.options.chunkSize;
	  var dictionary = this.options.dictionary;
	  var status, _mode;
	  var next_out_utf8, tail, utf8str;
	  var dict;
	
	  // Flag to properly process Z_BUF_ERROR on testing inflate call
	  // when we check that all output data was flushed.
	  var allowBufError = false;
	
	  if (this.ended) { return false; }
	  _mode = (mode === ~~mode) ? mode : ((mode === true) ? c.Z_FINISH : c.Z_NO_FLUSH);
	
	  // Convert data if needed
	  if (typeof data === 'string') {
	    // Only binary strings can be decompressed on practice
	    strm.input = strings.binstring2buf(data);
	  } else if (toString.call(data) === '[object ArrayBuffer]') {
	    strm.input = new Uint8Array(data);
	  } else {
	    strm.input = data;
	  }
	
	  strm.next_in = 0;
	  strm.avail_in = strm.input.length;
	
	  do {
	    if (strm.avail_out === 0) {
	      strm.output = new utils.Buf8(chunkSize);
	      strm.next_out = 0;
	      strm.avail_out = chunkSize;
	    }
	
	    status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);    /* no bad return value */
	
	    if (status === c.Z_NEED_DICT && dictionary) {
	      // Convert data if needed
	      if (typeof dictionary === 'string') {
	        dict = strings.string2buf(dictionary);
	      } else if (toString.call(dictionary) === '[object ArrayBuffer]') {
	        dict = new Uint8Array(dictionary);
	      } else {
	        dict = dictionary;
	      }
	
	      status = zlib_inflate.inflateSetDictionary(this.strm, dict);
	
	    }
	
	    if (status === c.Z_BUF_ERROR && allowBufError === true) {
	      status = c.Z_OK;
	      allowBufError = false;
	    }
	
	    if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
	      this.onEnd(status);
	      this.ended = true;
	      return false;
	    }
	
	    if (strm.next_out) {
	      if (strm.avail_out === 0 || status === c.Z_STREAM_END || (strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH))) {
	
	        if (this.options.to === 'string') {
	
	          next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
	
	          tail = strm.next_out - next_out_utf8;
	          utf8str = strings.buf2string(strm.output, next_out_utf8);
	
	          // move tail
	          strm.next_out = tail;
	          strm.avail_out = chunkSize - tail;
	          if (tail) { utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0); }
	
	          this.onData(utf8str);
	
	        } else {
	          this.onData(utils.shrinkBuf(strm.output, strm.next_out));
	        }
	      }
	    }
	
	    // When no more input data, we should check that internal inflate buffers
	    // are flushed. The only way to do it when avail_out = 0 - run one more
	    // inflate pass. But if output data not exists, inflate return Z_BUF_ERROR.
	    // Here we set flag to process this error properly.
	    //
	    // NOTE. Deflate does not return error in this case and does not needs such
	    // logic.
	    if (strm.avail_in === 0 && strm.avail_out === 0) {
	      allowBufError = true;
	    }
	
	  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);
	
	  if (status === c.Z_STREAM_END) {
	    _mode = c.Z_FINISH;
	  }
	
	  // Finalize on the last chunk.
	  if (_mode === c.Z_FINISH) {
	    status = zlib_inflate.inflateEnd(this.strm);
	    this.onEnd(status);
	    this.ended = true;
	    return status === c.Z_OK;
	  }
	
	  // callback interim results if Z_SYNC_FLUSH.
	  if (_mode === c.Z_SYNC_FLUSH) {
	    this.onEnd(c.Z_OK);
	    strm.avail_out = 0;
	    return true;
	  }
	
	  return true;
	};
	
	
	/**
	 * Inflate#onData(chunk) -> Void
	 * - chunk (Uint8Array|Array|String): ouput data. Type of array depends
	 *   on js engine support. When string output requested, each chunk
	 *   will be string.
	 *
	 * By default, stores data blocks in `chunks[]` property and glue
	 * those in `onEnd`. Override this handler, if you need another behaviour.
	 **/
	Inflate.prototype.onData = function (chunk) {
	  this.chunks.push(chunk);
	};
	
	
	/**
	 * Inflate#onEnd(status) -> Void
	 * - status (Number): inflate status. 0 (Z_OK) on success,
	 *   other if not.
	 *
	 * Called either after you tell inflate that the input stream is
	 * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
	 * or if an error happened. By default - join collected chunks,
	 * free memory and fill `results` / `err` properties.
	 **/
	Inflate.prototype.onEnd = function (status) {
	  // On success - join
	  if (status === c.Z_OK) {
	    if (this.options.to === 'string') {
	      // Glue & convert here, until we teach pako to send
	      // utf8 alligned strings to onData
	      this.result = this.chunks.join('');
	    } else {
	      this.result = utils.flattenChunks(this.chunks);
	    }
	  }
	  this.chunks = [];
	  this.err = status;
	  this.msg = this.strm.msg;
	};
	
	
	/**
	 * inflate(data[, options]) -> Uint8Array|Array|String
	 * - data (Uint8Array|Array|String): input data to decompress.
	 * - options (Object): zlib inflate options.
	 *
	 * Decompress `data` with inflate/ungzip and `options`. Autodetect
	 * format via wrapper header by default. That's why we don't provide
	 * separate `ungzip` method.
	 *
	 * Supported options are:
	 *
	 * - windowBits
	 *
	 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
	 * for more information.
	 *
	 * Sugar (options):
	 *
	 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
	 *   negative windowBits implicitly.
	 * - `to` (String) - if equal to 'string', then result will be converted
	 *   from utf8 to utf16 (javascript) string. When string output requested,
	 *   chunk length can differ from `chunkSize`, depending on content.
	 *
	 *
	 * ##### Example:
	 *
	 * ```javascript
	 * var pako = require('pako')
	 *   , input = pako.deflate([1,2,3,4,5,6,7,8,9])
	 *   , output;
	 *
	 * try {
	 *   output = pako.inflate(input);
	 * } catch (err)
	 *   console.log(err);
	 * }
	 * ```
	 **/
	function inflate(input, options) {
	  var inflator = new Inflate(options);
	
	  inflator.push(input, true);
	
	  // That will never happens, if you don't cheat with options :)
	  if (inflator.err) { throw inflator.msg || msg[inflator.err]; }
	
	  return inflator.result;
	}
	
	
	/**
	 * inflateRaw(data[, options]) -> Uint8Array|Array|String
	 * - data (Uint8Array|Array|String): input data to decompress.
	 * - options (Object): zlib inflate options.
	 *
	 * The same as [[inflate]], but creates raw data, without wrapper
	 * (header and adler32 crc).
	 **/
	function inflateRaw(input, options) {
	  options = options || {};
	  options.raw = true;
	  return inflate(input, options);
	}
	
	
	/**
	 * ungzip(data[, options]) -> Uint8Array|Array|String
	 * - data (Uint8Array|Array|String): input data to decompress.
	 * - options (Object): zlib inflate options.
	 *
	 * Just shortcut to [[inflate]], because it autodetects format
	 * by header.content. Done for convenience.
	 **/
	
	
	exports.Inflate = Inflate;
	exports.inflate = inflate;
	exports.inflateRaw = inflateRaw;
	exports.ungzip  = inflate;


/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	
	var utils         = __webpack_require__(33);
	var adler32       = __webpack_require__(34);
	var crc32         = __webpack_require__(35);
	var inflate_fast  = __webpack_require__(36);
	var inflate_table = __webpack_require__(37);
	
	var CODES = 0;
	var LENS = 1;
	var DISTS = 2;
	
	/* Public constants ==========================================================*/
	/* ===========================================================================*/
	
	
	/* Allowed flush values; see deflate() and inflate() below for details */
	//var Z_NO_FLUSH      = 0;
	//var Z_PARTIAL_FLUSH = 1;
	//var Z_SYNC_FLUSH    = 2;
	//var Z_FULL_FLUSH    = 3;
	var Z_FINISH        = 4;
	var Z_BLOCK         = 5;
	var Z_TREES         = 6;
	
	
	/* Return codes for the compression/decompression functions. Negative values
	 * are errors, positive values are used for special but normal events.
	 */
	var Z_OK            = 0;
	var Z_STREAM_END    = 1;
	var Z_NEED_DICT     = 2;
	//var Z_ERRNO         = -1;
	var Z_STREAM_ERROR  = -2;
	var Z_DATA_ERROR    = -3;
	var Z_MEM_ERROR     = -4;
	var Z_BUF_ERROR     = -5;
	//var Z_VERSION_ERROR = -6;
	
	/* The deflate compression method */
	var Z_DEFLATED  = 8;
	
	
	/* STATES ====================================================================*/
	/* ===========================================================================*/
	
	
	var    HEAD = 1;       /* i: waiting for magic header */
	var    FLAGS = 2;      /* i: waiting for method and flags (gzip) */
	var    TIME = 3;       /* i: waiting for modification time (gzip) */
	var    OS = 4;         /* i: waiting for extra flags and operating system (gzip) */
	var    EXLEN = 5;      /* i: waiting for extra length (gzip) */
	var    EXTRA = 6;      /* i: waiting for extra bytes (gzip) */
	var    NAME = 7;       /* i: waiting for end of file name (gzip) */
	var    COMMENT = 8;    /* i: waiting for end of comment (gzip) */
	var    HCRC = 9;       /* i: waiting for header crc (gzip) */
	var    DICTID = 10;    /* i: waiting for dictionary check value */
	var    DICT = 11;      /* waiting for inflateSetDictionary() call */
	var        TYPE = 12;      /* i: waiting for type bits, including last-flag bit */
	var        TYPEDO = 13;    /* i: same, but skip check to exit inflate on new block */
	var        STORED = 14;    /* i: waiting for stored size (length and complement) */
	var        COPY_ = 15;     /* i/o: same as COPY below, but only first time in */
	var        COPY = 16;      /* i/o: waiting for input or output to copy stored block */
	var        TABLE = 17;     /* i: waiting for dynamic block table lengths */
	var        LENLENS = 18;   /* i: waiting for code length code lengths */
	var        CODELENS = 19;  /* i: waiting for length/lit and distance code lengths */
	var            LEN_ = 20;      /* i: same as LEN below, but only first time in */
	var            LEN = 21;       /* i: waiting for length/lit/eob code */
	var            LENEXT = 22;    /* i: waiting for length extra bits */
	var            DIST = 23;      /* i: waiting for distance code */
	var            DISTEXT = 24;   /* i: waiting for distance extra bits */
	var            MATCH = 25;     /* o: waiting for output space to copy string */
	var            LIT = 26;       /* o: waiting for output space to write literal */
	var    CHECK = 27;     /* i: waiting for 32-bit check value */
	var    LENGTH = 28;    /* i: waiting for 32-bit length (gzip) */
	var    DONE = 29;      /* finished check, done -- remain here until reset */
	var    BAD = 30;       /* got a data error -- remain here until reset */
	var    MEM = 31;       /* got an inflate() memory error -- remain here until reset */
	var    SYNC = 32;      /* looking for synchronization bytes to restart inflate() */
	
	/* ===========================================================================*/
	
	
	
	var ENOUGH_LENS = 852;
	var ENOUGH_DISTS = 592;
	//var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);
	
	var MAX_WBITS = 15;
	/* 32K LZ77 window */
	var DEF_WBITS = MAX_WBITS;
	
	
	function zswap32(q) {
	  return  (((q >>> 24) & 0xff) +
	          ((q >>> 8) & 0xff00) +
	          ((q & 0xff00) << 8) +
	          ((q & 0xff) << 24));
	}
	
	
	function InflateState() {
	  this.mode = 0;             /* current inflate mode */
	  this.last = false;          /* true if processing last block */
	  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
	  this.havedict = false;      /* true if dictionary provided */
	  this.flags = 0;             /* gzip header method and flags (0 if zlib) */
	  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */
	  this.check = 0;             /* protected copy of check value */
	  this.total = 0;             /* protected copy of output count */
	  // TODO: may be {}
	  this.head = null;           /* where to save gzip header information */
	
	  /* sliding window */
	  this.wbits = 0;             /* log base 2 of requested window size */
	  this.wsize = 0;             /* window size or zero if not using window */
	  this.whave = 0;             /* valid bytes in the window */
	  this.wnext = 0;             /* window write index */
	  this.window = null;         /* allocated sliding window, if needed */
	
	  /* bit accumulator */
	  this.hold = 0;              /* input bit accumulator */
	  this.bits = 0;              /* number of bits in "in" */
	
	  /* for string and stored block copying */
	  this.length = 0;            /* literal or length of data to copy */
	  this.offset = 0;            /* distance back to copy string from */
	
	  /* for table and code decoding */
	  this.extra = 0;             /* extra bits needed */
	
	  /* fixed and dynamic code tables */
	  this.lencode = null;          /* starting table for length/literal codes */
	  this.distcode = null;         /* starting table for distance codes */
	  this.lenbits = 0;           /* index bits for lencode */
	  this.distbits = 0;          /* index bits for distcode */
	
	  /* dynamic table building */
	  this.ncode = 0;             /* number of code length code lengths */
	  this.nlen = 0;              /* number of length code lengths */
	  this.ndist = 0;             /* number of distance code lengths */
	  this.have = 0;              /* number of code lengths in lens[] */
	  this.next = null;              /* next available space in codes[] */
	
	  this.lens = new utils.Buf16(320); /* temporary storage for code lengths */
	  this.work = new utils.Buf16(288); /* work area for code table building */
	
	  /*
	   because we don't have pointers in js, we use lencode and distcode directly
	   as buffers so we don't need codes
	  */
	  //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */
	  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */
	  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */
	  this.sane = 0;                   /* if false, allow invalid distance too far */
	  this.back = 0;                   /* bits back of last unprocessed length/lit */
	  this.was = 0;                    /* initial length of match */
	}
	
	function inflateResetKeep(strm) {
	  var state;
	
	  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
	  state = strm.state;
	  strm.total_in = strm.total_out = state.total = 0;
	  strm.msg = ''; /*Z_NULL*/
	  if (state.wrap) {       /* to support ill-conceived Java test suite */
	    strm.adler = state.wrap & 1;
	  }
	  state.mode = HEAD;
	  state.last = 0;
	  state.havedict = 0;
	  state.dmax = 32768;
	  state.head = null/*Z_NULL*/;
	  state.hold = 0;
	  state.bits = 0;
	  //state.lencode = state.distcode = state.next = state.codes;
	  state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
	  state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);
	
	  state.sane = 1;
	  state.back = -1;
	  //Tracev((stderr, "inflate: reset\n"));
	  return Z_OK;
	}
	
	function inflateReset(strm) {
	  var state;
	
	  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
	  state = strm.state;
	  state.wsize = 0;
	  state.whave = 0;
	  state.wnext = 0;
	  return inflateResetKeep(strm);
	
	}
	
	function inflateReset2(strm, windowBits) {
	  var wrap;
	  var state;
	
	  /* get the state */
	  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
	  state = strm.state;
	
	  /* extract wrap request from windowBits parameter */
	  if (windowBits < 0) {
	    wrap = 0;
	    windowBits = -windowBits;
	  }
	  else {
	    wrap = (windowBits >> 4) + 1;
	    if (windowBits < 48) {
	      windowBits &= 15;
	    }
	  }
	
	  /* set number of window bits, free window if different */
	  if (windowBits && (windowBits < 8 || windowBits > 15)) {
	    return Z_STREAM_ERROR;
	  }
	  if (state.window !== null && state.wbits !== windowBits) {
	    state.window = null;
	  }
	
	  /* update state and reset the rest of it */
	  state.wrap = wrap;
	  state.wbits = windowBits;
	  return inflateReset(strm);
	}
	
	function inflateInit2(strm, windowBits) {
	  var ret;
	  var state;
	
	  if (!strm) { return Z_STREAM_ERROR; }
	  //strm.msg = Z_NULL;                 /* in case we return an error */
	
	  state = new InflateState();
	
	  //if (state === Z_NULL) return Z_MEM_ERROR;
	  //Tracev((stderr, "inflate: allocated\n"));
	  strm.state = state;
	  state.window = null/*Z_NULL*/;
	  ret = inflateReset2(strm, windowBits);
	  if (ret !== Z_OK) {
	    strm.state = null/*Z_NULL*/;
	  }
	  return ret;
	}
	
	function inflateInit(strm) {
	  return inflateInit2(strm, DEF_WBITS);
	}
	
	
	/*
	 Return state with length and distance decoding tables and index sizes set to
	 fixed code decoding.  Normally this returns fixed tables from inffixed.h.
	 If BUILDFIXED is defined, then instead this routine builds the tables the
	 first time it's called, and returns those tables the first time and
	 thereafter.  This reduces the size of the code by about 2K bytes, in
	 exchange for a little execution time.  However, BUILDFIXED should not be
	 used for threaded applications, since the rewriting of the tables and virgin
	 may not be thread-safe.
	 */
	var virgin = true;
	
	var lenfix, distfix; // We have no pointers in JS, so keep tables separate
	
	function fixedtables(state) {
	  /* build fixed huffman tables if first call (may not be thread safe) */
	  if (virgin) {
	    var sym;
	
	    lenfix = new utils.Buf32(512);
	    distfix = new utils.Buf32(32);
	
	    /* literal/length table */
	    sym = 0;
	    while (sym < 144) { state.lens[sym++] = 8; }
	    while (sym < 256) { state.lens[sym++] = 9; }
	    while (sym < 280) { state.lens[sym++] = 7; }
	    while (sym < 288) { state.lens[sym++] = 8; }
	
	    inflate_table(LENS,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });
	
	    /* distance table */
	    sym = 0;
	    while (sym < 32) { state.lens[sym++] = 5; }
	
	    inflate_table(DISTS, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });
	
	    /* do this just once */
	    virgin = false;
	  }
	
	  state.lencode = lenfix;
	  state.lenbits = 9;
	  state.distcode = distfix;
	  state.distbits = 5;
	}
	
	
	/*
	 Update the window with the last wsize (normally 32K) bytes written before
	 returning.  If window does not exist yet, create it.  This is only called
	 when a window is already in use, or when output has been written during this
	 inflate call, but the end of the deflate stream has not been reached yet.
	 It is also called to create a window for dictionary data when a dictionary
	 is loaded.
	
	 Providing output buffers larger than 32K to inflate() should provide a speed
	 advantage, since only the last 32K of output is copied to the sliding window
	 upon return from inflate(), and since all distances after the first 32K of
	 output will fall in the output data, making match copies simpler and faster.
	 The advantage may be dependent on the size of the processor's data caches.
	 */
	function updatewindow(strm, src, end, copy) {
	  var dist;
	  var state = strm.state;
	
	  /* if it hasn't been done already, allocate space for the window */
	  if (state.window === null) {
	    state.wsize = 1 << state.wbits;
	    state.wnext = 0;
	    state.whave = 0;
	
	    state.window = new utils.Buf8(state.wsize);
	  }
	
	  /* copy state->wsize or less output bytes into the circular window */
	  if (copy >= state.wsize) {
	    utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
	    state.wnext = 0;
	    state.whave = state.wsize;
	  }
	  else {
	    dist = state.wsize - state.wnext;
	    if (dist > copy) {
	      dist = copy;
	    }
	    //zmemcpy(state->window + state->wnext, end - copy, dist);
	    utils.arraySet(state.window, src, end - copy, dist, state.wnext);
	    copy -= dist;
	    if (copy) {
	      //zmemcpy(state->window, end - copy, copy);
	      utils.arraySet(state.window, src, end - copy, copy, 0);
	      state.wnext = copy;
	      state.whave = state.wsize;
	    }
	    else {
	      state.wnext += dist;
	      if (state.wnext === state.wsize) { state.wnext = 0; }
	      if (state.whave < state.wsize) { state.whave += dist; }
	    }
	  }
	  return 0;
	}
	
	function inflate(strm, flush) {
	  var state;
	  var input, output;          // input/output buffers
	  var next;                   /* next input INDEX */
	  var put;                    /* next output INDEX */
	  var have, left;             /* available input and output */
	  var hold;                   /* bit buffer */
	  var bits;                   /* bits in bit buffer */
	  var _in, _out;              /* save starting available input and output */
	  var copy;                   /* number of stored or match bytes to copy */
	  var from;                   /* where to copy match bytes from */
	  var from_source;
	  var here = 0;               /* current decoding table entry */
	  var here_bits, here_op, here_val; // paked "here" denormalized (JS specific)
	  //var last;                   /* parent table entry */
	  var last_bits, last_op, last_val; // paked "last" denormalized (JS specific)
	  var len;                    /* length to copy for repeats, bits to drop */
	  var ret;                    /* return code */
	  var hbuf = new utils.Buf8(4);    /* buffer for gzip header crc calculation */
	  var opts;
	
	  var n; // temporary var for NEED_BITS
	
	  var order = /* permutation of code lengths */
	    [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];
	
	
	  if (!strm || !strm.state || !strm.output ||
	      (!strm.input && strm.avail_in !== 0)) {
	    return Z_STREAM_ERROR;
	  }
	
	  state = strm.state;
	  if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */
	
	
	  //--- LOAD() ---
	  put = strm.next_out;
	  output = strm.output;
	  left = strm.avail_out;
	  next = strm.next_in;
	  input = strm.input;
	  have = strm.avail_in;
	  hold = state.hold;
	  bits = state.bits;
	  //---
	
	  _in = have;
	  _out = left;
	  ret = Z_OK;
	
	  inf_leave: // goto emulation
	  for (;;) {
	    switch (state.mode) {
	    case HEAD:
	      if (state.wrap === 0) {
	        state.mode = TYPEDO;
	        break;
	      }
	      //=== NEEDBITS(16);
	      while (bits < 16) {
	        if (have === 0) { break inf_leave; }
	        have--;
	        hold += input[next++] << bits;
	        bits += 8;
	      }
	      //===//
	      if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */
	        state.check = 0/*crc32(0L, Z_NULL, 0)*/;
	        //=== CRC2(state.check, hold);
	        hbuf[0] = hold & 0xff;
	        hbuf[1] = (hold >>> 8) & 0xff;
	        state.check = crc32(state.check, hbuf, 2, 0);
	        //===//
	
	        //=== INITBITS();
	        hold = 0;
	        bits = 0;
	        //===//
	        state.mode = FLAGS;
	        break;
	      }
	      state.flags = 0;           /* expect zlib header */
	      if (state.head) {
	        state.head.done = false;
	      }
	      if (!(state.wrap & 1) ||   /* check if zlib header allowed */
	        (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {
	        strm.msg = 'incorrect header check';
	        state.mode = BAD;
	        break;
	      }
	      if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {
	        strm.msg = 'unknown compression method';
	        state.mode = BAD;
	        break;
	      }
	      //--- DROPBITS(4) ---//
	      hold >>>= 4;
	      bits -= 4;
	      //---//
	      len = (hold & 0x0f)/*BITS(4)*/ + 8;
	      if (state.wbits === 0) {
	        state.wbits = len;
	      }
	      else if (len > state.wbits) {
	        strm.msg = 'invalid window size';
	        state.mode = BAD;
	        break;
	      }
	      state.dmax = 1 << len;
	      //Tracev((stderr, "inflate:   zlib header ok\n"));
	      strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
	      state.mode = hold & 0x200 ? DICTID : TYPE;
	      //=== INITBITS();
	      hold = 0;
	      bits = 0;
	      //===//
	      break;
	    case FLAGS:
	      //=== NEEDBITS(16); */
	      while (bits < 16) {
	        if (have === 0) { break inf_leave; }
	        have--;
	        hold += input[next++] << bits;
	        bits += 8;
	      }
	      //===//
	      state.flags = hold;
	      if ((state.flags & 0xff) !== Z_DEFLATED) {
	        strm.msg = 'unknown compression method';
	        state.mode = BAD;
	        break;
	      }
	      if (state.flags & 0xe000) {
	        strm.msg = 'unknown header flags set';
	        state.mode = BAD;
	        break;
	      }
	      if (state.head) {
	        state.head.text = ((hold >> 8) & 1);
	      }
	      if (state.flags & 0x0200) {
	        //=== CRC2(state.check, hold);
	        hbuf[0] = hold & 0xff;
	        hbuf[1] = (hold >>> 8) & 0xff;
	        state.check = crc32(state.check, hbuf, 2, 0);
	        //===//
	      }
	      //=== INITBITS();
	      hold = 0;
	      bits = 0;
	      //===//
	      state.mode = TIME;
	      /* falls through */
	    case TIME:
	      //=== NEEDBITS(32); */
	      while (bits < 32) {
	        if (have === 0) { break inf_leave; }
	        have--;
	        hold += input[next++] << bits;
	        bits += 8;
	      }
	      //===//
	      if (state.head) {
	        state.head.time = hold;
	      }
	      if (state.flags & 0x0200) {
	        //=== CRC4(state.check, hold)
	        hbuf[0] = hold & 0xff;
	        hbuf[1] = (hold >>> 8) & 0xff;
	        hbuf[2] = (hold >>> 16) & 0xff;
	        hbuf[3] = (hold >>> 24) & 0xff;
	        state.check = crc32(state.check, hbuf, 4, 0);
	        //===
	      }
	      //=== INITBITS();
	      hold = 0;
	      bits = 0;
	      //===//
	      state.mode = OS;
	      /* falls through */
	    case OS:
	      //=== NEEDBITS(16); */
	      while (bits < 16) {
	        if (have === 0) { break inf_leave; }
	        have--;
	        hold += input[next++] << bits;
	        bits += 8;
	      }
	      //===//
	      if (state.head) {
	        state.head.xflags = (hold & 0xff);
	        state.head.os = (hold >> 8);
	      }
	      if (state.flags & 0x0200) {
	        //=== CRC2(state.check, hold);
	        hbuf[0] = hold & 0xff;
	        hbuf[1] = (hold >>> 8) & 0xff;
	        state.check = crc32(state.check, hbuf, 2, 0);
	        //===//
	      }
	      //=== INITBITS();
	      hold = 0;
	      bits = 0;
	      //===//
	      state.mode = EXLEN;
	      /* falls through */
	    case EXLEN:
	      if (state.flags & 0x0400) {
	        //=== NEEDBITS(16); */
	        while (bits < 16) {
	          if (have === 0) { break inf_leave; }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	        }
	        //===//
	        state.length = hold;
	        if (state.head) {
	          state.head.extra_len = hold;
	        }
	        if (state.flags & 0x0200) {
	          //=== CRC2(state.check, hold);
	          hbuf[0] = hold & 0xff;
	          hbuf[1] = (hold >>> 8) & 0xff;
	          state.check = crc32(state.check, hbuf, 2, 0);
	          //===//
	        }
	        //=== INITBITS();
	        hold = 0;
	        bits = 0;
	        //===//
	      }
	      else if (state.head) {
	        state.head.extra = null/*Z_NULL*/;
	      }
	      state.mode = EXTRA;
	      /* falls through */
	    case EXTRA:
	      if (state.flags & 0x0400) {
	        copy = state.length;
	        if (copy > have) { copy = have; }
	        if (copy) {
	          if (state.head) {
	            len = state.head.extra_len - state.length;
	            if (!state.head.extra) {
	              // Use untyped array for more conveniend processing later
	              state.head.extra = new Array(state.head.extra_len);
	            }
	            utils.arraySet(
	              state.head.extra,
	              input,
	              next,
	              // extra field is limited to 65536 bytes
	              // - no need for additional size check
	              copy,
	              /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
	              len
	            );
	            //zmemcpy(state.head.extra + len, next,
	            //        len + copy > state.head.extra_max ?
	            //        state.head.extra_max - len : copy);
	          }
	          if (state.flags & 0x0200) {
	            state.check = crc32(state.check, input, copy, next);
	          }
	          have -= copy;
	          next += copy;
	          state.length -= copy;
	        }
	        if (state.length) { break inf_leave; }
	      }
	      state.length = 0;
	      state.mode = NAME;
	      /* falls through */
	    case NAME:
	      if (state.flags & 0x0800) {
	        if (have === 0) { break inf_leave; }
	        copy = 0;
	        do {
	          // TODO: 2 or 1 bytes?
	          len = input[next + copy++];
	          /* use constant limit because in js we should not preallocate memory */
	          if (state.head && len &&
	              (state.length < 65536 /*state.head.name_max*/)) {
	            state.head.name += String.fromCharCode(len);
	          }
	        } while (len && copy < have);
	
	        if (state.flags & 0x0200) {
	          state.check = crc32(state.check, input, copy, next);
	        }
	        have -= copy;
	        next += copy;
	        if (len) { break inf_leave; }
	      }
	      else if (state.head) {
	        state.head.name = null;
	      }
	      state.length = 0;
	      state.mode = COMMENT;
	      /* falls through */
	    case COMMENT:
	      if (state.flags & 0x1000) {
	        if (have === 0) { break inf_leave; }
	        copy = 0;
	        do {
	          len = input[next + copy++];
	          /* use constant limit because in js we should not preallocate memory */
	          if (state.head && len &&
	              (state.length < 65536 /*state.head.comm_max*/)) {
	            state.head.comment += String.fromCharCode(len);
	          }
	        } while (len && copy < have);
	        if (state.flags & 0x0200) {
	          state.check = crc32(state.check, input, copy, next);
	        }
	        have -= copy;
	        next += copy;
	        if (len) { break inf_leave; }
	      }
	      else if (state.head) {
	        state.head.comment = null;
	      }
	      state.mode = HCRC;
	      /* falls through */
	    case HCRC:
	      if (state.flags & 0x0200) {
	        //=== NEEDBITS(16); */
	        while (bits < 16) {
	          if (have === 0) { break inf_leave; }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	        }
	        //===//
	        if (hold !== (state.check & 0xffff)) {
	          strm.msg = 'header crc mismatch';
	          state.mode = BAD;
	          break;
	        }
	        //=== INITBITS();
	        hold = 0;
	        bits = 0;
	        //===//
	      }
	      if (state.head) {
	        state.head.hcrc = ((state.flags >> 9) & 1);
	        state.head.done = true;
	      }
	      strm.adler = state.check = 0;
	      state.mode = TYPE;
	      break;
	    case DICTID:
	      //=== NEEDBITS(32); */
	      while (bits < 32) {
	        if (have === 0) { break inf_leave; }
	        have--;
	        hold += input[next++] << bits;
	        bits += 8;
	      }
	      //===//
	      strm.adler = state.check = zswap32(hold);
	      //=== INITBITS();
	      hold = 0;
	      bits = 0;
	      //===//
	      state.mode = DICT;
	      /* falls through */
	    case DICT:
	      if (state.havedict === 0) {
	        //--- RESTORE() ---
	        strm.next_out = put;
	        strm.avail_out = left;
	        strm.next_in = next;
	        strm.avail_in = have;
	        state.hold = hold;
	        state.bits = bits;
	        //---
	        return Z_NEED_DICT;
	      }
	      strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
	      state.mode = TYPE;
	      /* falls through */
	    case TYPE:
	      if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }
	      /* falls through */
	    case TYPEDO:
	      if (state.last) {
	        //--- BYTEBITS() ---//
	        hold >>>= bits & 7;
	        bits -= bits & 7;
	        //---//
	        state.mode = CHECK;
	        break;
	      }
	      //=== NEEDBITS(3); */
	      while (bits < 3) {
	        if (have === 0) { break inf_leave; }
	        have--;
	        hold += input[next++] << bits;
	        bits += 8;
	      }
	      //===//
	      state.last = (hold & 0x01)/*BITS(1)*/;
	      //--- DROPBITS(1) ---//
	      hold >>>= 1;
	      bits -= 1;
	      //---//
	
	      switch ((hold & 0x03)/*BITS(2)*/) {
	      case 0:                             /* stored block */
	        //Tracev((stderr, "inflate:     stored block%s\n",
	        //        state.last ? " (last)" : ""));
	        state.mode = STORED;
	        break;
	      case 1:                             /* fixed block */
	        fixedtables(state);
	        //Tracev((stderr, "inflate:     fixed codes block%s\n",
	        //        state.last ? " (last)" : ""));
	        state.mode = LEN_;             /* decode codes */
	        if (flush === Z_TREES) {
	          //--- DROPBITS(2) ---//
	          hold >>>= 2;
	          bits -= 2;
	          //---//
	          break inf_leave;
	        }
	        break;
	      case 2:                             /* dynamic block */
	        //Tracev((stderr, "inflate:     dynamic codes block%s\n",
	        //        state.last ? " (last)" : ""));
	        state.mode = TABLE;
	        break;
	      case 3:
	        strm.msg = 'invalid block type';
	        state.mode = BAD;
	      }
	      //--- DROPBITS(2) ---//
	      hold >>>= 2;
	      bits -= 2;
	      //---//
	      break;
	    case STORED:
	      //--- BYTEBITS() ---// /* go to byte boundary */
	      hold >>>= bits & 7;
	      bits -= bits & 7;
	      //---//
	      //=== NEEDBITS(32); */
	      while (bits < 32) {
	        if (have === 0) { break inf_leave; }
	        have--;
	        hold += input[next++] << bits;
	        bits += 8;
	      }
	      //===//
	      if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {
	        strm.msg = 'invalid stored block lengths';
	        state.mode = BAD;
	        break;
	      }
	      state.length = hold & 0xffff;
	      //Tracev((stderr, "inflate:       stored length %u\n",
	      //        state.length));
	      //=== INITBITS();
	      hold = 0;
	      bits = 0;
	      //===//
	      state.mode = COPY_;
	      if (flush === Z_TREES) { break inf_leave; }
	      /* falls through */
	    case COPY_:
	      state.mode = COPY;
	      /* falls through */
	    case COPY:
	      copy = state.length;
	      if (copy) {
	        if (copy > have) { copy = have; }
	        if (copy > left) { copy = left; }
	        if (copy === 0) { break inf_leave; }
	        //--- zmemcpy(put, next, copy); ---
	        utils.arraySet(output, input, next, copy, put);
	        //---//
	        have -= copy;
	        next += copy;
	        left -= copy;
	        put += copy;
	        state.length -= copy;
	        break;
	      }
	      //Tracev((stderr, "inflate:       stored end\n"));
	      state.mode = TYPE;
	      break;
	    case TABLE:
	      //=== NEEDBITS(14); */
	      while (bits < 14) {
	        if (have === 0) { break inf_leave; }
	        have--;
	        hold += input[next++] << bits;
	        bits += 8;
	      }
	      //===//
	      state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;
	      //--- DROPBITS(5) ---//
	      hold >>>= 5;
	      bits -= 5;
	      //---//
	      state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;
	      //--- DROPBITS(5) ---//
	      hold >>>= 5;
	      bits -= 5;
	      //---//
	      state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;
	      //--- DROPBITS(4) ---//
	      hold >>>= 4;
	      bits -= 4;
	      //---//
	//#ifndef PKZIP_BUG_WORKAROUND
	      if (state.nlen > 286 || state.ndist > 30) {
	        strm.msg = 'too many length or distance symbols';
	        state.mode = BAD;
	        break;
	      }
	//#endif
	      //Tracev((stderr, "inflate:       table sizes ok\n"));
	      state.have = 0;
	      state.mode = LENLENS;
	      /* falls through */
	    case LENLENS:
	      while (state.have < state.ncode) {
	        //=== NEEDBITS(3);
	        while (bits < 3) {
	          if (have === 0) { break inf_leave; }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	        }
	        //===//
	        state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);
	        //--- DROPBITS(3) ---//
	        hold >>>= 3;
	        bits -= 3;
	        //---//
	      }
	      while (state.have < 19) {
	        state.lens[order[state.have++]] = 0;
	      }
	      // We have separate tables & no pointers. 2 commented lines below not needed.
	      //state.next = state.codes;
	      //state.lencode = state.next;
	      // Switch to use dynamic table
	      state.lencode = state.lendyn;
	      state.lenbits = 7;
	
	      opts = { bits: state.lenbits };
	      ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
	      state.lenbits = opts.bits;
	
	      if (ret) {
	        strm.msg = 'invalid code lengths set';
	        state.mode = BAD;
	        break;
	      }
	      //Tracev((stderr, "inflate:       code lengths ok\n"));
	      state.have = 0;
	      state.mode = CODELENS;
	      /* falls through */
	    case CODELENS:
	      while (state.have < state.nlen + state.ndist) {
	        for (;;) {
	          here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/
	          here_bits = here >>> 24;
	          here_op = (here >>> 16) & 0xff;
	          here_val = here & 0xffff;
	
	          if ((here_bits) <= bits) { break; }
	          //--- PULLBYTE() ---//
	          if (have === 0) { break inf_leave; }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	          //---//
	        }
	        if (here_val < 16) {
	          //--- DROPBITS(here.bits) ---//
	          hold >>>= here_bits;
	          bits -= here_bits;
	          //---//
	          state.lens[state.have++] = here_val;
	        }
	        else {
	          if (here_val === 16) {
	            //=== NEEDBITS(here.bits + 2);
	            n = here_bits + 2;
	            while (bits < n) {
	              if (have === 0) { break inf_leave; }
	              have--;
	              hold += input[next++] << bits;
	              bits += 8;
	            }
	            //===//
	            //--- DROPBITS(here.bits) ---//
	            hold >>>= here_bits;
	            bits -= here_bits;
	            //---//
	            if (state.have === 0) {
	              strm.msg = 'invalid bit length repeat';
	              state.mode = BAD;
	              break;
	            }
	            len = state.lens[state.have - 1];
	            copy = 3 + (hold & 0x03);//BITS(2);
	            //--- DROPBITS(2) ---//
	            hold >>>= 2;
	            bits -= 2;
	            //---//
	          }
	          else if (here_val === 17) {
	            //=== NEEDBITS(here.bits + 3);
	            n = here_bits + 3;
	            while (bits < n) {
	              if (have === 0) { break inf_leave; }
	              have--;
	              hold += input[next++] << bits;
	              bits += 8;
	            }
	            //===//
	            //--- DROPBITS(here.bits) ---//
	            hold >>>= here_bits;
	            bits -= here_bits;
	            //---//
	            len = 0;
	            copy = 3 + (hold & 0x07);//BITS(3);
	            //--- DROPBITS(3) ---//
	            hold >>>= 3;
	            bits -= 3;
	            //---//
	          }
	          else {
	            //=== NEEDBITS(here.bits + 7);
	            n = here_bits + 7;
	            while (bits < n) {
	              if (have === 0) { break inf_leave; }
	              have--;
	              hold += input[next++] << bits;
	              bits += 8;
	            }
	            //===//
	            //--- DROPBITS(here.bits) ---//
	            hold >>>= here_bits;
	            bits -= here_bits;
	            //---//
	            len = 0;
	            copy = 11 + (hold & 0x7f);//BITS(7);
	            //--- DROPBITS(7) ---//
	            hold >>>= 7;
	            bits -= 7;
	            //---//
	          }
	          if (state.have + copy > state.nlen + state.ndist) {
	            strm.msg = 'invalid bit length repeat';
	            state.mode = BAD;
	            break;
	          }
	          while (copy--) {
	            state.lens[state.have++] = len;
	          }
	        }
	      }
	
	      /* handle error breaks in while */
	      if (state.mode === BAD) { break; }
	
	      /* check for end-of-block code (better have one) */
	      if (state.lens[256] === 0) {
	        strm.msg = 'invalid code -- missing end-of-block';
	        state.mode = BAD;
	        break;
	      }
	
	      /* build code tables -- note: do not change the lenbits or distbits
	         values here (9 and 6) without reading the comments in inftrees.h
	         concerning the ENOUGH constants, which depend on those values */
	      state.lenbits = 9;
	
	      opts = { bits: state.lenbits };
	      ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
	      // We have separate tables & no pointers. 2 commented lines below not needed.
	      // state.next_index = opts.table_index;
	      state.lenbits = opts.bits;
	      // state.lencode = state.next;
	
	      if (ret) {
	        strm.msg = 'invalid literal/lengths set';
	        state.mode = BAD;
	        break;
	      }
	
	      state.distbits = 6;
	      //state.distcode.copy(state.codes);
	      // Switch to use dynamic table
	      state.distcode = state.distdyn;
	      opts = { bits: state.distbits };
	      ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
	      // We have separate tables & no pointers. 2 commented lines below not needed.
	      // state.next_index = opts.table_index;
	      state.distbits = opts.bits;
	      // state.distcode = state.next;
	
	      if (ret) {
	        strm.msg = 'invalid distances set';
	        state.mode = BAD;
	        break;
	      }
	      //Tracev((stderr, 'inflate:       codes ok\n'));
	      state.mode = LEN_;
	      if (flush === Z_TREES) { break inf_leave; }
	      /* falls through */
	    case LEN_:
	      state.mode = LEN;
	      /* falls through */
	    case LEN:
	      if (have >= 6 && left >= 258) {
	        //--- RESTORE() ---
	        strm.next_out = put;
	        strm.avail_out = left;
	        strm.next_in = next;
	        strm.avail_in = have;
	        state.hold = hold;
	        state.bits = bits;
	        //---
	        inflate_fast(strm, _out);
	        //--- LOAD() ---
	        put = strm.next_out;
	        output = strm.output;
	        left = strm.avail_out;
	        next = strm.next_in;
	        input = strm.input;
	        have = strm.avail_in;
	        hold = state.hold;
	        bits = state.bits;
	        //---
	
	        if (state.mode === TYPE) {
	          state.back = -1;
	        }
	        break;
	      }
	      state.back = 0;
	      for (;;) {
	        here = state.lencode[hold & ((1 << state.lenbits) - 1)];  /*BITS(state.lenbits)*/
	        here_bits = here >>> 24;
	        here_op = (here >>> 16) & 0xff;
	        here_val = here & 0xffff;
	
	        if (here_bits <= bits) { break; }
	        //--- PULLBYTE() ---//
	        if (have === 0) { break inf_leave; }
	        have--;
	        hold += input[next++] << bits;
	        bits += 8;
	        //---//
	      }
	      if (here_op && (here_op & 0xf0) === 0) {
	        last_bits = here_bits;
	        last_op = here_op;
	        last_val = here_val;
	        for (;;) {
	          here = state.lencode[last_val +
	                  ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
	          here_bits = here >>> 24;
	          here_op = (here >>> 16) & 0xff;
	          here_val = here & 0xffff;
	
	          if ((last_bits + here_bits) <= bits) { break; }
	          //--- PULLBYTE() ---//
	          if (have === 0) { break inf_leave; }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	          //---//
	        }
	        //--- DROPBITS(last.bits) ---//
	        hold >>>= last_bits;
	        bits -= last_bits;
	        //---//
	        state.back += last_bits;
	      }
	      //--- DROPBITS(here.bits) ---//
	      hold >>>= here_bits;
	      bits -= here_bits;
	      //---//
	      state.back += here_bits;
	      state.length = here_val;
	      if (here_op === 0) {
	        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
	        //        "inflate:         literal '%c'\n" :
	        //        "inflate:         literal 0x%02x\n", here.val));
	        state.mode = LIT;
	        break;
	      }
	      if (here_op & 32) {
	        //Tracevv((stderr, "inflate:         end of block\n"));
	        state.back = -1;
	        state.mode = TYPE;
	        break;
	      }
	      if (here_op & 64) {
	        strm.msg = 'invalid literal/length code';
	        state.mode = BAD;
	        break;
	      }
	      state.extra = here_op & 15;
	      state.mode = LENEXT;
	      /* falls through */
	    case LENEXT:
	      if (state.extra) {
	        //=== NEEDBITS(state.extra);
	        n = state.extra;
	        while (bits < n) {
	          if (have === 0) { break inf_leave; }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	        }
	        //===//
	        state.length += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
	        //--- DROPBITS(state.extra) ---//
	        hold >>>= state.extra;
	        bits -= state.extra;
	        //---//
	        state.back += state.extra;
	      }
	      //Tracevv((stderr, "inflate:         length %u\n", state.length));
	      state.was = state.length;
	      state.mode = DIST;
	      /* falls through */
	    case DIST:
	      for (;;) {
	        here = state.distcode[hold & ((1 << state.distbits) - 1)];/*BITS(state.distbits)*/
	        here_bits = here >>> 24;
	        here_op = (here >>> 16) & 0xff;
	        here_val = here & 0xffff;
	
	        if ((here_bits) <= bits) { break; }
	        //--- PULLBYTE() ---//
	        if (have === 0) { break inf_leave; }
	        have--;
	        hold += input[next++] << bits;
	        bits += 8;
	        //---//
	      }
	      if ((here_op & 0xf0) === 0) {
	        last_bits = here_bits;
	        last_op = here_op;
	        last_val = here_val;
	        for (;;) {
	          here = state.distcode[last_val +
	                  ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
	          here_bits = here >>> 24;
	          here_op = (here >>> 16) & 0xff;
	          here_val = here & 0xffff;
	
	          if ((last_bits + here_bits) <= bits) { break; }
	          //--- PULLBYTE() ---//
	          if (have === 0) { break inf_leave; }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	          //---//
	        }
	        //--- DROPBITS(last.bits) ---//
	        hold >>>= last_bits;
	        bits -= last_bits;
	        //---//
	        state.back += last_bits;
	      }
	      //--- DROPBITS(here.bits) ---//
	      hold >>>= here_bits;
	      bits -= here_bits;
	      //---//
	      state.back += here_bits;
	      if (here_op & 64) {
	        strm.msg = 'invalid distance code';
	        state.mode = BAD;
	        break;
	      }
	      state.offset = here_val;
	      state.extra = (here_op) & 15;
	      state.mode = DISTEXT;
	      /* falls through */
	    case DISTEXT:
	      if (state.extra) {
	        //=== NEEDBITS(state.extra);
	        n = state.extra;
	        while (bits < n) {
	          if (have === 0) { break inf_leave; }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	        }
	        //===//
	        state.offset += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
	        //--- DROPBITS(state.extra) ---//
	        hold >>>= state.extra;
	        bits -= state.extra;
	        //---//
	        state.back += state.extra;
	      }
	//#ifdef INFLATE_STRICT
	      if (state.offset > state.dmax) {
	        strm.msg = 'invalid distance too far back';
	        state.mode = BAD;
	        break;
	      }
	//#endif
	      //Tracevv((stderr, "inflate:         distance %u\n", state.offset));
	      state.mode = MATCH;
	      /* falls through */
	    case MATCH:
	      if (left === 0) { break inf_leave; }
	      copy = _out - left;
	      if (state.offset > copy) {         /* copy from window */
	        copy = state.offset - copy;
	        if (copy > state.whave) {
	          if (state.sane) {
	            strm.msg = 'invalid distance too far back';
	            state.mode = BAD;
	            break;
	          }
	// (!) This block is disabled in zlib defailts,
	// don't enable it for binary compatibility
	//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
	//          Trace((stderr, "inflate.c too far\n"));
	//          copy -= state.whave;
	//          if (copy > state.length) { copy = state.length; }
	//          if (copy > left) { copy = left; }
	//          left -= copy;
	//          state.length -= copy;
	//          do {
	//            output[put++] = 0;
	//          } while (--copy);
	//          if (state.length === 0) { state.mode = LEN; }
	//          break;
	//#endif
	        }
	        if (copy > state.wnext) {
	          copy -= state.wnext;
	          from = state.wsize - copy;
	        }
	        else {
	          from = state.wnext - copy;
	        }
	        if (copy > state.length) { copy = state.length; }
	        from_source = state.window;
	      }
	      else {                              /* copy from output */
	        from_source = output;
	        from = put - state.offset;
	        copy = state.length;
	      }
	      if (copy > left) { copy = left; }
	      left -= copy;
	      state.length -= copy;
	      do {
	        output[put++] = from_source[from++];
	      } while (--copy);
	      if (state.length === 0) { state.mode = LEN; }
	      break;
	    case LIT:
	      if (left === 0) { break inf_leave; }
	      output[put++] = state.length;
	      left--;
	      state.mode = LEN;
	      break;
	    case CHECK:
	      if (state.wrap) {
	        //=== NEEDBITS(32);
	        while (bits < 32) {
	          if (have === 0) { break inf_leave; }
	          have--;
	          // Use '|' insdead of '+' to make sure that result is signed
	          hold |= input[next++] << bits;
	          bits += 8;
	        }
	        //===//
	        _out -= left;
	        strm.total_out += _out;
	        state.total += _out;
	        if (_out) {
	          strm.adler = state.check =
	              /*UPDATE(state.check, put - _out, _out);*/
	              (state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out));
	
	        }
	        _out = left;
	        // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too
	        if ((state.flags ? hold : zswap32(hold)) !== state.check) {
	          strm.msg = 'incorrect data check';
	          state.mode = BAD;
	          break;
	        }
	        //=== INITBITS();
	        hold = 0;
	        bits = 0;
	        //===//
	        //Tracev((stderr, "inflate:   check matches trailer\n"));
	      }
	      state.mode = LENGTH;
	      /* falls through */
	    case LENGTH:
	      if (state.wrap && state.flags) {
	        //=== NEEDBITS(32);
	        while (bits < 32) {
	          if (have === 0) { break inf_leave; }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	        }
	        //===//
	        if (hold !== (state.total & 0xffffffff)) {
	          strm.msg = 'incorrect length check';
	          state.mode = BAD;
	          break;
	        }
	        //=== INITBITS();
	        hold = 0;
	        bits = 0;
	        //===//
	        //Tracev((stderr, "inflate:   length matches trailer\n"));
	      }
	      state.mode = DONE;
	      /* falls through */
	    case DONE:
	      ret = Z_STREAM_END;
	      break inf_leave;
	    case BAD:
	      ret = Z_DATA_ERROR;
	      break inf_leave;
	    case MEM:
	      return Z_MEM_ERROR;
	    case SYNC:
	      /* falls through */
	    default:
	      return Z_STREAM_ERROR;
	    }
	  }
	
	  // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"
	
	  /*
	     Return from inflate(), updating the total counts and the check value.
	     If there was no progress during the inflate() call, return a buffer
	     error.  Call updatewindow() to create and/or update the window state.
	     Note: a memory error from inflate() is non-recoverable.
	   */
	
	  //--- RESTORE() ---
	  strm.next_out = put;
	  strm.avail_out = left;
	  strm.next_in = next;
	  strm.avail_in = have;
	  state.hold = hold;
	  state.bits = bits;
	  //---
	
	  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&
	                      (state.mode < CHECK || flush !== Z_FINISH))) {
	    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
	      state.mode = MEM;
	      return Z_MEM_ERROR;
	    }
	  }
	  _in -= strm.avail_in;
	  _out -= strm.avail_out;
	  strm.total_in += _in;
	  strm.total_out += _out;
	  state.total += _out;
	  if (state.wrap && _out) {
	    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
	      (state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out));
	  }
	  strm.data_type = state.bits + (state.last ? 64 : 0) +
	                    (state.mode === TYPE ? 128 : 0) +
	                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
	  if (((_in === 0 && _out === 0) || flush === Z_FINISH) && ret === Z_OK) {
	    ret = Z_BUF_ERROR;
	  }
	  return ret;
	}
	
	function inflateEnd(strm) {
	
	  if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {
	    return Z_STREAM_ERROR;
	  }
	
	  var state = strm.state;
	  if (state.window) {
	    state.window = null;
	  }
	  strm.state = null;
	  return Z_OK;
	}
	
	function inflateGetHeader(strm, head) {
	  var state;
	
	  /* check state */
	  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
	  state = strm.state;
	  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR; }
	
	  /* save header structure */
	  state.head = head;
	  head.done = false;
	  return Z_OK;
	}
	
	function inflateSetDictionary(strm, dictionary) {
	  var dictLength = dictionary.length;
	
	  var state;
	  var dictid;
	  var ret;
	
	  /* check state */
	  if (!strm /* == Z_NULL */ || !strm.state /* == Z_NULL */) { return Z_STREAM_ERROR; }
	  state = strm.state;
	
	  if (state.wrap !== 0 && state.mode !== DICT) {
	    return Z_STREAM_ERROR;
	  }
	
	  /* check for correct dictionary identifier */
	  if (state.mode === DICT) {
	    dictid = 1; /* adler32(0, null, 0)*/
	    /* dictid = adler32(dictid, dictionary, dictLength); */
	    dictid = adler32(dictid, dictionary, dictLength, 0);
	    if (dictid !== state.check) {
	      return Z_DATA_ERROR;
	    }
	  }
	  /* copy dictionary to window using updatewindow(), which will amend the
	   existing dictionary if appropriate */
	  ret = updatewindow(strm, dictionary, dictLength, dictLength);
	  if (ret) {
	    state.mode = MEM;
	    return Z_MEM_ERROR;
	  }
	  state.havedict = 1;
	  // Tracev((stderr, "inflate:   dictionary set\n"));
	  return Z_OK;
	}
	
	exports.inflateReset = inflateReset;
	exports.inflateReset2 = inflateReset2;
	exports.inflateResetKeep = inflateResetKeep;
	exports.inflateInit = inflateInit;
	exports.inflateInit2 = inflateInit2;
	exports.inflate = inflate;
	exports.inflateEnd = inflateEnd;
	exports.inflateGetHeader = inflateGetHeader;
	exports.inflateSetDictionary = inflateSetDictionary;
	exports.inflateInfo = 'pako inflate (from Nodeca project)';
	
	/* Not implemented
	exports.inflateCopy = inflateCopy;
	exports.inflateGetDictionary = inflateGetDictionary;
	exports.inflateMark = inflateMark;
	exports.inflatePrime = inflatePrime;
	exports.inflateSync = inflateSync;
	exports.inflateSyncPoint = inflateSyncPoint;
	exports.inflateUndermine = inflateUndermine;
	*/


/***/ },
/* 33 */
/***/ function(module, exports) {

	'use strict';
	
	
	var TYPED_OK =  (typeof Uint8Array !== 'undefined') &&
	                (typeof Uint16Array !== 'undefined') &&
	                (typeof Int32Array !== 'undefined');
	
	
	exports.assign = function (obj /*from1, from2, from3, ...*/) {
	  var sources = Array.prototype.slice.call(arguments, 1);
	  while (sources.length) {
	    var source = sources.shift();
	    if (!source) { continue; }
	
	    if (typeof source !== 'object') {
	      throw new TypeError(source + 'must be non-object');
	    }
	
	    for (var p in source) {
	      if (source.hasOwnProperty(p)) {
	        obj[p] = source[p];
	      }
	    }
	  }
	
	  return obj;
	};
	
	
	// reduce buffer size, avoiding mem copy
	exports.shrinkBuf = function (buf, size) {
	  if (buf.length === size) { return buf; }
	  if (buf.subarray) { return buf.subarray(0, size); }
	  buf.length = size;
	  return buf;
	};
	
	
	var fnTyped = {
	  arraySet: function (dest, src, src_offs, len, dest_offs) {
	    if (src.subarray && dest.subarray) {
	      dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
	      return;
	    }
	    // Fallback to ordinary array
	    for (var i = 0; i < len; i++) {
	      dest[dest_offs + i] = src[src_offs + i];
	    }
	  },
	  // Join array of chunks to single array.
	  flattenChunks: function (chunks) {
	    var i, l, len, pos, chunk, result;
	
	    // calculate data length
	    len = 0;
	    for (i = 0, l = chunks.length; i < l; i++) {
	      len += chunks[i].length;
	    }
	
	    // join chunks
	    result = new Uint8Array(len);
	    pos = 0;
	    for (i = 0, l = chunks.length; i < l; i++) {
	      chunk = chunks[i];
	      result.set(chunk, pos);
	      pos += chunk.length;
	    }
	
	    return result;
	  }
	};
	
	var fnUntyped = {
	  arraySet: function (dest, src, src_offs, len, dest_offs) {
	    for (var i = 0; i < len; i++) {
	      dest[dest_offs + i] = src[src_offs + i];
	    }
	  },
	  // Join array of chunks to single array.
	  flattenChunks: function (chunks) {
	    return [].concat.apply([], chunks);
	  }
	};
	
	
	// Enable/Disable typed arrays use, for testing
	//
	exports.setTyped = function (on) {
	  if (on) {
	    exports.Buf8  = Uint8Array;
	    exports.Buf16 = Uint16Array;
	    exports.Buf32 = Int32Array;
	    exports.assign(exports, fnTyped);
	  } else {
	    exports.Buf8  = Array;
	    exports.Buf16 = Array;
	    exports.Buf32 = Array;
	    exports.assign(exports, fnUntyped);
	  }
	};
	
	exports.setTyped(TYPED_OK);


/***/ },
/* 34 */
/***/ function(module, exports) {

	'use strict';
	
	// Note: adler32 takes 12% for level 0 and 2% for level 6.
	// It doesn't worth to make additional optimizationa as in original.
	// Small size is preferable.
	
	function adler32(adler, buf, len, pos) {
	  var s1 = (adler & 0xffff) |0,
	      s2 = ((adler >>> 16) & 0xffff) |0,
	      n = 0;
	
	  while (len !== 0) {
	    // Set limit ~ twice less than 5552, to keep
	    // s2 in 31-bits, because we force signed ints.
	    // in other case %= will fail.
	    n = len > 2000 ? 2000 : len;
	    len -= n;
	
	    do {
	      s1 = (s1 + buf[pos++]) |0;
	      s2 = (s2 + s1) |0;
	    } while (--n);
	
	    s1 %= 65521;
	    s2 %= 65521;
	  }
	
	  return (s1 | (s2 << 16)) |0;
	}
	
	
	module.exports = adler32;


/***/ },
/* 35 */
/***/ function(module, exports) {

	'use strict';
	
	// Note: we can't get significant speed boost here.
	// So write code to minimize size - no pregenerated tables
	// and array tools dependencies.
	
	
	// Use ordinary array, since untyped makes no boost here
	function makeTable() {
	  var c, table = [];
	
	  for (var n = 0; n < 256; n++) {
	    c = n;
	    for (var k = 0; k < 8; k++) {
	      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
	    }
	    table[n] = c;
	  }
	
	  return table;
	}
	
	// Create table on load. Just 255 signed longs. Not a problem.
	var crcTable = makeTable();
	
	
	function crc32(crc, buf, len, pos) {
	  var t = crcTable,
	      end = pos + len;
	
	  crc ^= -1;
	
	  for (var i = pos; i < end; i++) {
	    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];
	  }
	
	  return (crc ^ (-1)); // >>> 0;
	}
	
	
	module.exports = crc32;


/***/ },
/* 36 */
/***/ function(module, exports) {

	'use strict';
	
	// See state defs from inflate.js
	var BAD = 30;       /* got a data error -- remain here until reset */
	var TYPE = 12;      /* i: waiting for type bits, including last-flag bit */
	
	/*
	   Decode literal, length, and distance codes and write out the resulting
	   literal and match bytes until either not enough input or output is
	   available, an end-of-block is encountered, or a data error is encountered.
	   When large enough input and output buffers are supplied to inflate(), for
	   example, a 16K input buffer and a 64K output buffer, more than 95% of the
	   inflate execution time is spent in this routine.
	
	   Entry assumptions:
	
	        state.mode === LEN
	        strm.avail_in >= 6
	        strm.avail_out >= 258
	        start >= strm.avail_out
	        state.bits < 8
	
	   On return, state.mode is one of:
	
	        LEN -- ran out of enough output space or enough available input
	        TYPE -- reached end of block code, inflate() to interpret next block
	        BAD -- error in block data
	
	   Notes:
	
	    - The maximum input bits used by a length/distance pair is 15 bits for the
	      length code, 5 bits for the length extra, 15 bits for the distance code,
	      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
	      Therefore if strm.avail_in >= 6, then there is enough input to avoid
	      checking for available input while decoding.
	
	    - The maximum bytes that a single length/distance pair can output is 258
	      bytes, which is the maximum length that can be coded.  inflate_fast()
	      requires strm.avail_out >= 258 for each loop to avoid checking for
	      output space.
	 */
	module.exports = function inflate_fast(strm, start) {
	  var state;
	  var _in;                    /* local strm.input */
	  var last;                   /* have enough input while in < last */
	  var _out;                   /* local strm.output */
	  var beg;                    /* inflate()'s initial strm.output */
	  var end;                    /* while out < end, enough space available */
	//#ifdef INFLATE_STRICT
	  var dmax;                   /* maximum distance from zlib header */
	//#endif
	  var wsize;                  /* window size or zero if not using window */
	  var whave;                  /* valid bytes in the window */
	  var wnext;                  /* window write index */
	  // Use `s_window` instead `window`, avoid conflict with instrumentation tools
	  var s_window;               /* allocated sliding window, if wsize != 0 */
	  var hold;                   /* local strm.hold */
	  var bits;                   /* local strm.bits */
	  var lcode;                  /* local strm.lencode */
	  var dcode;                  /* local strm.distcode */
	  var lmask;                  /* mask for first level of length codes */
	  var dmask;                  /* mask for first level of distance codes */
	  var here;                   /* retrieved table entry */
	  var op;                     /* code bits, operation, extra bits, or */
	                              /*  window position, window bytes to copy */
	  var len;                    /* match length, unused bytes */
	  var dist;                   /* match distance */
	  var from;                   /* where to copy match from */
	  var from_source;
	
	
	  var input, output; // JS specific, because we have no pointers
	
	  /* copy state to local variables */
	  state = strm.state;
	  //here = state.here;
	  _in = strm.next_in;
	  input = strm.input;
	  last = _in + (strm.avail_in - 5);
	  _out = strm.next_out;
	  output = strm.output;
	  beg = _out - (start - strm.avail_out);
	  end = _out + (strm.avail_out - 257);
	//#ifdef INFLATE_STRICT
	  dmax = state.dmax;
	//#endif
	  wsize = state.wsize;
	  whave = state.whave;
	  wnext = state.wnext;
	  s_window = state.window;
	  hold = state.hold;
	  bits = state.bits;
	  lcode = state.lencode;
	  dcode = state.distcode;
	  lmask = (1 << state.lenbits) - 1;
	  dmask = (1 << state.distbits) - 1;
	
	
	  /* decode literals and length/distances until end-of-block or not enough
	     input data or output space */
	
	  top:
	  do {
	    if (bits < 15) {
	      hold += input[_in++] << bits;
	      bits += 8;
	      hold += input[_in++] << bits;
	      bits += 8;
	    }
	
	    here = lcode[hold & lmask];
	
	    dolen:
	    for (;;) { // Goto emulation
	      op = here >>> 24/*here.bits*/;
	      hold >>>= op;
	      bits -= op;
	      op = (here >>> 16) & 0xff/*here.op*/;
	      if (op === 0) {                          /* literal */
	        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
	        //        "inflate:         literal '%c'\n" :
	        //        "inflate:         literal 0x%02x\n", here.val));
	        output[_out++] = here & 0xffff/*here.val*/;
	      }
	      else if (op & 16) {                     /* length base */
	        len = here & 0xffff/*here.val*/;
	        op &= 15;                           /* number of extra bits */
	        if (op) {
	          if (bits < op) {
	            hold += input[_in++] << bits;
	            bits += 8;
	          }
	          len += hold & ((1 << op) - 1);
	          hold >>>= op;
	          bits -= op;
	        }
	        //Tracevv((stderr, "inflate:         length %u\n", len));
	        if (bits < 15) {
	          hold += input[_in++] << bits;
	          bits += 8;
	          hold += input[_in++] << bits;
	          bits += 8;
	        }
	        here = dcode[hold & dmask];
	
	        dodist:
	        for (;;) { // goto emulation
	          op = here >>> 24/*here.bits*/;
	          hold >>>= op;
	          bits -= op;
	          op = (here >>> 16) & 0xff/*here.op*/;
	
	          if (op & 16) {                      /* distance base */
	            dist = here & 0xffff/*here.val*/;
	            op &= 15;                       /* number of extra bits */
	            if (bits < op) {
	              hold += input[_in++] << bits;
	              bits += 8;
	              if (bits < op) {
	                hold += input[_in++] << bits;
	                bits += 8;
	              }
	            }
	            dist += hold & ((1 << op) - 1);
	//#ifdef INFLATE_STRICT
	            if (dist > dmax) {
	              strm.msg = 'invalid distance too far back';
	              state.mode = BAD;
	              break top;
	            }
	//#endif
	            hold >>>= op;
	            bits -= op;
	            //Tracevv((stderr, "inflate:         distance %u\n", dist));
	            op = _out - beg;                /* max distance in output */
	            if (dist > op) {                /* see if copy from window */
	              op = dist - op;               /* distance back in window */
	              if (op > whave) {
	                if (state.sane) {
	                  strm.msg = 'invalid distance too far back';
	                  state.mode = BAD;
	                  break top;
	                }
	
	// (!) This block is disabled in zlib defailts,
	// don't enable it for binary compatibility
	//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
	//                if (len <= op - whave) {
	//                  do {
	//                    output[_out++] = 0;
	//                  } while (--len);
	//                  continue top;
	//                }
	//                len -= op - whave;
	//                do {
	//                  output[_out++] = 0;
	//                } while (--op > whave);
	//                if (op === 0) {
	//                  from = _out - dist;
	//                  do {
	//                    output[_out++] = output[from++];
	//                  } while (--len);
	//                  continue top;
	//                }
	//#endif
	              }
	              from = 0; // window index
	              from_source = s_window;
	              if (wnext === 0) {           /* very common case */
	                from += wsize - op;
	                if (op < len) {         /* some from window */
	                  len -= op;
	                  do {
	                    output[_out++] = s_window[from++];
	                  } while (--op);
	                  from = _out - dist;  /* rest from output */
	                  from_source = output;
	                }
	              }
	              else if (wnext < op) {      /* wrap around window */
	                from += wsize + wnext - op;
	                op -= wnext;
	                if (op < len) {         /* some from end of window */
	                  len -= op;
	                  do {
	                    output[_out++] = s_window[from++];
	                  } while (--op);
	                  from = 0;
	                  if (wnext < len) {  /* some from start of window */
	                    op = wnext;
	                    len -= op;
	                    do {
	                      output[_out++] = s_window[from++];
	                    } while (--op);
	                    from = _out - dist;      /* rest from output */
	                    from_source = output;
	                  }
	                }
	              }
	              else {                      /* contiguous in window */
	                from += wnext - op;
	                if (op < len) {         /* some from window */
	                  len -= op;
	                  do {
	                    output[_out++] = s_window[from++];
	                  } while (--op);
	                  from = _out - dist;  /* rest from output */
	                  from_source = output;
	                }
	              }
	              while (len > 2) {
	                output[_out++] = from_source[from++];
	                output[_out++] = from_source[from++];
	                output[_out++] = from_source[from++];
	                len -= 3;
	              }
	              if (len) {
	                output[_out++] = from_source[from++];
	                if (len > 1) {
	                  output[_out++] = from_source[from++];
	                }
	              }
	            }
	            else {
	              from = _out - dist;          /* copy direct from output */
	              do {                        /* minimum length is three */
	                output[_out++] = output[from++];
	                output[_out++] = output[from++];
	                output[_out++] = output[from++];
	                len -= 3;
	              } while (len > 2);
	              if (len) {
	                output[_out++] = output[from++];
	                if (len > 1) {
	                  output[_out++] = output[from++];
	                }
	              }
	            }
	          }
	          else if ((op & 64) === 0) {          /* 2nd level distance code */
	            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
	            continue dodist;
	          }
	          else {
	            strm.msg = 'invalid distance code';
	            state.mode = BAD;
	            break top;
	          }
	
	          break; // need to emulate goto via "continue"
	        }
	      }
	      else if ((op & 64) === 0) {              /* 2nd level length code */
	        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
	        continue dolen;
	      }
	      else if (op & 32) {                     /* end-of-block */
	        //Tracevv((stderr, "inflate:         end of block\n"));
	        state.mode = TYPE;
	        break top;
	      }
	      else {
	        strm.msg = 'invalid literal/length code';
	        state.mode = BAD;
	        break top;
	      }
	
	      break; // need to emulate goto via "continue"
	    }
	  } while (_in < last && _out < end);
	
	  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
	  len = bits >> 3;
	  _in -= len;
	  bits -= len << 3;
	  hold &= (1 << bits) - 1;
	
	  /* update state and return */
	  strm.next_in = _in;
	  strm.next_out = _out;
	  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));
	  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));
	  state.hold = hold;
	  state.bits = bits;
	  return;
	};


/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	
	var utils = __webpack_require__(33);
	
	var MAXBITS = 15;
	var ENOUGH_LENS = 852;
	var ENOUGH_DISTS = 592;
	//var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);
	
	var CODES = 0;
	var LENS = 1;
	var DISTS = 2;
	
	var lbase = [ /* Length codes 257..285 base */
	  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
	  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
	];
	
	var lext = [ /* Length codes 257..285 extra */
	  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
	  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78
	];
	
	var dbase = [ /* Distance codes 0..29 base */
	  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
	  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
	  8193, 12289, 16385, 24577, 0, 0
	];
	
	var dext = [ /* Distance codes 0..29 extra */
	  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
	  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
	  28, 28, 29, 29, 64, 64
	];
	
	module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts)
	{
	  var bits = opts.bits;
	      //here = opts.here; /* table entry for duplication */
	
	  var len = 0;               /* a code's length in bits */
	  var sym = 0;               /* index of code symbols */
	  var min = 0, max = 0;          /* minimum and maximum code lengths */
	  var root = 0;              /* number of index bits for root table */
	  var curr = 0;              /* number of index bits for current table */
	  var drop = 0;              /* code bits to drop for sub-table */
	  var left = 0;                   /* number of prefix codes available */
	  var used = 0;              /* code entries in table used */
	  var huff = 0;              /* Huffman code */
	  var incr;              /* for incrementing code, index */
	  var fill;              /* index for replicating entries */
	  var low;               /* low bits for current root entry */
	  var mask;              /* mask for low root bits */
	  var next;             /* next available space in table */
	  var base = null;     /* base value table to use */
	  var base_index = 0;
	//  var shoextra;    /* extra bits table to use */
	  var end;                    /* use base and extra for symbol > end */
	  var count = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */
	  var offs = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */
	  var extra = null;
	  var extra_index = 0;
	
	  var here_bits, here_op, here_val;
	
	  /*
	   Process a set of code lengths to create a canonical Huffman code.  The
	   code lengths are lens[0..codes-1].  Each length corresponds to the
	   symbols 0..codes-1.  The Huffman code is generated by first sorting the
	   symbols by length from short to long, and retaining the symbol order
	   for codes with equal lengths.  Then the code starts with all zero bits
	   for the first code of the shortest length, and the codes are integer
	   increments for the same length, and zeros are appended as the length
	   increases.  For the deflate format, these bits are stored backwards
	   from their more natural integer increment ordering, and so when the
	   decoding tables are built in the large loop below, the integer codes
	   are incremented backwards.
	
	   This routine assumes, but does not check, that all of the entries in
	   lens[] are in the range 0..MAXBITS.  The caller must assure this.
	   1..MAXBITS is interpreted as that code length.  zero means that that
	   symbol does not occur in this code.
	
	   The codes are sorted by computing a count of codes for each length,
	   creating from that a table of starting indices for each length in the
	   sorted table, and then entering the symbols in order in the sorted
	   table.  The sorted table is work[], with that space being provided by
	   the caller.
	
	   The length counts are used for other purposes as well, i.e. finding
	   the minimum and maximum length codes, determining if there are any
	   codes at all, checking for a valid set of lengths, and looking ahead
	   at length counts to determine sub-table sizes when building the
	   decoding tables.
	   */
	
	  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
	  for (len = 0; len <= MAXBITS; len++) {
	    count[len] = 0;
	  }
	  for (sym = 0; sym < codes; sym++) {
	    count[lens[lens_index + sym]]++;
	  }
	
	  /* bound code lengths, force root to be within code lengths */
	  root = bits;
	  for (max = MAXBITS; max >= 1; max--) {
	    if (count[max] !== 0) { break; }
	  }
	  if (root > max) {
	    root = max;
	  }
	  if (max === 0) {                     /* no symbols to code at all */
	    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */
	    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;
	    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;
	    table[table_index++] = (1 << 24) | (64 << 16) | 0;
	
	
	    //table.op[opts.table_index] = 64;
	    //table.bits[opts.table_index] = 1;
	    //table.val[opts.table_index++] = 0;
	    table[table_index++] = (1 << 24) | (64 << 16) | 0;
	
	    opts.bits = 1;
	    return 0;     /* no symbols, but wait for decoding to report error */
	  }
	  for (min = 1; min < max; min++) {
	    if (count[min] !== 0) { break; }
	  }
	  if (root < min) {
	    root = min;
	  }
	
	  /* check for an over-subscribed or incomplete set of lengths */
	  left = 1;
	  for (len = 1; len <= MAXBITS; len++) {
	    left <<= 1;
	    left -= count[len];
	    if (left < 0) {
	      return -1;
	    }        /* over-subscribed */
	  }
	  if (left > 0 && (type === CODES || max !== 1)) {
	    return -1;                      /* incomplete set */
	  }
	
	  /* generate offsets into symbol table for each length for sorting */
	  offs[1] = 0;
	  for (len = 1; len < MAXBITS; len++) {
	    offs[len + 1] = offs[len] + count[len];
	  }
	
	  /* sort symbols by length, by symbol order within each length */
	  for (sym = 0; sym < codes; sym++) {
	    if (lens[lens_index + sym] !== 0) {
	      work[offs[lens[lens_index + sym]]++] = sym;
	    }
	  }
	
	  /*
	   Create and fill in decoding tables.  In this loop, the table being
	   filled is at next and has curr index bits.  The code being used is huff
	   with length len.  That code is converted to an index by dropping drop
	   bits off of the bottom.  For codes where len is less than drop + curr,
	   those top drop + curr - len bits are incremented through all values to
	   fill the table with replicated entries.
	
	   root is the number of index bits for the root table.  When len exceeds
	   root, sub-tables are created pointed to by the root entry with an index
	   of the low root bits of huff.  This is saved in low to check for when a
	   new sub-table should be started.  drop is zero when the root table is
	   being filled, and drop is root when sub-tables are being filled.
	
	   When a new sub-table is needed, it is necessary to look ahead in the
	   code lengths to determine what size sub-table is needed.  The length
	   counts are used for this, and so count[] is decremented as codes are
	   entered in the tables.
	
	   used keeps track of how many table entries have been allocated from the
	   provided *table space.  It is checked for LENS and DIST tables against
	   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
	   the initial root table size constants.  See the comments in inftrees.h
	   for more information.
	
	   sym increments through all symbols, and the loop terminates when
	   all codes of length max, i.e. all codes, have been processed.  This
	   routine permits incomplete codes, so another loop after this one fills
	   in the rest of the decoding tables with invalid code markers.
	   */
	
	  /* set up for code type */
	  // poor man optimization - use if-else instead of switch,
	  // to avoid deopts in old v8
	  if (type === CODES) {
	    base = extra = work;    /* dummy value--not used */
	    end = 19;
	
	  } else if (type === LENS) {
	    base = lbase;
	    base_index -= 257;
	    extra = lext;
	    extra_index -= 257;
	    end = 256;
	
	  } else {                    /* DISTS */
	    base = dbase;
	    extra = dext;
	    end = -1;
	  }
	
	  /* initialize opts for loop */
	  huff = 0;                   /* starting code */
	  sym = 0;                    /* starting code symbol */
	  len = min;                  /* starting code length */
	  next = table_index;              /* current table to fill in */
	  curr = root;                /* current table index bits */
	  drop = 0;                   /* current bits to drop from code for index */
	  low = -1;                   /* trigger new sub-table when len > root */
	  used = 1 << root;          /* use root table entries */
	  mask = used - 1;            /* mask for comparing low */
	
	  /* check available table space */
	  if ((type === LENS && used > ENOUGH_LENS) ||
	    (type === DISTS && used > ENOUGH_DISTS)) {
	    return 1;
	  }
	
	  /* process all codes and make table entries */
	  for (;;) {
	    /* create table entry */
	    here_bits = len - drop;
	    if (work[sym] < end) {
	      here_op = 0;
	      here_val = work[sym];
	    }
	    else if (work[sym] > end) {
	      here_op = extra[extra_index + work[sym]];
	      here_val = base[base_index + work[sym]];
	    }
	    else {
	      here_op = 32 + 64;         /* end of block */
	      here_val = 0;
	    }
	
	    /* replicate for those indices with low len bits equal to huff */
	    incr = 1 << (len - drop);
	    fill = 1 << curr;
	    min = fill;                 /* save offset to next table */
	    do {
	      fill -= incr;
	      table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;
	    } while (fill !== 0);
	
	    /* backwards increment the len-bit code huff */
	    incr = 1 << (len - 1);
	    while (huff & incr) {
	      incr >>= 1;
	    }
	    if (incr !== 0) {
	      huff &= incr - 1;
	      huff += incr;
	    } else {
	      huff = 0;
	    }
	
	    /* go to next symbol, update count, len */
	    sym++;
	    if (--count[len] === 0) {
	      if (len === max) { break; }
	      len = lens[lens_index + work[sym]];
	    }
	
	    /* create new sub-table if needed */
	    if (len > root && (huff & mask) !== low) {
	      /* if first time, transition to sub-tables */
	      if (drop === 0) {
	        drop = root;
	      }
	
	      /* increment past last table */
	      next += min;            /* here min is 1 << curr */
	
	      /* determine length of next table */
	      curr = len - drop;
	      left = 1 << curr;
	      while (curr + drop < max) {
	        left -= count[curr + drop];
	        if (left <= 0) { break; }
	        curr++;
	        left <<= 1;
	      }
	
	      /* check for enough space */
	      used += 1 << curr;
	      if ((type === LENS && used > ENOUGH_LENS) ||
	        (type === DISTS && used > ENOUGH_DISTS)) {
	        return 1;
	      }
	
	      /* point entry in root table to sub-table */
	      low = huff & mask;
	      /*table.op[low] = curr;
	      table.bits[low] = root;
	      table.val[low] = next - opts.table_index;*/
	      table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;
	    }
	  }
	
	  /* fill in remaining table entry if code is incomplete (guaranteed to have
	   at most one remaining entry, since if the code is incomplete, the
	   maximum code length that was allowed to get this far is one bit) */
	  if (huff !== 0) {
	    //table.op[next + huff] = 64;            /* invalid code marker */
	    //table.bits[next + huff] = len - drop;
	    //table.val[next + huff] = 0;
	    table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;
	  }
	
	  /* set return parameters */
	  //opts.table_index += used;
	  opts.bits = root;
	  return 0;
	};


/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	// String encode/decode helpers
	'use strict';
	
	
	var utils = __webpack_require__(33);
	
	
	// Quick check if we can use fast array to bin string conversion
	//
	// - apply(Array) can fail on Android 2.2
	// - apply(Uint8Array) can fail on iOS 5.1 Safary
	//
	var STR_APPLY_OK = true;
	var STR_APPLY_UIA_OK = true;
	
	try { String.fromCharCode.apply(null, [ 0 ]); } catch (__) { STR_APPLY_OK = false; }
	try { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }
	
	
	// Table with utf8 lengths (calculated by first byte of sequence)
	// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
	// because max possible codepoint is 0x10ffff
	var _utf8len = new utils.Buf8(256);
	for (var q = 0; q < 256; q++) {
	  _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);
	}
	_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start
	
	
	// convert string to array (typed, when possible)
	exports.string2buf = function (str) {
	  var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
	
	  // count binary size
	  for (m_pos = 0; m_pos < str_len; m_pos++) {
	    c = str.charCodeAt(m_pos);
	    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
	      c2 = str.charCodeAt(m_pos + 1);
	      if ((c2 & 0xfc00) === 0xdc00) {
	        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
	        m_pos++;
	      }
	    }
	    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
	  }
	
	  // allocate buffer
	  buf = new utils.Buf8(buf_len);
	
	  // convert
	  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
	    c = str.charCodeAt(m_pos);
	    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
	      c2 = str.charCodeAt(m_pos + 1);
	      if ((c2 & 0xfc00) === 0xdc00) {
	        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
	        m_pos++;
	      }
	    }
	    if (c < 0x80) {
	      /* one byte */
	      buf[i++] = c;
	    } else if (c < 0x800) {
	      /* two bytes */
	      buf[i++] = 0xC0 | (c >>> 6);
	      buf[i++] = 0x80 | (c & 0x3f);
	    } else if (c < 0x10000) {
	      /* three bytes */
	      buf[i++] = 0xE0 | (c >>> 12);
	      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
	      buf[i++] = 0x80 | (c & 0x3f);
	    } else {
	      /* four bytes */
	      buf[i++] = 0xf0 | (c >>> 18);
	      buf[i++] = 0x80 | (c >>> 12 & 0x3f);
	      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
	      buf[i++] = 0x80 | (c & 0x3f);
	    }
	  }
	
	  return buf;
	};
	
	// Helper (used in 2 places)
	function buf2binstring(buf, len) {
	  // use fallback for big arrays to avoid stack overflow
	  if (len < 65537) {
	    if ((buf.subarray && STR_APPLY_UIA_OK) || (!buf.subarray && STR_APPLY_OK)) {
	      return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
	    }
	  }
	
	  var result = '';
	  for (var i = 0; i < len; i++) {
	    result += String.fromCharCode(buf[i]);
	  }
	  return result;
	}
	
	
	// Convert byte array to binary string
	exports.buf2binstring = function (buf) {
	  return buf2binstring(buf, buf.length);
	};
	
	
	// Convert binary string (typed, when possible)
	exports.binstring2buf = function (str) {
	  var buf = new utils.Buf8(str.length);
	  for (var i = 0, len = buf.length; i < len; i++) {
	    buf[i] = str.charCodeAt(i);
	  }
	  return buf;
	};
	
	
	// convert array to string
	exports.buf2string = function (buf, max) {
	  var i, out, c, c_len;
	  var len = max || buf.length;
	
	  // Reserve max possible length (2 words per char)
	  // NB: by unknown reasons, Array is significantly faster for
	  //     String.fromCharCode.apply than Uint16Array.
	  var utf16buf = new Array(len * 2);
	
	  for (out = 0, i = 0; i < len;) {
	    c = buf[i++];
	    // quick process ascii
	    if (c < 0x80) { utf16buf[out++] = c; continue; }
	
	    c_len = _utf8len[c];
	    // skip 5 & 6 byte codes
	    if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }
	
	    // apply mask on first byte
	    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
	    // join the rest
	    while (c_len > 1 && i < len) {
	      c = (c << 6) | (buf[i++] & 0x3f);
	      c_len--;
	    }
	
	    // terminated by end of string?
	    if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }
	
	    if (c < 0x10000) {
	      utf16buf[out++] = c;
	    } else {
	      c -= 0x10000;
	      utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);
	      utf16buf[out++] = 0xdc00 | (c & 0x3ff);
	    }
	  }
	
	  return buf2binstring(utf16buf, out);
	};
	
	
	// Calculate max possible position in utf8 buffer,
	// that will not break sequence. If that's not possible
	// - (very small limits) return max size as is.
	//
	// buf[] - utf8 bytes array
	// max   - length limit (mandatory);
	exports.utf8border = function (buf, max) {
	  var pos;
	
	  max = max || buf.length;
	  if (max > buf.length) { max = buf.length; }
	
	  // go back from last position, until start of sequence found
	  pos = max - 1;
	  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }
	
	  // Fuckup - very small and broken sequence,
	  // return max, because we should return something anyway.
	  if (pos < 0) { return max; }
	
	  // If we came to start of buffer - that means vuffer is too small,
	  // return max too.
	  if (pos === 0) { return max; }
	
	  return (pos + _utf8len[buf[pos]] > max) ? pos : max;
	};


/***/ },
/* 39 */
/***/ function(module, exports) {

	'use strict';
	
	
	module.exports = {
	
	  /* Allowed flush values; see deflate() and inflate() below for details */
	  Z_NO_FLUSH:         0,
	  Z_PARTIAL_FLUSH:    1,
	  Z_SYNC_FLUSH:       2,
	  Z_FULL_FLUSH:       3,
	  Z_FINISH:           4,
	  Z_BLOCK:            5,
	  Z_TREES:            6,
	
	  /* Return codes for the compression/decompression functions. Negative values
	  * are errors, positive values are used for special but normal events.
	  */
	  Z_OK:               0,
	  Z_STREAM_END:       1,
	  Z_NEED_DICT:        2,
	  Z_ERRNO:           -1,
	  Z_STREAM_ERROR:    -2,
	  Z_DATA_ERROR:      -3,
	  //Z_MEM_ERROR:     -4,
	  Z_BUF_ERROR:       -5,
	  //Z_VERSION_ERROR: -6,
	
	  /* compression levels */
	  Z_NO_COMPRESSION:         0,
	  Z_BEST_SPEED:             1,
	  Z_BEST_COMPRESSION:       9,
	  Z_DEFAULT_COMPRESSION:   -1,
	
	
	  Z_FILTERED:               1,
	  Z_HUFFMAN_ONLY:           2,
	  Z_RLE:                    3,
	  Z_FIXED:                  4,
	  Z_DEFAULT_STRATEGY:       0,
	
	  /* Possible values of the data_type field (though see inflate()) */
	  Z_BINARY:                 0,
	  Z_TEXT:                   1,
	  //Z_ASCII:                1, // = Z_TEXT (deprecated)
	  Z_UNKNOWN:                2,
	
	  /* The deflate compression method */
	  Z_DEFLATED:               8
	  //Z_NULL:                 null // Use -1 or null inline, depending on var type
	};


/***/ },
/* 40 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = {
	  2:      'need dictionary',     /* Z_NEED_DICT       2  */
	  1:      'stream end',          /* Z_STREAM_END      1  */
	  0:      '',                    /* Z_OK              0  */
	  '-1':   'file error',          /* Z_ERRNO         (-1) */
	  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */
	  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */
	  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */
	  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */
	  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */
	};


/***/ },
/* 41 */
/***/ function(module, exports) {

	'use strict';
	
	
	function ZStream() {
	  /* next input byte */
	  this.input = null; // JS specific, because we have no pointers
	  this.next_in = 0;
	  /* number of bytes available at input */
	  this.avail_in = 0;
	  /* total number of input bytes read so far */
	  this.total_in = 0;
	  /* next output byte should be put there */
	  this.output = null; // JS specific, because we have no pointers
	  this.next_out = 0;
	  /* remaining free space at output */
	  this.avail_out = 0;
	  /* total number of bytes output so far */
	  this.total_out = 0;
	  /* last error message, NULL if no error */
	  this.msg = ''/*Z_NULL*/;
	  /* not visible by applications */
	  this.state = null;
	  /* best guess about the data type: binary or text */
	  this.data_type = 2/*Z_UNKNOWN*/;
	  /* adler32 value of the uncompressed data */
	  this.adler = 0;
	}
	
	module.exports = ZStream;


/***/ },
/* 42 */
/***/ function(module, exports) {

	'use strict';
	
	
	function GZheader() {
	  /* true if compressed data believed to be text */
	  this.text       = 0;
	  /* modification time */
	  this.time       = 0;
	  /* extra flags (not used when writing a gzip file) */
	  this.xflags     = 0;
	  /* operating system */
	  this.os         = 0;
	  /* pointer to extra field or Z_NULL if none */
	  this.extra      = null;
	  /* extra field length (valid if extra != Z_NULL) */
	  this.extra_len  = 0; // Actually, we don't need it in JS,
	                       // but leave for few code modifications
	
	  //
	  // Setup limits is not necessary because in js we should not preallocate memory
	  // for inflate use constant limit in 65536 bytes
	  //
	
	  /* space at extra (only when reading header) */
	  // this.extra_max  = 0;
	  /* pointer to zero-terminated file name or Z_NULL */
	  this.name       = '';
	  /* space at name (only when reading header) */
	  // this.name_max   = 0;
	  /* pointer to zero-terminated comment or Z_NULL */
	  this.comment    = '';
	  /* space at comment (only when reading header) */
	  // this.comm_max   = 0;
	  /* true if there was or will be a header crc */
	  this.hcrc       = 0;
	  /* true when done reading gzip header (not used when writing a gzip file) */
	  this.done       = false;
	}
	
	module.exports = GZheader;


/***/ }
/******/ ])
});
;


/***/ }),

/***/ 320:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(385);


/***/ }),

/***/ 385:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: ../node_modules/@emotion/core/dist/core.browser.esm.js + 10 modules
var core_browser_esm = __webpack_require__(1);

// EXTERNAL MODULE: ../node_modules/reflect-metadata/Reflect.js
var Reflect = __webpack_require__(179);

// EXTERNAL MODULE: ../node_modules/react-dom/index.js
var react_dom = __webpack_require__(102);
var react_dom_default = /*#__PURE__*/__webpack_require__.n(react_dom);

// EXTERNAL MODULE: ../node_modules/react/index.js
var react = __webpack_require__(0);

// CONCATENATED MODULE: ./components/PopupRoot.tsx


function PopupRoot() {
  return Object(core_browser_esm["a" /* jsx */])("div", null, "PopUp");
}
// CONCATENATED MODULE: ./extension/Popup.tsx





react_dom_default.a.render(Object(core_browser_esm["a" /* jsx */])(PopupRoot, null), document.getElementById('app'));

/***/ }),

/***/ 5:
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9yZWFjdC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0BlbW90aW9uL3NoZWV0L2Rpc3Qvc2hlZXQuYnJvd3Nlci5lc20uanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AZW1vdGlvbi9zdHlsaXMvZGlzdC9zdHlsaXMuYnJvd3Nlci5lc20uanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AZW1vdGlvbi93ZWFrLW1lbW9pemUvZGlzdC93ZWFrLW1lbW9pemUuYnJvd3Nlci5lc20uanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AZW1vdGlvbi9jYWNoZS9kaXN0L2NhY2hlLmJyb3dzZXIuZXNtLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQGVtb3Rpb24vdXRpbHMvZGlzdC91dGlscy5icm93c2VyLmVzbS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0BlbW90aW9uL2hhc2gvZGlzdC9oYXNoLmJyb3dzZXIuZXNtLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQGVtb3Rpb24vdW5pdGxlc3MvZGlzdC91bml0bGVzcy5icm93c2VyLmVzbS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0BlbW90aW9uL21lbW9pemUvZGlzdC9tZW1vaXplLmJyb3dzZXIuZXNtLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQGVtb3Rpb24vc2VyaWFsaXplL2Rpc3Qvc2VyaWFsaXplLmJyb3dzZXIuZXNtLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQGVtb3Rpb24vY3NzL2Rpc3QvY3NzLmJyb3dzZXIuZXNtLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQGVtb3Rpb24vY29yZS9kaXN0L2NvcmUuYnJvd3Nlci5lc20uanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9vYmplY3QtYXNzaWduL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LnByb2R1Y3Rpb24ubWluLmpzIiwid2VicGFjazovLy9SZWZsZWN0LnRzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2Nqcy9yZWFjdC1kb20ucHJvZHVjdGlvbi5taW4uanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9zY2hlZHVsZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9zY2hlZHVsZXIvY2pzL3NjaGVkdWxlci5wcm9kdWN0aW9uLm1pbi5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2Jyb3dzZXJmcy9kaXN0L3NoaW1zL3Byb2Nlc3MuanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy93ZWJwYWNrOi8vL3dlYnBhY2svYm9vdHN0cmFwIDc1OTk3NjlhMDZkMTY3ODZhOGM3Iiwid2VicGFjazovLy93ZWJwYWNrOi8vL3NyYy9jb3JlL2FwaV9lcnJvci50cyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9zcmMvY29yZS9maWxlX2ZsYWcudHMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vc3JjL2NvcmUvbm9kZV9mc19zdGF0cy50cyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9zcmMvY29yZS9GUy50cyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9zcmMvY29yZS9ub2RlX2ZzLnRzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL3NyYy9jb3JlL2xldmVuc2h0ZWluLnRzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL3NyYy9jb3JlL3V0aWwudHMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vc3JjL2dlbmVyaWMvZW1zY3JpcHRlbl9mcy50cyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9zcmMvY29yZS9maWxlX3N5c3RlbS50cyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9zcmMvY29yZS9maWxlLnRzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL3NyYy9nZW5lcmljL3ByZWxvYWRfZmlsZS50cyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9zcmMvYmFja2VuZC9Bc3luY01pcnJvci50cyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9+L2xvZGFzaC1lcy9fYXBwbHkuanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vfi9sb2Rhc2gtZXMvX292ZXJSZXN0LmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL34vbG9kYXNoLWVzL2lkZW50aXR5LmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL34vYXN5bmMtZXMvaW50ZXJuYWwvcmVzdC5qcyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9+L2FzeW5jLWVzL2ludGVybmFsL2luaXRpYWxQYXJhbXMuanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vfi9hc3luYy1lcy9pbnRlcm5hbC9hcHBseUVhY2guanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vfi9sb2Rhc2gtZXMvX2ZyZWVHbG9iYWwuanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vfi9sb2Rhc2gtZXMvX3Jvb3QuanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vfi9sb2Rhc2gtZXMvX1N5bWJvbC5qcyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9+L2xvZGFzaC1lcy9fZ2V0UmF3VGFnLmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL34vbG9kYXNoLWVzL19vYmplY3RUb1N0cmluZy5qcyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9+L2xvZGFzaC1lcy9fYmFzZUdldFRhZy5qcyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9+L2xvZGFzaC1lcy9pc09iamVjdC5qcyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9+L2xvZGFzaC1lcy9pc0Z1bmN0aW9uLmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL34vbG9kYXNoLWVzL2lzTGVuZ3RoLmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL34vbG9kYXNoLWVzL2lzQXJyYXlMaWtlLmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL34vYXN5bmMtZXMvaW50ZXJuYWwvYnJlYWtMb29wLmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL34vbG9kYXNoLWVzL25vb3AuanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vfi9hc3luYy1lcy9pbnRlcm5hbC9vbmNlLmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL34vYXN5bmMtZXMvaW50ZXJuYWwvZ2V0SXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vfi9sb2Rhc2gtZXMvX2Jhc2VUaW1lcy5qcyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9+L2xvZGFzaC1lcy9pc09iamVjdExpa2UuanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vfi9sb2Rhc2gtZXMvX2Jhc2VJc0FyZ3VtZW50cy5qcyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9+L2xvZGFzaC1lcy9pc0FyZ3VtZW50cy5qcyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9+L2xvZGFzaC1lcy9pc0FycmF5LmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL34vbG9kYXNoLWVzL3N0dWJGYWxzZS5qcyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9+L2xvZGFzaC1lcy9pc0J1ZmZlci5qcyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9+L2xvZGFzaC1lcy9faXNJbmRleC5qcyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9+L2xvZGFzaC1lcy9fYmFzZUlzVHlwZWRBcnJheS5qcyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9+L2xvZGFzaC1lcy9fYmFzZVVuYXJ5LmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL34vbG9kYXNoLWVzL19ub2RlVXRpbC5qcyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9+L2xvZGFzaC1lcy9pc1R5cGVkQXJyYXkuanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vfi9sb2Rhc2gtZXMvX2FycmF5TGlrZUtleXMuanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vfi9sb2Rhc2gtZXMvX2lzUHJvdG90eXBlLmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL34vbG9kYXNoLWVzL19vdmVyQXJnLmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL34vbG9kYXNoLWVzL19uYXRpdmVLZXlzLmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL34vbG9kYXNoLWVzL19iYXNlS2V5cy5qcyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9+L2xvZGFzaC1lcy9rZXlzLmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL34vYXN5bmMtZXMvaW50ZXJuYWwvaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vfi9hc3luYy1lcy9pbnRlcm5hbC9vbmx5T25jZS5qcyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9+L2FzeW5jLWVzL2ludGVybmFsL2VhY2hPZkxpbWl0LmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL34vYXN5bmMtZXMvZWFjaE9mTGltaXQuanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vfi9hc3luYy1lcy9pbnRlcm5hbC9kb0xpbWl0LmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL34vYXN5bmMtZXMvZWFjaE9mLmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL34vYXN5bmMtZXMvaW50ZXJuYWwvZG9QYXJhbGxlbC5qcyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9+L2FzeW5jLWVzL2ludGVybmFsL21hcC5qcyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9+L2FzeW5jLWVzL21hcC5qcyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9+L2FzeW5jLWVzL2FwcGx5RWFjaC5qcyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9+L2FzeW5jLWVzL2ludGVybmFsL2RvUGFyYWxsZWxMaW1pdC5qcyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9+L2FzeW5jLWVzL21hcExpbWl0LmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL34vYXN5bmMtZXMvbWFwU2VyaWVzLmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL34vYXN5bmMtZXMvYXBwbHlFYWNoU2VyaWVzLmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL34vYXN5bmMtZXMvYXBwbHkuanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vfi9sb2Rhc2gtZXMvX2FycmF5RWFjaC5qcyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9+L2xvZGFzaC1lcy9fY3JlYXRlQmFzZUZvci5qcyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9+L2xvZGFzaC1lcy9fYmFzZUZvci5qcyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9+L2xvZGFzaC1lcy9fYmFzZUZvck93bi5qcyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9+L2xvZGFzaC1lcy9fYmFzZUZpbmRJbmRleC5qcyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9+L2xvZGFzaC1lcy9fYmFzZUlzTmFOLmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL34vbG9kYXNoLWVzL19zdHJpY3RJbmRleE9mLmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL34vbG9kYXNoLWVzL19iYXNlSW5kZXhPZi5qcyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9+L2FzeW5jLWVzL2F1dG8uanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vfi9sb2Rhc2gtZXMvX2FycmF5TWFwLmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL34vbG9kYXNoLWVzL19iYXNlU2xpY2UuanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vfi9sb2Rhc2gtZXMvX2FzY2lpVG9BcnJheS5qcyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9+L2xvZGFzaC1lcy9faGFzVW5pY29kZS5qcyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9+L2xvZGFzaC1lcy9fdW5pY29kZVRvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vfi9hc3luYy1lcy9pbnRlcm5hbC9zZXRJbW1lZGlhdGUuanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vfi9hc3luYy1lcy9pbnRlcm5hbC9Eb3VibHlMaW5rZWRMaXN0LmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL34vYXN5bmMtZXMvZWFjaE9mU2VyaWVzLmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL34vYXN5bmMtZXMvcmVkdWNlLmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL34vYXN5bmMtZXMvc2VxLmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL34vYXN5bmMtZXMvY29tcG9zZS5qcyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9+L2FzeW5jLWVzL2NvbmNhdC5qcyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9+L2FzeW5jLWVzL2NvbmNhdFNlcmllcy5qcyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9+L2FzeW5jLWVzL2NvbnN0YW50LmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL34vYXN5bmMtZXMvZGV0ZWN0LmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL34vYXN5bmMtZXMvZGV0ZWN0TGltaXQuanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vfi9hc3luYy1lcy9kZXRlY3RTZXJpZXMuanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vfi9hc3luYy1lcy9pbnRlcm5hbC9jb25zb2xlRnVuYy5qcyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9+L2FzeW5jLWVzL2Rpci5qcyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9+L2FzeW5jLWVzL2ludGVybmFsL3dpdGhvdXRJbmRleC5qcyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9+L2FzeW5jLWVzL2VhY2guanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vfi9hc3luYy1lcy9lYWNoU2VyaWVzLmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL34vYXN5bmMtZXMvZXZlcnkuanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vfi9hc3luYy1lcy9ldmVyeUxpbWl0LmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL34vYXN5bmMtZXMvZXZlcnlTZXJpZXMuanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vfi9sb2Rhc2gtZXMvX2Jhc2VQcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9+L2FzeW5jLWVzL2ZpbHRlci5qcyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9+L2FzeW5jLWVzL2ZpbHRlckxpbWl0LmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL34vYXN5bmMtZXMvZmlsdGVyU2VyaWVzLmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL34vYXN5bmMtZXMvbG9nLmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL34vYXN5bmMtZXMvbWFwVmFsdWVzLmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL34vYXN5bmMtZXMvbWFwVmFsdWVzU2VyaWVzLmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL34vYXN5bmMtZXMvbmV4dFRpY2suanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vfi9hc3luYy1lcy9zZXRJbW1lZGlhdGUuanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vfi9hc3luYy1lcy9xdWV1ZS5qcyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9+L2FzeW5jLWVzL3ByaW9yaXR5UXVldWUuanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vfi9hc3luYy1lcy9yZWplY3QuanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vfi9hc3luYy1lcy9yZWplY3RMaW1pdC5qcyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9+L2FzeW5jLWVzL3JlamVjdFNlcmllcy5qcyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9+L2xvZGFzaC1lcy9jb25zdGFudC5qcyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9+L2FzeW5jLWVzL3JldHJ5YWJsZS5qcyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9+L2FzeW5jLWVzL3NvbWUuanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vfi9hc3luYy1lcy9zb21lTGltaXQuanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vfi9hc3luYy1lcy9zb21lU2VyaWVzLmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL34vbG9kYXNoLWVzL19iYXNlUmFuZ2UuanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vfi9hc3luYy1lcy90aW1lcy5qcyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9+L2FzeW5jLWVzL3RpbWVzU2VyaWVzLmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL34vYXN5bmMtZXMvdW5tZW1vaXplLmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL34vYXN5bmMtZXMvd2F0ZXJmYWxsLmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL34vYXN5bmMtZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vc3JjL2JhY2tlbmQvRHJvcGJveC50cyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9zcmMvYmFja2VuZC9FbXNjcmlwdGVuLnRzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL3NyYy9iYWNrZW5kL0ZvbGRlckFkYXB0ZXIudHMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vc3JjL2NvcmUvZ2xvYmFsLnRzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL3NyYy9iYWNrZW5kL0hUTUw1RlMudHMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vc3JjL2dlbmVyaWMvaW5vZGUudHMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vc3JjL2dlbmVyaWMva2V5X3ZhbHVlX2ZpbGVzeXN0ZW0udHMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vc3JjL2JhY2tlbmQvSW5NZW1vcnkudHMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vc3JjL2JhY2tlbmQvSW5kZXhlZERCLnRzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL3NyYy9iYWNrZW5kL0xvY2FsU3RvcmFnZS50cyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9zcmMvYmFja2VuZC9Nb3VudGFibGVGaWxlU3lzdGVtLnRzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL3NyYy9nZW5lcmljL3NldEltbWVkaWF0ZS50cyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9zcmMvZ2VuZXJpYy9tdXRleC50cyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9zcmMvZ2VuZXJpYy9sb2NrZWRfZnMudHMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vc3JjL2JhY2tlbmQvT3ZlcmxheUZTLnRzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL3NyYy9iYWNrZW5kL1dvcmtlckZTLnRzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL3NyYy9nZW5lcmljL3hoci50cyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9zcmMvZ2VuZXJpYy9maWxlX2luZGV4LnRzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL3NyYy9iYWNrZW5kL1htbEh0dHBSZXF1ZXN0LnRzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL3NyYy9nZW5lcmljL2V4dGVuZGVkX2FzY2lpLnRzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL3NyYy9iYWNrZW5kL1ppcEZTLnRzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL3NyYy9iYWNrZW5kL0lzb0ZTLnRzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL3NyYy9jb3JlL2JhY2tlbmRzLnRzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL3NyYy9jb3JlL2Jyb3dzZXJmcy50cyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9zcmMvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vYnVpbGQvdGVtcC9saWJyYXJ5L3dlYnBhY2svQkZTQnVmZmVyLmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL34vYnVmZmVyL2luZGV4LmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL34vYmFzZTY0LWpzL2luZGV4LmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL34vaWVlZTc1NC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vdHMvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vdHMvcHJvY2Vzcy50cyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9+L2V2ZW50cy9ldmVudHMuanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vdHMvcGF0aC50cyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy90cy90dHkudHMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vfi9zdHJlYW0tYnJvd3NlcmlmeS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9+L2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vfi9yZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUuanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vfi9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcmVhZGFibGUuanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vfi9wcm9jZXNzLW5leHRpY2stYXJncy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9+L2lzYXJyYXkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vfi9idWZmZXItc2hpbXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vfi9jb3JlLXV0aWwtaXMvbGliL3V0aWwuanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vdXRpbCAoaWdub3JlZCkiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vfi9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvQnVmZmVyTGlzdC5qcyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9+L3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9kdXBsZXguanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vfi9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fd3JpdGFibGUuanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vfi91dGlsLWRlcHJlY2F0ZS9icm93c2VyLmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL34vc3RyaW5nX2RlY29kZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vfi9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL34vcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL34vcmVhZGFibGUtc3RyZWFtL3dyaXRhYmxlLmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL34vcmVhZGFibGUtc3RyZWFtL2R1cGxleC5qcyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9+L3JlYWRhYmxlLXN0cmVhbS90cmFuc2Zvcm0uanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vfi9yZWFkYWJsZS1zdHJlYW0vcGFzc3Rocm91Z2guanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vfi9wYWtvL2xpYi9pbmZsYXRlLmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL34vcGFrby9saWIvemxpYi9pbmZsYXRlLmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL34vcGFrby9saWIvdXRpbHMvY29tbW9uLmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL34vcGFrby9saWIvemxpYi9hZGxlcjMyLmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL34vcGFrby9saWIvemxpYi9jcmMzMi5qcyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9+L3Bha28vbGliL3psaWIvaW5mZmFzdC5qcyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9+L3Bha28vbGliL3psaWIvaW5mdHJlZXMuanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vfi9wYWtvL2xpYi91dGlscy9zdHJpbmdzLmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL34vcGFrby9saWIvemxpYi9jb25zdGFudHMuanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vfi9wYWtvL2xpYi96bGliL21lc3NhZ2VzLmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL34vcGFrby9saWIvemxpYi96c3RyZWFtLmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL34vcGFrby9saWIvemxpYi9nemhlYWRlci5qcyIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL1BvcHVwUm9vdC50c3giLCJ3ZWJwYWNrOi8vLy4vZXh0ZW5zaW9uL1BvcHVwLnRzeCIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3dlYnBhY2svYnVpbGRpbi9nbG9iYWwuanMiXSwibmFtZXMiOlsiY29uc3QiLCJwYXRoIiwic3VwZXIiLCJidWZmZXIiLCJsZXQiLCJwYXRoLnJlc29sdmUiLCJ0aGlzIiwiZGQiLCJ5IiwiYngwIiwiZHkiLCJwYXRoLmRpcm5hbWUiLCJmcyIsInBhdGguc2VwIiwicGF0aC5qb2luIiwib3ZlclJlc3QiLCJfb3ZlclJlc3QiLCJhcHBseUVhY2giLCJTeW1ib2wiLCJzeW1Ub1N0cmluZ1RhZyIsIm9iamVjdFByb3RvIiwibmF0aXZlT2JqZWN0VG9TdHJpbmciLCJoYXNPd25Qcm9wZXJ0eSIsIkJ1ZmZlciIsIk1BWF9TQUZFX0lOVEVHRVIiLCJhcmdzVGFnIiwiZnVuY1RhZyIsImZyZWVFeHBvcnRzIiwiZnJlZU1vZHVsZSIsIm1vZHVsZUV4cG9ydHMiLCJtYXAiLCJlYWNoT2ZMaW1pdCIsInJzQXN0cmFsUmFuZ2UiLCJyc0NvbWJvTWFya3NSYW5nZSIsInJlQ29tYm9IYWxmTWFya3NSYW5nZSIsInJzQ29tYm9TeW1ib2xzUmFuZ2UiLCJyc0NvbWJvUmFuZ2UiLCJyc1ZhclJhbmdlIiwicnNaV0oiLCJ3aXRob3V0SW5kZXgiLCJfZGVmZXIiLCJuYXRpdmVNYXgiLCJhc3luY0VhY2giLCJwYXRoLnJlbGF0aXZlIiwiZ2xvYmFsIiwiY29udmVydEVycm9yIiwicGF0aC5iYXNlbmFtZSIsImRpciIsIjBvMjIyIiwiMG83NzciLCIwbzY0NCIsImFyZ3VtZW50cyIsInNldEltbWVkaWF0ZSIsIkRyb3Bib3giLCJFbXNjcmlwdGVuIiwiSW5NZW1vcnkiLCJJbmRleGVkREIiLCJMb2NhbFN0b3JhZ2UiLCJFcnJvcnMuQXBpRXJyb3IiLCJFcnJvcnMuRXJyb3JDb2RlIiwiUG9wdXBSb290IiwiUmVhY3RET00iLCJyZW5kZXIiLCJkb2N1bWVudCIsImdldEVsZW1lbnRCeUlkIl0sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrREFBMEMsZ0NBQWdDO0FBQzFFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0VBQXdELGtCQUFrQjtBQUMxRTtBQUNBLHlEQUFpRCxjQUFjO0FBQy9EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBeUMsaUNBQWlDO0FBQzFFLHdIQUFnSCxtQkFBbUIsRUFBRTtBQUNySTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUEyQiwwQkFBMEIsRUFBRTtBQUN2RCx5Q0FBaUMsZUFBZTtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4REFBc0QsK0RBQStEOztBQUVySDtBQUNBOzs7QUFHQTtBQUNBOzs7Ozs7Ozs7QUNsRmE7O0FBRWIsSUFBSSxJQUFxQztBQUN6QyxtQkFBbUIsbUJBQU8sQ0FBQyxHQUErQjtBQUMxRCxDQUFDLE1BQU0sRUFFTjs7Ozs7Ozs7Ozs7Ozs7QUNORDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLFFBQVEsYUFBYTs7QUFFckIsaUNBQWlDLG9DQUFvQzs7QUFFckUseUJBQXlCLHVCQUF1QixFQUFFO0FBQ2xEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7O0FBR0EsaUJBQWlCLGlDQUFpQztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsWUFBb0I7QUFDdkU7QUFDQTtBQUNBLCtCQUErQjs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GO0FBQ25GOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLFlBQVksS0FBcUMsRUFBRSxFQUUxQztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVxQjs7O0FDdEl0QjtBQUNBO0FBQ0EseUtBQXlLLE9BQU87QUFDaEw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUIsT0FBTztBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxPQUFPO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QixrQ0FBa0M7QUFDMUQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsVUFBVTtBQUN4Qzs7QUFFQTtBQUNBO0FBQ0EsOEJBQThCLFVBQVU7QUFDeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsVUFBVTs7QUFFcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQ0FBMkMsT0FBTztBQUNsRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW9CLE9BQU87QUFDM0IseUJBQXlCLE9BQU87QUFDaEM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FB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QyxFQUFFOztFQWhEckQsMkJBQWEsR0FBRyxDQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxRQUFRO0tBQy9FLFFBQVEsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLFFBQVE7S0FDcEUsUUFBUSxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsUUFBUTtLQUNwRSxRQUFRLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxRQUFRO0tBQ3BFLFFBQVEsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLFFBQVE7S0FDcEUsUUFBUSxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsUUFBUTtLQUNwRSxRQUFRLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxRQUFRO0tBQ3BFLFFBQVEsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsUUFBUTtLQUN6RSxRQUFRLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHO0tBQ3pFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsR0FBRztLQUN6RSxHQUFHLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsR0FBRztLQUNw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QWMsQ0FBQyxJQUFJLENBQUMsQ0FBQztLQUNyQyxRQUFRLEdBQUcsQ0FBQyxhQUFhLEVBQUU7U0FDekIsS0FBSzthQUNILE9BQU8sSUFBSSxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDM0IsS0FBSzthQUNILE9BQU8sSUFBSyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDNUIsS0FBSzthQUNILE9BQU8sSUFBSSxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDM0IsS0FBSzthQUNILE9BQU8sSUFBSSxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDM0IsS0FBSzthQUNILE9BQU8sSUFBSSxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDM0IsS0FBSzthQUNILE9BQU8sSUFBSSxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDM0IsS0FBSzthQUNILE9BQU8sSUFBSSxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDM0IsS0FBSzthQUNILE9BQU8sSUFBSSxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDM0IsS0FBSzthQUNILE9BQU8sSUFBSSxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDM0IsS0FBSzthQUNILE9BQU8sSUFBSSxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDM0IsS0FBSzthQUNILE9BQU8sSUFBSSxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDM0IsS0FBSzthQUNILE9BQU8sSUFBSSxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDM0IsS0FBSzthQUNILE9BQU8sSUFBSSxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDM0IsS0FBSzthQUNILE9BQU8sSUFBSSxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDM0IsS0FBSzthQUNILE9BQU8sSUFBSSxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDM0IsS0FBSzthQUNILE9BQU8sSUFBSSxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDM0I7YUFDRSxPQUFPLEdBQUcsQ0FBQztNQUNk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SUFBSSxDQUFDLFVBQVUsR0FBRyxLQUFLLEVBQUUsR0FBRyxHQUFHLEtBQUssQ0FBQyxDQUFDO1VBQzFFLENBQUM7TUFDSDtFQUc4Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzlDakM7Ozs7Ozs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQixtREFBbUQ7QUFDeEU7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHdDQUF1QyxTQUFTO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFnRCxFQUFFO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5QkFBd0IsZUFBZTtBQUN2QztBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSx5QkFBd0IsUUFBUTtBQUNoQztBQUNBLHNCQUFxQixlQUFlO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHNCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFxQixRQUFRO0FBQzdCO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxnQkFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNB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QUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUc7QUFDSCxxQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUMxU0Esa0VBQWlFO0FBQ2pFLHVDQUFzQztBQUN0QyxLQUFJLFdBQVcsR0FBRywrREFBK0QsQ0FBQztBQUNsRix5QkFBd0IsUUFBZ0I7S0FDdEMsSUFBSSxHQUFHLEdBQUcsV0FBVyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztLQUNyQyxHQUFHLENBQUMsS0FBSyxFQUFFLENBQUM7S0FDWixNQUFNLENBQUMsR0FBRyxDQUFDO0FBQ2IsRUFBQztBQUVEOzs7Ozs7O0lBT0c7QUFDSDtLQUFBO0tBcWFBLENBQUM7S0FwYUM7Ozs7Ozs7Ozs7UUFVRztLQUNXLGNBQVMsR0FBdkIsVUFBd0IsQ0FBUztTQUMvQiwwQkFBMEI7U0FDMUIsRUFBRSxDQUFDLENBQUMsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDLENBQUM7YUFDYixDQUFDLEdBQUcsR0FBRyxDQUFDO1NBQ1YsQ0FBQztTQUNELHVFQUF1RTtTQUN2RSw4REFBOEQ7U0FDOUQsSUFBSSxRQUFRLEdBQUcsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDO1NBQ3hDLHNCQUFzQjtTQUN0QixDQUFDLEdBQUcsSUFBSSxDQUFDLG9CQUFvQixDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQ2pDLHNFQUFzRTtTQUN0RSxJQUFJLFVBQVUsR0FBRyxDQUFDLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztTQUNuQyxJQUFJLGNBQWMsR0FBYSxFQUFFLENBQUM7U0FDbEMsR0FBRyxDQUFDLENBQUMsSUFBSSxHQUFHLEdBQUcsQ0FBQyxFQUFFLEdBQUcsR0FBRyxVQUFVLENBQUMsTUFBTSxFQUFFLEdBQUcsRUFBRSxFQUFFLENBQUM7YUFDakQsSUFBSSxDQUFDLEdBQUcsVUFBVSxDQUFDLEdBQUcsQ0FBQyxDQUFDO2FBQ3hCLEVBQUUsQ0FBQyxDQUFDLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxDQUFDO2lCQUNkLFFBQVEsQ0FBQzthQUNYLENBQUM7YUFBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxLQUFLLElBQUksSUFBSSxDQUFDLFFBQVEsSUFBSSxDQUFDLENBQUMsUUFBUSxJQUFJLGNBQWMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxJQUFJLGNBQWMsQ0FBQyxDQUFDLENBQUMsS0FBSyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztpQkFDOUcsd0VBQXdFO2lCQUN4RSwyQ0FBMkM7aUJBQzNDLHVFQUF1RTtpQkFDdkUsZ0NBQWdDO2lCQUNoQyxjQUFjLENBQUMsR0FBRyxFQUFFLENBQUM7YUFDdkIsQ0FBQzthQUFDLElBQUksQ0FBQyxDQUFDO2lCQUNOLGNBQWMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7YUFDekIsQ0FBQztTQUNILENBQUM7U0FFRCwwRUFBMEU7U0FDMUUscURBQXFEO1NBQ3JELDBDQUEwQztTQUMxQyxFQUFFLENBQUMsQ0FBQyxDQUFDLFFBQVEsSUFBSSxjQUFjLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7YUFDM0MsTUFBTSxDQUFDLENBQUMsY0FBYyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7aUJBQzlCLEtBQUssQ0FBQztxQkFDSixFQUFFLENBQUMsQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUMsQ0FBQzt5QkFDN0IsY0FBYyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQztxQkFDOUIsQ0FBQztxQkFDRCxLQUFLLENBQUM7aUJBQ1I7cUJBQ0UsY0FBYyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQzthQUM3QixDQUFDO1NBQ0gsQ0FBQztTQUNELENBQUMsR0FBRyxjQUFjLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztTQUNsQyxFQUFFLENBQUMsQ0FBQyxRQUFRLElBQUksQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQzthQUN6QyxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUM7U0FDbkIsQ0FBQztTQUNELE1BQU0sQ0FBQyxDQUFDLENBQUM7S0FDWCxDQUFDO0tBRUQ7Ozs7Ozs7Ozs7Ozs7O1FBY0c7S0FDVyxTQUFJLEdBQWxCO1NBQW1CLGVBQWU7Y0FBZixXQUFlLENBQWYsc0JBQWUsQ0FBZixJQUFlO2FBQWYsOEJBQWU7O1NBQ2hDLDZFQUE2RTtTQUM3RSwyQ0FBMkM7U0FDM0MsSUFBSSxTQUFTLEdBQWEsRUFBRSxDQUFDO1NBQzdCLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsS0FBSyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDO2FBQ3RDLElBQUksT0FBTyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQzthQUN2QixFQUFFLENBQUMsQ0FBQyxPQUFPLE9BQU8sS0FBSyxRQUFRLENBQUMsQ0FBQyxDQUFDO2lCQUNoQyxNQUFNLElBQUksU0FBUyxDQUFDLHNDQUFzQyxHQUFHLENBQUMsT0FBTyxPQUFPLENBQUMsQ0FBQyxDQUFDO2FBQ2pGLENBQUM7YUFBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsT0FBTyxLQUFLLEVBQUUsQ0FBQyxDQUFDLENBQUM7aUJBQzFCLFNBQVMsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7YUFDMUIsQ0FBQztTQUNILENBQUM7U0FDRCxNQUFNLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0tBQ2xELENBQUM7S0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7UUFzQ0c7S0FDVyxZQUFPLEdBQXJCO1NBQXNCLGVBQWtCO2NBQWxCLFdBQWtCLENBQWxCLHNCQUFrQixDQUFsQixJQUFrQjthQUFsQiw4QkFBa0I7O1NBQ3RDLDRFQUE0RTtTQUM1RSw2QkFBNkI7U0FDN0IsSUFBSSxTQUFTLEdBQWEsRUFBRSxDQUFDO1NBQzdCLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsS0FBSyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDO2FBQ3RDLElBQUksQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQzthQUNqQixFQUFFLENBQUMsQ0FBQyxPQUFPLENBQUMsS0FBSyxRQUFRLENBQUMsQ0FBQyxDQUFDO2lCQUMxQixNQUFNLElBQUksU0FBUyxDQUFDLHNDQUFzQyxHQUFHLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDO2FBQzNFLENBQUM7YUFBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDLENBQUM7aUJBQ3BCLHFFQUFxRTtpQkFDckUsa0JBQWtCO2lCQUNsQixFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO3FCQUM3QixTQUFTLEdBQUcsRUFBRSxDQUFDO2lCQUNqQixDQUFDO2lCQUNELFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7YUFDcEIsQ0FBQztTQUNILENBQUM7U0FDRCxzREFBc0Q7U0FDdEQsSUFBSSxRQUFRLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1NBQ3hELEVBQUUsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxJQUFJLFFBQVEsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQzthQUM3RSxNQUFNLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsUUFBUSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQztTQUNqRCxDQUFDO1NBQ0QsNkVBQTZFO1NBQzdFLHlCQUF5QjtTQUN6QixFQUFFLENBQUMsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO2FBQ3BDLGdFQUFnRTthQUNoRSxFQUFFLENBQUMsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLEtBQUssQ0FBQyxJQUFJLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztpQkFDN0YsUUFBUSxHQUFHLFFBQVEsQ0FBQyxNQUFNLEtBQUssQ0FBQyxHQUFHLEVBQUUsR0FBRyxRQUFRLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO2FBQzdELENBQUM7YUFDRCxrRUFBa0U7YUFDbEUsSUFBSSxHQUFHLEdBQUcsT0FBTyxDQUFDLEdBQUcsRUFBRSxDQUFDO2FBQ3hCLEVBQUUsQ0FBQyxDQUFDLFFBQVEsS0FBSyxFQUFFLENBQUMsQ0FBQyxDQUFDO2lCQUNwQixxREFBcUQ7aUJBQ3JELFFBQVEsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsR0FBRyxDQUFDLEdBQUcsS0FBSyxHQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsR0FBRyxFQUFFLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQzthQUM1RSxDQUFDO2FBQUMsSUFBSSxDQUFDLENBQUM7aUJBQ04sUUFBUSxHQUFHLEdBQUcsQ0FBQzthQUNqQixDQUFDO1NBQ0gsQ0FBQztTQUNELE1BQU0sQ0FBQyxRQUFRLENBQUM7S0FDbEIsQ0FBQztLQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztRQW9CRztLQUNXLGFBQVEsR0FBdEIsVUFBdUIsSUFBWSxFQUFFLEVBQVU7U0FDN0MsSUFBSSxDQUFTLENBQUM7U0FDZCxvRUFBb0U7U0FDcEUsYUFBYTtTQUNiLElBQUksR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO1NBQzFCLEVBQUUsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1NBQ3RCLElBQUksUUFBUSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQ3BDLElBQUksTUFBTSxHQUFHLEVBQUUsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQ2hDLHlFQUF5RTtTQUN6RSxNQUFNLENBQUMsS0FBSyxFQUFFLENBQUM7U0FDZixRQUFRLENBQUMsS0FBSyxFQUFFLENBQUM7U0FDakIsdUNBQXVDO1NBQ3ZDLGlEQUFpRDtTQUNqRCwyREFBMkQ7U0FDM0QsSUFBSSxPQUFPLEdBQUcsQ0FBQyxDQUFDO1NBQ2hCLElBQUksUUFBUSxHQUFhLEVBQUUsQ0FBQztTQUM1Qiw2REFBNkQ7U0FDN0QsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsUUFBUSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDO2FBQ3JDLElBQUksR0FBRyxHQUFHLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQzthQUN0QixFQUFFLENBQUMsQ0FBQyxHQUFHLEtBQUssTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztpQkFDdEIsUUFBUSxDQUFDO2FBQ1gsQ0FBQzthQUNELHdFQUF3RTthQUN4RSxnQ0FBZ0M7YUFDaEMsT0FBTyxHQUFHLFFBQVEsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDO2FBQzlCLEtBQUssQ0FBQztTQUNSLENBQUM7U0FDRCx1RUFBdUU7U0FDdkUsNkVBQTZFO1NBQzdFLFFBQVEsR0FBRyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQzNCLGlDQUFpQztTQUNqQyxFQUFFLENBQUMsQ0FBQyxRQUFRLENBQUMsTUFBTSxLQUFLLENBQUMsSUFBSSxRQUFRLENBQUMsQ0FBQyxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUMsQ0FBQzthQUNoRCxPQUFPLEdBQUcsQ0FBQyxDQUFDO1NBQ2QsQ0FBQztTQUNELHVEQUF1RDtTQUN2RCw0QkFBNEI7U0FDNUIsRUFBRSxDQUFDLENBQUMsT0FBTyxHQUFHLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO2FBQzlCLE9BQU8sR0FBRyxRQUFRLENBQUMsTUFBTSxDQUFDO1NBQzVCLENBQUM7U0FDRCwyQkFBMkI7U0FDM0IsSUFBSSxFQUFFLEdBQUcsRUFBRSxDQUFDO1NBQ1osR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsT0FBTyxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUM7YUFDN0IsRUFBRSxJQUFJLEtBQUssQ0FBQztTQUNkLENBQUM7U0FDRCxFQUFFLElBQUksUUFBUSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7U0FDOUIseUVBQXlFO1NBQ3pFLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQzthQUMzRCxFQUFFLEdBQUcsRUFBRSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQztTQUNuQyxDQUFDO1NBQ0QsTUFBTSxDQUFDLEVBQUUsQ0FBQztLQUNaLENBQUM7S0FFRDs7Ozs7Ozs7Ozs7UUFXRztLQUNXLFlBQU8sR0FBckIsVUFBc0IsQ0FBUztTQUM3Qiw2RUFBNkU7U0FDN0UsMkJBQTJCO1NBQzNCLENBQUMsR0FBRyxJQUFJLENBQUMsb0JBQW9CLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDakMsSUFBSSxRQUFRLEdBQUcsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDO1NBQ3hDLElBQUksUUFBUSxHQUFHLENBQUMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQ2pDLDZDQUE2QztTQUM3QyxFQUFFLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLEtBQUssRUFBRSxJQUFJLFFBQVEsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQzthQUNqRCxRQUFRLENBQUMsR0FBRyxFQUFFLENBQUM7U0FDakIsQ0FBQztTQUNELG9GQUFvRjtTQUNwRiw4RUFBOEU7U0FDOUUsYUFBYTtTQUNiLEVBQUUsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sS0FBSyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUM7YUFDaEUsTUFBTSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQ2pDLENBQUM7U0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQzthQUNwQixNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQztTQUNsQixDQUFDO1NBQUMsSUFBSSxDQUFDLENBQUM7YUFDTixNQUFNLENBQUMsR0FBRyxDQUFDO1NBQ2IsQ0FBQztLQUNILENBQUM7S0FFRDs7Ozs7Ozs7Ozs7OztRQWFHO0tBQ1csYUFBUSxHQUF0QixVQUF1QixDQUFTLEVBQUUsR0FBZ0I7U0FBaEIsbUJBQWdCLEdBQWhCLFFBQWdCO1NBQ2hELGtEQUFrRDtTQUNsRCxFQUFFLENBQUMsQ0FBQyxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUMsQ0FBQzthQUNiLE1BQU0sQ0FBQyxDQUFDLENBQUM7U0FDWCxDQUFDO1NBQ0Qsc0RBQXNEO1NBQ3RELENBQUMsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQ3RCLG1DQUFtQztTQUNuQyxJQUFJLFFBQVEsR0FBRyxDQUFDLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztTQUNqQyxJQUFJLFFBQVEsR0FBRyxRQUFRLENBQUMsUUFBUSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQztTQUM3QyxtRUFBbUU7U0FDbkUsa0RBQWtEO1NBQ2xELEVBQUUsQ0FBQyxDQUFDLFFBQVEsS0FBSyxFQUFFLElBQUksUUFBUSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO2FBQzNDLE1BQU0sQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQztTQUN2QyxDQUFDO1NBQ0Qsb0NBQW9DO1NBQ3BDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQzthQUNuQixJQUFJLFdBQVcsR0FBRyxRQUFRLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxNQUFNLEdBQUcsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDO2FBQ2hFLEVBQUUsQ0FBQyxDQUFDLFdBQVcsS0FBSyxHQUFHLENBQUMsQ0FBQyxDQUFDO2lCQUN4QixNQUFNLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsUUFBUSxDQUFDLE1BQU0sR0FBRyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUM7YUFDMUQsQ0FBQztTQUNILENBQUM7U0FDRCxNQUFNLENBQUMsUUFBUSxDQUFDO0tBQ2xCLENBQUM7S0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7O1FBa0JHO0tBQ1csWUFBTyxHQUFyQixVQUFzQixDQUFTO1NBQzdCLENBQUMsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQ3RCLElBQUksUUFBUSxHQUFHLENBQUMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQ2pDLENBQUMsR0FBRyxRQUFRLENBQUMsR0FBRyxFQUFFLENBQUM7U0FDbkIsbURBQW1EO1NBQ25ELEVBQUUsQ0FBQyxDQUFDLENBQUMsS0FBSyxFQUFFLElBQUksUUFBUSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO2FBQ3BDLENBQUMsR0FBRyxRQUFRLENBQUMsR0FBRyxFQUFFLENBQUM7U0FDckIsQ0FBQztTQUNELEVBQUUsQ0FBQyxDQUFDLENBQUMsS0FBSyxJQUFJLENBQUMsQ0FBQyxDQUFDO2FBQ2YsTUFBTSxDQUFDLEVBQUUsQ0FBQztTQUNaLENBQUM7U0FDRCxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQzNCLEVBQUUsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQzthQUN4QixNQUFNLENBQUMsRUFBRSxDQUFDO1NBQ1osQ0FBQztTQUNELE1BQU0sQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO0tBQ3JCLENBQUM7S0FFRDs7Ozs7O1FBTUc7S0FDVyxlQUFVLEdBQXhCLFVBQXlCLENBQVM7U0FDaEMsTUFBTSxDQUFDLENBQUMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQztLQUNsRCxDQUFDO0tBRUQ7O1FBRUc7S0FDVyxjQUFTLEdBQXZCLFVBQXdCLENBQVM7U0FDL0IsTUFBTSxDQUFDLENBQUMsQ0FBQztLQUNYLENBQUM7S0FFRDs7UUFFRztLQUNXLFVBQUssR0FBbkIsVUFBb0IsQ0FBUztTQUMzQixJQUFJLFFBQVEsR0FBRyxjQUFjLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDakMsTUFBTSxDQUFDO2FBQ0wsSUFBSSxFQUFFLFFBQVEsQ0FBQyxDQUFDLENBQUM7YUFDakIsR0FBRyxFQUFFLFFBQVEsQ0FBQyxDQUFDLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQzthQUMzQyxJQUFJLEVBQUUsUUFBUSxDQUFDLENBQUMsQ0FBQzthQUNqQixHQUFHLEVBQUUsUUFBUSxDQUFDLENBQUMsQ0FBQzthQUNoQixJQUFJLEVBQUUsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDO1VBQ3BFLENBQUM7S0FDSixDQUFDO0tBRWEsV0FBTSxHQUFwQixVQUFxQixVQUE0QjtTQUMvQyxFQUFFLENBQUMsQ0FBQyxVQUFVLEtBQUssSUFBSSxJQUFJLE9BQU8sVUFBVSxLQUFLLFFBQVEsQ0FBQyxDQUFDLENBQUM7YUFDMUQsTUFBTSxJQUFJLFNBQVMsQ0FBQyxtREFBaUQsT0FBTyxVQUFZLENBQUMsQ0FBQztTQUM1RixDQUFDO1NBRUQsSUFBSSxJQUFJLEdBQUcsVUFBVSxDQUFDLElBQUksSUFBSSxFQUFFLENBQUM7U0FFakMsRUFBRSxDQUFDLENBQUMsT0FBTyxJQUFJLEtBQUssUUFBUSxDQUFDLENBQUMsQ0FBQzthQUM3QixNQUFNLElBQUksU0FBUyxDQUNmLHVEQUF1RDtpQkFDdkQsT0FBTyxVQUFVLENBQUMsSUFBSSxDQUN6QixDQUFDO1NBQ0osQ0FBQztTQUVELElBQUksR0FBRyxHQUFHLFVBQVUsQ0FBQyxHQUFHLEdBQUcsVUFBVSxDQUFDLEdBQUcsR0FBRyxJQUFJLENBQUMsR0FBRyxHQUFHLEVBQUUsQ0FBQztTQUMxRCxJQUFJLElBQUksR0FBRyxVQUFVLENBQUMsSUFBSSxJQUFJLEVBQUUsQ0FBQztTQUNqQyxNQUFNLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQztLQUNwQixDQUFDO0tBT2MseUJBQW9CLEdBQW5DLFVBQW9DLENBQVM7U0FDM0MsQ0FBQyxHQUFHLENBQUMsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLGFBQWEsRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7U0FDNUMsTUFBTSxDQUFDLENBQUMsQ0FBQztLQUNYLENBQUM7S0FSRCw0REFBNEQ7S0FDOUMsUUFBRyxHQUFXLEdBQUcsQ0FBQztLQUVqQixrQkFBYSxHQUFHLElBQUksTUFBTSxDQUFDLEtBQUssRUFBRSxHQUFHLENBQUMsQ0FBQztLQU90RCw0REFBNEQ7S0FDOUMsY0FBUyxHQUFHLEdBQUcsQ0FBQztLQUVoQixVQUFLLEdBQUcsSUFBSSxDQUFDO0tBQzNCLHFEQUFxRDtLQUN2QyxVQUFLLEdBQUcsSUFBSSxDQUFDO0tBQzdCLFdBQUM7QUFBRCxFQUFDO0FBRUQsS0FBSSxDQUFDLEdBQWlCLElBQUksQ0FBQztBQUUzQixrQkFBUyxJQUFJLENBQUM7Ozs7Ozs7Ozs7Ozs7O0FDN2JkLEtBQU8sTUFBTSx1QkFBVyxFQUFRLENBQUMsQ0FBQztBQUVsQztLQUFrQix1QkFBYTtLQVE3QjtTQUNFLGlCQUFPLENBQUM7U0FSSCxVQUFLLEdBQVksS0FBSyxDQUFDO1NBQ3ZCLFlBQU8sR0FBVyxFQUFFLENBQUM7U0FDckIsU0FBSSxHQUFXLEdBQUcsQ0FBQztTQUNuQixVQUFLLEdBQVksSUFBSSxDQUFDO1NBQ3JCLG9CQUFlLEdBQWEsRUFBRSxDQUFDO1NBQy9CLHNCQUFpQixHQUFZLEtBQUssQ0FBQztLQUkzQyxDQUFDO0tBRUQ7O1FBRUc7S0FDSSx3QkFBVSxHQUFqQixVQUFrQixJQUFhO1NBQzdCLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLEtBQUssSUFBSSxDQUFDLENBQUMsQ0FBQzthQUN4QixJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQzthQUNsQix3RUFBd0U7YUFDeEUsa0JBQWtCO2FBQ2xCLElBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUM7U0FDMUIsQ0FBQztLQUNILENBQUM7S0FFRDs7UUFFRztLQUNJLDJCQUFhLEdBQXBCLFVBQXFCLE9BQWU7U0FDbEMsRUFBRSxDQUFDLENBQUMsT0FBTyxLQUFLLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDO2FBQzdCLElBQUksQ0FBQyxPQUFPLEdBQUcsT0FBTyxDQUFDO2FBQ3ZCLGdCQUFnQjthQUNoQixJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1NBQ3RCLENBQUM7S0FDSCxDQUFDO0tBRUQ7O1FBRUc7S0FDSSx3QkFBVSxHQUFqQixVQUFrQixJQUFZO1NBQzVCLEVBQUUsQ0FBQyxDQUFDLElBQUksS0FBSyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQzthQUN2QixJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQzthQUNqQixnQkFBZ0I7YUFDaEIsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztTQUN0QixDQUFDO0tBQ0gsQ0FBQztLQUVEOztRQUVHO0tBQ1csVUFBTSxHQUFwQixVQUFxQixFQUFPO1NBQzFCLE1BQU0sQ0FBQyxFQUFFLElBQUksRUFBRSxZQUFZLEdBQUcsQ0FBQztLQUNqQyxDQUFDO0tBRU0sb0JBQU0sR0FBYixVQUFjLEtBQVUsRUFBRSxRQUFnQixFQUFFLEVBQVk7U0FDdEQsSUFBSSxLQUFVLENBQUM7U0FDZixJQUFJLENBQUM7YUFDSCxJQUFJLElBQVksQ0FBQzthQUNqQixFQUFFLENBQUMsQ0FBQyxPQUFNLENBQUMsS0FBSyxDQUFDLEtBQUssUUFBUSxDQUFDLENBQUMsQ0FBQztpQkFDL0IsSUFBSSxHQUFHLElBQUksTUFBTSxDQUFDLEtBQUssRUFBRSxRQUFRLENBQUMsQ0FBQzthQUNyQyxDQUFDO2FBQUMsSUFBSSxDQUFDLENBQUM7aUJBQ04sSUFBSSxHQUFHLEtBQUssQ0FBQzthQUNmLENBQUM7YUFDRCxJQUFJLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQzthQUNoQyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsaUJBQWlCLENBQUMsQ0FBQyxDQUFDO2lCQUMzQixJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDO2FBQ25CLENBQUM7U0FDSCxDQUFFO1NBQUEsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQzthQUNYLEtBQUssR0FBRyxDQUFDLENBQUM7U0FDWixDQUFDO2lCQUFTLENBQUM7YUFDVCxFQUFFLENBQUMsS0FBSyxDQUFDLENBQUM7U0FDWixDQUFDO0tBQ0gsQ0FBQztLQUVNLG1CQUFLLEdBQVosVUFBYSxJQUFZO1NBQ3ZCLHdDQUF3QztTQUN4QyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLE1BQU0sS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO2FBQ3RDLElBQUksQ0FBQyxpQkFBaUIsR0FBRyxJQUFJLENBQUM7U0FDaEMsQ0FBQztTQUFDLElBQUksQ0FBQyxDQUFDO2FBQ04sT0FBTyxJQUFJLENBQUMsZUFBZSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUUsQ0FBQztpQkFDdkMsSUFBSSxDQUFDLGlCQUFpQixHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDO2lCQUNqRSxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLENBQUM7cUJBQzVCLEtBQUssQ0FBQztpQkFDUixDQUFDO2FBQ0gsQ0FBQztTQUNILENBQUM7S0FDSCxDQUFDO0tBQ0gsVUFBQztBQUFELEVBQUMsQ0F0RmlCLE1BQU0sQ0FBQyxNQUFNLEdBc0Y5QjtBQUVELGtCQUFTLEdBQUcsQ0FBQzs7Ozs7Ozs7QUMxRmI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7O0FBSUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7QUM5SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUN0QkE7QUFDQTtBQUNBLG9DQUFrQztBQUNsQyxJQUFHO0FBQ0gsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNmQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHLGFBQWE7QUFDaEI7QUFDQTtBQUNBLEVBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBMkUsNkVBQTZFO0FBQ3hKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsdURBQXNEOztBQUV0RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNEU7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE2RDtBQUM3RDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUNBQXNDOztBQUV0QztBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTJEO0FBQzNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGdEQUErQzs7QUFFL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW1CLFNBQVM7QUFDNUI7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkVBQTRFOztBQUU1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvREFBbUQ7QUFDbkQ7QUFDQSxvREFBbUQsaUVBQWlFO0FBQ3BIO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXVDO0FBQ3ZDLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXVDO0FBQ3ZDLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBZ0MsT0FBTztBQUN2QztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBZ0MsT0FBTztBQUN2QztBQUNBO0FBQ0E7QUFDQSxFOzs7Ozs7O0FDNTZCQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBOzs7Ozs7OztBQzFDQSxrQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTs7Ozs7OztBQ0pBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUMzR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDMUdBLGdCOzs7Ozs7QUNBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWU7QUFDZiwrQ0FBOEM7QUFDOUM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1REFBc0Q7QUFDdEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHOzs7Ozs7QUMvREE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGdCQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlDQUFnQyxPQUFPO0FBQ3ZDO0FBQ0E7QUFDQSxFOzs7Ozs7QUMxRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUcsYUFBYTtBQUNoQjtBQUNBO0FBQ0EsRUFBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1AsTUFBSztBQUNMLElBQUc7QUFDSCxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7QUFDSCxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBaUM7O0FBRWpDOztBQUVBLDRDQUEyQztBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFtRDtBQUNuRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQ0FBb0M7O0FBRXBDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEscURBQW9EO0FBQ3BEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsRTs7Ozs7Ozs7QUNyaUJBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLFNBQVM7QUFDcEIsWUFBVyxPQUFPO0FBQ2xCLGNBQWEsU0FBUztBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLGNBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNsRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVEsT0FBTztBQUNmOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQzVOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEwQyxZQUFZO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLLEVBQUU7QUFDUCxJQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsRTs7Ozs7O0FDckxBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEc7Ozs7OztBQ3pCQTs7Ozs7OztBQ0FBOzs7Ozs7O0FDQUE7Ozs7Ozs7QUNBQTs7Ozs7OztBQ0FBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBbUMsVUFBVTtBQUM3QztBQUNBO0FBQ0EsK0JBQThCO0FBQzlCO0FBQ0Esc0JBQXFCLDhCQUE4QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHLGVBQWU7O0FBRWxCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQStCLHNCQUFzQjtBQUNyRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBa0I7QUFDbEIsb0JBQW1CO0FBQ25CLHVCQUFzQjtBQUN0QixvQkFBbUI7O0FBRW5CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUFzQjtBQUN0QjtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG9CQUFtQixjQUFjO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdURBQXNEOztBQUV0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBLFFBQU87QUFDUDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQixrRUFBa0U7O0FBRXZGOztBQUVBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNB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LCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4gXHRcdH1cbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiBcdH07XG5cbiBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbiBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbiBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuIFx0XHRyZXR1cm4gbnM7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIi9cIjtcblxuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDMyMCk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiIsIi8qXG5cbkJhc2VkIG9mZiBnbGFtb3IncyBTdHlsZVNoZWV0LCB0aGFua3MgU3VuaWwg4p2k77iPXG5cbmhpZ2ggcGVyZm9ybWFuY2UgU3R5bGVTaGVldCBmb3IgY3NzLWluLWpzIHN5c3RlbXNcblxuLSB1c2VzIG11bHRpcGxlIHN0eWxlIHRhZ3MgYmVoaW5kIHRoZSBzY2VuZXMgZm9yIG1pbGxpb25zIG9mIHJ1bGVzXG4tIHVzZXMgYGluc2VydFJ1bGVgIGZvciBhcHBlbmRpbmcgaW4gcHJvZHVjdGlvbiBmb3IgKm11Y2gqIGZhc3RlciBwZXJmb3JtYW5jZVxuXG4vLyB1c2FnZVxuXG5pbXBvcnQgeyBTdHlsZVNoZWV0IH0gZnJvbSAnQGVtb3Rpb24vc2hlZXQnXG5cbmxldCBzdHlsZVNoZWV0ID0gbmV3IFN0eWxlU2hlZXQoeyBrZXk6ICcnLCBjb250YWluZXI6IGRvY3VtZW50LmhlYWQgfSlcblxuc3R5bGVTaGVldC5pbnNlcnQoJyNib3ggeyBib3JkZXI6IDFweCBzb2xpZCByZWQ7IH0nKVxuLSBhcHBlbmRzIGEgY3NzIHJ1bGUgaW50byB0aGUgc3R5bGVzaGVldFxuXG5zdHlsZVNoZWV0LmZsdXNoKClcbi0gZW1wdGllcyB0aGUgc3R5bGVzaGVldCBvZiBhbGwgaXRzIGNvbnRlbnRzXG5cbiovXG4vLyAkRmxvd0ZpeE1lXG5mdW5jdGlvbiBzaGVldEZvclRhZyh0YWcpIHtcbiAgaWYgKHRhZy5zaGVldCkge1xuICAgIC8vICRGbG93Rml4TWVcbiAgICByZXR1cm4gdGFnLnNoZWV0O1xuICB9IC8vIHRoaXMgd2VpcmRuZXNzIGJyb3VnaHQgdG8geW91IGJ5IGZpcmVmb3hcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkb2N1bWVudC5zdHlsZVNoZWV0cy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChkb2N1bWVudC5zdHlsZVNoZWV0c1tpXS5vd25lck5vZGUgPT09IHRhZykge1xuICAgICAgLy8gJEZsb3dGaXhNZVxuICAgICAgcmV0dXJuIGRvY3VtZW50LnN0eWxlU2hlZXRzW2ldO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucykge1xuICB2YXIgdGFnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgdGFnLnNldEF0dHJpYnV0ZSgnZGF0YS1lbW90aW9uJywgb3B0aW9ucy5rZXkpO1xuXG4gIGlmIChvcHRpb25zLm5vbmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICB0YWcuc2V0QXR0cmlidXRlKCdub25jZScsIG9wdGlvbnMubm9uY2UpO1xuICB9XG5cbiAgdGFnLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKSk7XG4gIHJldHVybiB0YWc7XG59XG5cbnZhciBTdHlsZVNoZWV0ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU3R5bGVTaGVldChvcHRpb25zKSB7XG4gICAgdGhpcy5pc1NwZWVkeSA9IG9wdGlvbnMuc3BlZWR5ID09PSB1bmRlZmluZWQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nIDogb3B0aW9ucy5zcGVlZHk7XG4gICAgdGhpcy50YWdzID0gW107XG4gICAgdGhpcy5jdHIgPSAwO1xuICAgIHRoaXMubm9uY2UgPSBvcHRpb25zLm5vbmNlOyAvLyBrZXkgaXMgdGhlIHZhbHVlIG9mIHRoZSBkYXRhLWVtb3Rpb24gYXR0cmlidXRlLCBpdCdzIHVzZWQgdG8gaWRlbnRpZnkgZGlmZmVyZW50IHNoZWV0c1xuXG4gICAgdGhpcy5rZXkgPSBvcHRpb25zLmtleTtcbiAgICB0aGlzLmNvbnRhaW5lciA9IG9wdGlvbnMuY29udGFpbmVyO1xuICAgIHRoaXMuYmVmb3JlID0gbnVsbDtcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBTdHlsZVNoZWV0LnByb3RvdHlwZTtcblxuICBfcHJvdG8uaW5zZXJ0ID0gZnVuY3Rpb24gaW5zZXJ0KHJ1bGUpIHtcbiAgICAvLyB0aGUgbWF4IGxlbmd0aCBpcyBob3cgbWFueSBydWxlcyB3ZSBoYXZlIHBlciBzdHlsZSB0YWcsIGl0J3MgNjUwMDAgaW4gc3BlZWR5IG1vZGVcbiAgICAvLyBpdCdzIDEgaW4gZGV2IGJlY2F1c2Ugd2UgaW5zZXJ0IHNvdXJjZSBtYXBzIHRoYXQgbWFwIGEgc2luZ2xlIHJ1bGUgdG8gYSBsb2NhdGlvblxuICAgIC8vIGFuZCB5b3UgY2FuIG9ubHkgaGF2ZSBvbmUgc291cmNlIG1hcCBwZXIgc3R5bGUgdGFnXG4gICAgaWYgKHRoaXMuY3RyICUgKHRoaXMuaXNTcGVlZHkgPyA2NTAwMCA6IDEpID09PSAwKSB7XG4gICAgICB2YXIgX3RhZyA9IGNyZWF0ZVN0eWxlRWxlbWVudCh0aGlzKTtcblxuICAgICAgdmFyIGJlZm9yZTtcblxuICAgICAgaWYgKHRoaXMudGFncy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgYmVmb3JlID0gdGhpcy5iZWZvcmU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiZWZvcmUgPSB0aGlzLnRhZ3NbdGhpcy50YWdzLmxlbmd0aCAtIDFdLm5leHRTaWJsaW5nO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNvbnRhaW5lci5pbnNlcnRCZWZvcmUoX3RhZywgYmVmb3JlKTtcbiAgICAgIHRoaXMudGFncy5wdXNoKF90YWcpO1xuICAgIH1cblxuICAgIHZhciB0YWcgPSB0aGlzLnRhZ3NbdGhpcy50YWdzLmxlbmd0aCAtIDFdO1xuXG4gICAgaWYgKHRoaXMuaXNTcGVlZHkpIHtcbiAgICAgIHZhciBzaGVldCA9IHNoZWV0Rm9yVGFnKHRhZyk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIHRoaXMgaXMgYSByZWFsbHkgaG90IHBhdGhcbiAgICAgICAgLy8gd2UgY2hlY2sgdGhlIHNlY29uZCBjaGFyYWN0ZXIgZmlyc3QgYmVjYXVzZSBoYXZpbmcgXCJpXCJcbiAgICAgICAgLy8gYXMgdGhlIHNlY29uZCBjaGFyYWN0ZXIgd2lsbCBoYXBwZW4gbGVzcyBvZnRlbiB0aGFuXG4gICAgICAgIC8vIGhhdmluZyBcIkBcIiBhcyB0aGUgZmlyc3QgY2hhcmFjdGVyXG4gICAgICAgIHZhciBpc0ltcG9ydFJ1bGUgPSBydWxlLmNoYXJDb2RlQXQoMSkgPT09IDEwNSAmJiBydWxlLmNoYXJDb2RlQXQoMCkgPT09IDY0OyAvLyB0aGlzIGlzIHRoZSB1bHRyYWZhc3QgdmVyc2lvbiwgd29ya3MgYWNyb3NzIGJyb3dzZXJzXG4gICAgICAgIC8vIHRoZSBiaWcgZHJhd2JhY2sgaXMgdGhhdCB0aGUgY3NzIHdvbid0IGJlIGVkaXRhYmxlIGluIGRldnRvb2xzXG5cbiAgICAgICAgc2hlZXQuaW5zZXJ0UnVsZShydWxlLCAvLyB3ZSBuZWVkIHRvIGluc2VydCBAaW1wb3J0IHJ1bGVzIGJlZm9yZSBhbnl0aGluZyBlbHNlXG4gICAgICAgIC8vIG90aGVyd2lzZSB0aGVyZSB3aWxsIGJlIGFuIGVycm9yXG4gICAgICAgIC8vIHRlY2huaWNhbGx5IHRoaXMgbWVhbnMgdGhhdCB0aGUgQGltcG9ydCBydWxlcyB3aWxsXG4gICAgICAgIC8vIF91c3VhbGx5Xyhub3QgYWx3YXlzIHNpbmNlIHRoZXJlIGNvdWxkIGJlIG11bHRpcGxlIHN0eWxlIHRhZ3MpXG4gICAgICAgIC8vIGJlIHRoZSBmaXJzdCBvbmVzIGluIHByb2QgYW5kIGdlbmVyYWxseSBsYXRlciBpbiBkZXZcbiAgICAgICAgLy8gdGhpcyBzaG91bGRuJ3QgcmVhbGx5IG1hdHRlciBpbiB0aGUgcmVhbCB3b3JsZCB0aG91Z2hcbiAgICAgICAgLy8gQGltcG9ydCBpcyBnZW5lcmFsbHkgb25seSB1c2VkIGZvciBmb250IGZhY2VzIGZyb20gZ29vZ2xlIGZvbnRzIGFuZCBldGMuXG4gICAgICAgIC8vIHNvIHdoaWxlIHRoaXMgY291bGQgYmUgdGVjaG5pY2FsbHkgY29ycmVjdCB0aGVuIGl0IHdvdWxkIGJlIHNsb3dlciBhbmQgbGFyZ2VyXG4gICAgICAgIC8vIGZvciBhIHRpbnkgYml0IG9mIGNvcnJlY3RuZXNzIHRoYXQgd29uJ3QgbWF0dGVyIGluIHRoZSByZWFsIHdvcmxkXG4gICAgICAgIGlzSW1wb3J0UnVsZSA/IDAgOiBzaGVldC5jc3NSdWxlcy5sZW5ndGgpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcIlRoZXJlIHdhcyBhIHByb2JsZW0gaW5zZXJ0aW5nIHRoZSBmb2xsb3dpbmcgcnVsZTogXFxcIlwiICsgcnVsZSArIFwiXFxcIlwiLCBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0YWcuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUocnVsZSkpO1xuICAgIH1cblxuICAgIHRoaXMuY3RyKys7XG4gIH07XG5cbiAgX3Byb3RvLmZsdXNoID0gZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgLy8gJEZsb3dGaXhNZVxuICAgIHRoaXMudGFncy5mb3JFYWNoKGZ1bmN0aW9uICh0YWcpIHtcbiAgICAgIHJldHVybiB0YWcucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0YWcpO1xuICAgIH0pO1xuICAgIHRoaXMudGFncyA9IFtdO1xuICAgIHRoaXMuY3RyID0gMDtcbiAgfTtcblxuICByZXR1cm4gU3R5bGVTaGVldDtcbn0oKTtcblxuZXhwb3J0IHsgU3R5bGVTaGVldCB9O1xuIiwiZnVuY3Rpb24gc3R5bGlzX21pbiAoVykge1xuICBmdW5jdGlvbiBNKGQsIGMsIGUsIGgsIGEpIHtcbiAgICBmb3IgKHZhciBtID0gMCwgYiA9IDAsIHYgPSAwLCBuID0gMCwgcSwgZywgeCA9IDAsIEsgPSAwLCBrLCB1ID0gayA9IHEgPSAwLCBsID0gMCwgciA9IDAsIEkgPSAwLCB0ID0gMCwgQiA9IGUubGVuZ3RoLCBKID0gQiAtIDEsIHksIGYgPSAnJywgcCA9ICcnLCBGID0gJycsIEcgPSAnJywgQzsgbCA8IEI7KSB7XG4gICAgICBnID0gZS5jaGFyQ29kZUF0KGwpO1xuICAgICAgbCA9PT0gSiAmJiAwICE9PSBiICsgbiArIHYgKyBtICYmICgwICE9PSBiICYmIChnID0gNDcgPT09IGIgPyAxMCA6IDQ3KSwgbiA9IHYgPSBtID0gMCwgQisrLCBKKyspO1xuXG4gICAgICBpZiAoMCA9PT0gYiArIG4gKyB2ICsgbSkge1xuICAgICAgICBpZiAobCA9PT0gSiAmJiAoMCA8IHIgJiYgKGYgPSBmLnJlcGxhY2UoTiwgJycpKSwgMCA8IGYudHJpbSgpLmxlbmd0aCkpIHtcbiAgICAgICAgICBzd2l0Y2ggKGcpIHtcbiAgICAgICAgICAgIGNhc2UgMzI6XG4gICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICBjYXNlIDU5OlxuICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBmICs9IGUuY2hhckF0KGwpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGcgPSA1OTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAoZykge1xuICAgICAgICAgIGNhc2UgMTIzOlxuICAgICAgICAgICAgZiA9IGYudHJpbSgpO1xuICAgICAgICAgICAgcSA9IGYuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgIGsgPSAxO1xuXG4gICAgICAgICAgICBmb3IgKHQgPSArK2w7IGwgPCBCOykge1xuICAgICAgICAgICAgICBzd2l0Y2ggKGcgPSBlLmNoYXJDb2RlQXQobCkpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDEyMzpcbiAgICAgICAgICAgICAgICAgIGsrKztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAxMjU6XG4gICAgICAgICAgICAgICAgICBrLS07XG4gICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgNDc6XG4gICAgICAgICAgICAgICAgICBzd2l0Y2ggKGcgPSBlLmNoYXJDb2RlQXQobCArIDEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDc6XG4gICAgICAgICAgICAgICAgICAgICAgYToge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh1ID0gbCArIDE7IHUgPCBKOyArK3UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChlLmNoYXJDb2RlQXQodSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ3OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKDQyID09PSBnICYmIDQyID09PSBlLmNoYXJDb2RlQXQodSAtIDEpICYmIGwgKyAyICE9PSB1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGwgPSB1ICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKDQ3ID09PSBnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGwgPSB1ICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGwgPSB1O1xuICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgOTE6XG4gICAgICAgICAgICAgICAgICBnKys7XG5cbiAgICAgICAgICAgICAgICBjYXNlIDQwOlxuICAgICAgICAgICAgICAgICAgZysrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAzNDpcbiAgICAgICAgICAgICAgICBjYXNlIDM5OlxuICAgICAgICAgICAgICAgICAgZm9yICg7IGwrKyA8IEogJiYgZS5jaGFyQ29kZUF0KGwpICE9PSBnOykge1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoMCA9PT0gaykgYnJlYWs7XG4gICAgICAgICAgICAgIGwrKztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgayA9IGUuc3Vic3RyaW5nKHQsIGwpO1xuICAgICAgICAgICAgMCA9PT0gcSAmJiAocSA9IChmID0gZi5yZXBsYWNlKGNhLCAnJykudHJpbSgpKS5jaGFyQ29kZUF0KDApKTtcblxuICAgICAgICAgICAgc3dpdGNoIChxKSB7XG4gICAgICAgICAgICAgIGNhc2UgNjQ6XG4gICAgICAgICAgICAgICAgMCA8IHIgJiYgKGYgPSBmLnJlcGxhY2UoTiwgJycpKTtcbiAgICAgICAgICAgICAgICBnID0gZi5jaGFyQ29kZUF0KDEpO1xuXG4gICAgICAgICAgICAgICAgc3dpdGNoIChnKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIDEwMDpcbiAgICAgICAgICAgICAgICAgIGNhc2UgMTA5OlxuICAgICAgICAgICAgICAgICAgY2FzZSAxMTU6XG4gICAgICAgICAgICAgICAgICBjYXNlIDQ1OlxuICAgICAgICAgICAgICAgICAgICByID0gYztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHIgPSBPO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGsgPSBNKGMsIHIsIGssIGcsIGEgKyAxKTtcbiAgICAgICAgICAgICAgICB0ID0gay5sZW5ndGg7XG4gICAgICAgICAgICAgICAgMCA8IEEgJiYgKHIgPSBYKE8sIGYsIEkpLCBDID0gSCgzLCBrLCByLCBjLCBELCB6LCB0LCBnLCBhLCBoKSwgZiA9IHIuam9pbignJyksIHZvaWQgMCAhPT0gQyAmJiAwID09PSAodCA9IChrID0gQy50cmltKCkpLmxlbmd0aCkgJiYgKGcgPSAwLCBrID0gJycpKTtcbiAgICAgICAgICAgICAgICBpZiAoMCA8IHQpIHN3aXRjaCAoZykge1xuICAgICAgICAgICAgICAgICAgY2FzZSAxMTU6XG4gICAgICAgICAgICAgICAgICAgIGYgPSBmLnJlcGxhY2UoZGEsIGVhKTtcblxuICAgICAgICAgICAgICAgICAgY2FzZSAxMDA6XG4gICAgICAgICAgICAgICAgICBjYXNlIDEwOTpcbiAgICAgICAgICAgICAgICAgIGNhc2UgNDU6XG4gICAgICAgICAgICAgICAgICAgIGsgPSBmICsgJ3snICsgayArICd9JztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgIGNhc2UgMTA3OlxuICAgICAgICAgICAgICAgICAgICBmID0gZi5yZXBsYWNlKGZhLCAnJDEgJDInKTtcbiAgICAgICAgICAgICAgICAgICAgayA9IGYgKyAneycgKyBrICsgJ30nO1xuICAgICAgICAgICAgICAgICAgICBrID0gMSA9PT0gdyB8fCAyID09PSB3ICYmIEwoJ0AnICsgaywgMykgPyAnQC13ZWJraXQtJyArIGsgKyAnQCcgKyBrIDogJ0AnICsgaztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGsgPSBmICsgaywgMTEyID09PSBoICYmIChrID0gKHAgKz0gaywgJycpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgayA9ICcnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgayA9IE0oYywgWChjLCBmLCBJKSwgaywgaCwgYSArIDEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBGICs9IGs7XG4gICAgICAgICAgICBrID0gSSA9IHIgPSB1ID0gcSA9IDA7XG4gICAgICAgICAgICBmID0gJyc7XG4gICAgICAgICAgICBnID0gZS5jaGFyQ29kZUF0KCsrbCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMTI1OlxuICAgICAgICAgIGNhc2UgNTk6XG4gICAgICAgICAgICBmID0gKDAgPCByID8gZi5yZXBsYWNlKE4sICcnKSA6IGYpLnRyaW0oKTtcbiAgICAgICAgICAgIGlmICgxIDwgKHQgPSBmLmxlbmd0aCkpIHN3aXRjaCAoMCA9PT0gdSAmJiAocSA9IGYuY2hhckNvZGVBdCgwKSwgNDUgPT09IHEgfHwgOTYgPCBxICYmIDEyMyA+IHEpICYmICh0ID0gKGYgPSBmLnJlcGxhY2UoJyAnLCAnOicpKS5sZW5ndGgpLCAwIDwgQSAmJiB2b2lkIDAgIT09IChDID0gSCgxLCBmLCBjLCBkLCBELCB6LCBwLmxlbmd0aCwgaCwgYSwgaCkpICYmIDAgPT09ICh0ID0gKGYgPSBDLnRyaW0oKSkubGVuZ3RoKSAmJiAoZiA9ICdcXHgwMFxceDAwJyksIHEgPSBmLmNoYXJDb2RlQXQoMCksIGcgPSBmLmNoYXJDb2RlQXQoMSksIHEpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgNjQ6XG4gICAgICAgICAgICAgICAgaWYgKDEwNSA9PT0gZyB8fCA5OSA9PT0gZykge1xuICAgICAgICAgICAgICAgICAgRyArPSBmICsgZS5jaGFyQXQobCk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICA1OCAhPT0gZi5jaGFyQ29kZUF0KHQgLSAxKSAmJiAocCArPSBQKGYsIHEsIGcsIGYuY2hhckNvZGVBdCgyKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgSSA9IHIgPSB1ID0gcSA9IDA7XG4gICAgICAgICAgICBmID0gJyc7XG4gICAgICAgICAgICBnID0gZS5jaGFyQ29kZUF0KCsrbCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChnKSB7XG4gICAgICAgIGNhc2UgMTM6XG4gICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgNDcgPT09IGIgPyBiID0gMCA6IDAgPT09IDEgKyBxICYmIDEwNyAhPT0gaCAmJiAwIDwgZi5sZW5ndGggJiYgKHIgPSAxLCBmICs9ICdcXHgwMCcpO1xuICAgICAgICAgIDAgPCBBICogWSAmJiBIKDAsIGYsIGMsIGQsIEQsIHosIHAubGVuZ3RoLCBoLCBhLCBoKTtcbiAgICAgICAgICB6ID0gMTtcbiAgICAgICAgICBEKys7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSA1OTpcbiAgICAgICAgY2FzZSAxMjU6XG4gICAgICAgICAgaWYgKDAgPT09IGIgKyBuICsgdiArIG0pIHtcbiAgICAgICAgICAgIHorKztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHorKztcbiAgICAgICAgICB5ID0gZS5jaGFyQXQobCk7XG5cbiAgICAgICAgICBzd2l0Y2ggKGcpIHtcbiAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIGNhc2UgMzI6XG4gICAgICAgICAgICAgIGlmICgwID09PSBuICsgbSArIGIpIHN3aXRjaCAoeCkge1xuICAgICAgICAgICAgICAgIGNhc2UgNDQ6XG4gICAgICAgICAgICAgICAgY2FzZSA1ODpcbiAgICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgY2FzZSAzMjpcbiAgICAgICAgICAgICAgICAgIHkgPSAnJztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgIDMyICE9PSBnICYmICh5ID0gJyAnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICB5ID0gJ1xcXFwwJztcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgIHkgPSAnXFxcXGYnO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgeSA9ICdcXFxcdic7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDM4OlxuICAgICAgICAgICAgICAwID09PSBuICsgYiArIG0gJiYgKHIgPSBJID0gMSwgeSA9ICdcXGYnICsgeSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDEwODpcbiAgICAgICAgICAgICAgaWYgKDAgPT09IG4gKyBiICsgbSArIEUgJiYgMCA8IHUpIHN3aXRjaCAobCAtIHUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAxMTIgPT09IHggJiYgNTggPT09IGUuY2hhckNvZGVBdChsIC0gMykgJiYgKEUgPSB4KTtcblxuICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgIDExMSA9PT0gSyAmJiAoRSA9IEspO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDU4OlxuICAgICAgICAgICAgICAwID09PSBuICsgYiArIG0gJiYgKHUgPSBsKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgNDQ6XG4gICAgICAgICAgICAgIDAgPT09IGIgKyB2ICsgbiArIG0gJiYgKHIgPSAxLCB5ICs9ICdcXHInKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMzQ6XG4gICAgICAgICAgICBjYXNlIDM5OlxuICAgICAgICAgICAgICAwID09PSBiICYmIChuID0gbiA9PT0gZyA/IDAgOiAwID09PSBuID8gZyA6IG4pO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSA5MTpcbiAgICAgICAgICAgICAgMCA9PT0gbiArIGIgKyB2ICYmIG0rKztcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgOTM6XG4gICAgICAgICAgICAgIDAgPT09IG4gKyBiICsgdiAmJiBtLS07XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDQxOlxuICAgICAgICAgICAgICAwID09PSBuICsgYiArIG0gJiYgdi0tO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSA0MDpcbiAgICAgICAgICAgICAgaWYgKDAgPT09IG4gKyBiICsgbSkge1xuICAgICAgICAgICAgICAgIGlmICgwID09PSBxKSBzd2l0Y2ggKDIgKiB4ICsgMyAqIEspIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgNTMzOlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcSA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHYrKztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDY0OlxuICAgICAgICAgICAgICAwID09PSBiICsgdiArIG4gKyBtICsgdSArIGsgJiYgKGsgPSAxKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgNDI6XG4gICAgICAgICAgICBjYXNlIDQ3OlxuICAgICAgICAgICAgICBpZiAoISgwIDwgbiArIG0gKyB2KSkgc3dpdGNoIChiKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgc3dpdGNoICgyICogZyArIDMgKiBlLmNoYXJDb2RlQXQobCArIDEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjM1OlxuICAgICAgICAgICAgICAgICAgICAgIGIgPSA0NztcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlIDIyMDpcbiAgICAgICAgICAgICAgICAgICAgICB0ID0gbCwgYiA9IDQyO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgNDI6XG4gICAgICAgICAgICAgICAgICA0NyA9PT0gZyAmJiA0MiA9PT0geCAmJiB0ICsgMiAhPT0gbCAmJiAoMzMgPT09IGUuY2hhckNvZGVBdCh0ICsgMikgJiYgKHAgKz0gZS5zdWJzdHJpbmcodCwgbCArIDEpKSwgeSA9ICcnLCBiID0gMCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAwID09PSBiICYmIChmICs9IHkpO1xuICAgICAgfVxuXG4gICAgICBLID0geDtcbiAgICAgIHggPSBnO1xuICAgICAgbCsrO1xuICAgIH1cblxuICAgIHQgPSBwLmxlbmd0aDtcblxuICAgIGlmICgwIDwgdCkge1xuICAgICAgciA9IGM7XG4gICAgICBpZiAoMCA8IEEgJiYgKEMgPSBIKDIsIHAsIHIsIGQsIEQsIHosIHQsIGgsIGEsIGgpLCB2b2lkIDAgIT09IEMgJiYgMCA9PT0gKHAgPSBDKS5sZW5ndGgpKSByZXR1cm4gRyArIHAgKyBGO1xuICAgICAgcCA9IHIuam9pbignLCcpICsgJ3snICsgcCArICd9JztcblxuICAgICAgaWYgKDAgIT09IHcgKiBFKSB7XG4gICAgICAgIDIgIT09IHcgfHwgTChwLCAyKSB8fCAoRSA9IDApO1xuXG4gICAgICAgIHN3aXRjaCAoRSkge1xuICAgICAgICAgIGNhc2UgMTExOlxuICAgICAgICAgICAgcCA9IHAucmVwbGFjZShoYSwgJzotbW96LSQxJykgKyBwO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDExMjpcbiAgICAgICAgICAgIHAgPSBwLnJlcGxhY2UoUSwgJzo6LXdlYmtpdC1pbnB1dC0kMScpICsgcC5yZXBsYWNlKFEsICc6Oi1tb3otJDEnKSArIHAucmVwbGFjZShRLCAnOi1tcy1pbnB1dC0kMScpICsgcDtcbiAgICAgICAgfVxuXG4gICAgICAgIEUgPSAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBHICsgcCArIEY7XG4gIH1cblxuICBmdW5jdGlvbiBYKGQsIGMsIGUpIHtcbiAgICB2YXIgaCA9IGMudHJpbSgpLnNwbGl0KGlhKTtcbiAgICBjID0gaDtcbiAgICB2YXIgYSA9IGgubGVuZ3RoLFxuICAgICAgICBtID0gZC5sZW5ndGg7XG5cbiAgICBzd2l0Y2ggKG0pIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgdmFyIGIgPSAwO1xuXG4gICAgICAgIGZvciAoZCA9IDAgPT09IG0gPyAnJyA6IGRbMF0gKyAnICc7IGIgPCBhOyArK2IpIHtcbiAgICAgICAgICBjW2JdID0gWihkLCBjW2JdLCBlLCBtKS50cmltKCk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdmFyIHYgPSBiID0gMDtcblxuICAgICAgICBmb3IgKGMgPSBbXTsgYiA8IGE7ICsrYikge1xuICAgICAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgbTsgKytuKSB7XG4gICAgICAgICAgICBjW3YrK10gPSBaKGRbbl0gKyAnICcsIGhbYl0sIGUsIG0pLnRyaW0oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHJldHVybiBjO1xuICB9XG5cbiAgZnVuY3Rpb24gWihkLCBjLCBlKSB7XG4gICAgdmFyIGggPSBjLmNoYXJDb2RlQXQoMCk7XG4gICAgMzMgPiBoICYmIChoID0gKGMgPSBjLnRyaW0oKSkuY2hhckNvZGVBdCgwKSk7XG5cbiAgICBzd2l0Y2ggKGgpIHtcbiAgICAgIGNhc2UgMzg6XG4gICAgICAgIHJldHVybiBjLnJlcGxhY2UoRiwgJyQxJyArIGQudHJpbSgpKTtcblxuICAgICAgY2FzZSA1ODpcbiAgICAgICAgcmV0dXJuIGQudHJpbSgpICsgYy5yZXBsYWNlKEYsICckMScgKyBkLnRyaW0oKSk7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmICgwIDwgMSAqIGUgJiYgMCA8IGMuaW5kZXhPZignXFxmJykpIHJldHVybiBjLnJlcGxhY2UoRiwgKDU4ID09PSBkLmNoYXJDb2RlQXQoMCkgPyAnJyA6ICckMScpICsgZC50cmltKCkpO1xuICAgIH1cblxuICAgIHJldHVybiBkICsgYztcbiAgfVxuXG4gIGZ1bmN0aW9uIFAoZCwgYywgZSwgaCkge1xuICAgIHZhciBhID0gZCArICc7JyxcbiAgICAgICAgbSA9IDIgKiBjICsgMyAqIGUgKyA0ICogaDtcblxuICAgIGlmICg5NDQgPT09IG0pIHtcbiAgICAgIGQgPSBhLmluZGV4T2YoJzonLCA5KSArIDE7XG4gICAgICB2YXIgYiA9IGEuc3Vic3RyaW5nKGQsIGEubGVuZ3RoIC0gMSkudHJpbSgpO1xuICAgICAgYiA9IGEuc3Vic3RyaW5nKDAsIGQpLnRyaW0oKSArIGIgKyAnOyc7XG4gICAgICByZXR1cm4gMSA9PT0gdyB8fCAyID09PSB3ICYmIEwoYiwgMSkgPyAnLXdlYmtpdC0nICsgYiArIGIgOiBiO1xuICAgIH1cblxuICAgIGlmICgwID09PSB3IHx8IDIgPT09IHcgJiYgIUwoYSwgMSkpIHJldHVybiBhO1xuXG4gICAgc3dpdGNoIChtKSB7XG4gICAgICBjYXNlIDEwMTU6XG4gICAgICAgIHJldHVybiA5NyA9PT0gYS5jaGFyQ29kZUF0KDEwKSA/ICctd2Via2l0LScgKyBhICsgYSA6IGE7XG5cbiAgICAgIGNhc2UgOTUxOlxuICAgICAgICByZXR1cm4gMTE2ID09PSBhLmNoYXJDb2RlQXQoMykgPyAnLXdlYmtpdC0nICsgYSArIGEgOiBhO1xuXG4gICAgICBjYXNlIDk2MzpcbiAgICAgICAgcmV0dXJuIDExMCA9PT0gYS5jaGFyQ29kZUF0KDUpID8gJy13ZWJraXQtJyArIGEgKyBhIDogYTtcblxuICAgICAgY2FzZSAxMDA5OlxuICAgICAgICBpZiAoMTAwICE9PSBhLmNoYXJDb2RlQXQoNCkpIGJyZWFrO1xuXG4gICAgICBjYXNlIDk2OTpcbiAgICAgIGNhc2UgOTQyOlxuICAgICAgICByZXR1cm4gJy13ZWJraXQtJyArIGEgKyBhO1xuXG4gICAgICBjYXNlIDk3ODpcbiAgICAgICAgcmV0dXJuICctd2Via2l0LScgKyBhICsgJy1tb3otJyArIGEgKyBhO1xuXG4gICAgICBjYXNlIDEwMTk6XG4gICAgICBjYXNlIDk4MzpcbiAgICAgICAgcmV0dXJuICctd2Via2l0LScgKyBhICsgJy1tb3otJyArIGEgKyAnLW1zLScgKyBhICsgYTtcblxuICAgICAgY2FzZSA4ODM6XG4gICAgICAgIGlmICg0NSA9PT0gYS5jaGFyQ29kZUF0KDgpKSByZXR1cm4gJy13ZWJraXQtJyArIGEgKyBhO1xuICAgICAgICBpZiAoMCA8IGEuaW5kZXhPZignaW1hZ2Utc2V0KCcsIDExKSkgcmV0dXJuIGEucmVwbGFjZShqYSwgJyQxLXdlYmtpdC0kMicpICsgYTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgOTMyOlxuICAgICAgICBpZiAoNDUgPT09IGEuY2hhckNvZGVBdCg0KSkgc3dpdGNoIChhLmNoYXJDb2RlQXQoNSkpIHtcbiAgICAgICAgICBjYXNlIDEwMzpcbiAgICAgICAgICAgIHJldHVybiAnLXdlYmtpdC1ib3gtJyArIGEucmVwbGFjZSgnLWdyb3cnLCAnJykgKyAnLXdlYmtpdC0nICsgYSArICctbXMtJyArIGEucmVwbGFjZSgnZ3JvdycsICdwb3NpdGl2ZScpICsgYTtcblxuICAgICAgICAgIGNhc2UgMTE1OlxuICAgICAgICAgICAgcmV0dXJuICctd2Via2l0LScgKyBhICsgJy1tcy0nICsgYS5yZXBsYWNlKCdzaHJpbmsnLCAnbmVnYXRpdmUnKSArIGE7XG5cbiAgICAgICAgICBjYXNlIDk4OlxuICAgICAgICAgICAgcmV0dXJuICctd2Via2l0LScgKyBhICsgJy1tcy0nICsgYS5yZXBsYWNlKCdiYXNpcycsICdwcmVmZXJyZWQtc2l6ZScpICsgYTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJy13ZWJraXQtJyArIGEgKyAnLW1zLScgKyBhICsgYTtcblxuICAgICAgY2FzZSA5NjQ6XG4gICAgICAgIHJldHVybiAnLXdlYmtpdC0nICsgYSArICctbXMtZmxleC0nICsgYSArIGE7XG5cbiAgICAgIGNhc2UgMTAyMzpcbiAgICAgICAgaWYgKDk5ICE9PSBhLmNoYXJDb2RlQXQoOCkpIGJyZWFrO1xuICAgICAgICBiID0gYS5zdWJzdHJpbmcoYS5pbmRleE9mKCc6JywgMTUpKS5yZXBsYWNlKCdmbGV4LScsICcnKS5yZXBsYWNlKCdzcGFjZS1iZXR3ZWVuJywgJ2p1c3RpZnknKTtcbiAgICAgICAgcmV0dXJuICctd2Via2l0LWJveC1wYWNrJyArIGIgKyAnLXdlYmtpdC0nICsgYSArICctbXMtZmxleC1wYWNrJyArIGIgKyBhO1xuXG4gICAgICBjYXNlIDEwMDU6XG4gICAgICAgIHJldHVybiBrYS50ZXN0KGEpID8gYS5yZXBsYWNlKGFhLCAnOi13ZWJraXQtJykgKyBhLnJlcGxhY2UoYWEsICc6LW1vei0nKSArIGEgOiBhO1xuXG4gICAgICBjYXNlIDFlMzpcbiAgICAgICAgYiA9IGEuc3Vic3RyaW5nKDEzKS50cmltKCk7XG4gICAgICAgIGMgPSBiLmluZGV4T2YoJy0nKSArIDE7XG5cbiAgICAgICAgc3dpdGNoIChiLmNoYXJDb2RlQXQoMCkgKyBiLmNoYXJDb2RlQXQoYykpIHtcbiAgICAgICAgICBjYXNlIDIyNjpcbiAgICAgICAgICAgIGIgPSBhLnJlcGxhY2UoRywgJ3RiJyk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMjMyOlxuICAgICAgICAgICAgYiA9IGEucmVwbGFjZShHLCAndGItcmwnKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAyMjA6XG4gICAgICAgICAgICBiID0gYS5yZXBsYWNlKEcsICdscicpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJy13ZWJraXQtJyArIGEgKyAnLW1zLScgKyBiICsgYTtcblxuICAgICAgY2FzZSAxMDE3OlxuICAgICAgICBpZiAoLTEgPT09IGEuaW5kZXhPZignc3RpY2t5JywgOSkpIGJyZWFrO1xuXG4gICAgICBjYXNlIDk3NTpcbiAgICAgICAgYyA9IChhID0gZCkubGVuZ3RoIC0gMTA7XG4gICAgICAgIGIgPSAoMzMgPT09IGEuY2hhckNvZGVBdChjKSA/IGEuc3Vic3RyaW5nKDAsIGMpIDogYSkuc3Vic3RyaW5nKGQuaW5kZXhPZignOicsIDcpICsgMSkudHJpbSgpO1xuXG4gICAgICAgIHN3aXRjaCAobSA9IGIuY2hhckNvZGVBdCgwKSArIChiLmNoYXJDb2RlQXQoNykgfCAwKSkge1xuICAgICAgICAgIGNhc2UgMjAzOlxuICAgICAgICAgICAgaWYgKDExMSA+IGIuY2hhckNvZGVBdCg4KSkgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDExNTpcbiAgICAgICAgICAgIGEgPSBhLnJlcGxhY2UoYiwgJy13ZWJraXQtJyArIGIpICsgJzsnICsgYTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAyMDc6XG4gICAgICAgICAgY2FzZSAxMDI6XG4gICAgICAgICAgICBhID0gYS5yZXBsYWNlKGIsICctd2Via2l0LScgKyAoMTAyIDwgbSA/ICdpbmxpbmUtJyA6ICcnKSArICdib3gnKSArICc7JyArIGEucmVwbGFjZShiLCAnLXdlYmtpdC0nICsgYikgKyAnOycgKyBhLnJlcGxhY2UoYiwgJy1tcy0nICsgYiArICdib3gnKSArICc7JyArIGE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYSArICc7JztcblxuICAgICAgY2FzZSA5Mzg6XG4gICAgICAgIGlmICg0NSA9PT0gYS5jaGFyQ29kZUF0KDUpKSBzd2l0Y2ggKGEuY2hhckNvZGVBdCg2KSkge1xuICAgICAgICAgIGNhc2UgMTA1OlxuICAgICAgICAgICAgcmV0dXJuIGIgPSBhLnJlcGxhY2UoJy1pdGVtcycsICcnKSwgJy13ZWJraXQtJyArIGEgKyAnLXdlYmtpdC1ib3gtJyArIGIgKyAnLW1zLWZsZXgtJyArIGIgKyBhO1xuXG4gICAgICAgICAgY2FzZSAxMTU6XG4gICAgICAgICAgICByZXR1cm4gJy13ZWJraXQtJyArIGEgKyAnLW1zLWZsZXgtaXRlbS0nICsgYS5yZXBsYWNlKGJhLCAnJykgKyBhO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiAnLXdlYmtpdC0nICsgYSArICctbXMtZmxleC1saW5lLXBhY2snICsgYS5yZXBsYWNlKCdhbGlnbi1jb250ZW50JywgJycpLnJlcGxhY2UoYmEsICcnKSArIGE7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgOTczOlxuICAgICAgY2FzZSA5ODk6XG4gICAgICAgIGlmICg0NSAhPT0gYS5jaGFyQ29kZUF0KDMpIHx8IDEyMiA9PT0gYS5jaGFyQ29kZUF0KDQpKSBicmVhaztcblxuICAgICAgY2FzZSA5MzE6XG4gICAgICBjYXNlIDk1MzpcbiAgICAgICAgaWYgKCEwID09PSBsYS50ZXN0KGQpKSByZXR1cm4gMTE1ID09PSAoYiA9IGQuc3Vic3RyaW5nKGQuaW5kZXhPZignOicpICsgMSkpLmNoYXJDb2RlQXQoMCkgPyBQKGQucmVwbGFjZSgnc3RyZXRjaCcsICdmaWxsLWF2YWlsYWJsZScpLCBjLCBlLCBoKS5yZXBsYWNlKCc6ZmlsbC1hdmFpbGFibGUnLCAnOnN0cmV0Y2gnKSA6IGEucmVwbGFjZShiLCAnLXdlYmtpdC0nICsgYikgKyBhLnJlcGxhY2UoYiwgJy1tb3otJyArIGIucmVwbGFjZSgnZmlsbC0nLCAnJykpICsgYTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgOTYyOlxuICAgICAgICBpZiAoYSA9ICctd2Via2l0LScgKyBhICsgKDEwMiA9PT0gYS5jaGFyQ29kZUF0KDUpID8gJy1tcy0nICsgYSA6ICcnKSArIGEsIDIxMSA9PT0gZSArIGggJiYgMTA1ID09PSBhLmNoYXJDb2RlQXQoMTMpICYmIDAgPCBhLmluZGV4T2YoJ3RyYW5zZm9ybScsIDEwKSkgcmV0dXJuIGEuc3Vic3RyaW5nKDAsIGEuaW5kZXhPZignOycsIDI3KSArIDEpLnJlcGxhY2UobWEsICckMS13ZWJraXQtJDInKSArIGE7XG4gICAgfVxuXG4gICAgcmV0dXJuIGE7XG4gIH1cblxuICBmdW5jdGlvbiBMKGQsIGMpIHtcbiAgICB2YXIgZSA9IGQuaW5kZXhPZigxID09PSBjID8gJzonIDogJ3snKSxcbiAgICAgICAgaCA9IGQuc3Vic3RyaW5nKDAsIDMgIT09IGMgPyBlIDogMTApO1xuICAgIGUgPSBkLnN1YnN0cmluZyhlICsgMSwgZC5sZW5ndGggLSAxKTtcbiAgICByZXR1cm4gUigyICE9PSBjID8gaCA6IGgucmVwbGFjZShuYSwgJyQxJyksIGUsIGMpO1xuICB9XG5cbiAgZnVuY3Rpb24gZWEoZCwgYykge1xuICAgIHZhciBlID0gUChjLCBjLmNoYXJDb2RlQXQoMCksIGMuY2hhckNvZGVBdCgxKSwgYy5jaGFyQ29kZUF0KDIpKTtcbiAgICByZXR1cm4gZSAhPT0gYyArICc7JyA/IGUucmVwbGFjZShvYSwgJyBvciAoJDEpJykuc3Vic3RyaW5nKDQpIDogJygnICsgYyArICcpJztcbiAgfVxuXG4gIGZ1bmN0aW9uIEgoZCwgYywgZSwgaCwgYSwgbSwgYiwgdiwgbiwgcSkge1xuICAgIGZvciAodmFyIGcgPSAwLCB4ID0gYywgdzsgZyA8IEE7ICsrZykge1xuICAgICAgc3dpdGNoICh3ID0gU1tnXS5jYWxsKEIsIGQsIHgsIGUsIGgsIGEsIG0sIGIsIHYsIG4sIHEpKSB7XG4gICAgICAgIGNhc2Ugdm9pZCAwOlxuICAgICAgICBjYXNlICExOlxuICAgICAgICBjYXNlICEwOlxuICAgICAgICBjYXNlIG51bGw6XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB4ID0gdztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoeCAhPT0gYykgcmV0dXJuIHg7XG4gIH1cblxuICBmdW5jdGlvbiBUKGQpIHtcbiAgICBzd2l0Y2ggKGQpIHtcbiAgICAgIGNhc2Ugdm9pZCAwOlxuICAgICAgY2FzZSBudWxsOlxuICAgICAgICBBID0gUy5sZW5ndGggPSAwO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBkKSBTW0ErK10gPSBkO2Vsc2UgaWYgKCdvYmplY3QnID09PSB0eXBlb2YgZCkgZm9yICh2YXIgYyA9IDAsIGUgPSBkLmxlbmd0aDsgYyA8IGU7ICsrYykge1xuICAgICAgICAgIFQoZFtjXSk7XG4gICAgICAgIH0gZWxzZSBZID0gISFkIHwgMDtcbiAgICB9XG5cbiAgICByZXR1cm4gVDtcbiAgfVxuXG4gIGZ1bmN0aW9uIFUoZCkge1xuICAgIGQgPSBkLnByZWZpeDtcbiAgICB2b2lkIDAgIT09IGQgJiYgKFIgPSBudWxsLCBkID8gJ2Z1bmN0aW9uJyAhPT0gdHlwZW9mIGQgPyB3ID0gMSA6ICh3ID0gMiwgUiA9IGQpIDogdyA9IDApO1xuICAgIHJldHVybiBVO1xuICB9XG5cbiAgZnVuY3Rpb24gQihkLCBjKSB7XG4gICAgdmFyIGUgPSBkO1xuICAgIDMzID4gZS5jaGFyQ29kZUF0KDApICYmIChlID0gZS50cmltKCkpO1xuICAgIFYgPSBlO1xuICAgIGUgPSBbVl07XG5cbiAgICBpZiAoMCA8IEEpIHtcbiAgICAgIHZhciBoID0gSCgtMSwgYywgZSwgZSwgRCwgeiwgMCwgMCwgMCwgMCk7XG4gICAgICB2b2lkIDAgIT09IGggJiYgJ3N0cmluZycgPT09IHR5cGVvZiBoICYmIChjID0gaCk7XG4gICAgfVxuXG4gICAgdmFyIGEgPSBNKE8sIGUsIGMsIDAsIDApO1xuICAgIDAgPCBBICYmIChoID0gSCgtMiwgYSwgZSwgZSwgRCwgeiwgYS5sZW5ndGgsIDAsIDAsIDApLCB2b2lkIDAgIT09IGggJiYgKGEgPSBoKSk7XG4gICAgViA9ICcnO1xuICAgIEUgPSAwO1xuICAgIHogPSBEID0gMTtcbiAgICByZXR1cm4gYTtcbiAgfVxuXG4gIHZhciBjYSA9IC9eXFwwKy9nLFxuICAgICAgTiA9IC9bXFwwXFxyXFxmXS9nLFxuICAgICAgYWEgPSAvOiAqL2csXG4gICAgICBrYSA9IC96b298Z3JhLyxcbiAgICAgIG1hID0gLyhbLDogXSkodHJhbnNmb3JtKS9nLFxuICAgICAgaWEgPSAvLFxccis/L2csXG4gICAgICBGID0gLyhbXFx0XFxyXFxuIF0pKlxcZj8mL2csXG4gICAgICBmYSA9IC9AKGtcXHcrKVxccyooXFxTKilcXHMqLyxcbiAgICAgIFEgPSAvOjoocGxhY2UpL2csXG4gICAgICBoYSA9IC86KHJlYWQtb25seSkvZyxcbiAgICAgIEcgPSAvW3N2aF1cXHcrLVt0YmxyXXsyfS8sXG4gICAgICBkYSA9IC9cXChcXHMqKC4qKVxccypcXCkvZyxcbiAgICAgIG9hID0gLyhbXFxzXFxTXSo/KTsvZyxcbiAgICAgIGJhID0gLy1zZWxmfGZsZXgtL2csXG4gICAgICBuYSA9IC9bXl0qPyg6W3JwXVtlbF1hW1xcdy1dKylbXl0qLyxcbiAgICAgIGxhID0gL3N0cmV0Y2h8OlxccypcXHcrXFwtKD86Y29udGV8YXZhaWwpLyxcbiAgICAgIGphID0gLyhbXi1dKShpbWFnZS1zZXRcXCgpLyxcbiAgICAgIHogPSAxLFxuICAgICAgRCA9IDEsXG4gICAgICBFID0gMCxcbiAgICAgIHcgPSAxLFxuICAgICAgTyA9IFtdLFxuICAgICAgUyA9IFtdLFxuICAgICAgQSA9IDAsXG4gICAgICBSID0gbnVsbCxcbiAgICAgIFkgPSAwLFxuICAgICAgViA9ICcnO1xuICBCLnVzZSA9IFQ7XG4gIEIuc2V0ID0gVTtcbiAgdm9pZCAwICE9PSBXICYmIFUoVyk7XG4gIHJldHVybiBCO1xufVxuXG5leHBvcnQgZGVmYXVsdCBzdHlsaXNfbWluO1xuIiwidmFyIHdlYWtNZW1vaXplID0gZnVuY3Rpb24gd2Vha01lbW9pemUoZnVuYykge1xuICAvLyAkRmxvd0ZpeE1lIGZsb3cgZG9lc24ndCBpbmNsdWRlIGFsbCBub24tcHJpbWl0aXZlIHR5cGVzIGFzIGFsbG93ZWQgZm9yIHdlYWttYXBzXG4gIHZhciBjYWNoZSA9IG5ldyBXZWFrTWFwKCk7XG4gIHJldHVybiBmdW5jdGlvbiAoYXJnKSB7XG4gICAgaWYgKGNhY2hlLmhhcyhhcmcpKSB7XG4gICAgICAvLyAkRmxvd0ZpeE1lXG4gICAgICByZXR1cm4gY2FjaGUuZ2V0KGFyZyk7XG4gICAgfVxuXG4gICAgdmFyIHJldCA9IGZ1bmMoYXJnKTtcbiAgICBjYWNoZS5zZXQoYXJnLCByZXQpO1xuICAgIHJldHVybiByZXQ7XG4gIH07XG59O1xuXG5leHBvcnQgZGVmYXVsdCB3ZWFrTWVtb2l6ZTtcbiIsImltcG9ydCB7IFN0eWxlU2hlZXQgfSBmcm9tICdAZW1vdGlvbi9zaGVldCc7XG5pbXBvcnQgU3R5bGlzIGZyb20gJ0BlbW90aW9uL3N0eWxpcyc7XG5pbXBvcnQgJ0BlbW90aW9uL3dlYWstbWVtb2l6ZSc7XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90aHlzdWx0YW4vc3R5bGlzLmpzL3RyZWUvbWFzdGVyL3BsdWdpbnMvcnVsZS1zaGVldFxuLy8gaW5saW5lZCB0byBhdm9pZCB1bWQgd3JhcHBlciBhbmQgcGVlckRlcCB3YXJuaW5ncy9pbnN0YWxsaW5nIHN0eWxpc1xuLy8gc2luY2Ugd2UgdXNlIHN0eWxpcyBhZnRlciBjbG9zdXJlIGNvbXBpbGVyXG52YXIgZGVsaW1pdGVyID0gJy8qfCovJztcbnZhciBuZWVkbGUgPSBkZWxpbWl0ZXIgKyAnfSc7XG5cbmZ1bmN0aW9uIHRvU2hlZXQoYmxvY2spIHtcbiAgaWYgKGJsb2NrKSB7XG4gICAgU2hlZXQuY3VycmVudC5pbnNlcnQoYmxvY2sgKyAnfScpO1xuICB9XG59XG5cbnZhciBTaGVldCA9IHtcbiAgY3VycmVudDogbnVsbFxufTtcbnZhciBydWxlU2hlZXQgPSBmdW5jdGlvbiBydWxlU2hlZXQoY29udGV4dCwgY29udGVudCwgc2VsZWN0b3JzLCBwYXJlbnRzLCBsaW5lLCBjb2x1bW4sIGxlbmd0aCwgbnMsIGRlcHRoLCBhdCkge1xuICBzd2l0Y2ggKGNvbnRleHQpIHtcbiAgICAvLyBwcm9wZXJ0eVxuICAgIGNhc2UgMTpcbiAgICAgIHtcbiAgICAgICAgc3dpdGNoIChjb250ZW50LmNoYXJDb2RlQXQoMCkpIHtcbiAgICAgICAgICBjYXNlIDY0OlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAvLyBAaW1wb3J0XG4gICAgICAgICAgICAgIFNoZWV0LmN1cnJlbnQuaW5zZXJ0KGNvbnRlbnQgKyAnOycpO1xuICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgLy8gY2hhcmNvZGUgZm9yIGxcblxuICAgICAgICAgIGNhc2UgMTA4OlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAvLyBjaGFyY29kZSBmb3IgYlxuICAgICAgICAgICAgICAvLyB0aGlzIGlnbm9yZXMgbGFiZWxcbiAgICAgICAgICAgICAgaWYgKGNvbnRlbnQuY2hhckNvZGVBdCgyKSA9PT0gOTgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIC8vIHNlbGVjdG9yXG5cbiAgICBjYXNlIDI6XG4gICAgICB7XG4gICAgICAgIGlmIChucyA9PT0gMCkgcmV0dXJuIGNvbnRlbnQgKyBkZWxpbWl0ZXI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIC8vIGF0LXJ1bGVcblxuICAgIGNhc2UgMzpcbiAgICAgIHtcbiAgICAgICAgc3dpdGNoIChucykge1xuICAgICAgICAgIC8vIEBmb250LWZhY2UsIEBwYWdlXG4gICAgICAgICAgY2FzZSAxMDI6XG4gICAgICAgICAgY2FzZSAxMTI6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIFNoZWV0LmN1cnJlbnQuaW5zZXJ0KHNlbGVjdG9yc1swXSArIGNvbnRlbnQpO1xuICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICByZXR1cm4gY29udGVudCArIChhdCA9PT0gMCA/IGRlbGltaXRlciA6ICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgY2FzZSAtMjpcbiAgICAgIHtcbiAgICAgICAgY29udGVudC5zcGxpdChuZWVkbGUpLmZvckVhY2godG9TaGVldCk7XG4gICAgICB9XG4gIH1cbn07XG5cbnZhciBjcmVhdGVDYWNoZSA9IGZ1bmN0aW9uIGNyZWF0ZUNhY2hlKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCkgb3B0aW9ucyA9IHt9O1xuICB2YXIga2V5ID0gb3B0aW9ucy5rZXkgfHwgJ2Nzcyc7XG4gIHZhciBzdHlsaXNPcHRpb25zO1xuXG4gIGlmIChvcHRpb25zLnByZWZpeCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgc3R5bGlzT3B0aW9ucyA9IHtcbiAgICAgIHByZWZpeDogb3B0aW9ucy5wcmVmaXhcbiAgICB9O1xuICB9XG5cbiAgdmFyIHN0eWxpcyA9IG5ldyBTdHlsaXMoc3R5bGlzT3B0aW9ucyk7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAvLyAkRmxvd0ZpeE1lXG4gICAgaWYgKC9bXmEtei1dLy50ZXN0KGtleSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkVtb3Rpb24ga2V5IG11c3Qgb25seSBjb250YWluIGxvd2VyIGNhc2UgYWxwaGFiZXRpY2FsIGNoYXJhY3RlcnMgYW5kIC0gYnV0IFxcXCJcIiArIGtleSArIFwiXFxcIiB3YXMgcGFzc2VkXCIpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBpbnNlcnRlZCA9IHt9OyAvLyAkRmxvd0ZpeE1lXG5cbiAgdmFyIGNvbnRhaW5lcjtcblxuICB7XG4gICAgY29udGFpbmVyID0gb3B0aW9ucy5jb250YWluZXIgfHwgZG9jdW1lbnQuaGVhZDtcbiAgICB2YXIgbm9kZXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwic3R5bGVbZGF0YS1lbW90aW9uLVwiICsga2V5ICsgXCJdXCIpO1xuICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwobm9kZXMsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICB2YXIgYXR0cmliID0gbm9kZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLWVtb3Rpb24tXCIgKyBrZXkpOyAvLyAkRmxvd0ZpeE1lXG5cbiAgICAgIGF0dHJpYi5zcGxpdCgnICcpLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIGluc2VydGVkW2lkXSA9IHRydWU7XG4gICAgICB9KTtcblxuICAgICAgaWYgKG5vZGUucGFyZW50Tm9kZSAhPT0gY29udGFpbmVyKSB7XG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHZhciBfaW5zZXJ0O1xuXG4gIHtcbiAgICBzdHlsaXMudXNlKG9wdGlvbnMuc3R5bGlzUGx1Z2lucykocnVsZVNoZWV0KTtcblxuICAgIF9pbnNlcnQgPSBmdW5jdGlvbiBpbnNlcnQoc2VsZWN0b3IsIHNlcmlhbGl6ZWQsIHNoZWV0LCBzaG91bGRDYWNoZSkge1xuICAgICAgdmFyIG5hbWUgPSBzZXJpYWxpemVkLm5hbWU7XG4gICAgICBTaGVldC5jdXJyZW50ID0gc2hlZXQ7XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHNlcmlhbGl6ZWQubWFwICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIG1hcCA9IHNlcmlhbGl6ZWQubWFwO1xuICAgICAgICBTaGVldC5jdXJyZW50ID0ge1xuICAgICAgICAgIGluc2VydDogZnVuY3Rpb24gaW5zZXJ0KHJ1bGUpIHtcbiAgICAgICAgICAgIHNoZWV0Lmluc2VydChydWxlICsgbWFwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHN0eWxpcyhzZWxlY3Rvciwgc2VyaWFsaXplZC5zdHlsZXMpO1xuXG4gICAgICBpZiAoc2hvdWxkQ2FjaGUpIHtcbiAgICAgICAgY2FjaGUuaW5zZXJ0ZWRbbmFtZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIC8vIGh0dHBzOi8vZXNiZW5jaC5jb20vYmVuY2gvNWJmNzM3MWE0Y2Q3ZTYwMDllZjYxZDBhXG4gICAgdmFyIGNvbW1lbnRTdGFydCA9IC9cXC9cXCovZztcbiAgICB2YXIgY29tbWVudEVuZCA9IC9cXCpcXC8vZztcbiAgICBzdHlsaXMudXNlKGZ1bmN0aW9uIChjb250ZXh0LCBjb250ZW50KSB7XG4gICAgICBzd2l0Y2ggKGNvbnRleHQpIHtcbiAgICAgICAgY2FzZSAtMTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB3aGlsZSAoY29tbWVudFN0YXJ0LnRlc3QoY29udGVudCkpIHtcbiAgICAgICAgICAgICAgY29tbWVudEVuZC5sYXN0SW5kZXggPSBjb21tZW50U3RhcnQubGFzdEluZGV4O1xuXG4gICAgICAgICAgICAgIGlmIChjb21tZW50RW5kLnRlc3QoY29udGVudCkpIHtcbiAgICAgICAgICAgICAgICBjb21tZW50U3RhcnQubGFzdEluZGV4ID0gY29tbWVudEVuZC5sYXN0SW5kZXg7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdXIgc3R5bGVzIGhhdmUgYW4gdW50ZXJtaW5hdGVkIGNvbW1lbnQgKFwiLypcIiB3aXRob3V0IGNvcnJlc3BvbmRpbmcgXCIqL1wiKS4nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29tbWVudFN0YXJ0Lmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgc3R5bGlzLnVzZShmdW5jdGlvbiAoY29udGV4dCwgY29udGVudCwgc2VsZWN0b3JzKSB7XG4gICAgICBzd2l0Y2ggKGNvbnRleHQpIHtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzZWxlY3RvcnMubGVuZ3RoOyBsZW4gPiBpOyBpKyspIHtcbiAgICAgICAgICAgICAgLy8gOmxhc3QtY2hpbGQgaXNuJ3QgaW5jbHVkZWQgaGVyZSBzaW5jZSBpdCdzIHNhZmVcbiAgICAgICAgICAgICAgLy8gYmVjYXVzZSBhIHN0eWxlIGVsZW1lbnQgd2lsbCBuZXZlciBiZSB0aGUgbGFzdCBlbGVtZW50XG4gICAgICAgICAgICAgIHZhciBtYXRjaCA9IHNlbGVjdG9yc1tpXS5tYXRjaCgvOihmaXJzdHxudGh8bnRoLWxhc3QpLWNoaWxkLyk7XG5cbiAgICAgICAgICAgICAgaWYgKG1hdGNoICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIlRoZSBwc2V1ZG8gY2xhc3MgXFxcIlwiICsgbWF0Y2hbMF0gKyBcIlxcXCIgaXMgcG90ZW50aWFsbHkgdW5zYWZlIHdoZW4gZG9pbmcgc2VydmVyLXNpZGUgcmVuZGVyaW5nLiBUcnkgY2hhbmdpbmcgaXQgdG8gXFxcIlwiICsgbWF0Y2hbMV0gKyBcIi1vZi10eXBlXFxcIlwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICB2YXIgY2FjaGUgPSB7XG4gICAga2V5OiBrZXksXG4gICAgc2hlZXQ6IG5ldyBTdHlsZVNoZWV0KHtcbiAgICAgIGtleToga2V5LFxuICAgICAgY29udGFpbmVyOiBjb250YWluZXIsXG4gICAgICBub25jZTogb3B0aW9ucy5ub25jZSxcbiAgICAgIHNwZWVkeTogb3B0aW9ucy5zcGVlZHlcbiAgICB9KSxcbiAgICBub25jZTogb3B0aW9ucy5ub25jZSxcbiAgICBpbnNlcnRlZDogaW5zZXJ0ZWQsXG4gICAgcmVnaXN0ZXJlZDoge30sXG4gICAgaW5zZXJ0OiBfaW5zZXJ0XG4gIH07XG4gIHJldHVybiBjYWNoZTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZUNhY2hlO1xuIiwidmFyIGlzQnJvd3NlciA9IFwib2JqZWN0XCIgIT09ICd1bmRlZmluZWQnO1xuZnVuY3Rpb24gZ2V0UmVnaXN0ZXJlZFN0eWxlcyhyZWdpc3RlcmVkLCByZWdpc3RlcmVkU3R5bGVzLCBjbGFzc05hbWVzKSB7XG4gIHZhciByYXdDbGFzc05hbWUgPSAnJztcbiAgY2xhc3NOYW1lcy5zcGxpdCgnICcpLmZvckVhY2goZnVuY3Rpb24gKGNsYXNzTmFtZSkge1xuICAgIGlmIChyZWdpc3RlcmVkW2NsYXNzTmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmVnaXN0ZXJlZFN0eWxlcy5wdXNoKHJlZ2lzdGVyZWRbY2xhc3NOYW1lXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJhd0NsYXNzTmFtZSArPSBjbGFzc05hbWUgKyBcIiBcIjtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmF3Q2xhc3NOYW1lO1xufVxudmFyIGluc2VydFN0eWxlcyA9IGZ1bmN0aW9uIGluc2VydFN0eWxlcyhjYWNoZSwgc2VyaWFsaXplZCwgaXNTdHJpbmdUYWcpIHtcbiAgdmFyIGNsYXNzTmFtZSA9IGNhY2hlLmtleSArIFwiLVwiICsgc2VyaWFsaXplZC5uYW1lO1xuXG4gIGlmICggLy8gd2Ugb25seSBuZWVkIHRvIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSByZWdpc3RlcmVkIGNhY2hlIGlmIHRoZVxuICAvLyBjbGFzcyBuYW1lIGNvdWxkIGJlIHVzZWQgZnVydGhlciBkb3duXG4gIC8vIHRoZSB0cmVlIGJ1dCBpZiBpdCdzIGEgc3RyaW5nIHRhZywgd2Uga25vdyBpdCB3b24ndFxuICAvLyBzbyB3ZSBkb24ndCBoYXZlIHRvIGFkZCBpdCB0byByZWdpc3RlcmVkIGNhY2hlLlxuICAvLyB0aGlzIGltcHJvdmVzIG1lbW9yeSB1c2FnZSBzaW5jZSB3ZSBjYW4gYXZvaWQgc3RvcmluZyB0aGUgd2hvbGUgc3R5bGUgc3RyaW5nXG4gIChpc1N0cmluZ1RhZyA9PT0gZmFsc2UgfHwgLy8gd2UgbmVlZCB0byBhbHdheXMgc3RvcmUgaXQgaWYgd2UncmUgaW4gY29tcGF0IG1vZGUgYW5kXG4gIC8vIGluIG5vZGUgc2luY2UgZW1vdGlvbi1zZXJ2ZXIgcmVsaWVzIG9uIHdoZXRoZXIgYSBzdHlsZSBpcyBpblxuICAvLyB0aGUgcmVnaXN0ZXJlZCBjYWNoZSB0byBrbm93IHdoZXRoZXIgYSBzdHlsZSBpcyBnbG9iYWwgb3Igbm90XG4gIC8vIGFsc28sIG5vdGUgdGhhdCB0aGlzIGNoZWNrIHdpbGwgYmUgZGVhZCBjb2RlIGVsaW1pbmF0ZWQgaW4gdGhlIGJyb3dzZXJcbiAgaXNCcm93c2VyID09PSBmYWxzZSAmJiBjYWNoZS5jb21wYXQgIT09IHVuZGVmaW5lZCkgJiYgY2FjaGUucmVnaXN0ZXJlZFtjbGFzc05hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICBjYWNoZS5yZWdpc3RlcmVkW2NsYXNzTmFtZV0gPSBzZXJpYWxpemVkLnN0eWxlcztcbiAgfVxuXG4gIGlmIChjYWNoZS5pbnNlcnRlZFtzZXJpYWxpemVkLm5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgY3VycmVudCA9IHNlcmlhbGl6ZWQ7XG5cbiAgICBkbyB7XG4gICAgICB2YXIgbWF5YmVTdHlsZXMgPSBjYWNoZS5pbnNlcnQoXCIuXCIgKyBjbGFzc05hbWUsIGN1cnJlbnQsIGNhY2hlLnNoZWV0LCB0cnVlKTtcblxuICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgICB9IHdoaWxlIChjdXJyZW50ICE9PSB1bmRlZmluZWQpO1xuICB9XG59O1xuXG5leHBvcnQgeyBnZXRSZWdpc3RlcmVkU3R5bGVzLCBpbnNlcnRTdHlsZXMgfTtcbiIsIi8qIGVzbGludC1kaXNhYmxlICovXG4vLyBtdXJtdXJoYXNoMiB2aWEgaHR0cHM6Ly9naXRodWIuY29tL2dhcnljb3VydC9tdXJtdXJoYXNoLWpzL2Jsb2IvbWFzdGVyL211cm11cmhhc2gyX2djLmpzXG5mdW5jdGlvbiBtdXJtdXJoYXNoMl8zMl9nYyhzdHIpIHtcbiAgdmFyIGwgPSBzdHIubGVuZ3RoLFxuICAgICAgaCA9IGwgXiBsLFxuICAgICAgaSA9IDAsXG4gICAgICBrO1xuXG4gIHdoaWxlIChsID49IDQpIHtcbiAgICBrID0gc3RyLmNoYXJDb2RlQXQoaSkgJiAweGZmIHwgKHN0ci5jaGFyQ29kZUF0KCsraSkgJiAweGZmKSA8PCA4IHwgKHN0ci5jaGFyQ29kZUF0KCsraSkgJiAweGZmKSA8PCAxNiB8IChzdHIuY2hhckNvZGVBdCgrK2kpICYgMHhmZikgPDwgMjQ7XG4gICAgayA9IChrICYgMHhmZmZmKSAqIDB4NWJkMWU5OTUgKyAoKChrID4+PiAxNikgKiAweDViZDFlOTk1ICYgMHhmZmZmKSA8PCAxNik7XG4gICAgayBePSBrID4+PiAyNDtcbiAgICBrID0gKGsgJiAweGZmZmYpICogMHg1YmQxZTk5NSArICgoKGsgPj4+IDE2KSAqIDB4NWJkMWU5OTUgJiAweGZmZmYpIDw8IDE2KTtcbiAgICBoID0gKGggJiAweGZmZmYpICogMHg1YmQxZTk5NSArICgoKGggPj4+IDE2KSAqIDB4NWJkMWU5OTUgJiAweGZmZmYpIDw8IDE2KSBeIGs7XG4gICAgbCAtPSA0O1xuICAgICsraTtcbiAgfVxuXG4gIHN3aXRjaCAobCkge1xuICAgIGNhc2UgMzpcbiAgICAgIGggXj0gKHN0ci5jaGFyQ29kZUF0KGkgKyAyKSAmIDB4ZmYpIDw8IDE2O1xuXG4gICAgY2FzZSAyOlxuICAgICAgaCBePSAoc3RyLmNoYXJDb2RlQXQoaSArIDEpICYgMHhmZikgPDwgODtcblxuICAgIGNhc2UgMTpcbiAgICAgIGggXj0gc3RyLmNoYXJDb2RlQXQoaSkgJiAweGZmO1xuICAgICAgaCA9IChoICYgMHhmZmZmKSAqIDB4NWJkMWU5OTUgKyAoKChoID4+PiAxNikgKiAweDViZDFlOTk1ICYgMHhmZmZmKSA8PCAxNik7XG4gIH1cblxuICBoIF49IGggPj4+IDEzO1xuICBoID0gKGggJiAweGZmZmYpICogMHg1YmQxZTk5NSArICgoKGggPj4+IDE2KSAqIDB4NWJkMWU5OTUgJiAweGZmZmYpIDw8IDE2KTtcbiAgaCBePSBoID4+PiAxNTtcbiAgcmV0dXJuIChoID4+PiAwKS50b1N0cmluZygzNik7XG59XG5cbmV4cG9ydCBkZWZhdWx0IG11cm11cmhhc2gyXzMyX2djO1xuIiwidmFyIHVuaXRsZXNzS2V5cyA9IHtcbiAgYW5pbWF0aW9uSXRlcmF0aW9uQ291bnQ6IDEsXG4gIGJvcmRlckltYWdlT3V0c2V0OiAxLFxuICBib3JkZXJJbWFnZVNsaWNlOiAxLFxuICBib3JkZXJJbWFnZVdpZHRoOiAxLFxuICBib3hGbGV4OiAxLFxuICBib3hGbGV4R3JvdXA6IDEsXG4gIGJveE9yZGluYWxHcm91cDogMSxcbiAgY29sdW1uQ291bnQ6IDEsXG4gIGNvbHVtbnM6IDEsXG4gIGZsZXg6IDEsXG4gIGZsZXhHcm93OiAxLFxuICBmbGV4UG9zaXRpdmU6IDEsXG4gIGZsZXhTaHJpbms6IDEsXG4gIGZsZXhOZWdhdGl2ZTogMSxcbiAgZmxleE9yZGVyOiAxLFxuICBncmlkUm93OiAxLFxuICBncmlkUm93RW5kOiAxLFxuICBncmlkUm93U3BhbjogMSxcbiAgZ3JpZFJvd1N0YXJ0OiAxLFxuICBncmlkQ29sdW1uOiAxLFxuICBncmlkQ29sdW1uRW5kOiAxLFxuICBncmlkQ29sdW1uU3BhbjogMSxcbiAgZ3JpZENvbHVtblN0YXJ0OiAxLFxuICBtc0dyaWRSb3c6IDEsXG4gIG1zR3JpZFJvd1NwYW46IDEsXG4gIG1zR3JpZENvbHVtbjogMSxcbiAgbXNHcmlkQ29sdW1uU3BhbjogMSxcbiAgZm9udFdlaWdodDogMSxcbiAgbGluZUhlaWdodDogMSxcbiAgb3BhY2l0eTogMSxcbiAgb3JkZXI6IDEsXG4gIG9ycGhhbnM6IDEsXG4gIHRhYlNpemU6IDEsXG4gIHdpZG93czogMSxcbiAgekluZGV4OiAxLFxuICB6b29tOiAxLFxuICBXZWJraXRMaW5lQ2xhbXA6IDEsXG4gIC8vIFNWRy1yZWxhdGVkIHByb3BlcnRpZXNcbiAgZmlsbE9wYWNpdHk6IDEsXG4gIGZsb29kT3BhY2l0eTogMSxcbiAgc3RvcE9wYWNpdHk6IDEsXG4gIHN0cm9rZURhc2hhcnJheTogMSxcbiAgc3Ryb2tlRGFzaG9mZnNldDogMSxcbiAgc3Ryb2tlTWl0ZXJsaW1pdDogMSxcbiAgc3Ryb2tlT3BhY2l0eTogMSxcbiAgc3Ryb2tlV2lkdGg6IDFcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHVuaXRsZXNzS2V5cztcbiIsImZ1bmN0aW9uIG1lbW9pemUoZm4pIHtcbiAgdmFyIGNhY2hlID0ge307XG4gIHJldHVybiBmdW5jdGlvbiAoYXJnKSB7XG4gICAgaWYgKGNhY2hlW2FyZ10gPT09IHVuZGVmaW5lZCkgY2FjaGVbYXJnXSA9IGZuKGFyZyk7XG4gICAgcmV0dXJuIGNhY2hlW2FyZ107XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IG1lbW9pemU7XG4iLCJpbXBvcnQgaGFzaFN0cmluZyBmcm9tICdAZW1vdGlvbi9oYXNoJztcbmltcG9ydCB1bml0bGVzcyBmcm9tICdAZW1vdGlvbi91bml0bGVzcyc7XG5pbXBvcnQgbWVtb2l6ZSBmcm9tICdAZW1vdGlvbi9tZW1vaXplJztcblxudmFyIGh5cGhlbmF0ZVJlZ2V4ID0gL1tBLVpdfF5tcy9nO1xudmFyIGFuaW1hdGlvblJlZ2V4ID0gL19FTU9fKFteX10rPylfKFteXSo/KV9FTU9fL2c7XG52YXIgcHJvY2Vzc1N0eWxlTmFtZSA9IG1lbW9pemUoZnVuY3Rpb24gKHN0eWxlTmFtZSkge1xuICByZXR1cm4gc3R5bGVOYW1lLnJlcGxhY2UoaHlwaGVuYXRlUmVnZXgsICctJCYnKS50b0xvd2VyQ2FzZSgpO1xufSk7XG5cbnZhciBwcm9jZXNzU3R5bGVWYWx1ZSA9IGZ1bmN0aW9uIHByb2Nlc3NTdHlsZVZhbHVlKGtleSwgdmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBzd2l0Y2ggKGtleSkge1xuICAgIGNhc2UgJ2FuaW1hdGlvbic6XG4gICAgY2FzZSAnYW5pbWF0aW9uTmFtZSc6XG4gICAgICB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKGFuaW1hdGlvblJlZ2V4LCBmdW5jdGlvbiAobWF0Y2gsIHAxLCBwMikge1xuICAgICAgICAgICAgY3Vyc29yID0ge1xuICAgICAgICAgICAgICBuYW1lOiBwMSxcbiAgICAgICAgICAgICAgc3R5bGVzOiBwMixcbiAgICAgICAgICAgICAgbmV4dDogY3Vyc29yXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHAxO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gIH1cblxuICBpZiAodW5pdGxlc3Nba2V5XSAhPT0gMSAmJiBrZXkuY2hhckNvZGVBdCgxKSAhPT0gNDUgJiYgLy8gY3VzdG9tIHByb3BlcnRpZXNcbiAgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiB2YWx1ZSAhPT0gMCkge1xuICAgIHJldHVybiB2YWx1ZSArICdweCc7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgY29udGVudFZhbHVlUGF0dGVybiA9IC8oYXR0cnxjYWxjfGNvdW50ZXJzP3x1cmwpXFwoLztcbiAgdmFyIGNvbnRlbnRWYWx1ZXMgPSBbJ25vcm1hbCcsICdub25lJywgJ2NvdW50ZXInLCAnb3Blbi1xdW90ZScsICdjbG9zZS1xdW90ZScsICduby1vcGVuLXF1b3RlJywgJ25vLWNsb3NlLXF1b3RlJywgJ2luaXRpYWwnLCAnaW5oZXJpdCcsICd1bnNldCddO1xuICB2YXIgb2xkUHJvY2Vzc1N0eWxlVmFsdWUgPSBwcm9jZXNzU3R5bGVWYWx1ZTtcbiAgdmFyIG1zUGF0dGVybiA9IC9eLW1zLS87XG4gIHZhciBoeXBoZW5QYXR0ZXJuID0gLy0oLikvZztcbiAgdmFyIGh5cGhlbmF0ZWRDYWNoZSA9IHt9O1xuXG4gIHByb2Nlc3NTdHlsZVZhbHVlID0gZnVuY3Rpb24gcHJvY2Vzc1N0eWxlVmFsdWUoa2V5LCB2YWx1ZSkge1xuICAgIGlmIChrZXkgPT09ICdjb250ZW50Jykge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycgfHwgY29udGVudFZhbHVlcy5pbmRleE9mKHZhbHVlKSA9PT0gLTEgJiYgIWNvbnRlbnRWYWx1ZVBhdHRlcm4udGVzdCh2YWx1ZSkgJiYgKHZhbHVlLmNoYXJBdCgwKSAhPT0gdmFsdWUuY2hhckF0KHZhbHVlLmxlbmd0aCAtIDEpIHx8IHZhbHVlLmNoYXJBdCgwKSAhPT0gJ1wiJyAmJiB2YWx1ZS5jaGFyQXQoMCkgIT09IFwiJ1wiKSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiWW91IHNlZW0gdG8gYmUgdXNpbmcgYSB2YWx1ZSBmb3IgJ2NvbnRlbnQnIHdpdGhvdXQgcXVvdGVzLCB0cnkgcmVwbGFjaW5nIGl0IHdpdGggYGNvbnRlbnQ6ICdcXFwiXCIgKyB2YWx1ZSArIFwiXFxcIidgXCIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChrZXkuY2hhckNvZGVBdCgxKSAhPT0gNDUgJiYga2V5LmluZGV4T2YoJy0nKSAhPT0gLTEgJiYgaHlwaGVuYXRlZENhY2hlW2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgaHlwaGVuYXRlZENhY2hlW2tleV0gPSB0cnVlO1xuICAgICAgY29uc29sZS5lcnJvcihcIlVzaW5nIGtlYmFiLWNhc2UgZm9yIGNzcyBwcm9wZXJ0aWVzIGluIG9iamVjdHMgaXMgbm90IHN1cHBvcnRlZC4gRGlkIHlvdSBtZWFuIFwiICsga2V5LnJlcGxhY2UobXNQYXR0ZXJuLCAnbXMtJykucmVwbGFjZShoeXBoZW5QYXR0ZXJuLCBmdW5jdGlvbiAoc3RyLCBjaGFyKSB7XG4gICAgICAgIHJldHVybiBjaGFyLnRvVXBwZXJDYXNlKCk7XG4gICAgICB9KSArIFwiP1wiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb2xkUHJvY2Vzc1N0eWxlVmFsdWUoa2V5LCB2YWx1ZSk7XG4gIH07XG59XG5cbnZhciBzaG91bGRXYXJuQWJvdXRJbnRlcnBvbGF0aW5nQ2xhc3NOYW1lRnJvbUNzcyA9IHRydWU7XG5cbmZ1bmN0aW9uIGhhbmRsZUludGVycG9sYXRpb24obWVyZ2VkUHJvcHMsIHJlZ2lzdGVyZWQsIGludGVycG9sYXRpb24sIGNvdWxkQmVTZWxlY3RvckludGVycG9sYXRpb24pIHtcbiAgaWYgKGludGVycG9sYXRpb24gPT0gbnVsbCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGlmIChpbnRlcnBvbGF0aW9uLl9fZW1vdGlvbl9zdHlsZXMgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGludGVycG9sYXRpb24udG9TdHJpbmcoKSA9PT0gJ05PX0NPTVBPTkVOVF9TRUxFQ1RPUicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ29tcG9uZW50IHNlbGVjdG9ycyBjYW4gb25seSBiZSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggYmFiZWwtcGx1Z2luLWVtb3Rpb24uJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGludGVycG9sYXRpb247XG4gIH1cblxuICBzd2l0Y2ggKHR5cGVvZiBpbnRlcnBvbGF0aW9uKSB7XG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cblxuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICB7XG4gICAgICAgIGlmIChpbnRlcnBvbGF0aW9uLmFuaW0gPT09IDEpIHtcbiAgICAgICAgICBjdXJzb3IgPSB7XG4gICAgICAgICAgICBuYW1lOiBpbnRlcnBvbGF0aW9uLm5hbWUsXG4gICAgICAgICAgICBzdHlsZXM6IGludGVycG9sYXRpb24uc3R5bGVzLFxuICAgICAgICAgICAgbmV4dDogY3Vyc29yXG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4gaW50ZXJwb2xhdGlvbi5uYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGludGVycG9sYXRpb24uc3R5bGVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgbmV4dCA9IGludGVycG9sYXRpb24ubmV4dDtcblxuICAgICAgICAgIGlmIChuZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIG5vdCB0aGUgbW9zdCBlZmZpY2llbnQgdGhpbmcgZXZlciBidXQgdGhpcyBpcyBhIHByZXR0eSByYXJlIGNhc2VcbiAgICAgICAgICAgIC8vIGFuZCB0aGVyZSB3aWxsIGJlIHZlcnkgZmV3IGl0ZXJhdGlvbnMgb2YgdGhpcyBnZW5lcmFsbHlcbiAgICAgICAgICAgIHdoaWxlIChuZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgY3Vyc29yID0ge1xuICAgICAgICAgICAgICAgIG5hbWU6IG5leHQubmFtZSxcbiAgICAgICAgICAgICAgICBzdHlsZXM6IG5leHQuc3R5bGVzLFxuICAgICAgICAgICAgICAgIG5leHQ6IGN1cnNvclxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBuZXh0ID0gbmV4dC5uZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBzdHlsZXMgPSBpbnRlcnBvbGF0aW9uLnN0eWxlcztcblxuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGludGVycG9sYXRpb24ubWFwICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHN0eWxlcyArPSBpbnRlcnBvbGF0aW9uLm1hcDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gc3R5bGVzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNyZWF0ZVN0cmluZ0Zyb21PYmplY3QobWVyZ2VkUHJvcHMsIHJlZ2lzdGVyZWQsIGludGVycG9sYXRpb24pO1xuICAgICAgfVxuXG4gICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAge1xuICAgICAgICBpZiAobWVyZ2VkUHJvcHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBwcmV2aW91c0N1cnNvciA9IGN1cnNvcjtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gaW50ZXJwb2xhdGlvbihtZXJnZWRQcm9wcyk7XG4gICAgICAgICAgY3Vyc29yID0gcHJldmlvdXNDdXJzb3I7XG4gICAgICAgICAgcmV0dXJuIGhhbmRsZUludGVycG9sYXRpb24obWVyZ2VkUHJvcHMsIHJlZ2lzdGVyZWQsIHJlc3VsdCwgY291bGRCZVNlbGVjdG9ySW50ZXJwb2xhdGlvbik7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Z1bmN0aW9ucyB0aGF0IGFyZSBpbnRlcnBvbGF0ZWQgaW4gY3NzIGNhbGxzIHdpbGwgYmUgc3RyaW5naWZpZWQuXFxuJyArICdJZiB5b3Ugd2FudCB0byBoYXZlIGEgY3NzIGNhbGwgYmFzZWQgb24gcHJvcHMsIGNyZWF0ZSBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGNzcyBjYWxsIGxpa2UgdGhpc1xcbicgKyAnbGV0IGR5bmFtaWNTdHlsZSA9IChwcm9wcykgPT4gY3NzYGNvbG9yOiAke3Byb3BzLmNvbG9yfWBcXG4nICsgJ0l0IGNhbiBiZSBjYWxsZWQgZGlyZWN0bHkgd2l0aCBwcm9wcyBvciBpbnRlcnBvbGF0ZWQgaW4gYSBzdHlsZWQgY2FsbCBsaWtlIHRoaXNcXG4nICsgXCJsZXQgU29tZUNvbXBvbmVudCA9IHN0eWxlZCgnZGl2JylgJHtkeW5hbWljU3R5bGV9YFwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaFxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAgaWYgKHJlZ2lzdGVyZWQgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBpbnRlcnBvbGF0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNhY2hlZCA9IHJlZ2lzdGVyZWRbaW50ZXJwb2xhdGlvbl07XG5cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY291bGRCZVNlbGVjdG9ySW50ZXJwb2xhdGlvbiAmJiBzaG91bGRXYXJuQWJvdXRJbnRlcnBvbGF0aW5nQ2xhc3NOYW1lRnJvbUNzcyAmJiBjYWNoZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ludGVycG9sYXRpbmcgYSBjbGFzc05hbWUgZnJvbSBjc3NgYCBpcyBub3QgcmVjb21tZW5kZWQgYW5kIHdpbGwgY2F1c2UgcHJvYmxlbXMgd2l0aCBjb21wb3NpdGlvbi5cXG4nICsgJ0ludGVycG9sYXRpbmcgYSBjbGFzc05hbWUgZnJvbSBjc3NgYCB3aWxsIGJlIGNvbXBsZXRlbHkgdW5zdXBwb3J0ZWQgaW4gYSBmdXR1cmUgbWFqb3IgdmVyc2lvbiBvZiBFbW90aW9uJyk7XG4gICAgICAgICAgc2hvdWxkV2FybkFib3V0SW50ZXJwb2xhdGluZ0NsYXNzTmFtZUZyb21Dc3MgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjYWNoZWQgIT09IHVuZGVmaW5lZCAmJiAhY291bGRCZVNlbGVjdG9ySW50ZXJwb2xhdGlvbiA/IGNhY2hlZCA6IGludGVycG9sYXRpb247XG4gICAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlU3RyaW5nRnJvbU9iamVjdChtZXJnZWRQcm9wcywgcmVnaXN0ZXJlZCwgb2JqKSB7XG4gIHZhciBzdHJpbmcgPSAnJztcblxuICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmoubGVuZ3RoOyBpKyspIHtcbiAgICAgIHN0cmluZyArPSBoYW5kbGVJbnRlcnBvbGF0aW9uKG1lcmdlZFByb3BzLCByZWdpc3RlcmVkLCBvYmpbaV0sIGZhbHNlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgX2tleSBpbiBvYmopIHtcbiAgICAgIHZhciB2YWx1ZSA9IG9ialtfa2V5XTtcblxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKHJlZ2lzdGVyZWQgIT0gbnVsbCAmJiByZWdpc3RlcmVkW3ZhbHVlXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgc3RyaW5nICs9IF9rZXkgKyBcIntcIiArIHJlZ2lzdGVyZWRbdmFsdWVdICsgXCJ9XCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyaW5nICs9IHByb2Nlc3NTdHlsZU5hbWUoX2tleSkgKyBcIjpcIiArIHByb2Nlc3NTdHlsZVZhbHVlKF9rZXksIHZhbHVlKSArIFwiO1wiO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoX2tleSA9PT0gJ05PX0NPTVBPTkVOVF9TRUxFQ1RPUicgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ29tcG9uZW50IHNlbGVjdG9ycyBjYW4gb25seSBiZSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggYmFiZWwtcGx1Z2luLWVtb3Rpb24uJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdHlwZW9mIHZhbHVlWzBdID09PSAnc3RyaW5nJyAmJiAocmVnaXN0ZXJlZCA9PSBudWxsIHx8IHJlZ2lzdGVyZWRbdmFsdWVbMF1dID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHZhbHVlLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgc3RyaW5nICs9IHByb2Nlc3NTdHlsZU5hbWUoX2tleSkgKyBcIjpcIiArIHByb2Nlc3NTdHlsZVZhbHVlKF9rZXksIHZhbHVlW19pXSkgKyBcIjtcIjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyaW5nICs9IF9rZXkgKyBcIntcIiArIGhhbmRsZUludGVycG9sYXRpb24obWVyZ2VkUHJvcHMsIHJlZ2lzdGVyZWQsIHZhbHVlLCBmYWxzZSkgKyBcIn1cIjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdHJpbmc7XG59XG5cbnZhciBsYWJlbFBhdHRlcm4gPSAvbGFiZWw6XFxzKihbXlxccztcXG57XSspXFxzKjsvZztcbnZhciBzb3VyY2VNYXBQYXR0ZXJuO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBzb3VyY2VNYXBQYXR0ZXJuID0gL1xcL1xcKiNcXHNzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb25cXC9qc29uO1xcUytcXHMrXFwqXFwvLztcbn0gLy8gdGhpcyBpcyB0aGUgY3Vyc29yIGZvciBrZXlmcmFtZXNcbi8vIGtleWZyYW1lcyBhcmUgc3RvcmVkIG9uIHRoZSBTZXJpYWxpemVkU3R5bGVzIG9iamVjdCBhcyBhIGxpbmtlZCBsaXN0XG5cblxudmFyIGN1cnNvcjtcbnZhciBzZXJpYWxpemVTdHlsZXMgPSBmdW5jdGlvbiBzZXJpYWxpemVTdHlsZXMoYXJncywgcmVnaXN0ZXJlZCwgbWVyZ2VkUHJvcHMpIHtcbiAgaWYgKGFyZ3MubGVuZ3RoID09PSAxICYmIHR5cGVvZiBhcmdzWzBdID09PSAnb2JqZWN0JyAmJiBhcmdzWzBdICE9PSBudWxsICYmIGFyZ3NbMF0uc3R5bGVzICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gYXJnc1swXTtcbiAgfVxuXG4gIHZhciBzdHJpbmdNb2RlID0gdHJ1ZTtcbiAgdmFyIHN0eWxlcyA9ICcnO1xuICBjdXJzb3IgPSB1bmRlZmluZWQ7XG4gIHZhciBzdHJpbmdzID0gYXJnc1swXTtcblxuICBpZiAoc3RyaW5ncyA9PSBudWxsIHx8IHN0cmluZ3MucmF3ID09PSB1bmRlZmluZWQpIHtcbiAgICBzdHJpbmdNb2RlID0gZmFsc2U7XG4gICAgc3R5bGVzICs9IGhhbmRsZUludGVycG9sYXRpb24obWVyZ2VkUHJvcHMsIHJlZ2lzdGVyZWQsIHN0cmluZ3MsIGZhbHNlKTtcbiAgfSBlbHNlIHtcbiAgICBzdHlsZXMgKz0gc3RyaW5nc1swXTtcbiAgfSAvLyB3ZSBzdGFydCBhdCAxIHNpbmNlIHdlJ3ZlIGFscmVhZHkgaGFuZGxlZCB0aGUgZmlyc3QgYXJnXG5cblxuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICBzdHlsZXMgKz0gaGFuZGxlSW50ZXJwb2xhdGlvbihtZXJnZWRQcm9wcywgcmVnaXN0ZXJlZCwgYXJnc1tpXSwgc3R5bGVzLmNoYXJDb2RlQXQoc3R5bGVzLmxlbmd0aCAtIDEpID09PSA0Nik7XG5cbiAgICBpZiAoc3RyaW5nTW9kZSkge1xuICAgICAgc3R5bGVzICs9IHN0cmluZ3NbaV07XG4gICAgfVxuICB9XG5cbiAgdmFyIHNvdXJjZU1hcDtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHN0eWxlcyA9IHN0eWxlcy5yZXBsYWNlKHNvdXJjZU1hcFBhdHRlcm4sIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgICAgc291cmNlTWFwID0gbWF0Y2g7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfSk7XG4gIH0gLy8gdXNpbmcgYSBnbG9iYWwgcmVnZXggd2l0aCAuZXhlYyBpcyBzdGF0ZWZ1bCBzbyBsYXN0SW5kZXggaGFzIHRvIGJlIHJlc2V0IGVhY2ggdGltZVxuXG5cbiAgbGFiZWxQYXR0ZXJuLmxhc3RJbmRleCA9IDA7XG4gIHZhciBpZGVudGlmaWVyTmFtZSA9ICcnO1xuICB2YXIgbWF0Y2g7IC8vIGh0dHBzOi8vZXNiZW5jaC5jb20vYmVuY2gvNWI4MDljMmNmMjk0OTgwMGEwZjYxZmI1XG5cbiAgd2hpbGUgKChtYXRjaCA9IGxhYmVsUGF0dGVybi5leGVjKHN0eWxlcykpICE9PSBudWxsKSB7XG4gICAgaWRlbnRpZmllck5hbWUgKz0gJy0nICsgLy8gJEZsb3dGaXhNZSB3ZSBrbm93IGl0J3Mgbm90IG51bGxcbiAgICBtYXRjaFsxXTtcbiAgfVxuXG4gIHZhciBuYW1lID0gaGFzaFN0cmluZyhzdHlsZXMpICsgaWRlbnRpZmllck5hbWU7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIHN0eWxlczogc3R5bGVzLFxuICAgICAgbWFwOiBzb3VyY2VNYXAsXG4gICAgICBuZXh0OiBjdXJzb3JcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBuYW1lLFxuICAgIHN0eWxlczogc3R5bGVzLFxuICAgIG5leHQ6IGN1cnNvclxuICB9O1xufTtcblxuZXhwb3J0IHsgc2VyaWFsaXplU3R5bGVzIH07XG4iLCJpbXBvcnQgeyBzZXJpYWxpemVTdHlsZXMgfSBmcm9tICdAZW1vdGlvbi9zZXJpYWxpemUnO1xuXG5mdW5jdGlvbiBjc3MoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICByZXR1cm4gc2VyaWFsaXplU3R5bGVzKGFyZ3MpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjc3M7XG4iLCJpbXBvcnQgeyBjcmVhdGVDb250ZXh0LCBjcmVhdGVFbGVtZW50LCBmb3J3YXJkUmVmLCBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgY3JlYXRlQ2FjaGUgZnJvbSAnQGVtb3Rpb24vY2FjaGUnO1xuaW1wb3J0IHsgZ2V0UmVnaXN0ZXJlZFN0eWxlcywgaW5zZXJ0U3R5bGVzIH0gZnJvbSAnQGVtb3Rpb24vdXRpbHMnO1xuaW1wb3J0IHsgc2VyaWFsaXplU3R5bGVzIH0gZnJvbSAnQGVtb3Rpb24vc2VyaWFsaXplJztcbmltcG9ydCB7IFN0eWxlU2hlZXQgfSBmcm9tICdAZW1vdGlvbi9zaGVldCc7XG5pbXBvcnQgY3NzIGZyb20gJ0BlbW90aW9uL2Nzcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGNzcyB9IGZyb20gJ0BlbW90aW9uL2Nzcyc7XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpO1xuICBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzcztcbiAgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzcztcbn1cblxudmFyIEVtb3Rpb25DYWNoZUNvbnRleHQgPSBjcmVhdGVDb250ZXh0KGNyZWF0ZUNhY2hlKCkpO1xudmFyIFRoZW1lQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQoe30pO1xudmFyIENhY2hlUHJvdmlkZXIgPSAvLyAkRmxvd0ZpeE1lXG5FbW90aW9uQ2FjaGVDb250ZXh0LlByb3ZpZGVyO1xuXG52YXIgd2l0aEVtb3Rpb25DYWNoZSA9IGZ1bmN0aW9uIHdpdGhFbW90aW9uQ2FjaGUoZnVuYykge1xuICB2YXIgcmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKHByb3BzLCByZWYpIHtcbiAgICByZXR1cm4gY3JlYXRlRWxlbWVudChFbW90aW9uQ2FjaGVDb250ZXh0LkNvbnN1bWVyLCBudWxsLCBmdW5jdGlvbiAoIC8vICRGbG93Rml4TWUgd2Uga25vdyBpdCB3b24ndCBiZSBudWxsXG4gICAgY2FjaGUpIHtcbiAgICAgIHJldHVybiBmdW5jKHByb3BzLCBjYWNoZSwgcmVmKTtcbiAgICB9KTtcbiAgfTsgLy8gJEZsb3dGaXhNZVxuXG5cbiAgcmV0dXJuIGZvcndhcmRSZWYocmVuZGVyKTtcbn07XG5cbnZhciB0eXBlUHJvcE5hbWUgPSAnX19FTU9USU9OX1RZUEVfUExFQVNFX0RPX05PVF9VU0VfXyc7XG52YXIgbGFiZWxQcm9wTmFtZSA9ICdfX0VNT1RJT05fTEFCRUxfUExFQVNFX0RPX05PVF9VU0VfXyc7XG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgcmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKGNhY2hlLCBwcm9wcywgdGhlbWUsIHJlZikge1xuICB2YXIgdHlwZSA9IHByb3BzW3R5cGVQcm9wTmFtZV07XG4gIHZhciByZWdpc3RlcmVkU3R5bGVzID0gW107XG4gIHZhciBjbGFzc05hbWUgPSAnJztcbiAgdmFyIGNzc1Byb3AgPSB0aGVtZSA9PT0gbnVsbCA/IHByb3BzLmNzcyA6IHByb3BzLmNzcyh0aGVtZSk7IC8vIHNvIHRoYXQgdXNpbmcgYGNzc2AgZnJvbSBgZW1vdGlvbmAgYW5kIHBhc3NpbmcgdGhlIHJlc3VsdCB0byB0aGUgY3NzIHByb3Agd29ya3NcbiAgLy8gbm90IHBhc3NpbmcgdGhlIHJlZ2lzdGVyZWQgY2FjaGUgdG8gc2VyaWFsaXplU3R5bGVzIGJlY2F1c2UgaXQgd291bGRcbiAgLy8gbWFrZSBjZXJ0YWluIGJhYmVsIG9wdGltaXNhdGlvbnMgbm90IHBvc3NpYmxlXG5cbiAgaWYgKHR5cGVvZiBjc3NQcm9wID09PSAnc3RyaW5nJyAmJiBjYWNoZS5yZWdpc3RlcmVkW2Nzc1Byb3BdICE9PSB1bmRlZmluZWQpIHtcbiAgICBjc3NQcm9wID0gY2FjaGUucmVnaXN0ZXJlZFtjc3NQcm9wXTtcbiAgfVxuXG4gIHJlZ2lzdGVyZWRTdHlsZXMucHVzaChjc3NQcm9wKTtcblxuICBpZiAocHJvcHMuY2xhc3NOYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICBjbGFzc05hbWUgPSBnZXRSZWdpc3RlcmVkU3R5bGVzKGNhY2hlLnJlZ2lzdGVyZWQsIHJlZ2lzdGVyZWRTdHlsZXMsIHByb3BzLmNsYXNzTmFtZSk7XG4gIH1cblxuICB2YXIgc2VyaWFsaXplZCA9IHNlcmlhbGl6ZVN0eWxlcyhyZWdpc3RlcmVkU3R5bGVzKTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBzZXJpYWxpemVkLm5hbWUuaW5kZXhPZignLScpID09PSAtMSkge1xuICAgIHZhciBsYWJlbEZyb21TdGFjayA9IHByb3BzW2xhYmVsUHJvcE5hbWVdO1xuXG4gICAgaWYgKGxhYmVsRnJvbVN0YWNrKSB7XG4gICAgICBzZXJpYWxpemVkID0gc2VyaWFsaXplU3R5bGVzKFtzZXJpYWxpemVkLCAnbGFiZWw6JyArIGxhYmVsRnJvbVN0YWNrICsgJzsnXSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHJ1bGVzID0gaW5zZXJ0U3R5bGVzKGNhY2hlLCBzZXJpYWxpemVkLCB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpO1xuICBjbGFzc05hbWUgKz0gY2FjaGUua2V5ICsgXCItXCIgKyBzZXJpYWxpemVkLm5hbWU7XG4gIHZhciBuZXdQcm9wcyA9IHt9O1xuXG4gIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBrZXkpICYmIGtleSAhPT0gJ2NzcycgJiYga2V5ICE9PSB0eXBlUHJvcE5hbWUgJiYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicgfHwga2V5ICE9PSBsYWJlbFByb3BOYW1lKSkge1xuICAgICAgbmV3UHJvcHNba2V5XSA9IHByb3BzW2tleV07XG4gICAgfVxuICB9XG5cbiAgbmV3UHJvcHMucmVmID0gcmVmO1xuICBuZXdQcm9wcy5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG4gIHZhciBlbGUgPSBjcmVhdGVFbGVtZW50KHR5cGUsIG5ld1Byb3BzKTtcblxuICByZXR1cm4gZWxlO1xufTtcblxudmFyIEVtb3Rpb24gPSB3aXRoRW1vdGlvbkNhY2hlKGZ1bmN0aW9uIChwcm9wcywgY2FjaGUsIHJlZikge1xuICAvLyB1c2UgQ29udGV4dC5yZWFkIGZvciB0aGUgdGhlbWUgd2hlbiBpdCdzIHN0YWJsZVxuICBpZiAodHlwZW9mIHByb3BzLmNzcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBjcmVhdGVFbGVtZW50KFRoZW1lQ29udGV4dC5Db25zdW1lciwgbnVsbCwgZnVuY3Rpb24gKHRoZW1lKSB7XG4gICAgICByZXR1cm4gcmVuZGVyKGNhY2hlLCBwcm9wcywgdGhlbWUsIHJlZik7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gcmVuZGVyKGNhY2hlLCBwcm9wcywgbnVsbCwgcmVmKTtcbn0pOyAvLyAkRmxvd0ZpeE1lXG5cbnZhciBqc3ggPSBmdW5jdGlvbiBqc3godHlwZSwgcHJvcHMpIHtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG5cbiAgaWYgKHByb3BzID09IG51bGwgfHwgcHJvcHMuY3NzID09IG51bGwpIHtcbiAgICAvLyAkRmxvd0ZpeE1lXG4gICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQuYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHR5cGVvZiBwcm9wcy5jc3MgPT09ICdzdHJpbmcnICYmIC8vIGNoZWNrIGlmIHRoZXJlIGlzIGEgY3NzIGRlY2xhcmF0aW9uXG4gIHByb3BzLmNzcy5pbmRleE9mKCc6JykgIT09IC0xKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU3RyaW5ncyBhcmUgbm90IGFsbG93ZWQgYXMgY3NzIHByb3AgdmFsdWVzLCBwbGVhc2Ugd3JhcCBpdCBpbiBhIGNzcyB0ZW1wbGF0ZSBsaXRlcmFsIGZyb20gJ0BlbW90aW9uL2NzcycgbGlrZSB0aGlzOiBjc3NgXCIgKyBwcm9wcy5jc3MgKyBcImBcIik7XG4gIH1cblxuICB2YXIgYXJnc0xlbmd0aCA9IGFyZ3MubGVuZ3RoO1xuICB2YXIgY3JlYXRlRWxlbWVudEFyZ0FycmF5ID0gbmV3IEFycmF5KGFyZ3NMZW5ndGgpO1xuICBjcmVhdGVFbGVtZW50QXJnQXJyYXlbMF0gPSBFbW90aW9uO1xuICB2YXIgbmV3UHJvcHMgPSB7fTtcblxuICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywga2V5KSkge1xuICAgICAgbmV3UHJvcHNba2V5XSA9IHByb3BzW2tleV07XG4gICAgfVxuICB9XG5cbiAgbmV3UHJvcHNbdHlwZVByb3BOYW1lXSA9IHR5cGU7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoKTtcblxuICAgIGlmIChlcnJvci5zdGFjaykge1xuICAgICAgLy8gY2hyb21lXG4gICAgICB2YXIgbWF0Y2ggPSBlcnJvci5zdGFjay5tYXRjaCgvYXQganN4LipcXG5cXHMrYXQgKFtBLVpdW0EtWmEtel0rKSAvKTtcblxuICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICAvLyBzYWZhcmkgYW5kIGZpcmVmb3hcbiAgICAgICAgbWF0Y2ggPSBlcnJvci5zdGFjay5tYXRjaCgvXi4qXFxuKFtBLVpdW0EtWmEtel0rKUAvKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIG5ld1Byb3BzW2xhYmVsUHJvcE5hbWVdID0gbWF0Y2hbMV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY3JlYXRlRWxlbWVudEFyZ0FycmF5WzFdID0gbmV3UHJvcHM7XG5cbiAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmdzTGVuZ3RoOyBpKyspIHtcbiAgICBjcmVhdGVFbGVtZW50QXJnQXJyYXlbaV0gPSBhcmdzW2ldO1xuICB9IC8vICRGbG93Rml4TWVcblxuXG4gIHJldHVybiBjcmVhdGVFbGVtZW50LmFwcGx5KG51bGwsIGNyZWF0ZUVsZW1lbnRBcmdBcnJheSk7XG59O1xuXG52YXIgd2FybmVkQWJvdXRDc3NQcm9wRm9yR2xvYmFsID0gZmFsc2U7XG52YXIgR2xvYmFsID1cbi8qICNfX1BVUkVfXyAqL1xud2l0aEVtb3Rpb25DYWNoZShmdW5jdGlvbiAocHJvcHMsIGNhY2hlKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICF3YXJuZWRBYm91dENzc1Byb3BGb3JHbG9iYWwgJiYgKCAvLyBjaGVjayBmb3IgY2xhc3NOYW1lIGFzIHdlbGwgc2luY2UgdGhlIHVzZXIgaXNcbiAgLy8gcHJvYmFibHkgdXNpbmcgdGhlIGN1c3RvbSBjcmVhdGVFbGVtZW50IHdoaWNoXG4gIC8vIG1lYW5zIGl0IHdpbGwgYmUgdHVybmVkIGludG8gYSBjbGFzc05hbWUgcHJvcFxuICAvLyAkRmxvd0ZpeE1lIEkgZG9uJ3QgcmVhbGx5IHdhbnQgdG8gYWRkIGl0IHRvIHRoZSB0eXBlIHNpbmNlIGl0IHNob3VsZG4ndCBiZSB1c2VkXG4gIHByb3BzLmNsYXNzTmFtZSB8fCBwcm9wcy5jc3MpKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkl0IGxvb2tzIGxpa2UgeW91J3JlIHVzaW5nIHRoZSBjc3MgcHJvcCBvbiBHbG9iYWwsIGRpZCB5b3UgbWVhbiB0byB1c2UgdGhlIHN0eWxlcyBwcm9wIGluc3RlYWQ/XCIpO1xuICAgIHdhcm5lZEFib3V0Q3NzUHJvcEZvckdsb2JhbCA9IHRydWU7XG4gIH1cblxuICB2YXIgc3R5bGVzID0gcHJvcHMuc3R5bGVzO1xuXG4gIGlmICh0eXBlb2Ygc3R5bGVzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoVGhlbWVDb250ZXh0LkNvbnN1bWVyLCBudWxsLCBmdW5jdGlvbiAodGhlbWUpIHtcbiAgICAgIHZhciBzZXJpYWxpemVkID0gc2VyaWFsaXplU3R5bGVzKFtzdHlsZXModGhlbWUpXSk7XG4gICAgICByZXR1cm4gY3JlYXRlRWxlbWVudChJbm5lckdsb2JhbCwge1xuICAgICAgICBzZXJpYWxpemVkOiBzZXJpYWxpemVkLFxuICAgICAgICBjYWNoZTogY2FjaGVcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIHNlcmlhbGl6ZWQgPSBzZXJpYWxpemVTdHlsZXMoW3N0eWxlc10pO1xuICByZXR1cm4gY3JlYXRlRWxlbWVudChJbm5lckdsb2JhbCwge1xuICAgIHNlcmlhbGl6ZWQ6IHNlcmlhbGl6ZWQsXG4gICAgY2FjaGU6IGNhY2hlXG4gIH0pO1xufSk7XG5cbi8vIG1haW50YWluIHBsYWNlIG92ZXIgcmVyZW5kZXJzLlxuLy8gaW5pdGlhbCByZW5kZXIgZnJvbSBicm93c2VyLCBpbnNlcnRCZWZvcmUgY29udGV4dC5zaGVldC50YWdzWzBdIG9yIGlmIGEgc3R5bGUgaGFzbid0IGJlZW4gaW5zZXJ0ZWQgdGhlcmUgeWV0LCBhcHBlbmRDaGlsZFxuLy8gaW5pdGlhbCBjbGllbnQtc2lkZSByZW5kZXIgZnJvbSBTU1IsIHVzZSBwbGFjZSBvZiBoeWRyYXRpbmcgdGFnXG52YXIgSW5uZXJHbG9iYWwgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzTG9vc2UoSW5uZXJHbG9iYWwsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIElubmVyR2xvYmFsKHByb3BzLCBjb250ZXh0LCB1cGRhdGVyKSB7XG4gICAgcmV0dXJuIF9SZWFjdCRDb21wb25lbnQuY2FsbCh0aGlzLCBwcm9wcywgY29udGV4dCwgdXBkYXRlcikgfHwgdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBJbm5lckdsb2JhbC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgdGhpcy5zaGVldCA9IG5ldyBTdHlsZVNoZWV0KHtcbiAgICAgIGtleTogdGhpcy5wcm9wcy5jYWNoZS5rZXkgKyBcIi1nbG9iYWxcIixcbiAgICAgIG5vbmNlOiB0aGlzLnByb3BzLmNhY2hlLnNoZWV0Lm5vbmNlLFxuICAgICAgY29udGFpbmVyOiB0aGlzLnByb3BzLmNhY2hlLnNoZWV0LmNvbnRhaW5lclxuICAgIH0pOyAvLyAkRmxvd0ZpeE1lXG5cbiAgICB2YXIgbm9kZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJzdHlsZVtkYXRhLWVtb3Rpb24tXCIgKyB0aGlzLnByb3BzLmNhY2hlLmtleSArIFwiPVxcXCJcIiArIHRoaXMucHJvcHMuc2VyaWFsaXplZC5uYW1lICsgXCJcXFwiXVwiKTtcblxuICAgIGlmIChub2RlICE9PSBudWxsKSB7XG4gICAgICB0aGlzLnNoZWV0LnRhZ3MucHVzaChub2RlKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5wcm9wcy5jYWNoZS5zaGVldC50YWdzLmxlbmd0aCkge1xuICAgICAgdGhpcy5zaGVldC5iZWZvcmUgPSB0aGlzLnByb3BzLmNhY2hlLnNoZWV0LnRhZ3NbMF07XG4gICAgfVxuXG4gICAgdGhpcy5pbnNlcnRTdHlsZXMoKTtcbiAgfTtcblxuICBfcHJvdG8uY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xuICAgIGlmIChwcmV2UHJvcHMuc2VyaWFsaXplZC5uYW1lICE9PSB0aGlzLnByb3BzLnNlcmlhbGl6ZWQubmFtZSkge1xuICAgICAgdGhpcy5pbnNlcnRTdHlsZXMoKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmluc2VydFN0eWxlcyA9IGZ1bmN0aW9uIGluc2VydFN0eWxlcyQkMSgpIHtcbiAgICBpZiAodGhpcy5wcm9wcy5zZXJpYWxpemVkLm5leHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gaW5zZXJ0IGtleWZyYW1lc1xuICAgICAgaW5zZXJ0U3R5bGVzKHRoaXMucHJvcHMuY2FjaGUsIHRoaXMucHJvcHMuc2VyaWFsaXplZC5uZXh0LCB0cnVlKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zaGVldC50YWdzLmxlbmd0aCkge1xuICAgICAgLy8gaWYgdGhpcyBkb2Vzbid0IGV4aXN0IHRoZW4gaXQgd2lsbCBiZSBudWxsIHNvIHRoZSBzdHlsZSBlbGVtZW50IHdpbGwgYmUgYXBwZW5kZWRcbiAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5zaGVldC50YWdzWzBdLm5leHRFbGVtZW50U2libGluZztcbiAgICAgIHRoaXMuc2hlZXQuYmVmb3JlID0gZWxlbWVudDtcbiAgICAgIHRoaXMuc2hlZXQuZmx1c2goKTtcbiAgICB9XG5cbiAgICB0aGlzLnByb3BzLmNhY2hlLmluc2VydChcIlwiLCB0aGlzLnByb3BzLnNlcmlhbGl6ZWQsIHRoaXMuc2hlZXQsIGZhbHNlKTtcbiAgfTtcblxuICBfcHJvdG8uY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICB0aGlzLnNoZWV0LmZsdXNoKCk7XG4gIH07XG5cbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcblxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIHJldHVybiBJbm5lckdsb2JhbDtcbn0oQ29tcG9uZW50KTtcblxudmFyIGtleWZyYW1lcyA9IGZ1bmN0aW9uIGtleWZyYW1lcygpIHtcbiAgdmFyIGluc2VydGFibGUgPSBjc3MuYXBwbHkodm9pZCAwLCBhcmd1bWVudHMpO1xuICB2YXIgbmFtZSA9IFwiYW5pbWF0aW9uLVwiICsgaW5zZXJ0YWJsZS5uYW1lOyAvLyAkRmxvd0ZpeE1lXG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBuYW1lLFxuICAgIHN0eWxlczogXCJAa2V5ZnJhbWVzIFwiICsgbmFtZSArIFwie1wiICsgaW5zZXJ0YWJsZS5zdHlsZXMgKyBcIn1cIixcbiAgICBhbmltOiAxLFxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiBcIl9FTU9fXCIgKyB0aGlzLm5hbWUgKyBcIl9cIiArIHRoaXMuc3R5bGVzICsgXCJfRU1PX1wiO1xuICAgIH1cbiAgfTtcbn07XG5cbnZhciBjbGFzc25hbWVzID0gZnVuY3Rpb24gY2xhc3NuYW1lcyhhcmdzKSB7XG4gIHZhciBsZW4gPSBhcmdzLmxlbmd0aDtcbiAgdmFyIGkgPSAwO1xuICB2YXIgY2xzID0gJyc7XG5cbiAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBhcmcgPSBhcmdzW2ldO1xuICAgIGlmIChhcmcgPT0gbnVsbCkgY29udGludWU7XG4gICAgdmFyIHRvQWRkID0gdm9pZCAwO1xuXG4gICAgc3dpdGNoICh0eXBlb2YgYXJnKSB7XG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgICAgICAgICB0b0FkZCA9IGNsYXNzbmFtZXMoYXJnKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdG9BZGQgPSAnJztcblxuICAgICAgICAgICAgZm9yICh2YXIgayBpbiBhcmcpIHtcbiAgICAgICAgICAgICAgaWYgKGFyZ1trXSAmJiBrKSB7XG4gICAgICAgICAgICAgICAgdG9BZGQgJiYgKHRvQWRkICs9ICcgJyk7XG4gICAgICAgICAgICAgICAgdG9BZGQgKz0gaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHtcbiAgICAgICAgICB0b0FkZCA9IGFyZztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0b0FkZCkge1xuICAgICAgY2xzICYmIChjbHMgKz0gJyAnKTtcbiAgICAgIGNscyArPSB0b0FkZDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY2xzO1xufTtcblxuZnVuY3Rpb24gbWVyZ2UocmVnaXN0ZXJlZCwgY3NzJCQxLCBjbGFzc05hbWUpIHtcbiAgdmFyIHJlZ2lzdGVyZWRTdHlsZXMgPSBbXTtcbiAgdmFyIHJhd0NsYXNzTmFtZSA9IGdldFJlZ2lzdGVyZWRTdHlsZXMocmVnaXN0ZXJlZCwgcmVnaXN0ZXJlZFN0eWxlcywgY2xhc3NOYW1lKTtcblxuICBpZiAocmVnaXN0ZXJlZFN0eWxlcy5sZW5ndGggPCAyKSB7XG4gICAgcmV0dXJuIGNsYXNzTmFtZTtcbiAgfVxuXG4gIHJldHVybiByYXdDbGFzc05hbWUgKyBjc3MkJDEocmVnaXN0ZXJlZFN0eWxlcyk7XG59XG5cbnZhciBDbGFzc05hbWVzID0gd2l0aEVtb3Rpb25DYWNoZShmdW5jdGlvbiAocHJvcHMsIGNvbnRleHQpIHtcbiAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoVGhlbWVDb250ZXh0LkNvbnN1bWVyLCBudWxsLCBmdW5jdGlvbiAodGhlbWUpIHtcbiAgICB2YXIgaGFzUmVuZGVyZWQgPSBmYWxzZTtcblxuICAgIHZhciBjc3MkJDEgPSBmdW5jdGlvbiBjc3MkJDEoKSB7XG4gICAgICBpZiAoaGFzUmVuZGVyZWQgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NzcyBjYW4gb25seSBiZSB1c2VkIGR1cmluZyByZW5kZXInKTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIHZhciBzZXJpYWxpemVkID0gc2VyaWFsaXplU3R5bGVzKGFyZ3MsIGNvbnRleHQucmVnaXN0ZXJlZCk7XG5cbiAgICAgIHtcbiAgICAgICAgaW5zZXJ0U3R5bGVzKGNvbnRleHQsIHNlcmlhbGl6ZWQsIGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvbnRleHQua2V5ICsgXCItXCIgKyBzZXJpYWxpemVkLm5hbWU7XG4gICAgfTtcblxuICAgIHZhciBjeCA9IGZ1bmN0aW9uIGN4KCkge1xuICAgICAgaWYgKGhhc1JlbmRlcmVkICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjeCBjYW4gb25seSBiZSB1c2VkIGR1cmluZyByZW5kZXInKTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1lcmdlKGNvbnRleHQucmVnaXN0ZXJlZCwgY3NzJCQxLCBjbGFzc25hbWVzKGFyZ3MpKTtcbiAgICB9O1xuXG4gICAgdmFyIGNvbnRlbnQgPSB7XG4gICAgICBjc3M6IGNzcyQkMSxcbiAgICAgIGN4OiBjeCxcbiAgICAgIHRoZW1lOiB0aGVtZVxuICAgIH07XG4gICAgdmFyIGVsZSA9IHByb3BzLmNoaWxkcmVuKGNvbnRlbnQpO1xuICAgIGhhc1JlbmRlcmVkID0gdHJ1ZTtcblxuICAgIHJldHVybiBlbGU7XG4gIH0pO1xufSk7XG5cbmV4cG9ydCB7IHdpdGhFbW90aW9uQ2FjaGUsIENhY2hlUHJvdmlkZXIsIFRoZW1lQ29udGV4dCwganN4LCBHbG9iYWwsIGtleWZyYW1lcywgQ2xhc3NOYW1lcyB9O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBjaGVja0RDRSgpIHtcbiAgLyogZ2xvYmFsIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAqL1xuICBpZiAoXG4gICAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyA9PT0gJ3VuZGVmaW5lZCcgfHxcbiAgICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLmNoZWNrRENFICE9PSAnZnVuY3Rpb24nXG4gICkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIC8vIFRoaXMgYnJhbmNoIGlzIHVucmVhY2hhYmxlIGJlY2F1c2UgdGhpcyBmdW5jdGlvbiBpcyBvbmx5IGNhbGxlZFxuICAgIC8vIGluIHByb2R1Y3Rpb24sIGJ1dCB0aGUgY29uZGl0aW9uIGlzIHRydWUgb25seSBpbiBkZXZlbG9wbWVudC5cbiAgICAvLyBUaGVyZWZvcmUgaWYgdGhlIGJyYW5jaCBpcyBzdGlsbCBoZXJlLCBkZWFkIGNvZGUgZWxpbWluYXRpb24gd2Fzbid0XG4gICAgLy8gcHJvcGVybHkgYXBwbGllZC5cbiAgICAvLyBEb24ndCBjaGFuZ2UgdGhlIG1lc3NhZ2UuIFJlYWN0IERldlRvb2xzIHJlbGllcyBvbiBpdC4gQWxzbyBtYWtlIHN1cmVcbiAgICAvLyB0aGlzIG1lc3NhZ2UgZG9lc24ndCBvY2N1ciBlbHNld2hlcmUgaW4gdGhpcyBmdW5jdGlvbiwgb3IgaXQgd2lsbCBjYXVzZVxuICAgIC8vIGEgZmFsc2UgcG9zaXRpdmUuXG4gICAgdGhyb3cgbmV3IEVycm9yKCdeX14nKTtcbiAgfVxuICB0cnkge1xuICAgIC8vIFZlcmlmeSB0aGF0IHRoZSBjb2RlIGFib3ZlIGhhcyBiZWVuIGRlYWQgY29kZSBlbGltaW5hdGVkIChEQ0UnZCkuXG4gICAgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLmNoZWNrRENFKGNoZWNrRENFKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gRGV2VG9vbHMgc2hvdWxkbid0IGNyYXNoIFJlYWN0LCBubyBtYXR0ZXIgd2hhdC5cbiAgICAvLyBXZSBzaG91bGQgc3RpbGwgcmVwb3J0IGluIGNhc2Ugd2UgYnJlYWsgdGhpcyBjb2RlLlxuICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgfVxufVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICAvLyBEQ0UgY2hlY2sgc2hvdWxkIGhhcHBlbiBiZWZvcmUgUmVhY3RET00gYnVuZGxlIGV4ZWN1dGVzIHNvIHRoYXRcbiAgLy8gRGV2VG9vbHMgY2FuIHJlcG9ydCBiYWQgbWluaWZpY2F0aW9uIGR1cmluZyBpbmplY3Rpb24uXG4gIGNoZWNrRENFKCk7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtZG9tLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWRvbS5kZXZlbG9wbWVudC5qcycpO1xufVxuIiwiLypcbm9iamVjdC1hc3NpZ25cbihjKSBTaW5kcmUgU29yaHVzXG5AbGljZW5zZSBNSVRcbiovXG5cbid1c2Ugc3RyaWN0Jztcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgcHJvcElzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbmZ1bmN0aW9uIHRvT2JqZWN0KHZhbCkge1xuXHRpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmFzc2lnbiBjYW5ub3QgYmUgY2FsbGVkIHdpdGggbnVsbCBvciB1bmRlZmluZWQnKTtcblx0fVxuXG5cdHJldHVybiBPYmplY3QodmFsKTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkVXNlTmF0aXZlKCkge1xuXHR0cnkge1xuXHRcdGlmICghT2JqZWN0LmFzc2lnbikge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIERldGVjdCBidWdneSBwcm9wZXJ0eSBlbnVtZXJhdGlvbiBvcmRlciBpbiBvbGRlciBWOCB2ZXJzaW9ucy5cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTQxMThcblx0XHR2YXIgdGVzdDEgPSBuZXcgU3RyaW5nKCdhYmMnKTsgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3LXdyYXBwZXJzXG5cdFx0dGVzdDFbNV0gPSAnZGUnO1xuXHRcdGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MSlbMF0gPT09ICc1Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDIgPSB7fTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDEwOyBpKyspIHtcblx0XHRcdHRlc3QyWydfJyArIFN0cmluZy5mcm9tQ2hhckNvZGUoaSldID0gaTtcblx0XHR9XG5cdFx0dmFyIG9yZGVyMiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QyKS5tYXAoZnVuY3Rpb24gKG4pIHtcblx0XHRcdHJldHVybiB0ZXN0MltuXTtcblx0XHR9KTtcblx0XHRpZiAob3JkZXIyLmpvaW4oJycpICE9PSAnMDEyMzQ1Njc4OScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QzID0ge307XG5cdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAobGV0dGVyKSB7XG5cdFx0XHR0ZXN0M1tsZXR0ZXJdID0gbGV0dGVyO1xuXHRcdH0pO1xuXHRcdGlmIChPYmplY3Qua2V5cyhPYmplY3QuYXNzaWduKHt9LCB0ZXN0MykpLmpvaW4oJycpICE9PVxuXHRcdFx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gY2F0Y2ggKGVycikge1xuXHRcdC8vIFdlIGRvbid0IGV4cGVjdCBhbnkgb2YgdGhlIGFib3ZlIHRvIHRocm93LCBidXQgYmV0dGVyIHRvIGJlIHNhZmUuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hvdWxkVXNlTmF0aXZlKCkgPyBPYmplY3QuYXNzaWduIDogZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKSB7XG5cdHZhciBmcm9tO1xuXHR2YXIgdG8gPSB0b09iamVjdCh0YXJnZXQpO1xuXHR2YXIgc3ltYm9scztcblxuXHRmb3IgKHZhciBzID0gMTsgcyA8IGFyZ3VtZW50cy5sZW5ndGg7IHMrKykge1xuXHRcdGZyb20gPSBPYmplY3QoYXJndW1lbnRzW3NdKTtcblxuXHRcdGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG5cdFx0XHRpZiAoaGFzT3duUHJvcGVydHkuY2FsbChmcm9tLCBrZXkpKSB7XG5cdFx0XHRcdHRvW2tleV0gPSBmcm9tW2tleV07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGdldE93blByb3BlcnR5U3ltYm9scykge1xuXHRcdFx0c3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9scyhmcm9tKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3ltYm9scy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAocHJvcElzRW51bWVyYWJsZS5jYWxsKGZyb20sIHN5bWJvbHNbaV0pKSB7XG5cdFx0XHRcdFx0dG9bc3ltYm9sc1tpXV0gPSBmcm9tW3N5bWJvbHNbaV1dO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRvO1xufTtcbiIsIi8qKiBAbGljZW5zZSBSZWFjdCB2MTYuNy4wLWFscGhhLjBcbiAqIHJlYWN0LnByb2R1Y3Rpb24ubWluLmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO3ZhciBrPXJlcXVpcmUoXCJvYmplY3QtYXNzaWduXCIpLGw9XCJmdW5jdGlvblwiPT09dHlwZW9mIFN5bWJvbCYmU3ltYm9sLmZvcixwPWw/U3ltYm9sLmZvcihcInJlYWN0LmVsZW1lbnRcIik6NjAxMDMscT1sP1N5bWJvbC5mb3IoXCJyZWFjdC5wb3J0YWxcIik6NjAxMDYscj1sP1N5bWJvbC5mb3IoXCJyZWFjdC5mcmFnbWVudFwiKTo2MDEwNyx0PWw/U3ltYm9sLmZvcihcInJlYWN0LnN0cmljdF9tb2RlXCIpOjYwMTA4LHU9bD9TeW1ib2wuZm9yKFwicmVhY3QucHJvZmlsZXJcIik6NjAxMTQsdj1sP1N5bWJvbC5mb3IoXCJyZWFjdC5wcm92aWRlclwiKTo2MDEwOSx3PWw/U3ltYm9sLmZvcihcInJlYWN0LmNvbnRleHRcIik6NjAxMTAseD1sP1N5bWJvbC5mb3IoXCJyZWFjdC5jb25jdXJyZW50X21vZGVcIik6NjAxMTEseT1sP1N5bWJvbC5mb3IoXCJyZWFjdC5mb3J3YXJkX3JlZlwiKTo2MDExMix6PWw/U3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlXCIpOjYwMTEzLEE9bD9TeW1ib2wuZm9yKFwicmVhY3QubWVtb1wiKTpcbjYwMTE1LGFhPWw/U3ltYm9sLmZvcihcInJlYWN0LmxhenlcIik6NjAxMTYsQj1cImZ1bmN0aW9uXCI9PT10eXBlb2YgU3ltYm9sJiZTeW1ib2wuaXRlcmF0b3I7ZnVuY3Rpb24gYmEoYSxiLGQsYyxlLGcsaCxmKXtpZighYSl7YT12b2lkIDA7aWYodm9pZCAwPT09YilhPUVycm9yKFwiTWluaWZpZWQgZXhjZXB0aW9uIG9jY3VycmVkOyB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgZm9yIHRoZSBmdWxsIGVycm9yIG1lc3NhZ2UgYW5kIGFkZGl0aW9uYWwgaGVscGZ1bCB3YXJuaW5ncy5cIik7ZWxzZXt2YXIgbT1bZCxjLGUsZyxoLGZdLG49MDthPUVycm9yKGIucmVwbGFjZSgvJXMvZyxmdW5jdGlvbigpe3JldHVybiBtW24rK119KSk7YS5uYW1lPVwiSW52YXJpYW50IFZpb2xhdGlvblwifWEuZnJhbWVzVG9Qb3A9MTt0aHJvdyBhO319XG5mdW5jdGlvbiBDKGEpe2Zvcih2YXIgYj1hcmd1bWVudHMubGVuZ3RoLTEsZD1cImh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9lcnJvci1kZWNvZGVyLmh0bWw/aW52YXJpYW50PVwiK2EsYz0wO2M8YjtjKyspZCs9XCImYXJnc1tdPVwiK2VuY29kZVVSSUNvbXBvbmVudChhcmd1bWVudHNbYysxXSk7YmEoITEsXCJNaW5pZmllZCBSZWFjdCBlcnJvciAjXCIrYStcIjsgdmlzaXQgJXMgZm9yIHRoZSBmdWxsIG1lc3NhZ2Ugb3IgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50IGZvciBmdWxsIGVycm9ycyBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLiBcIixkKX12YXIgRD17aXNNb3VudGVkOmZ1bmN0aW9uKCl7cmV0dXJuITF9LGVucXVldWVGb3JjZVVwZGF0ZTpmdW5jdGlvbigpe30sZW5xdWV1ZVJlcGxhY2VTdGF0ZTpmdW5jdGlvbigpe30sZW5xdWV1ZVNldFN0YXRlOmZ1bmN0aW9uKCl7fX0sRT17fTtcbmZ1bmN0aW9uIEYoYSxiLGQpe3RoaXMucHJvcHM9YTt0aGlzLmNvbnRleHQ9Yjt0aGlzLnJlZnM9RTt0aGlzLnVwZGF0ZXI9ZHx8RH1GLnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50PXt9O0YucHJvdG90eXBlLnNldFN0YXRlPWZ1bmN0aW9uKGEsYil7XCJvYmplY3RcIiE9PXR5cGVvZiBhJiZcImZ1bmN0aW9uXCIhPT10eXBlb2YgYSYmbnVsbCE9YT9DKFwiODVcIik6dm9pZCAwO3RoaXMudXBkYXRlci5lbnF1ZXVlU2V0U3RhdGUodGhpcyxhLGIsXCJzZXRTdGF0ZVwiKX07Ri5wcm90b3R5cGUuZm9yY2VVcGRhdGU9ZnVuY3Rpb24oYSl7dGhpcy51cGRhdGVyLmVucXVldWVGb3JjZVVwZGF0ZSh0aGlzLGEsXCJmb3JjZVVwZGF0ZVwiKX07ZnVuY3Rpb24gRygpe31HLnByb3RvdHlwZT1GLnByb3RvdHlwZTtmdW5jdGlvbiBIKGEsYixkKXt0aGlzLnByb3BzPWE7dGhpcy5jb250ZXh0PWI7dGhpcy5yZWZzPUU7dGhpcy51cGRhdGVyPWR8fER9dmFyIEk9SC5wcm90b3R5cGU9bmV3IEc7XG5JLmNvbnN0cnVjdG9yPUg7ayhJLEYucHJvdG90eXBlKTtJLmlzUHVyZVJlYWN0Q29tcG9uZW50PSEwO3ZhciBKPXtjdXJyZW50Om51bGwsY3VycmVudERpc3BhdGNoZXI6bnVsbH0sSz1PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LEw9e2tleTohMCxyZWY6ITAsX19zZWxmOiEwLF9fc291cmNlOiEwfTtcbmZ1bmN0aW9uIE0oYSxiLGQpe3ZhciBjPXZvaWQgMCxlPXt9LGc9bnVsbCxoPW51bGw7aWYobnVsbCE9Yilmb3IoYyBpbiB2b2lkIDAhPT1iLnJlZiYmKGg9Yi5yZWYpLHZvaWQgMCE9PWIua2V5JiYoZz1cIlwiK2Iua2V5KSxiKUsuY2FsbChiLGMpJiYhTC5oYXNPd25Qcm9wZXJ0eShjKSYmKGVbY109YltjXSk7dmFyIGY9YXJndW1lbnRzLmxlbmd0aC0yO2lmKDE9PT1mKWUuY2hpbGRyZW49ZDtlbHNlIGlmKDE8Zil7Zm9yKHZhciBtPUFycmF5KGYpLG49MDtuPGY7bisrKW1bbl09YXJndW1lbnRzW24rMl07ZS5jaGlsZHJlbj1tfWlmKGEmJmEuZGVmYXVsdFByb3BzKWZvcihjIGluIGY9YS5kZWZhdWx0UHJvcHMsZil2b2lkIDA9PT1lW2NdJiYoZVtjXT1mW2NdKTtyZXR1cm57JCR0eXBlb2Y6cCx0eXBlOmEsa2V5OmcscmVmOmgscHJvcHM6ZSxfb3duZXI6Si5jdXJyZW50fX1cbmZ1bmN0aW9uIGNhKGEsYil7cmV0dXJueyQkdHlwZW9mOnAsdHlwZTphLnR5cGUsa2V5OmIscmVmOmEucmVmLHByb3BzOmEucHJvcHMsX293bmVyOmEuX293bmVyfX1mdW5jdGlvbiBOKGEpe3JldHVyblwib2JqZWN0XCI9PT10eXBlb2YgYSYmbnVsbCE9PWEmJmEuJCR0eXBlb2Y9PT1wfWZ1bmN0aW9uIGVzY2FwZShhKXt2YXIgYj17XCI9XCI6XCI9MFwiLFwiOlwiOlwiPTJcIn07cmV0dXJuXCIkXCIrKFwiXCIrYSkucmVwbGFjZSgvWz06XS9nLGZ1bmN0aW9uKGEpe3JldHVybiBiW2FdfSl9dmFyIE89L1xcLysvZyxQPVtdO2Z1bmN0aW9uIFEoYSxiLGQsYyl7aWYoUC5sZW5ndGgpe3ZhciBlPVAucG9wKCk7ZS5yZXN1bHQ9YTtlLmtleVByZWZpeD1iO2UuZnVuYz1kO2UuY29udGV4dD1jO2UuY291bnQ9MDtyZXR1cm4gZX1yZXR1cm57cmVzdWx0OmEsa2V5UHJlZml4OmIsZnVuYzpkLGNvbnRleHQ6Yyxjb3VudDowfX1cbmZ1bmN0aW9uIFIoYSl7YS5yZXN1bHQ9bnVsbDthLmtleVByZWZpeD1udWxsO2EuZnVuYz1udWxsO2EuY29udGV4dD1udWxsO2EuY291bnQ9MDsxMD5QLmxlbmd0aCYmUC5wdXNoKGEpfVxuZnVuY3Rpb24gUyhhLGIsZCxjKXt2YXIgZT10eXBlb2YgYTtpZihcInVuZGVmaW5lZFwiPT09ZXx8XCJib29sZWFuXCI9PT1lKWE9bnVsbDt2YXIgZz0hMTtpZihudWxsPT09YSlnPSEwO2Vsc2Ugc3dpdGNoKGUpe2Nhc2UgXCJzdHJpbmdcIjpjYXNlIFwibnVtYmVyXCI6Zz0hMDticmVhaztjYXNlIFwib2JqZWN0XCI6c3dpdGNoKGEuJCR0eXBlb2Ype2Nhc2UgcDpjYXNlIHE6Zz0hMH19aWYoZylyZXR1cm4gZChjLGEsXCJcIj09PWI/XCIuXCIrVChhLDApOmIpLDE7Zz0wO2I9XCJcIj09PWI/XCIuXCI6YitcIjpcIjtpZihBcnJheS5pc0FycmF5KGEpKWZvcih2YXIgaD0wO2g8YS5sZW5ndGg7aCsrKXtlPWFbaF07dmFyIGY9YitUKGUsaCk7Zys9UyhlLGYsZCxjKX1lbHNlIGlmKG51bGw9PT1hfHxcIm9iamVjdFwiIT09dHlwZW9mIGE/Zj1udWxsOihmPUImJmFbQl18fGFbXCJAQGl0ZXJhdG9yXCJdLGY9XCJmdW5jdGlvblwiPT09dHlwZW9mIGY/ZjpudWxsKSxcImZ1bmN0aW9uXCI9PT10eXBlb2YgZilmb3IoYT1mLmNhbGwoYSksaD1cbjA7IShlPWEubmV4dCgpKS5kb25lOyllPWUudmFsdWUsZj1iK1QoZSxoKyspLGcrPVMoZSxmLGQsYyk7ZWxzZVwib2JqZWN0XCI9PT1lJiYoZD1cIlwiK2EsQyhcIjMxXCIsXCJbb2JqZWN0IE9iamVjdF1cIj09PWQ/XCJvYmplY3Qgd2l0aCBrZXlzIHtcIitPYmplY3Qua2V5cyhhKS5qb2luKFwiLCBcIikrXCJ9XCI6ZCxcIlwiKSk7cmV0dXJuIGd9ZnVuY3Rpb24gVShhLGIsZCl7cmV0dXJuIG51bGw9PWE/MDpTKGEsXCJcIixiLGQpfWZ1bmN0aW9uIFQoYSxiKXtyZXR1cm5cIm9iamVjdFwiPT09dHlwZW9mIGEmJm51bGwhPT1hJiZudWxsIT1hLmtleT9lc2NhcGUoYS5rZXkpOmIudG9TdHJpbmcoMzYpfWZ1bmN0aW9uIGRhKGEsYil7YS5mdW5jLmNhbGwoYS5jb250ZXh0LGIsYS5jb3VudCsrKX1cbmZ1bmN0aW9uIGVhKGEsYixkKXt2YXIgYz1hLnJlc3VsdCxlPWEua2V5UHJlZml4O2E9YS5mdW5jLmNhbGwoYS5jb250ZXh0LGIsYS5jb3VudCsrKTtBcnJheS5pc0FycmF5KGEpP1YoYSxjLGQsZnVuY3Rpb24oYSl7cmV0dXJuIGF9KTpudWxsIT1hJiYoTihhKSYmKGE9Y2EoYSxlKyghYS5rZXl8fGImJmIua2V5PT09YS5rZXk/XCJcIjooXCJcIithLmtleSkucmVwbGFjZShPLFwiJCYvXCIpK1wiL1wiKStkKSksYy5wdXNoKGEpKX1mdW5jdGlvbiBWKGEsYixkLGMsZSl7dmFyIGc9XCJcIjtudWxsIT1kJiYoZz0oXCJcIitkKS5yZXBsYWNlKE8sXCIkJi9cIikrXCIvXCIpO2I9UShiLGcsYyxlKTtVKGEsZWEsYik7UihiKX1mdW5jdGlvbiBXKCl7dmFyIGE9Si5jdXJyZW50RGlzcGF0Y2hlcjtudWxsPT09YT9DKFwiMjk4XCIpOnZvaWQgMDtyZXR1cm4gYX1cbnZhciBYPXtDaGlsZHJlbjp7bWFwOmZ1bmN0aW9uKGEsYixkKXtpZihudWxsPT1hKXJldHVybiBhO3ZhciBjPVtdO1YoYSxjLG51bGwsYixkKTtyZXR1cm4gY30sZm9yRWFjaDpmdW5jdGlvbihhLGIsZCl7aWYobnVsbD09YSlyZXR1cm4gYTtiPVEobnVsbCxudWxsLGIsZCk7VShhLGRhLGIpO1IoYil9LGNvdW50OmZ1bmN0aW9uKGEpe3JldHVybiBVKGEsZnVuY3Rpb24oKXtyZXR1cm4gbnVsbH0sbnVsbCl9LHRvQXJyYXk6ZnVuY3Rpb24oYSl7dmFyIGI9W107VihhLGIsbnVsbCxmdW5jdGlvbihhKXtyZXR1cm4gYX0pO3JldHVybiBifSxvbmx5OmZ1bmN0aW9uKGEpe04oYSk/dm9pZCAwOkMoXCIxNDNcIik7cmV0dXJuIGF9fSxjcmVhdGVSZWY6ZnVuY3Rpb24oKXtyZXR1cm57Y3VycmVudDpudWxsfX0sQ29tcG9uZW50OkYsUHVyZUNvbXBvbmVudDpILGNyZWF0ZUNvbnRleHQ6ZnVuY3Rpb24oYSxiKXt2b2lkIDA9PT1iJiYoYj1udWxsKTthPXskJHR5cGVvZjp3LF9jYWxjdWxhdGVDaGFuZ2VkQml0czpiLFxuX2N1cnJlbnRWYWx1ZTphLF9jdXJyZW50VmFsdWUyOmEsUHJvdmlkZXI6bnVsbCxDb25zdW1lcjpudWxsfTthLlByb3ZpZGVyPXskJHR5cGVvZjp2LF9jb250ZXh0OmF9O3JldHVybiBhLkNvbnN1bWVyPWF9LGZvcndhcmRSZWY6ZnVuY3Rpb24oYSl7cmV0dXJueyQkdHlwZW9mOnkscmVuZGVyOmF9fSxsYXp5OmZ1bmN0aW9uKGEpe3JldHVybnskJHR5cGVvZjphYSxfY3RvcjphLF9zdGF0dXM6LTEsX3Jlc3VsdDpudWxsfX0sbWVtbzpmdW5jdGlvbihhLGIpe3JldHVybnskJHR5cGVvZjpBLHR5cGU6YSxjb21wYXJlOnZvaWQgMD09PWI/bnVsbDpifX0sRnJhZ21lbnQ6cixTdHJpY3RNb2RlOnQsU3VzcGVuc2U6eixjcmVhdGVFbGVtZW50Ok0sY2xvbmVFbGVtZW50OmZ1bmN0aW9uKGEsYixkKXtudWxsPT09YXx8dm9pZCAwPT09YT9DKFwiMjY3XCIsYSk6dm9pZCAwO3ZhciBjPXZvaWQgMCxlPWsoe30sYS5wcm9wcyksZz1hLmtleSxoPWEucmVmLGY9YS5fb3duZXI7aWYobnVsbCE9Yil7dm9pZCAwIT09XG5iLnJlZiYmKGg9Yi5yZWYsZj1KLmN1cnJlbnQpO3ZvaWQgMCE9PWIua2V5JiYoZz1cIlwiK2Iua2V5KTt2YXIgbT12b2lkIDA7YS50eXBlJiZhLnR5cGUuZGVmYXVsdFByb3BzJiYobT1hLnR5cGUuZGVmYXVsdFByb3BzKTtmb3IoYyBpbiBiKUsuY2FsbChiLGMpJiYhTC5oYXNPd25Qcm9wZXJ0eShjKSYmKGVbY109dm9pZCAwPT09YltjXSYmdm9pZCAwIT09bT9tW2NdOmJbY10pfWM9YXJndW1lbnRzLmxlbmd0aC0yO2lmKDE9PT1jKWUuY2hpbGRyZW49ZDtlbHNlIGlmKDE8Yyl7bT1BcnJheShjKTtmb3IodmFyIG49MDtuPGM7bisrKW1bbl09YXJndW1lbnRzW24rMl07ZS5jaGlsZHJlbj1tfXJldHVybnskJHR5cGVvZjpwLHR5cGU6YS50eXBlLGtleTpnLHJlZjpoLHByb3BzOmUsX293bmVyOmZ9fSxjcmVhdGVGYWN0b3J5OmZ1bmN0aW9uKGEpe3ZhciBiPU0uYmluZChudWxsLGEpO2IudHlwZT1hO3JldHVybiBifSxpc1ZhbGlkRWxlbWVudDpOLHZlcnNpb246XCIxNi43LjAtYWxwaGEuMFwiLFxuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ6e1JlYWN0Q3VycmVudE93bmVyOkosYXNzaWduOmt9fTtYLkNvbmN1cnJlbnRNb2RlPXg7WC5Qcm9maWxlcj11O1gudXNlQ2FsbGJhY2s9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gVygpLnVzZUNhbGxiYWNrKGEsYil9O1gudXNlQ29udGV4dD1mdW5jdGlvbihhLGIpe3JldHVybiBXKCkudXNlQ29udGV4dChhLGIpfTtYLnVzZUVmZmVjdD1mdW5jdGlvbihhLGIpe3JldHVybiBXKCkudXNlRWZmZWN0KGEsYil9O1gudXNlSW1wZXJhdGl2ZU1ldGhvZHM9ZnVuY3Rpb24oYSxiLGQpe3JldHVybiBXKCkudXNlSW1wZXJhdGl2ZU1ldGhvZHMoYSxiLGQpfTtYLnVzZUxheW91dEVmZmVjdD1mdW5jdGlvbihhLGIpe3JldHVybiBXKCkudXNlTGF5b3V0RWZmZWN0KGEsYil9O1gudXNlTWVtbz1mdW5jdGlvbihhLGIpe3JldHVybiBXKCkudXNlTWVtbyhhLGIpfTtcblgudXNlTXV0YXRpb25FZmZlY3Q9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gVygpLnVzZU11dGF0aW9uRWZmZWN0KGEsYil9O1gudXNlUmVkdWNlcj1mdW5jdGlvbihhLGIsZCl7cmV0dXJuIFcoKS51c2VSZWR1Y2VyKGEsYixkKX07WC51c2VSZWY9ZnVuY3Rpb24oYSl7cmV0dXJuIFcoKS51c2VSZWYoYSl9O1gudXNlU3RhdGU9ZnVuY3Rpb24oYSl7cmV0dXJuIFcoKS51c2VTdGF0ZShhKX07dmFyIFk9e2RlZmF1bHQ6WH0sWj1ZJiZYfHxZO21vZHVsZS5leHBvcnRzPVouZGVmYXVsdHx8WjtcbiIsbnVsbCwiLyoqIEBsaWNlbnNlIFJlYWN0IHYxNi43LjAtYWxwaGEuMFxuICogcmVhY3QtZG9tLnByb2R1Y3Rpb24ubWluLmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuLypcbiBNb2Rlcm5penIgMy4wLjBwcmUgKEN1c3RvbSBCdWlsZCkgfCBNSVRcbiovXG4ndXNlIHN0cmljdCc7dmFyIGFhPXJlcXVpcmUoXCJyZWFjdFwiKSxuPXJlcXVpcmUoXCJvYmplY3QtYXNzaWduXCIpLGJhPXJlcXVpcmUoXCJzY2hlZHVsZXJcIik7ZnVuY3Rpb24gY2EoYSxiLGMsZCxlLGYsZyxoKXtpZighYSl7YT12b2lkIDA7aWYodm9pZCAwPT09YilhPUVycm9yKFwiTWluaWZpZWQgZXhjZXB0aW9uIG9jY3VycmVkOyB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgZm9yIHRoZSBmdWxsIGVycm9yIG1lc3NhZ2UgYW5kIGFkZGl0aW9uYWwgaGVscGZ1bCB3YXJuaW5ncy5cIik7ZWxzZXt2YXIgaz1bYyxkLGUsZixnLGhdLGw9MDthPUVycm9yKGIucmVwbGFjZSgvJXMvZyxmdW5jdGlvbigpe3JldHVybiBrW2wrK119KSk7YS5uYW1lPVwiSW52YXJpYW50IFZpb2xhdGlvblwifWEuZnJhbWVzVG9Qb3A9MTt0aHJvdyBhO319XG5mdW5jdGlvbiByKGEpe2Zvcih2YXIgYj1hcmd1bWVudHMubGVuZ3RoLTEsYz1cImh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9lcnJvci1kZWNvZGVyLmh0bWw/aW52YXJpYW50PVwiK2EsZD0wO2Q8YjtkKyspYys9XCImYXJnc1tdPVwiK2VuY29kZVVSSUNvbXBvbmVudChhcmd1bWVudHNbZCsxXSk7Y2EoITEsXCJNaW5pZmllZCBSZWFjdCBlcnJvciAjXCIrYStcIjsgdmlzaXQgJXMgZm9yIHRoZSBmdWxsIG1lc3NhZ2Ugb3IgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50IGZvciBmdWxsIGVycm9ycyBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLiBcIixjKX1hYT92b2lkIDA6cihcIjIyN1wiKTtmdW5jdGlvbiBkYShhLGIsYyxkLGUsZixnLGgsayl7dmFyIGw9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDMpO3RyeXtiLmFwcGx5KGMsbCl9Y2F0Y2gobSl7dGhpcy5vbkVycm9yKG0pfX1cbnZhciBlYT0hMSxpYT1udWxsLGphPSExLGthPW51bGwsbGE9e29uRXJyb3I6ZnVuY3Rpb24oYSl7ZWE9ITA7aWE9YX19O2Z1bmN0aW9uIG1hKGEsYixjLGQsZSxmLGcsaCxrKXtlYT0hMTtpYT1udWxsO2RhLmFwcGx5KGxhLGFyZ3VtZW50cyl9ZnVuY3Rpb24gbmEoYSxiLGMsZCxlLGYsZyxoLGspe21hLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtpZihlYSl7aWYoZWEpe3ZhciBsPWlhO2VhPSExO2lhPW51bGx9ZWxzZSByKFwiMTk4XCIpLGw9dm9pZCAwO2phfHwoamE9ITAsa2E9bCl9fXZhciBvYT1udWxsLHBhPXt9O1xuZnVuY3Rpb24gcWEoKXtpZihvYSlmb3IodmFyIGEgaW4gcGEpe3ZhciBiPXBhW2FdLGM9b2EuaW5kZXhPZihhKTstMTxjP3ZvaWQgMDpyKFwiOTZcIixhKTtpZighcmFbY10pe2IuZXh0cmFjdEV2ZW50cz92b2lkIDA6cihcIjk3XCIsYSk7cmFbY109YjtjPWIuZXZlbnRUeXBlcztmb3IodmFyIGQgaW4gYyl7dmFyIGU9dm9pZCAwO3ZhciBmPWNbZF0sZz1iLGg9ZDtzYS5oYXNPd25Qcm9wZXJ0eShoKT9yKFwiOTlcIixoKTp2b2lkIDA7c2FbaF09Zjt2YXIgaz1mLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzO2lmKGspe2ZvcihlIGluIGspay5oYXNPd25Qcm9wZXJ0eShlKSYmdGEoa1tlXSxnLGgpO2U9ITB9ZWxzZSBmLnJlZ2lzdHJhdGlvbk5hbWU/KHRhKGYucmVnaXN0cmF0aW9uTmFtZSxnLGgpLGU9ITApOmU9ITE7ZT92b2lkIDA6cihcIjk4XCIsZCxhKX19fX1cbmZ1bmN0aW9uIHRhKGEsYixjKXt1YVthXT9yKFwiMTAwXCIsYSk6dm9pZCAwO3VhW2FdPWI7dmFbYV09Yi5ldmVudFR5cGVzW2NdLmRlcGVuZGVuY2llc312YXIgcmE9W10sc2E9e30sdWE9e30sdmE9e30sd2E9bnVsbCx4YT1udWxsLHlhPW51bGw7ZnVuY3Rpb24gemEoYSxiLGMsZCl7Yj1hLnR5cGV8fFwidW5rbm93bi1ldmVudFwiO2EuY3VycmVudFRhcmdldD15YShkKTtuYShiLGMsdm9pZCAwLGEpO2EuY3VycmVudFRhcmdldD1udWxsfWZ1bmN0aW9uIEFhKGEsYil7bnVsbD09Yj9yKFwiMzBcIik6dm9pZCAwO2lmKG51bGw9PWEpcmV0dXJuIGI7aWYoQXJyYXkuaXNBcnJheShhKSl7aWYoQXJyYXkuaXNBcnJheShiKSlyZXR1cm4gYS5wdXNoLmFwcGx5KGEsYiksYTthLnB1c2goYik7cmV0dXJuIGF9cmV0dXJuIEFycmF5LmlzQXJyYXkoYik/W2FdLmNvbmNhdChiKTpbYSxiXX1cbmZ1bmN0aW9uIEJhKGEsYixjKXtBcnJheS5pc0FycmF5KGEpP2EuZm9yRWFjaChiLGMpOmEmJmIuY2FsbChjLGEpfXZhciBDYT1udWxsO2Z1bmN0aW9uIERhKGEsYil7aWYoYSl7dmFyIGM9YS5fZGlzcGF0Y2hMaXN0ZW5lcnMsZD1hLl9kaXNwYXRjaEluc3RhbmNlcztpZihBcnJheS5pc0FycmF5KGMpKWZvcih2YXIgZT0wO2U8Yy5sZW5ndGgmJiFhLmlzUHJvcGFnYXRpb25TdG9wcGVkKCk7ZSsrKXphKGEsYixjW2VdLGRbZV0pO2Vsc2UgYyYmemEoYSxiLGMsZCk7YS5fZGlzcGF0Y2hMaXN0ZW5lcnM9bnVsbDthLl9kaXNwYXRjaEluc3RhbmNlcz1udWxsO2EuaXNQZXJzaXN0ZW50KCl8fGEuY29uc3RydWN0b3IucmVsZWFzZShhKX19ZnVuY3Rpb24gRWEoYSl7cmV0dXJuIERhKGEsITApfWZ1bmN0aW9uIEZhKGEpe3JldHVybiBEYShhLCExKX1cbnZhciBHYT17aW5qZWN0RXZlbnRQbHVnaW5PcmRlcjpmdW5jdGlvbihhKXtvYT9yKFwiMTAxXCIpOnZvaWQgMDtvYT1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhKTtxYSgpfSxpbmplY3RFdmVudFBsdWdpbnNCeU5hbWU6ZnVuY3Rpb24oYSl7dmFyIGI9ITEsYztmb3IoYyBpbiBhKWlmKGEuaGFzT3duUHJvcGVydHkoYykpe3ZhciBkPWFbY107cGEuaGFzT3duUHJvcGVydHkoYykmJnBhW2NdPT09ZHx8KHBhW2NdP3IoXCIxMDJcIixjKTp2b2lkIDAscGFbY109ZCxiPSEwKX1iJiZxYSgpfX07XG5mdW5jdGlvbiBIYShhLGIpe3ZhciBjPWEuc3RhdGVOb2RlO2lmKCFjKXJldHVybiBudWxsO3ZhciBkPXdhKGMpO2lmKCFkKXJldHVybiBudWxsO2M9ZFtiXTthOnN3aXRjaChiKXtjYXNlIFwib25DbGlja1wiOmNhc2UgXCJvbkNsaWNrQ2FwdHVyZVwiOmNhc2UgXCJvbkRvdWJsZUNsaWNrXCI6Y2FzZSBcIm9uRG91YmxlQ2xpY2tDYXB0dXJlXCI6Y2FzZSBcIm9uTW91c2VEb3duXCI6Y2FzZSBcIm9uTW91c2VEb3duQ2FwdHVyZVwiOmNhc2UgXCJvbk1vdXNlTW92ZVwiOmNhc2UgXCJvbk1vdXNlTW92ZUNhcHR1cmVcIjpjYXNlIFwib25Nb3VzZVVwXCI6Y2FzZSBcIm9uTW91c2VVcENhcHR1cmVcIjooZD0hZC5kaXNhYmxlZCl8fChhPWEudHlwZSxkPSEoXCJidXR0b25cIj09PWF8fFwiaW5wdXRcIj09PWF8fFwic2VsZWN0XCI9PT1hfHxcInRleHRhcmVhXCI9PT1hKSk7YT0hZDticmVhayBhO2RlZmF1bHQ6YT0hMX1pZihhKXJldHVybiBudWxsO2MmJlwiZnVuY3Rpb25cIiE9PXR5cGVvZiBjP3IoXCIyMzFcIixiLHR5cGVvZiBjKTp2b2lkIDA7XG5yZXR1cm4gY31mdW5jdGlvbiBJYShhLGIpe251bGwhPT1hJiYoQ2E9QWEoQ2EsYSkpO2E9Q2E7Q2E9bnVsbDtpZihhJiYoYj9CYShhLEVhKTpCYShhLEZhKSxDYT9yKFwiOTVcIik6dm9pZCAwLGphKSl0aHJvdyBiPWthLGphPSExLGthPW51bGwsYjt9dmFyIEphPU1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpLEthPVwiX19yZWFjdEludGVybmFsSW5zdGFuY2UkXCIrSmEsTGE9XCJfX3JlYWN0RXZlbnRIYW5kbGVycyRcIitKYTtmdW5jdGlvbiBNYShhKXtpZihhW0thXSlyZXR1cm4gYVtLYV07Zm9yKDshYVtLYV07KWlmKGEucGFyZW50Tm9kZSlhPWEucGFyZW50Tm9kZTtlbHNlIHJldHVybiBudWxsO2E9YVtLYV07cmV0dXJuIDU9PT1hLnRhZ3x8Nj09PWEudGFnP2E6bnVsbH1mdW5jdGlvbiBOYShhKXthPWFbS2FdO3JldHVybiFhfHw1IT09YS50YWcmJjYhPT1hLnRhZz9udWxsOmF9XG5mdW5jdGlvbiBPYShhKXtpZig1PT09YS50YWd8fDY9PT1hLnRhZylyZXR1cm4gYS5zdGF0ZU5vZGU7cihcIjMzXCIpfWZ1bmN0aW9uIFBhKGEpe3JldHVybiBhW0xhXXx8bnVsbH1mdW5jdGlvbiBRYShhKXtkbyBhPWEucmV0dXJuO3doaWxlKGEmJjUhPT1hLnRhZyk7cmV0dXJuIGE/YTpudWxsfWZ1bmN0aW9uIFJhKGEsYixjKXtpZihiPUhhKGEsYy5kaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lc1tiXSkpYy5fZGlzcGF0Y2hMaXN0ZW5lcnM9QWEoYy5fZGlzcGF0Y2hMaXN0ZW5lcnMsYiksYy5fZGlzcGF0Y2hJbnN0YW5jZXM9QWEoYy5fZGlzcGF0Y2hJbnN0YW5jZXMsYSl9XG5mdW5jdGlvbiBTYShhKXtpZihhJiZhLmRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzKXtmb3IodmFyIGI9YS5fdGFyZ2V0SW5zdCxjPVtdO2I7KWMucHVzaChiKSxiPVFhKGIpO2ZvcihiPWMubGVuZ3RoOzA8Yi0tOylSYShjW2JdLFwiY2FwdHVyZWRcIixhKTtmb3IoYj0wO2I8Yy5sZW5ndGg7YisrKVJhKGNbYl0sXCJidWJibGVkXCIsYSl9fWZ1bmN0aW9uIFRhKGEsYixjKXthJiZjJiZjLmRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUmJihiPUhhKGEsYy5kaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lKSkmJihjLl9kaXNwYXRjaExpc3RlbmVycz1BYShjLl9kaXNwYXRjaExpc3RlbmVycyxiKSxjLl9kaXNwYXRjaEluc3RhbmNlcz1BYShjLl9kaXNwYXRjaEluc3RhbmNlcyxhKSl9ZnVuY3Rpb24gVmEoYSl7YSYmYS5kaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lJiZUYShhLl90YXJnZXRJbnN0LG51bGwsYSl9XG5mdW5jdGlvbiBXYShhKXtCYShhLFNhKX12YXIgWGE9IShcInVuZGVmaW5lZFwiPT09dHlwZW9mIHdpbmRvd3x8IXdpbmRvdy5kb2N1bWVudHx8IXdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KTtmdW5jdGlvbiBZYShhLGIpe3ZhciBjPXt9O2NbYS50b0xvd2VyQ2FzZSgpXT1iLnRvTG93ZXJDYXNlKCk7Y1tcIldlYmtpdFwiK2FdPVwid2Via2l0XCIrYjtjW1wiTW96XCIrYV09XCJtb3pcIitiO3JldHVybiBjfXZhciBaYT17YW5pbWF0aW9uZW5kOllhKFwiQW5pbWF0aW9uXCIsXCJBbmltYXRpb25FbmRcIiksYW5pbWF0aW9uaXRlcmF0aW9uOllhKFwiQW5pbWF0aW9uXCIsXCJBbmltYXRpb25JdGVyYXRpb25cIiksYW5pbWF0aW9uc3RhcnQ6WWEoXCJBbmltYXRpb25cIixcIkFuaW1hdGlvblN0YXJ0XCIpLHRyYW5zaXRpb25lbmQ6WWEoXCJUcmFuc2l0aW9uXCIsXCJUcmFuc2l0aW9uRW5kXCIpfSwkYT17fSxhYj17fTtcblhhJiYoYWI9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKS5zdHlsZSxcIkFuaW1hdGlvbkV2ZW50XCJpbiB3aW5kb3d8fChkZWxldGUgWmEuYW5pbWF0aW9uZW5kLmFuaW1hdGlvbixkZWxldGUgWmEuYW5pbWF0aW9uaXRlcmF0aW9uLmFuaW1hdGlvbixkZWxldGUgWmEuYW5pbWF0aW9uc3RhcnQuYW5pbWF0aW9uKSxcIlRyYW5zaXRpb25FdmVudFwiaW4gd2luZG93fHxkZWxldGUgWmEudHJhbnNpdGlvbmVuZC50cmFuc2l0aW9uKTtmdW5jdGlvbiBiYihhKXtpZigkYVthXSlyZXR1cm4gJGFbYV07aWYoIVphW2FdKXJldHVybiBhO3ZhciBiPVphW2FdLGM7Zm9yKGMgaW4gYilpZihiLmhhc093blByb3BlcnR5KGMpJiZjIGluIGFiKXJldHVybiAkYVthXT1iW2NdO3JldHVybiBhfVxudmFyIGNiPWJiKFwiYW5pbWF0aW9uZW5kXCIpLGRiPWJiKFwiYW5pbWF0aW9uaXRlcmF0aW9uXCIpLGViPWJiKFwiYW5pbWF0aW9uc3RhcnRcIiksZmI9YmIoXCJ0cmFuc2l0aW9uZW5kXCIpLGdiPVwiYWJvcnQgY2FucGxheSBjYW5wbGF5dGhyb3VnaCBkdXJhdGlvbmNoYW5nZSBlbXB0aWVkIGVuY3J5cHRlZCBlbmRlZCBlcnJvciBsb2FkZWRkYXRhIGxvYWRlZG1ldGFkYXRhIGxvYWRzdGFydCBwYXVzZSBwbGF5IHBsYXlpbmcgcHJvZ3Jlc3MgcmF0ZWNoYW5nZSBzZWVrZWQgc2Vla2luZyBzdGFsbGVkIHN1c3BlbmQgdGltZXVwZGF0ZSB2b2x1bWVjaGFuZ2Ugd2FpdGluZ1wiLnNwbGl0KFwiIFwiKSxoYj1udWxsLGliPW51bGwsamI9bnVsbDtcbmZ1bmN0aW9uIGtiKCl7aWYoamIpcmV0dXJuIGpiO3ZhciBhLGI9aWIsYz1iLmxlbmd0aCxkLGU9XCJ2YWx1ZVwiaW4gaGI/aGIudmFsdWU6aGIudGV4dENvbnRlbnQsZj1lLmxlbmd0aDtmb3IoYT0wO2E8YyYmYlthXT09PWVbYV07YSsrKTt2YXIgZz1jLWE7Zm9yKGQ9MTtkPD1nJiZiW2MtZF09PT1lW2YtZF07ZCsrKTtyZXR1cm4gamI9ZS5zbGljZShhLDE8ZD8xLWQ6dm9pZCAwKX1mdW5jdGlvbiBsYigpe3JldHVybiEwfWZ1bmN0aW9uIG1iKCl7cmV0dXJuITF9XG5mdW5jdGlvbiB1KGEsYixjLGQpe3RoaXMuZGlzcGF0Y2hDb25maWc9YTt0aGlzLl90YXJnZXRJbnN0PWI7dGhpcy5uYXRpdmVFdmVudD1jO2E9dGhpcy5jb25zdHJ1Y3Rvci5JbnRlcmZhY2U7Zm9yKHZhciBlIGluIGEpYS5oYXNPd25Qcm9wZXJ0eShlKSYmKChiPWFbZV0pP3RoaXNbZV09YihjKTpcInRhcmdldFwiPT09ZT90aGlzLnRhcmdldD1kOnRoaXNbZV09Y1tlXSk7dGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQ9KG51bGwhPWMuZGVmYXVsdFByZXZlbnRlZD9jLmRlZmF1bHRQcmV2ZW50ZWQ6ITE9PT1jLnJldHVyblZhbHVlKT9sYjptYjt0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkPW1iO3JldHVybiB0aGlzfVxubih1LnByb3RvdHlwZSx7cHJldmVudERlZmF1bHQ6ZnVuY3Rpb24oKXt0aGlzLmRlZmF1bHRQcmV2ZW50ZWQ9ITA7dmFyIGE9dGhpcy5uYXRpdmVFdmVudDthJiYoYS5wcmV2ZW50RGVmYXVsdD9hLnByZXZlbnREZWZhdWx0KCk6XCJ1bmtub3duXCIhPT10eXBlb2YgYS5yZXR1cm5WYWx1ZSYmKGEucmV0dXJuVmFsdWU9ITEpLHRoaXMuaXNEZWZhdWx0UHJldmVudGVkPWxiKX0sc3RvcFByb3BhZ2F0aW9uOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5uYXRpdmVFdmVudDthJiYoYS5zdG9wUHJvcGFnYXRpb24/YS5zdG9wUHJvcGFnYXRpb24oKTpcInVua25vd25cIiE9PXR5cGVvZiBhLmNhbmNlbEJ1YmJsZSYmKGEuY2FuY2VsQnViYmxlPSEwKSx0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkPWxiKX0scGVyc2lzdDpmdW5jdGlvbigpe3RoaXMuaXNQZXJzaXN0ZW50PWxifSxpc1BlcnNpc3RlbnQ6bWIsZGVzdHJ1Y3RvcjpmdW5jdGlvbigpe3ZhciBhPXRoaXMuY29uc3RydWN0b3IuSW50ZXJmYWNlLFxuYjtmb3IoYiBpbiBhKXRoaXNbYl09bnVsbDt0aGlzLm5hdGl2ZUV2ZW50PXRoaXMuX3RhcmdldEluc3Q9dGhpcy5kaXNwYXRjaENvbmZpZz1udWxsO3RoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQ9dGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQ9bWI7dGhpcy5fZGlzcGF0Y2hJbnN0YW5jZXM9dGhpcy5fZGlzcGF0Y2hMaXN0ZW5lcnM9bnVsbH19KTt1LkludGVyZmFjZT17dHlwZTpudWxsLHRhcmdldDpudWxsLGN1cnJlbnRUYXJnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbH0sZXZlbnRQaGFzZTpudWxsLGJ1YmJsZXM6bnVsbCxjYW5jZWxhYmxlOm51bGwsdGltZVN0YW1wOmZ1bmN0aW9uKGEpe3JldHVybiBhLnRpbWVTdGFtcHx8RGF0ZS5ub3coKX0sZGVmYXVsdFByZXZlbnRlZDpudWxsLGlzVHJ1c3RlZDpudWxsfTtcbnUuZXh0ZW5kPWZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGIoKXt9ZnVuY3Rpb24gYygpe3JldHVybiBkLmFwcGx5KHRoaXMsYXJndW1lbnRzKX12YXIgZD10aGlzO2IucHJvdG90eXBlPWQucHJvdG90eXBlO3ZhciBlPW5ldyBiO24oZSxjLnByb3RvdHlwZSk7Yy5wcm90b3R5cGU9ZTtjLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1jO2MuSW50ZXJmYWNlPW4oe30sZC5JbnRlcmZhY2UsYSk7Yy5leHRlbmQ9ZC5leHRlbmQ7bmIoYyk7cmV0dXJuIGN9O25iKHUpO2Z1bmN0aW9uIG9iKGEsYixjLGQpe2lmKHRoaXMuZXZlbnRQb29sLmxlbmd0aCl7dmFyIGU9dGhpcy5ldmVudFBvb2wucG9wKCk7dGhpcy5jYWxsKGUsYSxiLGMsZCk7cmV0dXJuIGV9cmV0dXJuIG5ldyB0aGlzKGEsYixjLGQpfWZ1bmN0aW9uIHBiKGEpe2EgaW5zdGFuY2VvZiB0aGlzP3ZvaWQgMDpyKFwiMjc5XCIpO2EuZGVzdHJ1Y3RvcigpOzEwPnRoaXMuZXZlbnRQb29sLmxlbmd0aCYmdGhpcy5ldmVudFBvb2wucHVzaChhKX1cbmZ1bmN0aW9uIG5iKGEpe2EuZXZlbnRQb29sPVtdO2EuZ2V0UG9vbGVkPW9iO2EucmVsZWFzZT1wYn12YXIgcWI9dS5leHRlbmQoe2RhdGE6bnVsbH0pLHJiPXUuZXh0ZW5kKHtkYXRhOm51bGx9KSx5Yj1bOSwxMywyNywzMl0semI9WGEmJlwiQ29tcG9zaXRpb25FdmVudFwiaW4gd2luZG93LEFiPW51bGw7WGEmJlwiZG9jdW1lbnRNb2RlXCJpbiBkb2N1bWVudCYmKEFiPWRvY3VtZW50LmRvY3VtZW50TW9kZSk7XG52YXIgQmI9WGEmJlwiVGV4dEV2ZW50XCJpbiB3aW5kb3cmJiFBYixDYj1YYSYmKCF6Ynx8QWImJjg8QWImJjExPj1BYiksRGI9U3RyaW5nLmZyb21DaGFyQ29kZSgzMiksRWI9e2JlZm9yZUlucHV0OntwaGFzZWRSZWdpc3RyYXRpb25OYW1lczp7YnViYmxlZDpcIm9uQmVmb3JlSW5wdXRcIixjYXB0dXJlZDpcIm9uQmVmb3JlSW5wdXRDYXB0dXJlXCJ9LGRlcGVuZGVuY2llczpbXCJjb21wb3NpdGlvbmVuZFwiLFwia2V5cHJlc3NcIixcInRleHRJbnB1dFwiLFwicGFzdGVcIl19LGNvbXBvc2l0aW9uRW5kOntwaGFzZWRSZWdpc3RyYXRpb25OYW1lczp7YnViYmxlZDpcIm9uQ29tcG9zaXRpb25FbmRcIixjYXB0dXJlZDpcIm9uQ29tcG9zaXRpb25FbmRDYXB0dXJlXCJ9LGRlcGVuZGVuY2llczpcImJsdXIgY29tcG9zaXRpb25lbmQga2V5ZG93biBrZXlwcmVzcyBrZXl1cCBtb3VzZWRvd25cIi5zcGxpdChcIiBcIil9LGNvbXBvc2l0aW9uU3RhcnQ6e3BoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOntidWJibGVkOlwib25Db21wb3NpdGlvblN0YXJ0XCIsXG5jYXB0dXJlZDpcIm9uQ29tcG9zaXRpb25TdGFydENhcHR1cmVcIn0sZGVwZW5kZW5jaWVzOlwiYmx1ciBjb21wb3NpdGlvbnN0YXJ0IGtleWRvd24ga2V5cHJlc3Mga2V5dXAgbW91c2Vkb3duXCIuc3BsaXQoXCIgXCIpfSxjb21wb3NpdGlvblVwZGF0ZTp7cGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6e2J1YmJsZWQ6XCJvbkNvbXBvc2l0aW9uVXBkYXRlXCIsY2FwdHVyZWQ6XCJvbkNvbXBvc2l0aW9uVXBkYXRlQ2FwdHVyZVwifSxkZXBlbmRlbmNpZXM6XCJibHVyIGNvbXBvc2l0aW9udXBkYXRlIGtleWRvd24ga2V5cHJlc3Mga2V5dXAgbW91c2Vkb3duXCIuc3BsaXQoXCIgXCIpfX0sRmI9ITE7XG5mdW5jdGlvbiBHYihhLGIpe3N3aXRjaChhKXtjYXNlIFwia2V5dXBcIjpyZXR1cm4tMSE9PXliLmluZGV4T2YoYi5rZXlDb2RlKTtjYXNlIFwia2V5ZG93blwiOnJldHVybiAyMjkhPT1iLmtleUNvZGU7Y2FzZSBcImtleXByZXNzXCI6Y2FzZSBcIm1vdXNlZG93blwiOmNhc2UgXCJibHVyXCI6cmV0dXJuITA7ZGVmYXVsdDpyZXR1cm4hMX19ZnVuY3Rpb24gSGIoYSl7YT1hLmRldGFpbDtyZXR1cm5cIm9iamVjdFwiPT09dHlwZW9mIGEmJlwiZGF0YVwiaW4gYT9hLmRhdGE6bnVsbH12YXIgSWI9ITE7ZnVuY3Rpb24gSmIoYSxiKXtzd2l0Y2goYSl7Y2FzZSBcImNvbXBvc2l0aW9uZW5kXCI6cmV0dXJuIEhiKGIpO2Nhc2UgXCJrZXlwcmVzc1wiOmlmKDMyIT09Yi53aGljaClyZXR1cm4gbnVsbDtGYj0hMDtyZXR1cm4gRGI7Y2FzZSBcInRleHRJbnB1dFwiOnJldHVybiBhPWIuZGF0YSxhPT09RGImJkZiP251bGw6YTtkZWZhdWx0OnJldHVybiBudWxsfX1cbmZ1bmN0aW9uIEtiKGEsYil7aWYoSWIpcmV0dXJuXCJjb21wb3NpdGlvbmVuZFwiPT09YXx8IXpiJiZHYihhLGIpPyhhPWtiKCksamI9aWI9aGI9bnVsbCxJYj0hMSxhKTpudWxsO3N3aXRjaChhKXtjYXNlIFwicGFzdGVcIjpyZXR1cm4gbnVsbDtjYXNlIFwia2V5cHJlc3NcIjppZighKGIuY3RybEtleXx8Yi5hbHRLZXl8fGIubWV0YUtleSl8fGIuY3RybEtleSYmYi5hbHRLZXkpe2lmKGIuY2hhciYmMTxiLmNoYXIubGVuZ3RoKXJldHVybiBiLmNoYXI7aWYoYi53aGljaClyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShiLndoaWNoKX1yZXR1cm4gbnVsbDtjYXNlIFwiY29tcG9zaXRpb25lbmRcIjpyZXR1cm4gQ2ImJlwia29cIiE9PWIubG9jYWxlP251bGw6Yi5kYXRhO2RlZmF1bHQ6cmV0dXJuIG51bGx9fVxudmFyIExiPXtldmVudFR5cGVzOkViLGV4dHJhY3RFdmVudHM6ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9dm9pZCAwO3ZhciBmPXZvaWQgMDtpZih6YiliOntzd2l0Y2goYSl7Y2FzZSBcImNvbXBvc2l0aW9uc3RhcnRcIjplPUViLmNvbXBvc2l0aW9uU3RhcnQ7YnJlYWsgYjtjYXNlIFwiY29tcG9zaXRpb25lbmRcIjplPUViLmNvbXBvc2l0aW9uRW5kO2JyZWFrIGI7Y2FzZSBcImNvbXBvc2l0aW9udXBkYXRlXCI6ZT1FYi5jb21wb3NpdGlvblVwZGF0ZTticmVhayBifWU9dm9pZCAwfWVsc2UgSWI/R2IoYSxjKSYmKGU9RWIuY29tcG9zaXRpb25FbmQpOlwia2V5ZG93blwiPT09YSYmMjI5PT09Yy5rZXlDb2RlJiYoZT1FYi5jb21wb3NpdGlvblN0YXJ0KTtlPyhDYiYmXCJrb1wiIT09Yy5sb2NhbGUmJihJYnx8ZSE9PUViLmNvbXBvc2l0aW9uU3RhcnQ/ZT09PUViLmNvbXBvc2l0aW9uRW5kJiZJYiYmKGY9a2IoKSk6KGhiPWQsaWI9XCJ2YWx1ZVwiaW4gaGI/aGIudmFsdWU6aGIudGV4dENvbnRlbnQsSWI9XG4hMCkpLGU9cWIuZ2V0UG9vbGVkKGUsYixjLGQpLGY/ZS5kYXRhPWY6KGY9SGIoYyksbnVsbCE9PWYmJihlLmRhdGE9ZikpLFdhKGUpLGY9ZSk6Zj1udWxsOyhhPUJiP0piKGEsYyk6S2IoYSxjKSk/KGI9cmIuZ2V0UG9vbGVkKEViLmJlZm9yZUlucHV0LGIsYyxkKSxiLmRhdGE9YSxXYShiKSk6Yj1udWxsO3JldHVybiBudWxsPT09Zj9iOm51bGw9PT1iP2Y6W2YsYl19fSxNYj1udWxsLE5iPW51bGwsT2I9bnVsbDtmdW5jdGlvbiBQYihhKXtpZihhPXhhKGEpKXtcImZ1bmN0aW9uXCIhPT10eXBlb2YgTWI/cihcIjI4MFwiKTp2b2lkIDA7dmFyIGI9d2EoYS5zdGF0ZU5vZGUpO01iKGEuc3RhdGVOb2RlLGEudHlwZSxiKX19ZnVuY3Rpb24gUWIoYSl7TmI/T2I/T2IucHVzaChhKTpPYj1bYV06TmI9YX1mdW5jdGlvbiBSYigpe2lmKE5iKXt2YXIgYT1OYixiPU9iO09iPU5iPW51bGw7UGIoYSk7aWYoYilmb3IoYT0wO2E8Yi5sZW5ndGg7YSsrKVBiKGJbYV0pfX1cbmZ1bmN0aW9uIFNiKGEsYil7cmV0dXJuIGEoYil9ZnVuY3Rpb24gVGIoYSxiLGMpe3JldHVybiBhKGIsYyl9ZnVuY3Rpb24gVWIoKXt9dmFyIFZiPSExO2Z1bmN0aW9uIFdiKGEsYil7aWYoVmIpcmV0dXJuIGEoYik7VmI9ITA7dHJ5e3JldHVybiBTYihhLGIpfWZpbmFsbHl7aWYoVmI9ITEsbnVsbCE9PU5ifHxudWxsIT09T2IpVWIoKSxSYigpfX12YXIgWGI9e2NvbG9yOiEwLGRhdGU6ITAsZGF0ZXRpbWU6ITAsXCJkYXRldGltZS1sb2NhbFwiOiEwLGVtYWlsOiEwLG1vbnRoOiEwLG51bWJlcjohMCxwYXNzd29yZDohMCxyYW5nZTohMCxzZWFyY2g6ITAsdGVsOiEwLHRleHQ6ITAsdGltZTohMCx1cmw6ITAsd2VlazohMH07ZnVuY3Rpb24gWWIoYSl7dmFyIGI9YSYmYS5ub2RlTmFtZSYmYS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO3JldHVyblwiaW5wdXRcIj09PWI/ISFYYlthLnR5cGVdOlwidGV4dGFyZWFcIj09PWI/ITA6ITF9XG5mdW5jdGlvbiBhYyhhKXthPWEudGFyZ2V0fHxhLnNyY0VsZW1lbnR8fHdpbmRvdzthLmNvcnJlc3BvbmRpbmdVc2VFbGVtZW50JiYoYT1hLmNvcnJlc3BvbmRpbmdVc2VFbGVtZW50KTtyZXR1cm4gMz09PWEubm9kZVR5cGU/YS5wYXJlbnROb2RlOmF9ZnVuY3Rpb24gYmMoYSl7aWYoIVhhKXJldHVybiExO2E9XCJvblwiK2E7dmFyIGI9YSBpbiBkb2N1bWVudDtifHwoYj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLGIuc2V0QXR0cmlidXRlKGEsXCJyZXR1cm47XCIpLGI9XCJmdW5jdGlvblwiPT09dHlwZW9mIGJbYV0pO3JldHVybiBifWZ1bmN0aW9uIGNjKGEpe3ZhciBiPWEudHlwZTtyZXR1cm4oYT1hLm5vZGVOYW1lKSYmXCJpbnB1dFwiPT09YS50b0xvd2VyQ2FzZSgpJiYoXCJjaGVja2JveFwiPT09Ynx8XCJyYWRpb1wiPT09Yil9XG5mdW5jdGlvbiBkYyhhKXt2YXIgYj1jYyhhKT9cImNoZWNrZWRcIjpcInZhbHVlXCIsYz1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGEuY29uc3RydWN0b3IucHJvdG90eXBlLGIpLGQ9XCJcIithW2JdO2lmKCFhLmhhc093blByb3BlcnR5KGIpJiZcInVuZGVmaW5lZFwiIT09dHlwZW9mIGMmJlwiZnVuY3Rpb25cIj09PXR5cGVvZiBjLmdldCYmXCJmdW5jdGlvblwiPT09dHlwZW9mIGMuc2V0KXt2YXIgZT1jLmdldCxmPWMuc2V0O09iamVjdC5kZWZpbmVQcm9wZXJ0eShhLGIse2NvbmZpZ3VyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZS5jYWxsKHRoaXMpfSxzZXQ6ZnVuY3Rpb24oYSl7ZD1cIlwiK2E7Zi5jYWxsKHRoaXMsYSl9fSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KGEsYix7ZW51bWVyYWJsZTpjLmVudW1lcmFibGV9KTtyZXR1cm57Z2V0VmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gZH0sc2V0VmFsdWU6ZnVuY3Rpb24oYSl7ZD1cIlwiK2F9LHN0b3BUcmFja2luZzpmdW5jdGlvbigpe2EuX3ZhbHVlVHJhY2tlcj1cbm51bGw7ZGVsZXRlIGFbYl19fX19ZnVuY3Rpb24gZWMoYSl7YS5fdmFsdWVUcmFja2VyfHwoYS5fdmFsdWVUcmFja2VyPWRjKGEpKX1mdW5jdGlvbiBqYyhhKXtpZighYSlyZXR1cm4hMTt2YXIgYj1hLl92YWx1ZVRyYWNrZXI7aWYoIWIpcmV0dXJuITA7dmFyIGM9Yi5nZXRWYWx1ZSgpO3ZhciBkPVwiXCI7YSYmKGQ9Y2MoYSk/YS5jaGVja2VkP1widHJ1ZVwiOlwiZmFsc2VcIjphLnZhbHVlKTthPWQ7cmV0dXJuIGEhPT1jPyhiLnNldFZhbHVlKGEpLCEwKTohMX1cbnZhciBrYz1hYS5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRCxsYz0vXiguKilbXFxcXFxcL10vLHo9XCJmdW5jdGlvblwiPT09dHlwZW9mIFN5bWJvbCYmU3ltYm9sLmZvcixtYz16P1N5bWJvbC5mb3IoXCJyZWFjdC5lbGVtZW50XCIpOjYwMTAzLG5jPXo/U3ltYm9sLmZvcihcInJlYWN0LnBvcnRhbFwiKTo2MDEwNixvYz16P1N5bWJvbC5mb3IoXCJyZWFjdC5mcmFnbWVudFwiKTo2MDEwNyxwYz16P1N5bWJvbC5mb3IoXCJyZWFjdC5zdHJpY3RfbW9kZVwiKTo2MDEwOCxxYz16P1N5bWJvbC5mb3IoXCJyZWFjdC5wcm9maWxlclwiKTo2MDExNCxyYz16P1N5bWJvbC5mb3IoXCJyZWFjdC5wcm92aWRlclwiKTo2MDEwOSxzYz16P1N5bWJvbC5mb3IoXCJyZWFjdC5jb250ZXh0XCIpOjYwMTEwLHRjPXo/U3ltYm9sLmZvcihcInJlYWN0LmNvbmN1cnJlbnRfbW9kZVwiKTo2MDExMSx1Yz16P1N5bWJvbC5mb3IoXCJyZWFjdC5mb3J3YXJkX3JlZlwiKTo2MDExMix2Yz16P1N5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZVwiKTpcbjYwMTEzLHdjPXo/U3ltYm9sLmZvcihcInJlYWN0Lm1lbW9cIik6NjAxMTUseGM9ej9TeW1ib2wuZm9yKFwicmVhY3QubGF6eVwiKTo2MDExNix5Yz1cImZ1bmN0aW9uXCI9PT10eXBlb2YgU3ltYm9sJiZTeW1ib2wuaXRlcmF0b3I7ZnVuY3Rpb24gemMoYSl7aWYobnVsbD09PWF8fFwib2JqZWN0XCIhPT10eXBlb2YgYSlyZXR1cm4gbnVsbDthPXljJiZhW3ljXXx8YVtcIkBAaXRlcmF0b3JcIl07cmV0dXJuXCJmdW5jdGlvblwiPT09dHlwZW9mIGE/YTpudWxsfVxuZnVuY3Rpb24gQWMoYSl7aWYobnVsbD09YSlyZXR1cm4gbnVsbDtpZihcImZ1bmN0aW9uXCI9PT10eXBlb2YgYSlyZXR1cm4gYS5kaXNwbGF5TmFtZXx8YS5uYW1lfHxudWxsO2lmKFwic3RyaW5nXCI9PT10eXBlb2YgYSlyZXR1cm4gYTtzd2l0Y2goYSl7Y2FzZSB0YzpyZXR1cm5cIkNvbmN1cnJlbnRNb2RlXCI7Y2FzZSBvYzpyZXR1cm5cIkZyYWdtZW50XCI7Y2FzZSBuYzpyZXR1cm5cIlBvcnRhbFwiO2Nhc2UgcWM6cmV0dXJuXCJQcm9maWxlclwiO2Nhc2UgcGM6cmV0dXJuXCJTdHJpY3RNb2RlXCI7Y2FzZSB2YzpyZXR1cm5cIlN1c3BlbnNlXCJ9aWYoXCJvYmplY3RcIj09PXR5cGVvZiBhKXN3aXRjaChhLiQkdHlwZW9mKXtjYXNlIHNjOnJldHVyblwiQ29udGV4dC5Db25zdW1lclwiO2Nhc2UgcmM6cmV0dXJuXCJDb250ZXh0LlByb3ZpZGVyXCI7Y2FzZSB1Yzp2YXIgYj1hLnJlbmRlcjtiPWIuZGlzcGxheU5hbWV8fGIubmFtZXx8XCJcIjtyZXR1cm4gYS5kaXNwbGF5TmFtZXx8KFwiXCIhPT1iP1wiRm9yd2FyZFJlZihcIitiK1xuXCIpXCI6XCJGb3J3YXJkUmVmXCIpO2Nhc2Ugd2M6cmV0dXJuIEFjKGEudHlwZSk7Y2FzZSB4YzppZihhPTE9PT1hLl9zdGF0dXM/YS5fcmVzdWx0Om51bGwpcmV0dXJuIEFjKGEpfXJldHVybiBudWxsfWZ1bmN0aW9uIEJjKGEpe3ZhciBiPVwiXCI7ZG97YTpzd2l0Y2goYS50YWcpe2Nhc2UgMjpjYXNlIDE2OmNhc2UgMDpjYXNlIDE6Y2FzZSA1OmNhc2UgODp2YXIgYz1hLl9kZWJ1Z093bmVyLGQ9YS5fZGVidWdTb3VyY2UsZT1BYyhhLnR5cGUpO3ZhciBmPW51bGw7YyYmKGY9QWMoYy50eXBlKSk7Yz1lO2U9XCJcIjtkP2U9XCIgKGF0IFwiK2QuZmlsZU5hbWUucmVwbGFjZShsYyxcIlwiKStcIjpcIitkLmxpbmVOdW1iZXIrXCIpXCI6ZiYmKGU9XCIgKGNyZWF0ZWQgYnkgXCIrZitcIilcIik7Zj1cIlxcbiAgICBpbiBcIisoY3x8XCJVbmtub3duXCIpK2U7YnJlYWsgYTtkZWZhdWx0OmY9XCJcIn1iKz1mO2E9YS5yZXR1cm59d2hpbGUoYSk7cmV0dXJuIGJ9XG52YXIgQ2M9L15bOkEtWl9hLXpcXHUwMEMwLVxcdTAwRDZcXHUwMEQ4LVxcdTAwRjZcXHUwMEY4LVxcdTAyRkZcXHUwMzcwLVxcdTAzN0RcXHUwMzdGLVxcdTFGRkZcXHUyMDBDLVxcdTIwMERcXHUyMDcwLVxcdTIxOEZcXHUyQzAwLVxcdTJGRUZcXHUzMDAxLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRkRdWzpBLVpfYS16XFx1MDBDMC1cXHUwMEQ2XFx1MDBEOC1cXHUwMEY2XFx1MDBGOC1cXHUwMkZGXFx1MDM3MC1cXHUwMzdEXFx1MDM3Ri1cXHUxRkZGXFx1MjAwQy1cXHUyMDBEXFx1MjA3MC1cXHUyMThGXFx1MkMwMC1cXHUyRkVGXFx1MzAwMS1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkZEXFwtLjAtOVxcdTAwQjdcXHUwMzAwLVxcdTAzNkZcXHUyMDNGLVxcdTIwNDBdKiQvLERjPU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksRWM9e30sRmM9e307XG5mdW5jdGlvbiBHYyhhKXtpZihEYy5jYWxsKEZjLGEpKXJldHVybiEwO2lmKERjLmNhbGwoRWMsYSkpcmV0dXJuITE7aWYoQ2MudGVzdChhKSlyZXR1cm4gRmNbYV09ITA7RWNbYV09ITA7cmV0dXJuITF9ZnVuY3Rpb24gSGMoYSxiLGMsZCl7aWYobnVsbCE9PWMmJjA9PT1jLnR5cGUpcmV0dXJuITE7c3dpdGNoKHR5cGVvZiBiKXtjYXNlIFwiZnVuY3Rpb25cIjpjYXNlIFwic3ltYm9sXCI6cmV0dXJuITA7Y2FzZSBcImJvb2xlYW5cIjppZihkKXJldHVybiExO2lmKG51bGwhPT1jKXJldHVybiFjLmFjY2VwdHNCb29sZWFuczthPWEudG9Mb3dlckNhc2UoKS5zbGljZSgwLDUpO3JldHVyblwiZGF0YS1cIiE9PWEmJlwiYXJpYS1cIiE9PWE7ZGVmYXVsdDpyZXR1cm4hMX19XG5mdW5jdGlvbiBJYyhhLGIsYyxkKXtpZihudWxsPT09Ynx8XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBifHxIYyhhLGIsYyxkKSlyZXR1cm4hMDtpZihkKXJldHVybiExO2lmKG51bGwhPT1jKXN3aXRjaChjLnR5cGUpe2Nhc2UgMzpyZXR1cm4hYjtjYXNlIDQ6cmV0dXJuITE9PT1iO2Nhc2UgNTpyZXR1cm4gaXNOYU4oYik7Y2FzZSA2OnJldHVybiBpc05hTihiKXx8MT5ifXJldHVybiExfWZ1bmN0aW9uIEMoYSxiLGMsZCxlKXt0aGlzLmFjY2VwdHNCb29sZWFucz0yPT09Ynx8Mz09PWJ8fDQ9PT1iO3RoaXMuYXR0cmlidXRlTmFtZT1kO3RoaXMuYXR0cmlidXRlTmFtZXNwYWNlPWU7dGhpcy5tdXN0VXNlUHJvcGVydHk9Yzt0aGlzLnByb3BlcnR5TmFtZT1hO3RoaXMudHlwZT1ifXZhciBEPXt9O1xuXCJjaGlsZHJlbiBkYW5nZXJvdXNseVNldElubmVySFRNTCBkZWZhdWx0VmFsdWUgZGVmYXVsdENoZWNrZWQgaW5uZXJIVE1MIHN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZyBzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcgc3R5bGVcIi5zcGxpdChcIiBcIikuZm9yRWFjaChmdW5jdGlvbihhKXtEW2FdPW5ldyBDKGEsMCwhMSxhLG51bGwpfSk7W1tcImFjY2VwdENoYXJzZXRcIixcImFjY2VwdC1jaGFyc2V0XCJdLFtcImNsYXNzTmFtZVwiLFwiY2xhc3NcIl0sW1wiaHRtbEZvclwiLFwiZm9yXCJdLFtcImh0dHBFcXVpdlwiLFwiaHR0cC1lcXVpdlwiXV0uZm9yRWFjaChmdW5jdGlvbihhKXt2YXIgYj1hWzBdO0RbYl09bmV3IEMoYiwxLCExLGFbMV0sbnVsbCl9KTtbXCJjb250ZW50RWRpdGFibGVcIixcImRyYWdnYWJsZVwiLFwic3BlbGxDaGVja1wiLFwidmFsdWVcIl0uZm9yRWFjaChmdW5jdGlvbihhKXtEW2FdPW5ldyBDKGEsMiwhMSxhLnRvTG93ZXJDYXNlKCksbnVsbCl9KTtcbltcImF1dG9SZXZlcnNlXCIsXCJleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkXCIsXCJmb2N1c2FibGVcIixcInByZXNlcnZlQWxwaGFcIl0uZm9yRWFjaChmdW5jdGlvbihhKXtEW2FdPW5ldyBDKGEsMiwhMSxhLG51bGwpfSk7XCJhbGxvd0Z1bGxTY3JlZW4gYXN5bmMgYXV0b0ZvY3VzIGF1dG9QbGF5IGNvbnRyb2xzIGRlZmF1bHQgZGVmZXIgZGlzYWJsZWQgZm9ybU5vVmFsaWRhdGUgaGlkZGVuIGxvb3Agbm9Nb2R1bGUgbm9WYWxpZGF0ZSBvcGVuIHBsYXlzSW5saW5lIHJlYWRPbmx5IHJlcXVpcmVkIHJldmVyc2VkIHNjb3BlZCBzZWFtbGVzcyBpdGVtU2NvcGVcIi5zcGxpdChcIiBcIikuZm9yRWFjaChmdW5jdGlvbihhKXtEW2FdPW5ldyBDKGEsMywhMSxhLnRvTG93ZXJDYXNlKCksbnVsbCl9KTtbXCJjaGVja2VkXCIsXCJtdWx0aXBsZVwiLFwibXV0ZWRcIixcInNlbGVjdGVkXCJdLmZvckVhY2goZnVuY3Rpb24oYSl7RFthXT1uZXcgQyhhLDMsITAsYSxudWxsKX0pO1xuW1wiY2FwdHVyZVwiLFwiZG93bmxvYWRcIl0uZm9yRWFjaChmdW5jdGlvbihhKXtEW2FdPW5ldyBDKGEsNCwhMSxhLG51bGwpfSk7W1wiY29sc1wiLFwicm93c1wiLFwic2l6ZVwiLFwic3BhblwiXS5mb3JFYWNoKGZ1bmN0aW9uKGEpe0RbYV09bmV3IEMoYSw2LCExLGEsbnVsbCl9KTtbXCJyb3dTcGFuXCIsXCJzdGFydFwiXS5mb3JFYWNoKGZ1bmN0aW9uKGEpe0RbYV09bmV3IEMoYSw1LCExLGEudG9Mb3dlckNhc2UoKSxudWxsKX0pO3ZhciBKYz0vW1xcLTpdKFthLXpdKS9nO2Z1bmN0aW9uIEtjKGEpe3JldHVybiBhWzFdLnRvVXBwZXJDYXNlKCl9XG5cImFjY2VudC1oZWlnaHQgYWxpZ25tZW50LWJhc2VsaW5lIGFyYWJpYy1mb3JtIGJhc2VsaW5lLXNoaWZ0IGNhcC1oZWlnaHQgY2xpcC1wYXRoIGNsaXAtcnVsZSBjb2xvci1pbnRlcnBvbGF0aW9uIGNvbG9yLWludGVycG9sYXRpb24tZmlsdGVycyBjb2xvci1wcm9maWxlIGNvbG9yLXJlbmRlcmluZyBkb21pbmFudC1iYXNlbGluZSBlbmFibGUtYmFja2dyb3VuZCBmaWxsLW9wYWNpdHkgZmlsbC1ydWxlIGZsb29kLWNvbG9yIGZsb29kLW9wYWNpdHkgZm9udC1mYW1pbHkgZm9udC1zaXplIGZvbnQtc2l6ZS1hZGp1c3QgZm9udC1zdHJldGNoIGZvbnQtc3R5bGUgZm9udC12YXJpYW50IGZvbnQtd2VpZ2h0IGdseXBoLW5hbWUgZ2x5cGgtb3JpZW50YXRpb24taG9yaXpvbnRhbCBnbHlwaC1vcmllbnRhdGlvbi12ZXJ0aWNhbCBob3Jpei1hZHYteCBob3Jpei1vcmlnaW4teCBpbWFnZS1yZW5kZXJpbmcgbGV0dGVyLXNwYWNpbmcgbGlnaHRpbmctY29sb3IgbWFya2VyLWVuZCBtYXJrZXItbWlkIG1hcmtlci1zdGFydCBvdmVybGluZS1wb3NpdGlvbiBvdmVybGluZS10aGlja25lc3MgcGFpbnQtb3JkZXIgcGFub3NlLTEgcG9pbnRlci1ldmVudHMgcmVuZGVyaW5nLWludGVudCBzaGFwZS1yZW5kZXJpbmcgc3RvcC1jb2xvciBzdG9wLW9wYWNpdHkgc3RyaWtldGhyb3VnaC1wb3NpdGlvbiBzdHJpa2V0aHJvdWdoLXRoaWNrbmVzcyBzdHJva2UtZGFzaGFycmF5IHN0cm9rZS1kYXNob2Zmc2V0IHN0cm9rZS1saW5lY2FwIHN0cm9rZS1saW5lam9pbiBzdHJva2UtbWl0ZXJsaW1pdCBzdHJva2Utb3BhY2l0eSBzdHJva2Utd2lkdGggdGV4dC1hbmNob3IgdGV4dC1kZWNvcmF0aW9uIHRleHQtcmVuZGVyaW5nIHVuZGVybGluZS1wb3NpdGlvbiB1bmRlcmxpbmUtdGhpY2tuZXNzIHVuaWNvZGUtYmlkaSB1bmljb2RlLXJhbmdlIHVuaXRzLXBlci1lbSB2LWFscGhhYmV0aWMgdi1oYW5naW5nIHYtaWRlb2dyYXBoaWMgdi1tYXRoZW1hdGljYWwgdmVjdG9yLWVmZmVjdCB2ZXJ0LWFkdi15IHZlcnQtb3JpZ2luLXggdmVydC1vcmlnaW4teSB3b3JkLXNwYWNpbmcgd3JpdGluZy1tb2RlIHhtbG5zOnhsaW5rIHgtaGVpZ2h0XCIuc3BsaXQoXCIgXCIpLmZvckVhY2goZnVuY3Rpb24oYSl7dmFyIGI9YS5yZXBsYWNlKEpjLFxuS2MpO0RbYl09bmV3IEMoYiwxLCExLGEsbnVsbCl9KTtcInhsaW5rOmFjdHVhdGUgeGxpbms6YXJjcm9sZSB4bGluazpocmVmIHhsaW5rOnJvbGUgeGxpbms6c2hvdyB4bGluazp0aXRsZSB4bGluazp0eXBlXCIuc3BsaXQoXCIgXCIpLmZvckVhY2goZnVuY3Rpb24oYSl7dmFyIGI9YS5yZXBsYWNlKEpjLEtjKTtEW2JdPW5ldyBDKGIsMSwhMSxhLFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiKX0pO1tcInhtbDpiYXNlXCIsXCJ4bWw6bGFuZ1wiLFwieG1sOnNwYWNlXCJdLmZvckVhY2goZnVuY3Rpb24oYSl7dmFyIGI9YS5yZXBsYWNlKEpjLEtjKTtEW2JdPW5ldyBDKGIsMSwhMSxhLFwiaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlXCIpfSk7RC50YWJJbmRleD1uZXcgQyhcInRhYkluZGV4XCIsMSwhMSxcInRhYmluZGV4XCIsbnVsbCk7XG5mdW5jdGlvbiBMYyhhLGIsYyxkKXt2YXIgZT1ELmhhc093blByb3BlcnR5KGIpP0RbYl06bnVsbDt2YXIgZj1udWxsIT09ZT8wPT09ZS50eXBlOmQ/ITE6ISgyPGIubGVuZ3RoKXx8XCJvXCIhPT1iWzBdJiZcIk9cIiE9PWJbMF18fFwiblwiIT09YlsxXSYmXCJOXCIhPT1iWzFdPyExOiEwO2Z8fChJYyhiLGMsZSxkKSYmKGM9bnVsbCksZHx8bnVsbD09PWU/R2MoYikmJihudWxsPT09Yz9hLnJlbW92ZUF0dHJpYnV0ZShiKTphLnNldEF0dHJpYnV0ZShiLFwiXCIrYykpOmUubXVzdFVzZVByb3BlcnR5P2FbZS5wcm9wZXJ0eU5hbWVdPW51bGw9PT1jPzM9PT1lLnR5cGU/ITE6XCJcIjpjOihiPWUuYXR0cmlidXRlTmFtZSxkPWUuYXR0cmlidXRlTmFtZXNwYWNlLG51bGw9PT1jP2EucmVtb3ZlQXR0cmlidXRlKGIpOihlPWUudHlwZSxjPTM9PT1lfHw0PT09ZSYmITA9PT1jP1wiXCI6XCJcIitjLGQ/YS5zZXRBdHRyaWJ1dGVOUyhkLGIsYyk6YS5zZXRBdHRyaWJ1dGUoYixjKSkpKX1cbmZ1bmN0aW9uIE1jKGEpe3N3aXRjaCh0eXBlb2YgYSl7Y2FzZSBcImJvb2xlYW5cIjpjYXNlIFwibnVtYmVyXCI6Y2FzZSBcIm9iamVjdFwiOmNhc2UgXCJzdHJpbmdcIjpjYXNlIFwidW5kZWZpbmVkXCI6cmV0dXJuIGE7ZGVmYXVsdDpyZXR1cm5cIlwifX1mdW5jdGlvbiBOYyhhLGIpe3ZhciBjPWIuY2hlY2tlZDtyZXR1cm4gbih7fSxiLHtkZWZhdWx0Q2hlY2tlZDp2b2lkIDAsZGVmYXVsdFZhbHVlOnZvaWQgMCx2YWx1ZTp2b2lkIDAsY2hlY2tlZDpudWxsIT1jP2M6YS5fd3JhcHBlclN0YXRlLmluaXRpYWxDaGVja2VkfSl9XG5mdW5jdGlvbiBPYyhhLGIpe3ZhciBjPW51bGw9PWIuZGVmYXVsdFZhbHVlP1wiXCI6Yi5kZWZhdWx0VmFsdWUsZD1udWxsIT1iLmNoZWNrZWQ/Yi5jaGVja2VkOmIuZGVmYXVsdENoZWNrZWQ7Yz1NYyhudWxsIT1iLnZhbHVlP2IudmFsdWU6Yyk7YS5fd3JhcHBlclN0YXRlPXtpbml0aWFsQ2hlY2tlZDpkLGluaXRpYWxWYWx1ZTpjLGNvbnRyb2xsZWQ6XCJjaGVja2JveFwiPT09Yi50eXBlfHxcInJhZGlvXCI9PT1iLnR5cGU/bnVsbCE9Yi5jaGVja2VkOm51bGwhPWIudmFsdWV9fWZ1bmN0aW9uIFBjKGEsYil7Yj1iLmNoZWNrZWQ7bnVsbCE9YiYmTGMoYSxcImNoZWNrZWRcIixiLCExKX1cbmZ1bmN0aW9uIFFjKGEsYil7UGMoYSxiKTt2YXIgYz1NYyhiLnZhbHVlKSxkPWIudHlwZTtpZihudWxsIT1jKWlmKFwibnVtYmVyXCI9PT1kKXtpZigwPT09YyYmXCJcIj09PWEudmFsdWV8fGEudmFsdWUhPWMpYS52YWx1ZT1cIlwiK2N9ZWxzZSBhLnZhbHVlIT09XCJcIitjJiYoYS52YWx1ZT1cIlwiK2MpO2Vsc2UgaWYoXCJzdWJtaXRcIj09PWR8fFwicmVzZXRcIj09PWQpe2EucmVtb3ZlQXR0cmlidXRlKFwidmFsdWVcIik7cmV0dXJufWIuaGFzT3duUHJvcGVydHkoXCJ2YWx1ZVwiKT9SYyhhLGIudHlwZSxjKTpiLmhhc093blByb3BlcnR5KFwiZGVmYXVsdFZhbHVlXCIpJiZSYyhhLGIudHlwZSxNYyhiLmRlZmF1bHRWYWx1ZSkpO251bGw9PWIuY2hlY2tlZCYmbnVsbCE9Yi5kZWZhdWx0Q2hlY2tlZCYmKGEuZGVmYXVsdENoZWNrZWQ9ISFiLmRlZmF1bHRDaGVja2VkKX1cbmZ1bmN0aW9uIFNjKGEsYixjKXtpZihiLmhhc093blByb3BlcnR5KFwidmFsdWVcIil8fGIuaGFzT3duUHJvcGVydHkoXCJkZWZhdWx0VmFsdWVcIikpe3ZhciBkPWIudHlwZTtpZighKFwic3VibWl0XCIhPT1kJiZcInJlc2V0XCIhPT1kfHx2b2lkIDAhPT1iLnZhbHVlJiZudWxsIT09Yi52YWx1ZSkpcmV0dXJuO2I9XCJcIithLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlO2N8fGI9PT1hLnZhbHVlfHwoYS52YWx1ZT1iKTthLmRlZmF1bHRWYWx1ZT1ifWM9YS5uYW1lO1wiXCIhPT1jJiYoYS5uYW1lPVwiXCIpO2EuZGVmYXVsdENoZWNrZWQ9IWEuZGVmYXVsdENoZWNrZWQ7YS5kZWZhdWx0Q2hlY2tlZD0hIWEuX3dyYXBwZXJTdGF0ZS5pbml0aWFsQ2hlY2tlZDtcIlwiIT09YyYmKGEubmFtZT1jKX1cbmZ1bmN0aW9uIFJjKGEsYixjKXtpZihcIm51bWJlclwiIT09Ynx8YS5vd25lckRvY3VtZW50LmFjdGl2ZUVsZW1lbnQhPT1hKW51bGw9PWM/YS5kZWZhdWx0VmFsdWU9XCJcIithLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlOmEuZGVmYXVsdFZhbHVlIT09XCJcIitjJiYoYS5kZWZhdWx0VmFsdWU9XCJcIitjKX12YXIgVGM9e2NoYW5nZTp7cGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6e2J1YmJsZWQ6XCJvbkNoYW5nZVwiLGNhcHR1cmVkOlwib25DaGFuZ2VDYXB0dXJlXCJ9LGRlcGVuZGVuY2llczpcImJsdXIgY2hhbmdlIGNsaWNrIGZvY3VzIGlucHV0IGtleWRvd24ga2V5dXAgc2VsZWN0aW9uY2hhbmdlXCIuc3BsaXQoXCIgXCIpfX07ZnVuY3Rpb24gVWMoYSxiLGMpe2E9dS5nZXRQb29sZWQoVGMuY2hhbmdlLGEsYixjKTthLnR5cGU9XCJjaGFuZ2VcIjtRYihjKTtXYShhKTtyZXR1cm4gYX12YXIgVmM9bnVsbCxXYz1udWxsO2Z1bmN0aW9uIFhjKGEpe0lhKGEsITEpfVxuZnVuY3Rpb24gWWMoYSl7dmFyIGI9T2EoYSk7aWYoamMoYikpcmV0dXJuIGF9ZnVuY3Rpb24gYmQoYSxiKXtpZihcImNoYW5nZVwiPT09YSlyZXR1cm4gYn12YXIgY2Q9ITE7WGEmJihjZD1iYyhcImlucHV0XCIpJiYoIWRvY3VtZW50LmRvY3VtZW50TW9kZXx8OTxkb2N1bWVudC5kb2N1bWVudE1vZGUpKTtmdW5jdGlvbiBkZCgpe1ZjJiYoVmMuZGV0YWNoRXZlbnQoXCJvbnByb3BlcnR5Y2hhbmdlXCIsZWQpLFdjPVZjPW51bGwpfWZ1bmN0aW9uIGVkKGEpe1widmFsdWVcIj09PWEucHJvcGVydHlOYW1lJiZZYyhXYykmJihhPVVjKFdjLGEsYWMoYSkpLFdiKFhjLGEpKX1mdW5jdGlvbiBmZChhLGIsYyl7XCJmb2N1c1wiPT09YT8oZGQoKSxWYz1iLFdjPWMsVmMuYXR0YWNoRXZlbnQoXCJvbnByb3BlcnR5Y2hhbmdlXCIsZWQpKTpcImJsdXJcIj09PWEmJmRkKCl9ZnVuY3Rpb24gZ2QoYSl7aWYoXCJzZWxlY3Rpb25jaGFuZ2VcIj09PWF8fFwia2V5dXBcIj09PWF8fFwia2V5ZG93blwiPT09YSlyZXR1cm4gWWMoV2MpfVxuZnVuY3Rpb24gaGQoYSxiKXtpZihcImNsaWNrXCI9PT1hKXJldHVybiBZYyhiKX1mdW5jdGlvbiBpZChhLGIpe2lmKFwiaW5wdXRcIj09PWF8fFwiY2hhbmdlXCI9PT1hKXJldHVybiBZYyhiKX1cbnZhciBqZD17ZXZlbnRUeXBlczpUYyxfaXNJbnB1dEV2ZW50U3VwcG9ydGVkOmNkLGV4dHJhY3RFdmVudHM6ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9Yj9PYShiKTp3aW5kb3csZj12b2lkIDAsZz12b2lkIDAsaD1lLm5vZGVOYW1lJiZlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XCJzZWxlY3RcIj09PWh8fFwiaW5wdXRcIj09PWgmJlwiZmlsZVwiPT09ZS50eXBlP2Y9YmQ6WWIoZSk/Y2Q/Zj1pZDooZj1nZCxnPWZkKTooaD1lLm5vZGVOYW1lKSYmXCJpbnB1dFwiPT09aC50b0xvd2VyQ2FzZSgpJiYoXCJjaGVja2JveFwiPT09ZS50eXBlfHxcInJhZGlvXCI9PT1lLnR5cGUpJiYoZj1oZCk7aWYoZiYmKGY9ZihhLGIpKSlyZXR1cm4gVWMoZixjLGQpO2cmJmcoYSxlLGIpO1wiYmx1clwiPT09YSYmKGE9ZS5fd3JhcHBlclN0YXRlKSYmYS5jb250cm9sbGVkJiZcIm51bWJlclwiPT09ZS50eXBlJiZSYyhlLFwibnVtYmVyXCIsZS52YWx1ZSl9fSxrZD11LmV4dGVuZCh7dmlldzpudWxsLGRldGFpbDpudWxsfSksbGQ9e0FsdDpcImFsdEtleVwiLFxuQ29udHJvbDpcImN0cmxLZXlcIixNZXRhOlwibWV0YUtleVwiLFNoaWZ0Olwic2hpZnRLZXlcIn07ZnVuY3Rpb24gdGQoYSl7dmFyIGI9dGhpcy5uYXRpdmVFdmVudDtyZXR1cm4gYi5nZXRNb2RpZmllclN0YXRlP2IuZ2V0TW9kaWZpZXJTdGF0ZShhKTooYT1sZFthXSk/ISFiW2FdOiExfWZ1bmN0aW9uIHVkKCl7cmV0dXJuIHRkfVxudmFyIHZkPTAsd2Q9MCx4ZD0hMSx5ZD0hMSx6ZD1rZC5leHRlbmQoe3NjcmVlblg6bnVsbCxzY3JlZW5ZOm51bGwsY2xpZW50WDpudWxsLGNsaWVudFk6bnVsbCxwYWdlWDpudWxsLHBhZ2VZOm51bGwsY3RybEtleTpudWxsLHNoaWZ0S2V5Om51bGwsYWx0S2V5Om51bGwsbWV0YUtleTpudWxsLGdldE1vZGlmaWVyU3RhdGU6dWQsYnV0dG9uOm51bGwsYnV0dG9uczpudWxsLHJlbGF0ZWRUYXJnZXQ6ZnVuY3Rpb24oYSl7cmV0dXJuIGEucmVsYXRlZFRhcmdldHx8KGEuZnJvbUVsZW1lbnQ9PT1hLnNyY0VsZW1lbnQ/YS50b0VsZW1lbnQ6YS5mcm9tRWxlbWVudCl9LG1vdmVtZW50WDpmdW5jdGlvbihhKXtpZihcIm1vdmVtZW50WFwiaW4gYSlyZXR1cm4gYS5tb3ZlbWVudFg7dmFyIGI9dmQ7dmQ9YS5zY3JlZW5YO3JldHVybiB4ZD9cIm1vdXNlbW92ZVwiPT09YS50eXBlP2Euc2NyZWVuWC1iOjA6KHhkPSEwLDApfSxtb3ZlbWVudFk6ZnVuY3Rpb24oYSl7aWYoXCJtb3ZlbWVudFlcImluIGEpcmV0dXJuIGEubW92ZW1lbnRZO1xudmFyIGI9d2Q7d2Q9YS5zY3JlZW5ZO3JldHVybiB5ZD9cIm1vdXNlbW92ZVwiPT09YS50eXBlP2Euc2NyZWVuWS1iOjA6KHlkPSEwLDApfX0pLEFkPXpkLmV4dGVuZCh7cG9pbnRlcklkOm51bGwsd2lkdGg6bnVsbCxoZWlnaHQ6bnVsbCxwcmVzc3VyZTpudWxsLHRhbmdlbnRpYWxQcmVzc3VyZTpudWxsLHRpbHRYOm51bGwsdGlsdFk6bnVsbCx0d2lzdDpudWxsLHBvaW50ZXJUeXBlOm51bGwsaXNQcmltYXJ5Om51bGx9KSxCZD17bW91c2VFbnRlcjp7cmVnaXN0cmF0aW9uTmFtZTpcIm9uTW91c2VFbnRlclwiLGRlcGVuZGVuY2llczpbXCJtb3VzZW91dFwiLFwibW91c2VvdmVyXCJdfSxtb3VzZUxlYXZlOntyZWdpc3RyYXRpb25OYW1lOlwib25Nb3VzZUxlYXZlXCIsZGVwZW5kZW5jaWVzOltcIm1vdXNlb3V0XCIsXCJtb3VzZW92ZXJcIl19LHBvaW50ZXJFbnRlcjp7cmVnaXN0cmF0aW9uTmFtZTpcIm9uUG9pbnRlckVudGVyXCIsZGVwZW5kZW5jaWVzOltcInBvaW50ZXJvdXRcIixcInBvaW50ZXJvdmVyXCJdfSxwb2ludGVyTGVhdmU6e3JlZ2lzdHJhdGlvbk5hbWU6XCJvblBvaW50ZXJMZWF2ZVwiLFxuZGVwZW5kZW5jaWVzOltcInBvaW50ZXJvdXRcIixcInBvaW50ZXJvdmVyXCJdfX0sQ2Q9e2V2ZW50VHlwZXM6QmQsZXh0cmFjdEV2ZW50czpmdW5jdGlvbihhLGIsYyxkKXt2YXIgZT1cIm1vdXNlb3ZlclwiPT09YXx8XCJwb2ludGVyb3ZlclwiPT09YSxmPVwibW91c2VvdXRcIj09PWF8fFwicG9pbnRlcm91dFwiPT09YTtpZihlJiYoYy5yZWxhdGVkVGFyZ2V0fHxjLmZyb21FbGVtZW50KXx8IWYmJiFlKXJldHVybiBudWxsO2U9ZC53aW5kb3c9PT1kP2Q6KGU9ZC5vd25lckRvY3VtZW50KT9lLmRlZmF1bHRWaWV3fHxlLnBhcmVudFdpbmRvdzp3aW5kb3c7Zj8oZj1iLGI9KGI9Yy5yZWxhdGVkVGFyZ2V0fHxjLnRvRWxlbWVudCk/TWEoYik6bnVsbCk6Zj1udWxsO2lmKGY9PT1iKXJldHVybiBudWxsO3ZhciBnPXZvaWQgMCxoPXZvaWQgMCxrPXZvaWQgMCxsPXZvaWQgMDtpZihcIm1vdXNlb3V0XCI9PT1hfHxcIm1vdXNlb3ZlclwiPT09YSlnPXpkLGg9QmQubW91c2VMZWF2ZSxrPUJkLm1vdXNlRW50ZXIsbD1cIm1vdXNlXCI7XG5lbHNlIGlmKFwicG9pbnRlcm91dFwiPT09YXx8XCJwb2ludGVyb3ZlclwiPT09YSlnPUFkLGg9QmQucG9pbnRlckxlYXZlLGs9QmQucG9pbnRlckVudGVyLGw9XCJwb2ludGVyXCI7dmFyIG09bnVsbD09Zj9lOk9hKGYpO2U9bnVsbD09Yj9lOk9hKGIpO2E9Zy5nZXRQb29sZWQoaCxmLGMsZCk7YS50eXBlPWwrXCJsZWF2ZVwiO2EudGFyZ2V0PW07YS5yZWxhdGVkVGFyZ2V0PWU7Yz1nLmdldFBvb2xlZChrLGIsYyxkKTtjLnR5cGU9bCtcImVudGVyXCI7Yy50YXJnZXQ9ZTtjLnJlbGF0ZWRUYXJnZXQ9bTtkPWI7aWYoZiYmZClhOntiPWY7ZT1kO2w9MDtmb3IoZz1iO2c7Zz1RYShnKSlsKys7Zz0wO2ZvcihrPWU7aztrPVFhKGspKWcrKztmb3IoOzA8bC1nOyliPVFhKGIpLGwtLTtmb3IoOzA8Zy1sOyllPVFhKGUpLGctLTtmb3IoO2wtLTspe2lmKGI9PT1lfHxiPT09ZS5hbHRlcm5hdGUpYnJlYWsgYTtiPVFhKGIpO2U9UWEoZSl9Yj1udWxsfWVsc2UgYj1udWxsO2U9Yjtmb3IoYj1bXTtmJiZmIT09ZTspe2w9XG5mLmFsdGVybmF0ZTtpZihudWxsIT09bCYmbD09PWUpYnJlYWs7Yi5wdXNoKGYpO2Y9UWEoZil9Zm9yKGY9W107ZCYmZCE9PWU7KXtsPWQuYWx0ZXJuYXRlO2lmKG51bGwhPT1sJiZsPT09ZSlicmVhaztmLnB1c2goZCk7ZD1RYShkKX1mb3IoZD0wO2Q8Yi5sZW5ndGg7ZCsrKVRhKGJbZF0sXCJidWJibGVkXCIsYSk7Zm9yKGQ9Zi5sZW5ndGg7MDxkLS07KVRhKGZbZF0sXCJjYXB0dXJlZFwiLGMpO3JldHVyblthLGNdfX0sRGQ9T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtmdW5jdGlvbiBFZChhLGIpe3JldHVybiBhPT09Yj8wIT09YXx8MCE9PWJ8fDEvYT09PTEvYjphIT09YSYmYiE9PWJ9XG5mdW5jdGlvbiBGZChhLGIpe2lmKEVkKGEsYikpcmV0dXJuITA7aWYoXCJvYmplY3RcIiE9PXR5cGVvZiBhfHxudWxsPT09YXx8XCJvYmplY3RcIiE9PXR5cGVvZiBifHxudWxsPT09YilyZXR1cm4hMTt2YXIgYz1PYmplY3Qua2V5cyhhKSxkPU9iamVjdC5rZXlzKGIpO2lmKGMubGVuZ3RoIT09ZC5sZW5ndGgpcmV0dXJuITE7Zm9yKGQ9MDtkPGMubGVuZ3RoO2QrKylpZighRGQuY2FsbChiLGNbZF0pfHwhRWQoYVtjW2RdXSxiW2NbZF1dKSlyZXR1cm4hMTtyZXR1cm4hMH1mdW5jdGlvbiBHZChhKXt2YXIgYj1hO2lmKGEuYWx0ZXJuYXRlKWZvcig7Yi5yZXR1cm47KWI9Yi5yZXR1cm47ZWxzZXtpZigwIT09KGIuZWZmZWN0VGFnJjIpKXJldHVybiAxO2Zvcig7Yi5yZXR1cm47KWlmKGI9Yi5yZXR1cm4sMCE9PShiLmVmZmVjdFRhZyYyKSlyZXR1cm4gMX1yZXR1cm4gMz09PWIudGFnPzI6M31mdW5jdGlvbiBIZChhKXsyIT09R2QoYSk/cihcIjE4OFwiKTp2b2lkIDB9XG5mdW5jdGlvbiBJZChhKXt2YXIgYj1hLmFsdGVybmF0ZTtpZighYilyZXR1cm4gYj1HZChhKSwzPT09Yj9yKFwiMTg4XCIpOnZvaWQgMCwxPT09Yj9udWxsOmE7Zm9yKHZhciBjPWEsZD1iOzspe3ZhciBlPWMucmV0dXJuLGY9ZT9lLmFsdGVybmF0ZTpudWxsO2lmKCFlfHwhZilicmVhaztpZihlLmNoaWxkPT09Zi5jaGlsZCl7Zm9yKHZhciBnPWUuY2hpbGQ7Zzspe2lmKGc9PT1jKXJldHVybiBIZChlKSxhO2lmKGc9PT1kKXJldHVybiBIZChlKSxiO2c9Zy5zaWJsaW5nfXIoXCIxODhcIil9aWYoYy5yZXR1cm4hPT1kLnJldHVybiljPWUsZD1mO2Vsc2V7Zz0hMTtmb3IodmFyIGg9ZS5jaGlsZDtoOyl7aWYoaD09PWMpe2c9ITA7Yz1lO2Q9ZjticmVha31pZihoPT09ZCl7Zz0hMDtkPWU7Yz1mO2JyZWFrfWg9aC5zaWJsaW5nfWlmKCFnKXtmb3IoaD1mLmNoaWxkO2g7KXtpZihoPT09Yyl7Zz0hMDtjPWY7ZD1lO2JyZWFrfWlmKGg9PT1kKXtnPSEwO2Q9ZjtjPWU7YnJlYWt9aD1oLnNpYmxpbmd9Zz9cbnZvaWQgMDpyKFwiMTg5XCIpfX1jLmFsdGVybmF0ZSE9PWQ/cihcIjE5MFwiKTp2b2lkIDB9MyE9PWMudGFnP3IoXCIxODhcIik6dm9pZCAwO3JldHVybiBjLnN0YXRlTm9kZS5jdXJyZW50PT09Yz9hOmJ9ZnVuY3Rpb24gSmQoYSl7YT1JZChhKTtpZighYSlyZXR1cm4gbnVsbDtmb3IodmFyIGI9YTs7KXtpZig1PT09Yi50YWd8fDY9PT1iLnRhZylyZXR1cm4gYjtpZihiLmNoaWxkKWIuY2hpbGQucmV0dXJuPWIsYj1iLmNoaWxkO2Vsc2V7aWYoYj09PWEpYnJlYWs7Zm9yKDshYi5zaWJsaW5nOyl7aWYoIWIucmV0dXJufHxiLnJldHVybj09PWEpcmV0dXJuIG51bGw7Yj1iLnJldHVybn1iLnNpYmxpbmcucmV0dXJuPWIucmV0dXJuO2I9Yi5zaWJsaW5nfX1yZXR1cm4gbnVsbH1cbnZhciBLZD11LmV4dGVuZCh7YW5pbWF0aW9uTmFtZTpudWxsLGVsYXBzZWRUaW1lOm51bGwscHNldWRvRWxlbWVudDpudWxsfSksTGQ9dS5leHRlbmQoe2NsaXBib2FyZERhdGE6ZnVuY3Rpb24oYSl7cmV0dXJuXCJjbGlwYm9hcmREYXRhXCJpbiBhP2EuY2xpcGJvYXJkRGF0YTp3aW5kb3cuY2xpcGJvYXJkRGF0YX19KSxNZD1rZC5leHRlbmQoe3JlbGF0ZWRUYXJnZXQ6bnVsbH0pO2Z1bmN0aW9uIE5kKGEpe3ZhciBiPWEua2V5Q29kZTtcImNoYXJDb2RlXCJpbiBhPyhhPWEuY2hhckNvZGUsMD09PWEmJjEzPT09YiYmKGE9MTMpKTphPWI7MTA9PT1hJiYoYT0xMyk7cmV0dXJuIDMyPD1hfHwxMz09PWE/YTowfVxudmFyIE9kPXtFc2M6XCJFc2NhcGVcIixTcGFjZWJhcjpcIiBcIixMZWZ0OlwiQXJyb3dMZWZ0XCIsVXA6XCJBcnJvd1VwXCIsUmlnaHQ6XCJBcnJvd1JpZ2h0XCIsRG93bjpcIkFycm93RG93blwiLERlbDpcIkRlbGV0ZVwiLFdpbjpcIk9TXCIsTWVudTpcIkNvbnRleHRNZW51XCIsQXBwczpcIkNvbnRleHRNZW51XCIsU2Nyb2xsOlwiU2Nyb2xsTG9ja1wiLE1velByaW50YWJsZUtleTpcIlVuaWRlbnRpZmllZFwifSxQZD17ODpcIkJhY2tzcGFjZVwiLDk6XCJUYWJcIiwxMjpcIkNsZWFyXCIsMTM6XCJFbnRlclwiLDE2OlwiU2hpZnRcIiwxNzpcIkNvbnRyb2xcIiwxODpcIkFsdFwiLDE5OlwiUGF1c2VcIiwyMDpcIkNhcHNMb2NrXCIsMjc6XCJFc2NhcGVcIiwzMjpcIiBcIiwzMzpcIlBhZ2VVcFwiLDM0OlwiUGFnZURvd25cIiwzNTpcIkVuZFwiLDM2OlwiSG9tZVwiLDM3OlwiQXJyb3dMZWZ0XCIsMzg6XCJBcnJvd1VwXCIsMzk6XCJBcnJvd1JpZ2h0XCIsNDA6XCJBcnJvd0Rvd25cIiw0NTpcIkluc2VydFwiLDQ2OlwiRGVsZXRlXCIsMTEyOlwiRjFcIiwxMTM6XCJGMlwiLDExNDpcIkYzXCIsMTE1OlwiRjRcIixcbjExNjpcIkY1XCIsMTE3OlwiRjZcIiwxMTg6XCJGN1wiLDExOTpcIkY4XCIsMTIwOlwiRjlcIiwxMjE6XCJGMTBcIiwxMjI6XCJGMTFcIiwxMjM6XCJGMTJcIiwxNDQ6XCJOdW1Mb2NrXCIsMTQ1OlwiU2Nyb2xsTG9ja1wiLDIyNDpcIk1ldGFcIn0sUWQ9a2QuZXh0ZW5kKHtrZXk6ZnVuY3Rpb24oYSl7aWYoYS5rZXkpe3ZhciBiPU9kW2Eua2V5XXx8YS5rZXk7aWYoXCJVbmlkZW50aWZpZWRcIiE9PWIpcmV0dXJuIGJ9cmV0dXJuXCJrZXlwcmVzc1wiPT09YS50eXBlPyhhPU5kKGEpLDEzPT09YT9cIkVudGVyXCI6U3RyaW5nLmZyb21DaGFyQ29kZShhKSk6XCJrZXlkb3duXCI9PT1hLnR5cGV8fFwia2V5dXBcIj09PWEudHlwZT9QZFthLmtleUNvZGVdfHxcIlVuaWRlbnRpZmllZFwiOlwiXCJ9LGxvY2F0aW9uOm51bGwsY3RybEtleTpudWxsLHNoaWZ0S2V5Om51bGwsYWx0S2V5Om51bGwsbWV0YUtleTpudWxsLHJlcGVhdDpudWxsLGxvY2FsZTpudWxsLGdldE1vZGlmaWVyU3RhdGU6dWQsY2hhckNvZGU6ZnVuY3Rpb24oYSl7cmV0dXJuXCJrZXlwcmVzc1wiPT09XG5hLnR5cGU/TmQoYSk6MH0sa2V5Q29kZTpmdW5jdGlvbihhKXtyZXR1cm5cImtleWRvd25cIj09PWEudHlwZXx8XCJrZXl1cFwiPT09YS50eXBlP2Eua2V5Q29kZTowfSx3aGljaDpmdW5jdGlvbihhKXtyZXR1cm5cImtleXByZXNzXCI9PT1hLnR5cGU/TmQoYSk6XCJrZXlkb3duXCI9PT1hLnR5cGV8fFwia2V5dXBcIj09PWEudHlwZT9hLmtleUNvZGU6MH19KSxSZD16ZC5leHRlbmQoe2RhdGFUcmFuc2ZlcjpudWxsfSksU2Q9a2QuZXh0ZW5kKHt0b3VjaGVzOm51bGwsdGFyZ2V0VG91Y2hlczpudWxsLGNoYW5nZWRUb3VjaGVzOm51bGwsYWx0S2V5Om51bGwsbWV0YUtleTpudWxsLGN0cmxLZXk6bnVsbCxzaGlmdEtleTpudWxsLGdldE1vZGlmaWVyU3RhdGU6dWR9KSxUZD11LmV4dGVuZCh7cHJvcGVydHlOYW1lOm51bGwsZWxhcHNlZFRpbWU6bnVsbCxwc2V1ZG9FbGVtZW50Om51bGx9KSxVZD16ZC5leHRlbmQoe2RlbHRhWDpmdW5jdGlvbihhKXtyZXR1cm5cImRlbHRhWFwiaW4gYT9hLmRlbHRhWDpcIndoZWVsRGVsdGFYXCJpblxuYT8tYS53aGVlbERlbHRhWDowfSxkZWx0YVk6ZnVuY3Rpb24oYSl7cmV0dXJuXCJkZWx0YVlcImluIGE/YS5kZWx0YVk6XCJ3aGVlbERlbHRhWVwiaW4gYT8tYS53aGVlbERlbHRhWTpcIndoZWVsRGVsdGFcImluIGE/LWEud2hlZWxEZWx0YTowfSxkZWx0YVo6bnVsbCxkZWx0YU1vZGU6bnVsbH0pLFZkPVtbXCJhYm9ydFwiLFwiYWJvcnRcIl0sW2NiLFwiYW5pbWF0aW9uRW5kXCJdLFtkYixcImFuaW1hdGlvbkl0ZXJhdGlvblwiXSxbZWIsXCJhbmltYXRpb25TdGFydFwiXSxbXCJjYW5wbGF5XCIsXCJjYW5QbGF5XCJdLFtcImNhbnBsYXl0aHJvdWdoXCIsXCJjYW5QbGF5VGhyb3VnaFwiXSxbXCJkcmFnXCIsXCJkcmFnXCJdLFtcImRyYWdlbnRlclwiLFwiZHJhZ0VudGVyXCJdLFtcImRyYWdleGl0XCIsXCJkcmFnRXhpdFwiXSxbXCJkcmFnbGVhdmVcIixcImRyYWdMZWF2ZVwiXSxbXCJkcmFnb3ZlclwiLFwiZHJhZ092ZXJcIl0sW1wiZHVyYXRpb25jaGFuZ2VcIixcImR1cmF0aW9uQ2hhbmdlXCJdLFtcImVtcHRpZWRcIixcImVtcHRpZWRcIl0sW1wiZW5jcnlwdGVkXCIsXCJlbmNyeXB0ZWRcIl0sXG5bXCJlbmRlZFwiLFwiZW5kZWRcIl0sW1wiZXJyb3JcIixcImVycm9yXCJdLFtcImdvdHBvaW50ZXJjYXB0dXJlXCIsXCJnb3RQb2ludGVyQ2FwdHVyZVwiXSxbXCJsb2FkXCIsXCJsb2FkXCJdLFtcImxvYWRlZGRhdGFcIixcImxvYWRlZERhdGFcIl0sW1wibG9hZGVkbWV0YWRhdGFcIixcImxvYWRlZE1ldGFkYXRhXCJdLFtcImxvYWRzdGFydFwiLFwibG9hZFN0YXJ0XCJdLFtcImxvc3Rwb2ludGVyY2FwdHVyZVwiLFwibG9zdFBvaW50ZXJDYXB0dXJlXCJdLFtcIm1vdXNlbW92ZVwiLFwibW91c2VNb3ZlXCJdLFtcIm1vdXNlb3V0XCIsXCJtb3VzZU91dFwiXSxbXCJtb3VzZW92ZXJcIixcIm1vdXNlT3ZlclwiXSxbXCJwbGF5aW5nXCIsXCJwbGF5aW5nXCJdLFtcInBvaW50ZXJtb3ZlXCIsXCJwb2ludGVyTW92ZVwiXSxbXCJwb2ludGVyb3V0XCIsXCJwb2ludGVyT3V0XCJdLFtcInBvaW50ZXJvdmVyXCIsXCJwb2ludGVyT3ZlclwiXSxbXCJwcm9ncmVzc1wiLFwicHJvZ3Jlc3NcIl0sW1wic2Nyb2xsXCIsXCJzY3JvbGxcIl0sW1wic2Vla2luZ1wiLFwic2Vla2luZ1wiXSxbXCJzdGFsbGVkXCIsXCJzdGFsbGVkXCJdLFxuW1wic3VzcGVuZFwiLFwic3VzcGVuZFwiXSxbXCJ0aW1ldXBkYXRlXCIsXCJ0aW1lVXBkYXRlXCJdLFtcInRvZ2dsZVwiLFwidG9nZ2xlXCJdLFtcInRvdWNobW92ZVwiLFwidG91Y2hNb3ZlXCJdLFtmYixcInRyYW5zaXRpb25FbmRcIl0sW1wid2FpdGluZ1wiLFwid2FpdGluZ1wiXSxbXCJ3aGVlbFwiLFwid2hlZWxcIl1dLFdkPXt9LFhkPXt9O2Z1bmN0aW9uIFlkKGEsYil7dmFyIGM9YVswXTthPWFbMV07dmFyIGQ9XCJvblwiKyhhWzBdLnRvVXBwZXJDYXNlKCkrYS5zbGljZSgxKSk7Yj17cGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6e2J1YmJsZWQ6ZCxjYXB0dXJlZDpkK1wiQ2FwdHVyZVwifSxkZXBlbmRlbmNpZXM6W2NdLGlzSW50ZXJhY3RpdmU6Yn07V2RbYV09YjtYZFtjXT1ifVxuW1tcImJsdXJcIixcImJsdXJcIl0sW1wiY2FuY2VsXCIsXCJjYW5jZWxcIl0sW1wiY2xpY2tcIixcImNsaWNrXCJdLFtcImNsb3NlXCIsXCJjbG9zZVwiXSxbXCJjb250ZXh0bWVudVwiLFwiY29udGV4dE1lbnVcIl0sW1wiY29weVwiLFwiY29weVwiXSxbXCJjdXRcIixcImN1dFwiXSxbXCJhdXhjbGlja1wiLFwiYXV4Q2xpY2tcIl0sW1wiZGJsY2xpY2tcIixcImRvdWJsZUNsaWNrXCJdLFtcImRyYWdlbmRcIixcImRyYWdFbmRcIl0sW1wiZHJhZ3N0YXJ0XCIsXCJkcmFnU3RhcnRcIl0sW1wiZHJvcFwiLFwiZHJvcFwiXSxbXCJmb2N1c1wiLFwiZm9jdXNcIl0sW1wiaW5wdXRcIixcImlucHV0XCJdLFtcImludmFsaWRcIixcImludmFsaWRcIl0sW1wia2V5ZG93blwiLFwia2V5RG93blwiXSxbXCJrZXlwcmVzc1wiLFwia2V5UHJlc3NcIl0sW1wia2V5dXBcIixcImtleVVwXCJdLFtcIm1vdXNlZG93blwiLFwibW91c2VEb3duXCJdLFtcIm1vdXNldXBcIixcIm1vdXNlVXBcIl0sW1wicGFzdGVcIixcInBhc3RlXCJdLFtcInBhdXNlXCIsXCJwYXVzZVwiXSxbXCJwbGF5XCIsXCJwbGF5XCJdLFtcInBvaW50ZXJjYW5jZWxcIixcInBvaW50ZXJDYW5jZWxcIl0sXG5bXCJwb2ludGVyZG93blwiLFwicG9pbnRlckRvd25cIl0sW1wicG9pbnRlcnVwXCIsXCJwb2ludGVyVXBcIl0sW1wicmF0ZWNoYW5nZVwiLFwicmF0ZUNoYW5nZVwiXSxbXCJyZXNldFwiLFwicmVzZXRcIl0sW1wic2Vla2VkXCIsXCJzZWVrZWRcIl0sW1wic3VibWl0XCIsXCJzdWJtaXRcIl0sW1widG91Y2hjYW5jZWxcIixcInRvdWNoQ2FuY2VsXCJdLFtcInRvdWNoZW5kXCIsXCJ0b3VjaEVuZFwiXSxbXCJ0b3VjaHN0YXJ0XCIsXCJ0b3VjaFN0YXJ0XCJdLFtcInZvbHVtZWNoYW5nZVwiLFwidm9sdW1lQ2hhbmdlXCJdXS5mb3JFYWNoKGZ1bmN0aW9uKGEpe1lkKGEsITApfSk7VmQuZm9yRWFjaChmdW5jdGlvbihhKXtZZChhLCExKX0pO1xudmFyIFpkPXtldmVudFR5cGVzOldkLGlzSW50ZXJhY3RpdmVUb3BMZXZlbEV2ZW50VHlwZTpmdW5jdGlvbihhKXthPVhkW2FdO3JldHVybiB2b2lkIDAhPT1hJiYhMD09PWEuaXNJbnRlcmFjdGl2ZX0sZXh0cmFjdEV2ZW50czpmdW5jdGlvbihhLGIsYyxkKXt2YXIgZT1YZFthXTtpZighZSlyZXR1cm4gbnVsbDtzd2l0Y2goYSl7Y2FzZSBcImtleXByZXNzXCI6aWYoMD09PU5kKGMpKXJldHVybiBudWxsO2Nhc2UgXCJrZXlkb3duXCI6Y2FzZSBcImtleXVwXCI6YT1RZDticmVhaztjYXNlIFwiYmx1clwiOmNhc2UgXCJmb2N1c1wiOmE9TWQ7YnJlYWs7Y2FzZSBcImNsaWNrXCI6aWYoMj09PWMuYnV0dG9uKXJldHVybiBudWxsO2Nhc2UgXCJhdXhjbGlja1wiOmNhc2UgXCJkYmxjbGlja1wiOmNhc2UgXCJtb3VzZWRvd25cIjpjYXNlIFwibW91c2Vtb3ZlXCI6Y2FzZSBcIm1vdXNldXBcIjpjYXNlIFwibW91c2VvdXRcIjpjYXNlIFwibW91c2VvdmVyXCI6Y2FzZSBcImNvbnRleHRtZW51XCI6YT16ZDticmVhaztjYXNlIFwiZHJhZ1wiOmNhc2UgXCJkcmFnZW5kXCI6Y2FzZSBcImRyYWdlbnRlclwiOmNhc2UgXCJkcmFnZXhpdFwiOmNhc2UgXCJkcmFnbGVhdmVcIjpjYXNlIFwiZHJhZ292ZXJcIjpjYXNlIFwiZHJhZ3N0YXJ0XCI6Y2FzZSBcImRyb3BcIjphPVxuUmQ7YnJlYWs7Y2FzZSBcInRvdWNoY2FuY2VsXCI6Y2FzZSBcInRvdWNoZW5kXCI6Y2FzZSBcInRvdWNobW92ZVwiOmNhc2UgXCJ0b3VjaHN0YXJ0XCI6YT1TZDticmVhaztjYXNlIGNiOmNhc2UgZGI6Y2FzZSBlYjphPUtkO2JyZWFrO2Nhc2UgZmI6YT1UZDticmVhaztjYXNlIFwic2Nyb2xsXCI6YT1rZDticmVhaztjYXNlIFwid2hlZWxcIjphPVVkO2JyZWFrO2Nhc2UgXCJjb3B5XCI6Y2FzZSBcImN1dFwiOmNhc2UgXCJwYXN0ZVwiOmE9TGQ7YnJlYWs7Y2FzZSBcImdvdHBvaW50ZXJjYXB0dXJlXCI6Y2FzZSBcImxvc3Rwb2ludGVyY2FwdHVyZVwiOmNhc2UgXCJwb2ludGVyY2FuY2VsXCI6Y2FzZSBcInBvaW50ZXJkb3duXCI6Y2FzZSBcInBvaW50ZXJtb3ZlXCI6Y2FzZSBcInBvaW50ZXJvdXRcIjpjYXNlIFwicG9pbnRlcm92ZXJcIjpjYXNlIFwicG9pbnRlcnVwXCI6YT1BZDticmVhaztkZWZhdWx0OmE9dX1iPWEuZ2V0UG9vbGVkKGUsYixjLGQpO1dhKGIpO3JldHVybiBifX0sJGQ9WmQuaXNJbnRlcmFjdGl2ZVRvcExldmVsRXZlbnRUeXBlLFxuYWU9W107ZnVuY3Rpb24gYmUoYSl7dmFyIGI9YS50YXJnZXRJbnN0LGM9Yjtkb3tpZighYyl7YS5hbmNlc3RvcnMucHVzaChjKTticmVha312YXIgZDtmb3IoZD1jO2QucmV0dXJuOylkPWQucmV0dXJuO2Q9MyE9PWQudGFnP251bGw6ZC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztpZighZClicmVhazthLmFuY2VzdG9ycy5wdXNoKGMpO2M9TWEoZCl9d2hpbGUoYyk7Zm9yKGM9MDtjPGEuYW5jZXN0b3JzLmxlbmd0aDtjKyspe2I9YS5hbmNlc3RvcnNbY107dmFyIGU9YWMoYS5uYXRpdmVFdmVudCk7ZD1hLnRvcExldmVsVHlwZTtmb3IodmFyIGY9YS5uYXRpdmVFdmVudCxnPW51bGwsaD0wO2g8cmEubGVuZ3RoO2grKyl7dmFyIGs9cmFbaF07ayYmKGs9ay5leHRyYWN0RXZlbnRzKGQsYixmLGUpKSYmKGc9QWEoZyxrKSl9SWEoZywhMSl9fXZhciBjZT0hMDtcbmZ1bmN0aW9uIEcoYSxiKXtpZighYilyZXR1cm4gbnVsbDt2YXIgYz0oJGQoYSk/ZGU6ZWUpLmJpbmQobnVsbCxhKTtiLmFkZEV2ZW50TGlzdGVuZXIoYSxjLCExKX1mdW5jdGlvbiBmZShhLGIpe2lmKCFiKXJldHVybiBudWxsO3ZhciBjPSgkZChhKT9kZTplZSkuYmluZChudWxsLGEpO2IuYWRkRXZlbnRMaXN0ZW5lcihhLGMsITApfWZ1bmN0aW9uIGRlKGEsYil7VGIoZWUsYSxiKX1cbmZ1bmN0aW9uIGVlKGEsYil7aWYoY2Upe3ZhciBjPWFjKGIpO2M9TWEoYyk7bnVsbD09PWN8fFwibnVtYmVyXCIhPT10eXBlb2YgYy50YWd8fDI9PT1HZChjKXx8KGM9bnVsbCk7aWYoYWUubGVuZ3RoKXt2YXIgZD1hZS5wb3AoKTtkLnRvcExldmVsVHlwZT1hO2QubmF0aXZlRXZlbnQ9YjtkLnRhcmdldEluc3Q9YzthPWR9ZWxzZSBhPXt0b3BMZXZlbFR5cGU6YSxuYXRpdmVFdmVudDpiLHRhcmdldEluc3Q6YyxhbmNlc3RvcnM6W119O3RyeXtXYihiZSxhKX1maW5hbGx5e2EudG9wTGV2ZWxUeXBlPW51bGwsYS5uYXRpdmVFdmVudD1udWxsLGEudGFyZ2V0SW5zdD1udWxsLGEuYW5jZXN0b3JzLmxlbmd0aD0wLDEwPmFlLmxlbmd0aCYmYWUucHVzaChhKX19fXZhciBnZT17fSxoZT0wLGllPVwiX3JlYWN0TGlzdGVuZXJzSURcIisoXCJcIitNYXRoLnJhbmRvbSgpKS5zbGljZSgyKTtcbmZ1bmN0aW9uIGplKGEpe09iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhLGllKXx8KGFbaWVdPWhlKyssZ2VbYVtpZV1dPXt9KTtyZXR1cm4gZ2VbYVtpZV1dfWZ1bmN0aW9uIGtlKGEpe2E9YXx8KFwidW5kZWZpbmVkXCIhPT10eXBlb2YgZG9jdW1lbnQ/ZG9jdW1lbnQ6dm9pZCAwKTtpZihcInVuZGVmaW5lZFwiPT09dHlwZW9mIGEpcmV0dXJuIG51bGw7dHJ5e3JldHVybiBhLmFjdGl2ZUVsZW1lbnR8fGEuYm9keX1jYXRjaChiKXtyZXR1cm4gYS5ib2R5fX1mdW5jdGlvbiBsZShhKXtmb3IoO2EmJmEuZmlyc3RDaGlsZDspYT1hLmZpcnN0Q2hpbGQ7cmV0dXJuIGF9XG5mdW5jdGlvbiBtZShhLGIpe3ZhciBjPWxlKGEpO2E9MDtmb3IodmFyIGQ7Yzspe2lmKDM9PT1jLm5vZGVUeXBlKXtkPWErYy50ZXh0Q29udGVudC5sZW5ndGg7aWYoYTw9YiYmZD49YilyZXR1cm57bm9kZTpjLG9mZnNldDpiLWF9O2E9ZH1hOntmb3IoO2M7KXtpZihjLm5leHRTaWJsaW5nKXtjPWMubmV4dFNpYmxpbmc7YnJlYWsgYX1jPWMucGFyZW50Tm9kZX1jPXZvaWQgMH1jPWxlKGMpfX1mdW5jdGlvbiBuZShhLGIpe3JldHVybiBhJiZiP2E9PT1iPyEwOmEmJjM9PT1hLm5vZGVUeXBlPyExOmImJjM9PT1iLm5vZGVUeXBlP25lKGEsYi5wYXJlbnROb2RlKTpcImNvbnRhaW5zXCJpbiBhP2EuY29udGFpbnMoYik6YS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbj8hIShhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGIpJjE2KTohMTohMX1cbmZ1bmN0aW9uIG9lKCl7Zm9yKHZhciBhPXdpbmRvdyxiPWtlKCk7YiBpbnN0YW5jZW9mIGEuSFRNTElGcmFtZUVsZW1lbnQ7KXt0cnl7YT1iLmNvbnRlbnREb2N1bWVudC5kZWZhdWx0Vmlld31jYXRjaChjKXticmVha31iPWtlKGEuZG9jdW1lbnQpfXJldHVybiBifWZ1bmN0aW9uIHBlKGEpe3ZhciBiPWEmJmEubm9kZU5hbWUmJmEubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtyZXR1cm4gYiYmKFwiaW5wdXRcIj09PWImJihcInRleHRcIj09PWEudHlwZXx8XCJzZWFyY2hcIj09PWEudHlwZXx8XCJ0ZWxcIj09PWEudHlwZXx8XCJ1cmxcIj09PWEudHlwZXx8XCJwYXNzd29yZFwiPT09YS50eXBlKXx8XCJ0ZXh0YXJlYVwiPT09Ynx8XCJ0cnVlXCI9PT1hLmNvbnRlbnRFZGl0YWJsZSl9XG52YXIgcWU9WGEmJlwiZG9jdW1lbnRNb2RlXCJpbiBkb2N1bWVudCYmMTE+PWRvY3VtZW50LmRvY3VtZW50TW9kZSxyZT17c2VsZWN0OntwaGFzZWRSZWdpc3RyYXRpb25OYW1lczp7YnViYmxlZDpcIm9uU2VsZWN0XCIsY2FwdHVyZWQ6XCJvblNlbGVjdENhcHR1cmVcIn0sZGVwZW5kZW5jaWVzOlwiYmx1ciBjb250ZXh0bWVudSBkcmFnZW5kIGZvY3VzIGtleWRvd24ga2V5dXAgbW91c2Vkb3duIG1vdXNldXAgc2VsZWN0aW9uY2hhbmdlXCIuc3BsaXQoXCIgXCIpfX0sc2U9bnVsbCx0ZT1udWxsLHVlPW51bGwsdmU9ITE7XG5mdW5jdGlvbiB3ZShhLGIpe3ZhciBjPWIud2luZG93PT09Yj9iLmRvY3VtZW50Ojk9PT1iLm5vZGVUeXBlP2I6Yi5vd25lckRvY3VtZW50O2lmKHZlfHxudWxsPT1zZXx8c2UhPT1rZShjKSlyZXR1cm4gbnVsbDtjPXNlO1wic2VsZWN0aW9uU3RhcnRcImluIGMmJnBlKGMpP2M9e3N0YXJ0OmMuc2VsZWN0aW9uU3RhcnQsZW5kOmMuc2VsZWN0aW9uRW5kfTooYz0oYy5vd25lckRvY3VtZW50JiZjLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXd8fHdpbmRvdykuZ2V0U2VsZWN0aW9uKCksYz17YW5jaG9yTm9kZTpjLmFuY2hvck5vZGUsYW5jaG9yT2Zmc2V0OmMuYW5jaG9yT2Zmc2V0LGZvY3VzTm9kZTpjLmZvY3VzTm9kZSxmb2N1c09mZnNldDpjLmZvY3VzT2Zmc2V0fSk7cmV0dXJuIHVlJiZGZCh1ZSxjKT9udWxsOih1ZT1jLGE9dS5nZXRQb29sZWQocmUuc2VsZWN0LHRlLGEsYiksYS50eXBlPVwic2VsZWN0XCIsYS50YXJnZXQ9c2UsV2EoYSksYSl9XG52YXIgeGU9e2V2ZW50VHlwZXM6cmUsZXh0cmFjdEV2ZW50czpmdW5jdGlvbihhLGIsYyxkKXt2YXIgZT1kLndpbmRvdz09PWQ/ZC5kb2N1bWVudDo5PT09ZC5ub2RlVHlwZT9kOmQub3duZXJEb2N1bWVudCxmO2lmKCEoZj0hZSkpe2E6e2U9amUoZSk7Zj12YS5vblNlbGVjdDtmb3IodmFyIGc9MDtnPGYubGVuZ3RoO2crKyl7dmFyIGg9ZltnXTtpZighZS5oYXNPd25Qcm9wZXJ0eShoKXx8IWVbaF0pe2U9ITE7YnJlYWsgYX19ZT0hMH1mPSFlfWlmKGYpcmV0dXJuIG51bGw7ZT1iP09hKGIpOndpbmRvdztzd2l0Y2goYSl7Y2FzZSBcImZvY3VzXCI6aWYoWWIoZSl8fFwidHJ1ZVwiPT09ZS5jb250ZW50RWRpdGFibGUpc2U9ZSx0ZT1iLHVlPW51bGw7YnJlYWs7Y2FzZSBcImJsdXJcIjp1ZT10ZT1zZT1udWxsO2JyZWFrO2Nhc2UgXCJtb3VzZWRvd25cIjp2ZT0hMDticmVhaztjYXNlIFwiY29udGV4dG1lbnVcIjpjYXNlIFwibW91c2V1cFwiOmNhc2UgXCJkcmFnZW5kXCI6cmV0dXJuIHZlPSExLHdlKGMsZCk7Y2FzZSBcInNlbGVjdGlvbmNoYW5nZVwiOmlmKHFlKWJyZWFrO1xuY2FzZSBcImtleWRvd25cIjpjYXNlIFwia2V5dXBcIjpyZXR1cm4gd2UoYyxkKX1yZXR1cm4gbnVsbH19O0dhLmluamVjdEV2ZW50UGx1Z2luT3JkZXIoXCJSZXNwb25kZXJFdmVudFBsdWdpbiBTaW1wbGVFdmVudFBsdWdpbiBFbnRlckxlYXZlRXZlbnRQbHVnaW4gQ2hhbmdlRXZlbnRQbHVnaW4gU2VsZWN0RXZlbnRQbHVnaW4gQmVmb3JlSW5wdXRFdmVudFBsdWdpblwiLnNwbGl0KFwiIFwiKSk7d2E9UGE7eGE9TmE7eWE9T2E7R2EuaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lKHtTaW1wbGVFdmVudFBsdWdpbjpaZCxFbnRlckxlYXZlRXZlbnRQbHVnaW46Q2QsQ2hhbmdlRXZlbnRQbHVnaW46amQsU2VsZWN0RXZlbnRQbHVnaW46eGUsQmVmb3JlSW5wdXRFdmVudFBsdWdpbjpMYn0pO2Z1bmN0aW9uIHllKGEpe3ZhciBiPVwiXCI7YWEuQ2hpbGRyZW4uZm9yRWFjaChhLGZ1bmN0aW9uKGEpe251bGwhPWEmJihiKz1hKX0pO3JldHVybiBifVxuZnVuY3Rpb24gemUoYSxiKXthPW4oe2NoaWxkcmVuOnZvaWQgMH0sYik7aWYoYj15ZShiLmNoaWxkcmVuKSlhLmNoaWxkcmVuPWI7cmV0dXJuIGF9ZnVuY3Rpb24gQWUoYSxiLGMsZCl7YT1hLm9wdGlvbnM7aWYoYil7Yj17fTtmb3IodmFyIGU9MDtlPGMubGVuZ3RoO2UrKyliW1wiJFwiK2NbZV1dPSEwO2ZvcihjPTA7YzxhLmxlbmd0aDtjKyspZT1iLmhhc093blByb3BlcnR5KFwiJFwiK2FbY10udmFsdWUpLGFbY10uc2VsZWN0ZWQhPT1lJiYoYVtjXS5zZWxlY3RlZD1lKSxlJiZkJiYoYVtjXS5kZWZhdWx0U2VsZWN0ZWQ9ITApfWVsc2V7Yz1cIlwiK01jKGMpO2I9bnVsbDtmb3IoZT0wO2U8YS5sZW5ndGg7ZSsrKXtpZihhW2VdLnZhbHVlPT09Yyl7YVtlXS5zZWxlY3RlZD0hMDtkJiYoYVtlXS5kZWZhdWx0U2VsZWN0ZWQ9ITApO3JldHVybn1udWxsIT09Ynx8YVtlXS5kaXNhYmxlZHx8KGI9YVtlXSl9bnVsbCE9PWImJihiLnNlbGVjdGVkPSEwKX19XG5mdW5jdGlvbiBCZShhLGIpe251bGwhPWIuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw/cihcIjkxXCIpOnZvaWQgMDtyZXR1cm4gbih7fSxiLHt2YWx1ZTp2b2lkIDAsZGVmYXVsdFZhbHVlOnZvaWQgMCxjaGlsZHJlbjpcIlwiK2EuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWV9KX1mdW5jdGlvbiBEZShhLGIpe3ZhciBjPWIudmFsdWU7bnVsbD09YyYmKGM9Yi5kZWZhdWx0VmFsdWUsYj1iLmNoaWxkcmVuLG51bGwhPWImJihudWxsIT1jP3IoXCI5MlwiKTp2b2lkIDAsQXJyYXkuaXNBcnJheShiKSYmKDE+PWIubGVuZ3RoP3ZvaWQgMDpyKFwiOTNcIiksYj1iWzBdKSxjPWIpLG51bGw9PWMmJihjPVwiXCIpKTthLl93cmFwcGVyU3RhdGU9e2luaXRpYWxWYWx1ZTpNYyhjKX19XG5mdW5jdGlvbiBFZShhLGIpe3ZhciBjPU1jKGIudmFsdWUpLGQ9TWMoYi5kZWZhdWx0VmFsdWUpO251bGwhPWMmJihjPVwiXCIrYyxjIT09YS52YWx1ZSYmKGEudmFsdWU9YyksbnVsbD09Yi5kZWZhdWx0VmFsdWUmJmEuZGVmYXVsdFZhbHVlIT09YyYmKGEuZGVmYXVsdFZhbHVlPWMpKTtudWxsIT1kJiYoYS5kZWZhdWx0VmFsdWU9XCJcIitkKX1mdW5jdGlvbiBGZShhKXt2YXIgYj1hLnRleHRDb250ZW50O2I9PT1hLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlJiYoYS52YWx1ZT1iKX12YXIgR2U9e2h0bWw6XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCIsbWF0aG1sOlwiaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTFwiLHN2ZzpcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJ9O1xuZnVuY3Rpb24gSGUoYSl7c3dpdGNoKGEpe2Nhc2UgXCJzdmdcIjpyZXR1cm5cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI7Y2FzZSBcIm1hdGhcIjpyZXR1cm5cImh0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUxcIjtkZWZhdWx0OnJldHVyblwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwifX1mdW5jdGlvbiBJZShhLGIpe3JldHVybiBudWxsPT1hfHxcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIj09PWE/SGUoYik6XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPT09YSYmXCJmb3JlaWduT2JqZWN0XCI9PT1iP1wiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiOmF9XG52YXIgSmU9dm9pZCAwLEtlPWZ1bmN0aW9uKGEpe3JldHVyblwidW5kZWZpbmVkXCIhPT10eXBlb2YgTVNBcHAmJk1TQXBwLmV4ZWNVbnNhZmVMb2NhbEZ1bmN0aW9uP2Z1bmN0aW9uKGIsYyxkLGUpe01TQXBwLmV4ZWNVbnNhZmVMb2NhbEZ1bmN0aW9uKGZ1bmN0aW9uKCl7cmV0dXJuIGEoYixjLGQsZSl9KX06YX0oZnVuY3Rpb24oYSxiKXtpZihhLm5hbWVzcGFjZVVSSSE9PUdlLnN2Z3x8XCJpbm5lckhUTUxcImluIGEpYS5pbm5lckhUTUw9YjtlbHNle0plPUplfHxkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO0plLmlubmVySFRNTD1cIjxzdmc+XCIrYitcIjwvc3ZnPlwiO2ZvcihiPUplLmZpcnN0Q2hpbGQ7YS5maXJzdENoaWxkOylhLnJlbW92ZUNoaWxkKGEuZmlyc3RDaGlsZCk7Zm9yKDtiLmZpcnN0Q2hpbGQ7KWEuYXBwZW5kQ2hpbGQoYi5maXJzdENoaWxkKX19KTtcbmZ1bmN0aW9uIExlKGEsYil7aWYoYil7dmFyIGM9YS5maXJzdENoaWxkO2lmKGMmJmM9PT1hLmxhc3RDaGlsZCYmMz09PWMubm9kZVR5cGUpe2Mubm9kZVZhbHVlPWI7cmV0dXJufX1hLnRleHRDb250ZW50PWJ9XG52YXIgTWU9e2FuaW1hdGlvbkl0ZXJhdGlvbkNvdW50OiEwLGJvcmRlckltYWdlT3V0c2V0OiEwLGJvcmRlckltYWdlU2xpY2U6ITAsYm9yZGVySW1hZ2VXaWR0aDohMCxib3hGbGV4OiEwLGJveEZsZXhHcm91cDohMCxib3hPcmRpbmFsR3JvdXA6ITAsY29sdW1uQ291bnQ6ITAsY29sdW1uczohMCxmbGV4OiEwLGZsZXhHcm93OiEwLGZsZXhQb3NpdGl2ZTohMCxmbGV4U2hyaW5rOiEwLGZsZXhOZWdhdGl2ZTohMCxmbGV4T3JkZXI6ITAsZ3JpZEFyZWE6ITAsZ3JpZFJvdzohMCxncmlkUm93RW5kOiEwLGdyaWRSb3dTcGFuOiEwLGdyaWRSb3dTdGFydDohMCxncmlkQ29sdW1uOiEwLGdyaWRDb2x1bW5FbmQ6ITAsZ3JpZENvbHVtblNwYW46ITAsZ3JpZENvbHVtblN0YXJ0OiEwLGZvbnRXZWlnaHQ6ITAsbGluZUNsYW1wOiEwLGxpbmVIZWlnaHQ6ITAsb3BhY2l0eTohMCxvcmRlcjohMCxvcnBoYW5zOiEwLHRhYlNpemU6ITAsd2lkb3dzOiEwLHpJbmRleDohMCx6b29tOiEwLGZpbGxPcGFjaXR5OiEwLFxuZmxvb2RPcGFjaXR5OiEwLHN0b3BPcGFjaXR5OiEwLHN0cm9rZURhc2hhcnJheTohMCxzdHJva2VEYXNob2Zmc2V0OiEwLHN0cm9rZU1pdGVybGltaXQ6ITAsc3Ryb2tlT3BhY2l0eTohMCxzdHJva2VXaWR0aDohMH0sTmU9W1wiV2Via2l0XCIsXCJtc1wiLFwiTW96XCIsXCJPXCJdO09iamVjdC5rZXlzKE1lKS5mb3JFYWNoKGZ1bmN0aW9uKGEpe05lLmZvckVhY2goZnVuY3Rpb24oYil7Yj1iK2EuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrYS5zdWJzdHJpbmcoMSk7TWVbYl09TWVbYV19KX0pO1xuZnVuY3Rpb24gT2UoYSxiKXthPWEuc3R5bGU7Zm9yKHZhciBjIGluIGIpaWYoYi5oYXNPd25Qcm9wZXJ0eShjKSl7dmFyIGQ9MD09PWMuaW5kZXhPZihcIi0tXCIpO3ZhciBlPWM7dmFyIGY9YltjXTtlPW51bGw9PWZ8fFwiYm9vbGVhblwiPT09dHlwZW9mIGZ8fFwiXCI9PT1mP1wiXCI6ZHx8XCJudW1iZXJcIiE9PXR5cGVvZiBmfHwwPT09Znx8TWUuaGFzT3duUHJvcGVydHkoZSkmJk1lW2VdPyhcIlwiK2YpLnRyaW0oKTpmK1wicHhcIjtcImZsb2F0XCI9PT1jJiYoYz1cImNzc0Zsb2F0XCIpO2Q/YS5zZXRQcm9wZXJ0eShjLGUpOmFbY109ZX19dmFyIFBlPW4oe21lbnVpdGVtOiEwfSx7YXJlYTohMCxiYXNlOiEwLGJyOiEwLGNvbDohMCxlbWJlZDohMCxocjohMCxpbWc6ITAsaW5wdXQ6ITAsa2V5Z2VuOiEwLGxpbms6ITAsbWV0YTohMCxwYXJhbTohMCxzb3VyY2U6ITAsdHJhY2s6ITAsd2JyOiEwfSk7XG5mdW5jdGlvbiBRZShhLGIpe2ImJihQZVthXSYmKG51bGwhPWIuY2hpbGRyZW58fG51bGwhPWIuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw/cihcIjEzN1wiLGEsXCJcIik6dm9pZCAwKSxudWxsIT1iLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MJiYobnVsbCE9Yi5jaGlsZHJlbj9yKFwiNjBcIik6dm9pZCAwLFwib2JqZWN0XCI9PT10eXBlb2YgYi5kYW5nZXJvdXNseVNldElubmVySFRNTCYmXCJfX2h0bWxcImluIGIuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw/dm9pZCAwOnIoXCI2MVwiKSksbnVsbCE9Yi5zdHlsZSYmXCJvYmplY3RcIiE9PXR5cGVvZiBiLnN0eWxlP3IoXCI2MlwiLFwiXCIpOnZvaWQgMCl9XG5mdW5jdGlvbiBSZShhLGIpe2lmKC0xPT09YS5pbmRleE9mKFwiLVwiKSlyZXR1cm5cInN0cmluZ1wiPT09dHlwZW9mIGIuaXM7c3dpdGNoKGEpe2Nhc2UgXCJhbm5vdGF0aW9uLXhtbFwiOmNhc2UgXCJjb2xvci1wcm9maWxlXCI6Y2FzZSBcImZvbnQtZmFjZVwiOmNhc2UgXCJmb250LWZhY2Utc3JjXCI6Y2FzZSBcImZvbnQtZmFjZS11cmlcIjpjYXNlIFwiZm9udC1mYWNlLWZvcm1hdFwiOmNhc2UgXCJmb250LWZhY2UtbmFtZVwiOmNhc2UgXCJtaXNzaW5nLWdseXBoXCI6cmV0dXJuITE7ZGVmYXVsdDpyZXR1cm4hMH19XG5mdW5jdGlvbiBTZShhLGIpe2E9OT09PWEubm9kZVR5cGV8fDExPT09YS5ub2RlVHlwZT9hOmEub3duZXJEb2N1bWVudDt2YXIgYz1qZShhKTtiPXZhW2JdO2Zvcih2YXIgZD0wO2Q8Yi5sZW5ndGg7ZCsrKXt2YXIgZT1iW2RdO2lmKCFjLmhhc093blByb3BlcnR5KGUpfHwhY1tlXSl7c3dpdGNoKGUpe2Nhc2UgXCJzY3JvbGxcIjpmZShcInNjcm9sbFwiLGEpO2JyZWFrO2Nhc2UgXCJmb2N1c1wiOmNhc2UgXCJibHVyXCI6ZmUoXCJmb2N1c1wiLGEpO2ZlKFwiYmx1clwiLGEpO2MuYmx1cj0hMDtjLmZvY3VzPSEwO2JyZWFrO2Nhc2UgXCJjYW5jZWxcIjpjYXNlIFwiY2xvc2VcIjpiYyhlKSYmZmUoZSxhKTticmVhaztjYXNlIFwiaW52YWxpZFwiOmNhc2UgXCJzdWJtaXRcIjpjYXNlIFwicmVzZXRcIjpicmVhaztkZWZhdWx0Oi0xPT09Z2IuaW5kZXhPZihlKSYmRyhlLGEpfWNbZV09ITB9fX1mdW5jdGlvbiBUZSgpe312YXIgVWU9bnVsbCxsZj1udWxsO1xuZnVuY3Rpb24gbWYoYSxiKXtzd2l0Y2goYSl7Y2FzZSBcImJ1dHRvblwiOmNhc2UgXCJpbnB1dFwiOmNhc2UgXCJzZWxlY3RcIjpjYXNlIFwidGV4dGFyZWFcIjpyZXR1cm4hIWIuYXV0b0ZvY3VzfXJldHVybiExfWZ1bmN0aW9uIG5mKGEsYil7cmV0dXJuXCJ0ZXh0YXJlYVwiPT09YXx8XCJvcHRpb25cIj09PWF8fFwibm9zY3JpcHRcIj09PWF8fFwic3RyaW5nXCI9PT10eXBlb2YgYi5jaGlsZHJlbnx8XCJudW1iZXJcIj09PXR5cGVvZiBiLmNoaWxkcmVufHxcIm9iamVjdFwiPT09dHlwZW9mIGIuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwmJm51bGwhPT1iLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MJiZudWxsIT1iLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MLl9faHRtbH12YXIgb2Y9c2V0VGltZW91dCxwZj1jbGVhclRpbWVvdXQ7ZnVuY3Rpb24gcWYoYSl7Zm9yKGE9YS5uZXh0U2libGluZzthJiYxIT09YS5ub2RlVHlwZSYmMyE9PWEubm9kZVR5cGU7KWE9YS5uZXh0U2libGluZztyZXR1cm4gYX1cbmZ1bmN0aW9uIHJmKGEpe2ZvcihhPWEuZmlyc3RDaGlsZDthJiYxIT09YS5ub2RlVHlwZSYmMyE9PWEubm9kZVR5cGU7KWE9YS5uZXh0U2libGluZztyZXR1cm4gYX1uZXcgU2V0O3ZhciBzZj1bXSx0Zj0tMTtmdW5jdGlvbiBJKGEpezA+dGZ8fChhLmN1cnJlbnQ9c2ZbdGZdLHNmW3RmXT1udWxsLHRmLS0pfWZ1bmN0aW9uIEooYSxiKXt0ZisrO3NmW3RmXT1hLmN1cnJlbnQ7YS5jdXJyZW50PWJ9dmFyIHVmPXt9LEs9e2N1cnJlbnQ6dWZ9LEw9e2N1cnJlbnQ6ITF9LHZmPXVmO1xuZnVuY3Rpb24gd2YoYSxiKXt2YXIgYz1hLnR5cGUuY29udGV4dFR5cGVzO2lmKCFjKXJldHVybiB1Zjt2YXIgZD1hLnN0YXRlTm9kZTtpZihkJiZkLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkVW5tYXNrZWRDaGlsZENvbnRleHQ9PT1iKXJldHVybiBkLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWFza2VkQ2hpbGRDb250ZXh0O3ZhciBlPXt9LGY7Zm9yKGYgaW4gYyllW2ZdPWJbZl07ZCYmKGE9YS5zdGF0ZU5vZGUsYS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZFVubWFza2VkQ2hpbGRDb250ZXh0PWIsYS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1hc2tlZENoaWxkQ29udGV4dD1lKTtyZXR1cm4gZX1mdW5jdGlvbiBNKGEpe2E9YS5jaGlsZENvbnRleHRUeXBlcztyZXR1cm4gbnVsbCE9PWEmJnZvaWQgMCE9PWF9ZnVuY3Rpb24geGYoYSl7SShMLGEpO0koSyxhKX1mdW5jdGlvbiB5ZihhKXtJKEwsYSk7SShLLGEpfVxuZnVuY3Rpb24gemYoYSxiLGMpe0suY3VycmVudCE9PXVmP3IoXCIxNjhcIik6dm9pZCAwO0ooSyxiLGEpO0ooTCxjLGEpfWZ1bmN0aW9uIEFmKGEsYixjKXt2YXIgZD1hLnN0YXRlTm9kZTthPWIuY2hpbGRDb250ZXh0VHlwZXM7aWYoXCJmdW5jdGlvblwiIT09dHlwZW9mIGQuZ2V0Q2hpbGRDb250ZXh0KXJldHVybiBjO2Q9ZC5nZXRDaGlsZENvbnRleHQoKTtmb3IodmFyIGUgaW4gZCllIGluIGE/dm9pZCAwOnIoXCIxMDhcIixBYyhiKXx8XCJVbmtub3duXCIsZSk7cmV0dXJuIG4oe30sYyxkKX1mdW5jdGlvbiBCZihhKXt2YXIgYj1hLnN0YXRlTm9kZTtiPWImJmIuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHR8fHVmO3ZmPUsuY3VycmVudDtKKEssYixhKTtKKEwsTC5jdXJyZW50LGEpO3JldHVybiEwfVxuZnVuY3Rpb24gQ2YoYSxiLGMpe3ZhciBkPWEuc3RhdGVOb2RlO2Q/dm9pZCAwOnIoXCIxNjlcIik7Yz8oYj1BZihhLGIsdmYpLGQuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHQ9YixJKEwsYSksSShLLGEpLEooSyxiLGEpKTpJKEwsYSk7SihMLGMsYSl9dmFyIERmPW51bGwsRWY9bnVsbDtmdW5jdGlvbiBGZihhKXtyZXR1cm4gZnVuY3Rpb24oYil7dHJ5e3JldHVybiBhKGIpfWNhdGNoKGMpe319fVxuZnVuY3Rpb24gR2YoYSl7aWYoXCJ1bmRlZmluZWRcIj09PXR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18pcmV0dXJuITE7dmFyIGI9X19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fO2lmKGIuaXNEaXNhYmxlZHx8IWIuc3VwcG9ydHNGaWJlcilyZXR1cm4hMDt0cnl7dmFyIGM9Yi5pbmplY3QoYSk7RGY9RmYoZnVuY3Rpb24oYSl7cmV0dXJuIGIub25Db21taXRGaWJlclJvb3QoYyxhKX0pO0VmPUZmKGZ1bmN0aW9uKGEpe3JldHVybiBiLm9uQ29tbWl0RmliZXJVbm1vdW50KGMsYSl9KX1jYXRjaChkKXt9cmV0dXJuITB9XG5mdW5jdGlvbiBIZihhLGIsYyxkKXt0aGlzLnRhZz1hO3RoaXMua2V5PWM7dGhpcy5zaWJsaW5nPXRoaXMuY2hpbGQ9dGhpcy5yZXR1cm49dGhpcy5zdGF0ZU5vZGU9dGhpcy50eXBlPXRoaXMuZWxlbWVudFR5cGU9bnVsbDt0aGlzLmluZGV4PTA7dGhpcy5yZWY9bnVsbDt0aGlzLnBlbmRpbmdQcm9wcz1iO3RoaXMuZmlyc3RDb250ZXh0RGVwZW5kZW5jeT10aGlzLm1lbW9pemVkU3RhdGU9dGhpcy51cGRhdGVRdWV1ZT10aGlzLm1lbW9pemVkUHJvcHM9bnVsbDt0aGlzLm1vZGU9ZDt0aGlzLmVmZmVjdFRhZz0wO3RoaXMubGFzdEVmZmVjdD10aGlzLmZpcnN0RWZmZWN0PXRoaXMubmV4dEVmZmVjdD1udWxsO3RoaXMuY2hpbGRFeHBpcmF0aW9uVGltZT10aGlzLmV4cGlyYXRpb25UaW1lPTA7dGhpcy5hbHRlcm5hdGU9bnVsbH1mdW5jdGlvbiBOKGEsYixjLGQpe3JldHVybiBuZXcgSGYoYSxiLGMsZCl9XG5mdW5jdGlvbiBJZihhKXthPWEucHJvdG90eXBlO3JldHVybiEoIWF8fCFhLmlzUmVhY3RDb21wb25lbnQpfWZ1bmN0aW9uIEpmKGEpe2lmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiBhKXJldHVybiBJZihhKT8xOjA7aWYodm9pZCAwIT09YSYmbnVsbCE9PWEpe2E9YS4kJHR5cGVvZjtpZihhPT09dWMpcmV0dXJuIDExO2lmKGE9PT13YylyZXR1cm4gMTR9cmV0dXJuIDJ9XG5mdW5jdGlvbiBLZihhLGIpe3ZhciBjPWEuYWx0ZXJuYXRlO251bGw9PT1jPyhjPU4oYS50YWcsYixhLmtleSxhLm1vZGUpLGMuZWxlbWVudFR5cGU9YS5lbGVtZW50VHlwZSxjLnR5cGU9YS50eXBlLGMuc3RhdGVOb2RlPWEuc3RhdGVOb2RlLGMuYWx0ZXJuYXRlPWEsYS5hbHRlcm5hdGU9Yyk6KGMucGVuZGluZ1Byb3BzPWIsYy5lZmZlY3RUYWc9MCxjLm5leHRFZmZlY3Q9bnVsbCxjLmZpcnN0RWZmZWN0PW51bGwsYy5sYXN0RWZmZWN0PW51bGwpO2MuY2hpbGRFeHBpcmF0aW9uVGltZT1hLmNoaWxkRXhwaXJhdGlvblRpbWU7Yy5leHBpcmF0aW9uVGltZT1hLmV4cGlyYXRpb25UaW1lO2MuY2hpbGQ9YS5jaGlsZDtjLm1lbW9pemVkUHJvcHM9YS5tZW1vaXplZFByb3BzO2MubWVtb2l6ZWRTdGF0ZT1hLm1lbW9pemVkU3RhdGU7Yy51cGRhdGVRdWV1ZT1hLnVwZGF0ZVF1ZXVlO2MuZmlyc3RDb250ZXh0RGVwZW5kZW5jeT1hLmZpcnN0Q29udGV4dERlcGVuZGVuY3k7Yy5zaWJsaW5nPWEuc2libGluZztcbmMuaW5kZXg9YS5pbmRleDtjLnJlZj1hLnJlZjtyZXR1cm4gY31cbmZ1bmN0aW9uIExmKGEsYixjLGQsZSxmKXt2YXIgZz0yO2Q9YTtpZihcImZ1bmN0aW9uXCI9PT10eXBlb2YgYSlJZihhKSYmKGc9MSk7ZWxzZSBpZihcInN0cmluZ1wiPT09dHlwZW9mIGEpZz01O2Vsc2UgYTpzd2l0Y2goYSl7Y2FzZSBvYzpyZXR1cm4gTWYoYy5jaGlsZHJlbixlLGYsYik7Y2FzZSB0YzpyZXR1cm4gTmYoYyxlfDMsZixiKTtjYXNlIHBjOnJldHVybiBOZihjLGV8MixmLGIpO2Nhc2UgcWM6cmV0dXJuIGE9TigxMixjLGIsZXw0KSxhLmVsZW1lbnRUeXBlPXFjLGEudHlwZT1xYyxhLmV4cGlyYXRpb25UaW1lPWYsYTtjYXNlIHZjOnJldHVybiBhPU4oMTMsYyxiLGUpLGEuZWxlbWVudFR5cGU9dmMsYS50eXBlPXZjLGEuZXhwaXJhdGlvblRpbWU9ZixhO2RlZmF1bHQ6aWYoXCJvYmplY3RcIj09PXR5cGVvZiBhJiZudWxsIT09YSlzd2l0Y2goYS4kJHR5cGVvZil7Y2FzZSByYzpnPTEwO2JyZWFrIGE7Y2FzZSBzYzpnPTk7YnJlYWsgYTtjYXNlIHVjOmc9MTE7YnJlYWsgYTtjYXNlIHdjOmc9XG4xNDticmVhayBhO2Nhc2UgeGM6Zz0xNjtkPW51bGw7YnJlYWsgYX1yKFwiMTMwXCIsbnVsbD09YT9hOnR5cGVvZiBhLFwiXCIpfWI9TihnLGMsYixlKTtiLmVsZW1lbnRUeXBlPWE7Yi50eXBlPWQ7Yi5leHBpcmF0aW9uVGltZT1mO3JldHVybiBifWZ1bmN0aW9uIE1mKGEsYixjLGQpe2E9Tig3LGEsZCxiKTthLmV4cGlyYXRpb25UaW1lPWM7cmV0dXJuIGF9ZnVuY3Rpb24gTmYoYSxiLGMsZCl7YT1OKDgsYSxkLGIpO2I9MD09PShiJjEpP3BjOnRjO2EuZWxlbWVudFR5cGU9YjthLnR5cGU9YjthLmV4cGlyYXRpb25UaW1lPWM7cmV0dXJuIGF9ZnVuY3Rpb24gT2YoYSxiLGMpe2E9Tig2LGEsbnVsbCxiKTthLmV4cGlyYXRpb25UaW1lPWM7cmV0dXJuIGF9XG5mdW5jdGlvbiBQZihhLGIsYyl7Yj1OKDQsbnVsbCE9PWEuY2hpbGRyZW4/YS5jaGlsZHJlbjpbXSxhLmtleSxiKTtiLmV4cGlyYXRpb25UaW1lPWM7Yi5zdGF0ZU5vZGU9e2NvbnRhaW5lckluZm86YS5jb250YWluZXJJbmZvLHBlbmRpbmdDaGlsZHJlbjpudWxsLGltcGxlbWVudGF0aW9uOmEuaW1wbGVtZW50YXRpb259O3JldHVybiBifWZ1bmN0aW9uIFFmKGEsYil7YS5kaWRFcnJvcj0hMTt2YXIgYz1hLmVhcmxpZXN0UGVuZGluZ1RpbWU7MD09PWM/YS5lYXJsaWVzdFBlbmRpbmdUaW1lPWEubGF0ZXN0UGVuZGluZ1RpbWU9YjpjPmI/YS5lYXJsaWVzdFBlbmRpbmdUaW1lPWI6YS5sYXRlc3RQZW5kaW5nVGltZTxiJiYoYS5sYXRlc3RQZW5kaW5nVGltZT1iKTtSZihiLGEpfVxuZnVuY3Rpb24gU2YoYSxiKXthLmRpZEVycm9yPSExO3ZhciBjPWEubGF0ZXN0UGluZ2VkVGltZTswIT09YyYmYzw9YiYmKGEubGF0ZXN0UGluZ2VkVGltZT0wKTtjPWEuZWFybGllc3RQZW5kaW5nVGltZTt2YXIgZD1hLmxhdGVzdFBlbmRpbmdUaW1lO2M9PT1iP2EuZWFybGllc3RQZW5kaW5nVGltZT1kPT09Yj9hLmxhdGVzdFBlbmRpbmdUaW1lPTA6ZDpkPT09YiYmKGEubGF0ZXN0UGVuZGluZ1RpbWU9Yyk7Yz1hLmVhcmxpZXN0U3VzcGVuZGVkVGltZTtkPWEubGF0ZXN0U3VzcGVuZGVkVGltZTswPT09Yz9hLmVhcmxpZXN0U3VzcGVuZGVkVGltZT1hLmxhdGVzdFN1c3BlbmRlZFRpbWU9YjpjPmI/YS5lYXJsaWVzdFN1c3BlbmRlZFRpbWU9YjpkPGImJihhLmxhdGVzdFN1c3BlbmRlZFRpbWU9Yik7UmYoYixhKX1cbmZ1bmN0aW9uIFRmKGEsYil7dmFyIGM9YS5lYXJsaWVzdFBlbmRpbmdUaW1lO2E9YS5lYXJsaWVzdFN1c3BlbmRlZFRpbWU7aWYoMD09PWJ8fDAhPT1jJiZjPGIpYj1jO2lmKDA9PT1ifHwwIT09YSYmYTxiKWI9YTtyZXR1cm4gYn1mdW5jdGlvbiBSZihhLGIpe3ZhciBjPWIuZWFybGllc3RTdXNwZW5kZWRUaW1lLGQ9Yi5sYXRlc3RTdXNwZW5kZWRUaW1lLGU9Yi5lYXJsaWVzdFBlbmRpbmdUaW1lLGY9Yi5sYXRlc3RQaW5nZWRUaW1lO2U9MCE9PWU/ZTpmOzA9PT1lJiYoMD09PWF8fGQ+YSkmJihlPWQpO2E9ZTswIT09YSYmMCE9PWMmJmM8YSYmKGE9Yyk7Yi5uZXh0RXhwaXJhdGlvblRpbWVUb1dvcmtPbj1lO2IuZXhwaXJhdGlvblRpbWU9YX12YXIgVWY9ITE7XG5mdW5jdGlvbiBWZihhKXtyZXR1cm57YmFzZVN0YXRlOmEsZmlyc3RVcGRhdGU6bnVsbCxsYXN0VXBkYXRlOm51bGwsZmlyc3RDYXB0dXJlZFVwZGF0ZTpudWxsLGxhc3RDYXB0dXJlZFVwZGF0ZTpudWxsLGZpcnN0RWZmZWN0Om51bGwsbGFzdEVmZmVjdDpudWxsLGZpcnN0Q2FwdHVyZWRFZmZlY3Q6bnVsbCxsYXN0Q2FwdHVyZWRFZmZlY3Q6bnVsbH19ZnVuY3Rpb24gV2YoYSl7cmV0dXJue2Jhc2VTdGF0ZTphLmJhc2VTdGF0ZSxmaXJzdFVwZGF0ZTphLmZpcnN0VXBkYXRlLGxhc3RVcGRhdGU6YS5sYXN0VXBkYXRlLGZpcnN0Q2FwdHVyZWRVcGRhdGU6bnVsbCxsYXN0Q2FwdHVyZWRVcGRhdGU6bnVsbCxmaXJzdEVmZmVjdDpudWxsLGxhc3RFZmZlY3Q6bnVsbCxmaXJzdENhcHR1cmVkRWZmZWN0Om51bGwsbGFzdENhcHR1cmVkRWZmZWN0Om51bGx9fVxuZnVuY3Rpb24gWGYoYSl7cmV0dXJue2V4cGlyYXRpb25UaW1lOmEsdGFnOjAscGF5bG9hZDpudWxsLGNhbGxiYWNrOm51bGwsbmV4dDpudWxsLG5leHRFZmZlY3Q6bnVsbH19ZnVuY3Rpb24gWWYoYSxiKXtudWxsPT09YS5sYXN0VXBkYXRlP2EuZmlyc3RVcGRhdGU9YS5sYXN0VXBkYXRlPWI6KGEubGFzdFVwZGF0ZS5uZXh0PWIsYS5sYXN0VXBkYXRlPWIpfVxuZnVuY3Rpb24gWmYoYSxiKXt2YXIgYz1hLmFsdGVybmF0ZTtpZihudWxsPT09Yyl7dmFyIGQ9YS51cGRhdGVRdWV1ZTt2YXIgZT1udWxsO251bGw9PT1kJiYoZD1hLnVwZGF0ZVF1ZXVlPVZmKGEubWVtb2l6ZWRTdGF0ZSkpfWVsc2UgZD1hLnVwZGF0ZVF1ZXVlLGU9Yy51cGRhdGVRdWV1ZSxudWxsPT09ZD9udWxsPT09ZT8oZD1hLnVwZGF0ZVF1ZXVlPVZmKGEubWVtb2l6ZWRTdGF0ZSksZT1jLnVwZGF0ZVF1ZXVlPVZmKGMubWVtb2l6ZWRTdGF0ZSkpOmQ9YS51cGRhdGVRdWV1ZT1XZihlKTpudWxsPT09ZSYmKGU9Yy51cGRhdGVRdWV1ZT1XZihkKSk7bnVsbD09PWV8fGQ9PT1lP1lmKGQsYik6bnVsbD09PWQubGFzdFVwZGF0ZXx8bnVsbD09PWUubGFzdFVwZGF0ZT8oWWYoZCxiKSxZZihlLGIpKTooWWYoZCxiKSxlLmxhc3RVcGRhdGU9Yil9XG5mdW5jdGlvbiAkZihhLGIpe3ZhciBjPWEudXBkYXRlUXVldWU7Yz1udWxsPT09Yz9hLnVwZGF0ZVF1ZXVlPVZmKGEubWVtb2l6ZWRTdGF0ZSk6YWcoYSxjKTtudWxsPT09Yy5sYXN0Q2FwdHVyZWRVcGRhdGU/Yy5maXJzdENhcHR1cmVkVXBkYXRlPWMubGFzdENhcHR1cmVkVXBkYXRlPWI6KGMubGFzdENhcHR1cmVkVXBkYXRlLm5leHQ9YixjLmxhc3RDYXB0dXJlZFVwZGF0ZT1iKX1mdW5jdGlvbiBhZyhhLGIpe3ZhciBjPWEuYWx0ZXJuYXRlO251bGwhPT1jJiZiPT09Yy51cGRhdGVRdWV1ZSYmKGI9YS51cGRhdGVRdWV1ZT1XZihiKSk7cmV0dXJuIGJ9XG5mdW5jdGlvbiBiZyhhLGIsYyxkLGUsZil7c3dpdGNoKGMudGFnKXtjYXNlIDE6cmV0dXJuIGE9Yy5wYXlsb2FkLFwiZnVuY3Rpb25cIj09PXR5cGVvZiBhP2EuY2FsbChmLGQsZSk6YTtjYXNlIDM6YS5lZmZlY3RUYWc9YS5lZmZlY3RUYWcmLTIwNDl8NjQ7Y2FzZSAwOmE9Yy5wYXlsb2FkO2U9XCJmdW5jdGlvblwiPT09dHlwZW9mIGE/YS5jYWxsKGYsZCxlKTphO2lmKG51bGw9PT1lfHx2b2lkIDA9PT1lKWJyZWFrO3JldHVybiBuKHt9LGQsZSk7Y2FzZSAyOlVmPSEwfXJldHVybiBkfVxuZnVuY3Rpb24gY2coYSxiLGMsZCxlKXtVZj0hMTtiPWFnKGEsYik7Zm9yKHZhciBmPWIuYmFzZVN0YXRlLGc9bnVsbCxoPTAsaz1iLmZpcnN0VXBkYXRlLGw9ZjtudWxsIT09azspe3ZhciBtPWsuZXhwaXJhdGlvblRpbWU7aWYobT5lKXtpZihudWxsPT09ZyYmKGc9ayxmPWwpLDA9PT1ofHxoPm0paD1tfWVsc2UgbD1iZyhhLGIsayxsLGMsZCksbnVsbCE9PWsuY2FsbGJhY2smJihhLmVmZmVjdFRhZ3w9MzIsay5uZXh0RWZmZWN0PW51bGwsbnVsbD09PWIubGFzdEVmZmVjdD9iLmZpcnN0RWZmZWN0PWIubGFzdEVmZmVjdD1rOihiLmxhc3RFZmZlY3QubmV4dEVmZmVjdD1rLGIubGFzdEVmZmVjdD1rKSk7az1rLm5leHR9bT1udWxsO2ZvcihrPWIuZmlyc3RDYXB0dXJlZFVwZGF0ZTtudWxsIT09azspe3ZhciBwPWsuZXhwaXJhdGlvblRpbWU7aWYocD5lKXtpZihudWxsPT09bSYmKG09ayxudWxsPT09ZyYmKGY9bCkpLDA9PT1ofHxoPnApaD1wfWVsc2UgbD1iZyhhLGIsayxsLGMsZCksXG5udWxsIT09ay5jYWxsYmFjayYmKGEuZWZmZWN0VGFnfD0zMixrLm5leHRFZmZlY3Q9bnVsbCxudWxsPT09Yi5sYXN0Q2FwdHVyZWRFZmZlY3Q/Yi5maXJzdENhcHR1cmVkRWZmZWN0PWIubGFzdENhcHR1cmVkRWZmZWN0PWs6KGIubGFzdENhcHR1cmVkRWZmZWN0Lm5leHRFZmZlY3Q9ayxiLmxhc3RDYXB0dXJlZEVmZmVjdD1rKSk7az1rLm5leHR9bnVsbD09PWcmJihiLmxhc3RVcGRhdGU9bnVsbCk7bnVsbD09PW0/Yi5sYXN0Q2FwdHVyZWRVcGRhdGU9bnVsbDphLmVmZmVjdFRhZ3w9MzI7bnVsbD09PWcmJm51bGw9PT1tJiYoZj1sKTtiLmJhc2VTdGF0ZT1mO2IuZmlyc3RVcGRhdGU9ZztiLmZpcnN0Q2FwdHVyZWRVcGRhdGU9bTthLmV4cGlyYXRpb25UaW1lPWg7YS5tZW1vaXplZFN0YXRlPWx9XG5mdW5jdGlvbiBkZyhhLGIsYyl7bnVsbCE9PWIuZmlyc3RDYXB0dXJlZFVwZGF0ZSYmKG51bGwhPT1iLmxhc3RVcGRhdGUmJihiLmxhc3RVcGRhdGUubmV4dD1iLmZpcnN0Q2FwdHVyZWRVcGRhdGUsYi5sYXN0VXBkYXRlPWIubGFzdENhcHR1cmVkVXBkYXRlKSxiLmZpcnN0Q2FwdHVyZWRVcGRhdGU9Yi5sYXN0Q2FwdHVyZWRVcGRhdGU9bnVsbCk7ZWcoYi5maXJzdEVmZmVjdCxjKTtiLmZpcnN0RWZmZWN0PWIubGFzdEVmZmVjdD1udWxsO2VnKGIuZmlyc3RDYXB0dXJlZEVmZmVjdCxjKTtiLmZpcnN0Q2FwdHVyZWRFZmZlY3Q9Yi5sYXN0Q2FwdHVyZWRFZmZlY3Q9bnVsbH1mdW5jdGlvbiBlZyhhLGIpe2Zvcig7bnVsbCE9PWE7KXt2YXIgYz1hLmNhbGxiYWNrO2lmKG51bGwhPT1jKXthLmNhbGxiYWNrPW51bGw7dmFyIGQ9YjtcImZ1bmN0aW9uXCIhPT10eXBlb2YgYz9yKFwiMTkxXCIsYyk6dm9pZCAwO2MuY2FsbChkKX1hPWEubmV4dEVmZmVjdH19XG5mdW5jdGlvbiBmZyhhLGIpe3JldHVybnt2YWx1ZTphLHNvdXJjZTpiLHN0YWNrOkJjKGIpfX12YXIgZ2c9e2N1cnJlbnQ6bnVsbH0saGc9bnVsbCxpZz1udWxsLGpnPW51bGw7ZnVuY3Rpb24ga2coYSxiKXt2YXIgYz1hLnR5cGUuX2NvbnRleHQ7SihnZyxjLl9jdXJyZW50VmFsdWUsYSk7Yy5fY3VycmVudFZhbHVlPWJ9ZnVuY3Rpb24gbGcoYSl7dmFyIGI9Z2cuY3VycmVudDtJKGdnLGEpO2EudHlwZS5fY29udGV4dC5fY3VycmVudFZhbHVlPWJ9ZnVuY3Rpb24gbWcoYSl7aGc9YTtqZz1pZz1udWxsO2EuZmlyc3RDb250ZXh0RGVwZW5kZW5jeT1udWxsfVxuZnVuY3Rpb24gbmcoYSxiKXtpZihqZyE9PWEmJiExIT09YiYmMCE9PWIpe2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYnx8MTA3Mzc0MTgyMz09PWIpamc9YSxiPTEwNzM3NDE4MjM7Yj17Y29udGV4dDphLG9ic2VydmVkQml0czpiLG5leHQ6bnVsbH07bnVsbD09PWlnPyhudWxsPT09aGc/cihcIjI5M1wiKTp2b2lkIDAsaGcuZmlyc3RDb250ZXh0RGVwZW5kZW5jeT1pZz1iKTppZz1pZy5uZXh0PWJ9cmV0dXJuIGEuX2N1cnJlbnRWYWx1ZX12YXIgb2c9MCxPPW51bGwscGc9bnVsbCxQPW51bGwscWc9bnVsbCxRPW51bGwscmc9MCxSPW51bGwsc2c9ITEsdGc9ITEsdWc9bnVsbCx2Zz0wO2Z1bmN0aW9uIHdnKCl7bnVsbD09PU8/cihcIjI5OFwiKTp2b2lkIDA7cmV0dXJuIE99XG5mdW5jdGlvbiB4ZyhhLGIsYyxkKXtmb3IoO3RnOyl0Zz0hMSx2Zys9MSxSPVE9UD1udWxsLGM9YShiLGQpO3VnPW51bGw7dmc9MDthPU87YS5tZW1vaXplZFN0YXRlPXFnO2EuZXhwaXJhdGlvblRpbWU9cmc7YS51cGRhdGVRdWV1ZT1SO2E9bnVsbCE9PVAmJm51bGwhPT1QLm5leHQ7b2c9MDtRPXFnPVA9cGc9Tz1udWxsO3JnPTA7Uj1udWxsO2E/cihcIjI5OVwiKTp2b2lkIDA7cmV0dXJuIGN9ZnVuY3Rpb24geWcoKXtvZz0wO1E9cWc9UD1wZz1PPW51bGw7cmc9MDtSPW51bGw7dGc9ITE7dWc9bnVsbDt2Zz0wfWZ1bmN0aW9uIHpnKCl7cmV0dXJue21lbW9pemVkU3RhdGU6bnVsbCxiYXNlU3RhdGU6bnVsbCxxdWV1ZTpudWxsLGJhc2VVcGRhdGU6bnVsbCxuZXh0Om51bGx9fVxuZnVuY3Rpb24gQWcoYSl7cmV0dXJue21lbW9pemVkU3RhdGU6YS5tZW1vaXplZFN0YXRlLGJhc2VTdGF0ZTphLm1lbW9pemVkU3RhdGUscXVldWU6YS5xdWV1ZSxiYXNlVXBkYXRlOmEuYmFzZVVwZGF0ZSxuZXh0Om51bGx9fWZ1bmN0aW9uIEJnKCl7aWYobnVsbD09PVEpbnVsbD09PXFnPyhzZz0hMSxQPXBnLHFnPVE9bnVsbD09PVA/emcoKTpBZyhQKSk6KHNnPSEwLFA9cGcsUT1xZyk7ZWxzZSBpZihudWxsPT09US5uZXh0KXtzZz0hMTtpZihudWxsPT09UCl2YXIgYT16ZygpO2Vsc2UgUD1QLm5leHQsYT1udWxsPT09UD96ZygpOkFnKFApO1E9US5uZXh0PWF9ZWxzZSBzZz0hMCxRPVEubmV4dCxQPW51bGwhPT1QP1AubmV4dDpudWxsO3JldHVybiBRfWZ1bmN0aW9uIENnKGEsYil7cmV0dXJuXCJmdW5jdGlvblwiPT09dHlwZW9mIGI/YihhKTpifVxuZnVuY3Rpb24gRGcoYSxiLGMpe089d2coKTtRPUJnKCk7dmFyIGQ9US5xdWV1ZTtpZihudWxsIT09ZCl7aWYoc2cpe2I9ZC5kaXNwYXRjaDtpZihudWxsIT09dWcpe3ZhciBlPXVnLmdldChkKTtpZih2b2lkIDAhPT1lKXt1Zy5kZWxldGUoZCk7Yz1RLm1lbW9pemVkU3RhdGU7ZG8gYz1hKGMsZS5hY3Rpb24pLG51bGwhPT1lLmNhbGxiYWNrJiZFZyhPLGUpLGU9ZS5uZXh0O3doaWxlKG51bGwhPT1lKTtRLm1lbW9pemVkU3RhdGU9YztRLmJhc2VVcGRhdGU9PT1kLmxhc3QmJihRLmJhc2VTdGF0ZT1jKTtyZXR1cm5bYyxiXX19cmV0dXJuW1EubWVtb2l6ZWRTdGF0ZSxiXX1iPWQubGFzdDt2YXIgZj1RLmJhc2VVcGRhdGU7bnVsbCE9PWY/KG51bGwhPT1iJiYoYi5uZXh0PW51bGwpLGI9Zi5uZXh0KTpiPW51bGwhPT1iP2IubmV4dDpudWxsO2lmKG51bGwhPT1iKXtjPVEuYmFzZVN0YXRlO3ZhciBnPWU9bnVsbCxoPWIsaz0hMTtkb3t2YXIgbD1oLmV4cGlyYXRpb25UaW1lO2lmKGw+b2cpe2lmKGt8fFxuKGs9ITAsZz1mLGU9YyksMD09PXJnfHxsPHJnKXJnPWx9ZWxzZSBjPWEoYyxoLmFjdGlvbiksbnVsbCE9PWguY2FsbGJhY2smJkVnKE8saCk7Zj1oO2g9aC5uZXh0fXdoaWxlKG51bGwhPT1oJiZoIT09Yik7a3x8KGc9ZixlPWMpO1EubWVtb2l6ZWRTdGF0ZT1jO1EuYmFzZVVwZGF0ZT1nO1EuYmFzZVN0YXRlPWV9cmV0dXJuW1EubWVtb2l6ZWRTdGF0ZSxkLmRpc3BhdGNoXX1hPT09Q2c/XCJmdW5jdGlvblwiPT09dHlwZW9mIGImJihiPWIoKSk6dm9pZCAwIT09YyYmbnVsbCE9PWMmJihiPWEoYixjKSk7US5tZW1vaXplZFN0YXRlPVEuYmFzZVN0YXRlPWI7ZD1RLnF1ZXVlPXtsYXN0Om51bGwsZGlzcGF0Y2g6bnVsbH07YT1kLmRpc3BhdGNoPUZnLmJpbmQobnVsbCxPLGQpO3JldHVybltRLm1lbW9pemVkU3RhdGUsYV19XG5mdW5jdGlvbiBFZyhhLGIpe2lmKG51bGw9PT1SKVI9e2NhbGxiYWNrTGlzdDpudWxsLGxhc3RFZmZlY3Q6bnVsbH0sUi5jYWxsYmFja0xpc3Q9W2JdO2Vsc2V7dmFyIGM9Ui5jYWxsYmFja0xpc3Q7bnVsbD09PWM/Ui5jYWxsYmFja0xpc3Q9W2JdOmMucHVzaChiKX1hLmVmZmVjdFRhZ3w9MzJ9ZnVuY3Rpb24gR2coYSxiLGMsZCl7YT17dGFnOmEsY3JlYXRlOmIsZGVzdHJveTpjLGlucHV0czpkLG5leHQ6bnVsbH07bnVsbD09PVI/KFI9e2NhbGxiYWNrTGlzdDpudWxsLGxhc3RFZmZlY3Q6bnVsbH0sUi5sYXN0RWZmZWN0PWEubmV4dD1hKTooYj1SLmxhc3RFZmZlY3QsbnVsbD09PWI/Ui5sYXN0RWZmZWN0PWEubmV4dD1hOihjPWIubmV4dCxiLm5leHQ9YSxhLm5leHQ9YyxSLmxhc3RFZmZlY3Q9YSkpO3JldHVybiBhfVxuZnVuY3Rpb24gSGcoYSxiLGMsZCl7Tz13ZygpO1E9QmcoKTtkPXZvaWQgMCE9PWQmJm51bGwhPT1kP2Q6W2NdO3ZhciBlPW51bGw7aWYobnVsbCE9PVApe3ZhciBmPVAubWVtb2l6ZWRTdGF0ZTtlPWYuZGVzdHJveTtpZihJZyhkLGYuaW5wdXRzKSl7R2coMCxjLGUsZCk7cmV0dXJufX1PLmVmZmVjdFRhZ3w9YTtRLm1lbW9pemVkU3RhdGU9R2coYixjLGUsZCl9XG5mdW5jdGlvbiBGZyhhLGIsYyxkKXtkPW51bGw7MjU+dmc/dm9pZCAwOnIoXCIzMDBcIik7dmFyIGU9YS5hbHRlcm5hdGU7aWYoYT09PU98fG51bGwhPT1lJiZlPT09TylpZih0Zz0hMCxhPXtleHBpcmF0aW9uVGltZTpvZyxhY3Rpb246YyxjYWxsYmFjazp2b2lkIDAhPT1kP2Q6bnVsbCxuZXh0Om51bGx9LG51bGw9PT11ZyYmKHVnPW5ldyBNYXApLGU9dWcuZ2V0KGIpLHZvaWQgMD09PWUpdWcuc2V0KGIsYSk7ZWxzZXtmb3IoYj1lO251bGwhPT1iLm5leHQ7KWI9Yi5uZXh0O2IubmV4dD1hfWVsc2V7ZT1KZygpO2U9S2coZSxhKTtjPXtleHBpcmF0aW9uVGltZTplLGFjdGlvbjpjLGNhbGxiYWNrOnZvaWQgMCE9PWQ/ZDpudWxsLG5leHQ6bnVsbH07TGcoKTtkPWIubGFzdDtpZihudWxsPT09ZCljLm5leHQ9YztlbHNle3ZhciBmPWQubmV4dDtudWxsIT09ZiYmKGMubmV4dD1mKTtkLm5leHQ9Y31iLmxhc3Q9YztNZyhhLGUpfX1cbmZ1bmN0aW9uIElnKGEsYil7Zm9yKHZhciBjPTA7YzxhLmxlbmd0aDtjKyspe3ZhciBkPWFbY10sZT1iW2NdO2lmKChkIT09ZXx8MD09PWQmJjEvZCE9PTEvZSkmJihkPT09ZHx8ZT09PWUpKXJldHVybiExfXJldHVybiEwfXZhciBOZz17fSxPZz17Y3VycmVudDpOZ30sUGc9e2N1cnJlbnQ6Tmd9LFFnPXtjdXJyZW50Ok5nfTtmdW5jdGlvbiBSZyhhKXthPT09Tmc/cihcIjE3NFwiKTp2b2lkIDA7cmV0dXJuIGF9ZnVuY3Rpb24gU2coYSxiKXtKKFFnLGIsYSk7SihQZyxhLGEpO0ooT2csTmcsYSk7dmFyIGM9Yi5ub2RlVHlwZTtzd2l0Y2goYyl7Y2FzZSA5OmNhc2UgMTE6Yj0oYj1iLmRvY3VtZW50RWxlbWVudCk/Yi5uYW1lc3BhY2VVUkk6SWUobnVsbCxcIlwiKTticmVhaztkZWZhdWx0OmM9OD09PWM/Yi5wYXJlbnROb2RlOmIsYj1jLm5hbWVzcGFjZVVSSXx8bnVsbCxjPWMudGFnTmFtZSxiPUllKGIsYyl9SShPZyxhKTtKKE9nLGIsYSl9XG5mdW5jdGlvbiBUZyhhKXtJKE9nLGEpO0koUGcsYSk7SShRZyxhKX1mdW5jdGlvbiBVZyhhKXtSZyhRZy5jdXJyZW50KTt2YXIgYj1SZyhPZy5jdXJyZW50KTt2YXIgYz1JZShiLGEudHlwZSk7YiE9PWMmJihKKFBnLGEsYSksSihPZyxjLGEpKX1mdW5jdGlvbiBWZyhhKXtQZy5jdXJyZW50PT09YSYmKEkoT2csYSksSShQZyxhKSl9dmFyIFdnPWtjLlJlYWN0Q3VycmVudE93bmVyLFhnPShuZXcgYWEuQ29tcG9uZW50KS5yZWZzO2Z1bmN0aW9uIFlnKGEsYixjLGQpe2I9YS5tZW1vaXplZFN0YXRlO2M9YyhkLGIpO2M9bnVsbD09PWN8fHZvaWQgMD09PWM/YjpuKHt9LGIsYyk7YS5tZW1vaXplZFN0YXRlPWM7ZD1hLnVwZGF0ZVF1ZXVlO251bGwhPT1kJiYwPT09YS5leHBpcmF0aW9uVGltZSYmKGQuYmFzZVN0YXRlPWMpfVxudmFyIFpnPXtpc01vdW50ZWQ6ZnVuY3Rpb24oYSl7cmV0dXJuKGE9YS5fcmVhY3RJbnRlcm5hbEZpYmVyKT8yPT09R2QoYSk6ITF9LGVucXVldWVTZXRTdGF0ZTpmdW5jdGlvbihhLGIsYyl7YT1hLl9yZWFjdEludGVybmFsRmliZXI7dmFyIGQ9SmcoKTtkPUtnKGQsYSk7dmFyIGU9WGYoZCk7ZS5wYXlsb2FkPWI7dm9pZCAwIT09YyYmbnVsbCE9PWMmJihlLmNhbGxiYWNrPWMpO0xnKCk7WmYoYSxlKTtNZyhhLGQpfSxlbnF1ZXVlUmVwbGFjZVN0YXRlOmZ1bmN0aW9uKGEsYixjKXthPWEuX3JlYWN0SW50ZXJuYWxGaWJlcjt2YXIgZD1KZygpO2Q9S2coZCxhKTt2YXIgZT1YZihkKTtlLnRhZz0xO2UucGF5bG9hZD1iO3ZvaWQgMCE9PWMmJm51bGwhPT1jJiYoZS5jYWxsYmFjaz1jKTtMZygpO1pmKGEsZSk7TWcoYSxkKX0sZW5xdWV1ZUZvcmNlVXBkYXRlOmZ1bmN0aW9uKGEsYil7YT1hLl9yZWFjdEludGVybmFsRmliZXI7dmFyIGM9SmcoKTtjPUtnKGMsYSk7dmFyIGQ9WGYoYyk7ZC50YWc9XG4yO3ZvaWQgMCE9PWImJm51bGwhPT1iJiYoZC5jYWxsYmFjaz1iKTtMZygpO1pmKGEsZCk7TWcoYSxjKX19O2Z1bmN0aW9uICRnKGEsYixjLGQsZSxmLGcpe2E9YS5zdGF0ZU5vZGU7cmV0dXJuXCJmdW5jdGlvblwiPT09dHlwZW9mIGEuc2hvdWxkQ29tcG9uZW50VXBkYXRlP2Euc2hvdWxkQ29tcG9uZW50VXBkYXRlKGQsZixnKTpiLnByb3RvdHlwZSYmYi5wcm90b3R5cGUuaXNQdXJlUmVhY3RDb21wb25lbnQ/IUZkKGMsZCl8fCFGZChlLGYpOiEwfVxuZnVuY3Rpb24gYWgoYSxiLGMpe3ZhciBkPSExLGU9dWY7dmFyIGY9Yi5jb250ZXh0VHlwZTtcIm9iamVjdFwiPT09dHlwZW9mIGYmJm51bGwhPT1mP2Y9V2cuY3VycmVudERpc3BhdGNoZXIucmVhZENvbnRleHQoZik6KGU9TShiKT92ZjpLLmN1cnJlbnQsZD1iLmNvbnRleHRUeXBlcyxmPShkPW51bGwhPT1kJiZ2b2lkIDAhPT1kKT93ZihhLGUpOnVmKTtiPW5ldyBiKGMsZik7YS5tZW1vaXplZFN0YXRlPW51bGwhPT1iLnN0YXRlJiZ2b2lkIDAhPT1iLnN0YXRlP2Iuc3RhdGU6bnVsbDtiLnVwZGF0ZXI9Wmc7YS5zdGF0ZU5vZGU9YjtiLl9yZWFjdEludGVybmFsRmliZXI9YTtkJiYoYT1hLnN0YXRlTm9kZSxhLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkVW5tYXNrZWRDaGlsZENvbnRleHQ9ZSxhLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWFza2VkQ2hpbGRDb250ZXh0PWYpO3JldHVybiBifVxuZnVuY3Rpb24gYmgoYSxiLGMsZCl7YT1iLnN0YXRlO1wiZnVuY3Rpb25cIj09PXR5cGVvZiBiLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMmJmIuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhjLGQpO1wiZnVuY3Rpb25cIj09PXR5cGVvZiBiLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJiZiLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKGMsZCk7Yi5zdGF0ZSE9PWEmJlpnLmVucXVldWVSZXBsYWNlU3RhdGUoYixiLnN0YXRlLG51bGwpfVxuZnVuY3Rpb24gY2goYSxiLGMsZCl7dmFyIGU9YS5zdGF0ZU5vZGU7ZS5wcm9wcz1jO2Uuc3RhdGU9YS5tZW1vaXplZFN0YXRlO2UucmVmcz1YZzt2YXIgZj1iLmNvbnRleHRUeXBlO1wib2JqZWN0XCI9PT10eXBlb2YgZiYmbnVsbCE9PWY/ZS5jb250ZXh0PVdnLmN1cnJlbnREaXNwYXRjaGVyLnJlYWRDb250ZXh0KGYpOihmPU0oYik/dmY6Sy5jdXJyZW50LGUuY29udGV4dD13ZihhLGYpKTtmPWEudXBkYXRlUXVldWU7bnVsbCE9PWYmJihjZyhhLGYsYyxlLGQpLGUuc3RhdGU9YS5tZW1vaXplZFN0YXRlKTtmPWIuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzO1wiZnVuY3Rpb25cIj09PXR5cGVvZiBmJiYoWWcoYSxiLGYsYyksZS5zdGF0ZT1hLm1lbW9pemVkU3RhdGUpO1wiZnVuY3Rpb25cIj09PXR5cGVvZiBiLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wc3x8XCJmdW5jdGlvblwiPT09dHlwZW9mIGUuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGV8fFwiZnVuY3Rpb25cIiE9PXR5cGVvZiBlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQmJlxuXCJmdW5jdGlvblwiIT09dHlwZW9mIGUuY29tcG9uZW50V2lsbE1vdW50fHwoYj1lLnN0YXRlLFwiZnVuY3Rpb25cIj09PXR5cGVvZiBlLmNvbXBvbmVudFdpbGxNb3VudCYmZS5jb21wb25lbnRXaWxsTW91bnQoKSxcImZ1bmN0aW9uXCI9PT10eXBlb2YgZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50JiZlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQoKSxiIT09ZS5zdGF0ZSYmWmcuZW5xdWV1ZVJlcGxhY2VTdGF0ZShlLGUuc3RhdGUsbnVsbCksZj1hLnVwZGF0ZVF1ZXVlLG51bGwhPT1mJiYoY2coYSxmLGMsZSxkKSxlLnN0YXRlPWEubWVtb2l6ZWRTdGF0ZSkpO1wiZnVuY3Rpb25cIj09PXR5cGVvZiBlLmNvbXBvbmVudERpZE1vdW50JiYoYS5lZmZlY3RUYWd8PTQpfXZhciBkaD1BcnJheS5pc0FycmF5O1xuZnVuY3Rpb24gZWgoYSxiLGMpe2E9Yy5yZWY7aWYobnVsbCE9PWEmJlwiZnVuY3Rpb25cIiE9PXR5cGVvZiBhJiZcIm9iamVjdFwiIT09dHlwZW9mIGEpe2lmKGMuX293bmVyKXtjPWMuX293bmVyO3ZhciBkPXZvaWQgMDtjJiYoMSE9PWMudGFnP3IoXCIyODlcIik6dm9pZCAwLGQ9Yy5zdGF0ZU5vZGUpO2Q/dm9pZCAwOnIoXCIxNDdcIixhKTt2YXIgZT1cIlwiK2E7aWYobnVsbCE9PWImJm51bGwhPT1iLnJlZiYmXCJmdW5jdGlvblwiPT09dHlwZW9mIGIucmVmJiZiLnJlZi5fc3RyaW5nUmVmPT09ZSlyZXR1cm4gYi5yZWY7Yj1mdW5jdGlvbihhKXt2YXIgYj1kLnJlZnM7Yj09PVhnJiYoYj1kLnJlZnM9e30pO251bGw9PT1hP2RlbGV0ZSBiW2VdOmJbZV09YX07Yi5fc3RyaW5nUmVmPWU7cmV0dXJuIGJ9XCJzdHJpbmdcIiE9PXR5cGVvZiBhP3IoXCIyODRcIik6dm9pZCAwO2MuX293bmVyP3ZvaWQgMDpyKFwiMjkwXCIsYSl9cmV0dXJuIGF9XG5mdW5jdGlvbiBmaChhLGIpe1widGV4dGFyZWFcIiE9PWEudHlwZSYmcihcIjMxXCIsXCJbb2JqZWN0IE9iamVjdF1cIj09PU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChiKT9cIm9iamVjdCB3aXRoIGtleXMge1wiK09iamVjdC5rZXlzKGIpLmpvaW4oXCIsIFwiKStcIn1cIjpiLFwiXCIpfVxuZnVuY3Rpb24gZ2goYSl7ZnVuY3Rpb24gYihiLGMpe2lmKGEpe3ZhciBkPWIubGFzdEVmZmVjdDtudWxsIT09ZD8oZC5uZXh0RWZmZWN0PWMsYi5sYXN0RWZmZWN0PWMpOmIuZmlyc3RFZmZlY3Q9Yi5sYXN0RWZmZWN0PWM7Yy5uZXh0RWZmZWN0PW51bGw7Yy5lZmZlY3RUYWc9OH19ZnVuY3Rpb24gYyhjLGQpe2lmKCFhKXJldHVybiBudWxsO2Zvcig7bnVsbCE9PWQ7KWIoYyxkKSxkPWQuc2libGluZztyZXR1cm4gbnVsbH1mdW5jdGlvbiBkKGEsYil7Zm9yKGE9bmV3IE1hcDtudWxsIT09YjspbnVsbCE9PWIua2V5P2Euc2V0KGIua2V5LGIpOmEuc2V0KGIuaW5kZXgsYiksYj1iLnNpYmxpbmc7cmV0dXJuIGF9ZnVuY3Rpb24gZShhLGIsYyl7YT1LZihhLGIsYyk7YS5pbmRleD0wO2Euc2libGluZz1udWxsO3JldHVybiBhfWZ1bmN0aW9uIGYoYixjLGQpe2IuaW5kZXg9ZDtpZighYSlyZXR1cm4gYztkPWIuYWx0ZXJuYXRlO2lmKG51bGwhPT1kKXJldHVybiBkPWQuaW5kZXgsZDxjPyhiLmVmZmVjdFRhZz1cbjIsYyk6ZDtiLmVmZmVjdFRhZz0yO3JldHVybiBjfWZ1bmN0aW9uIGcoYil7YSYmbnVsbD09PWIuYWx0ZXJuYXRlJiYoYi5lZmZlY3RUYWc9Mik7cmV0dXJuIGJ9ZnVuY3Rpb24gaChhLGIsYyxkKXtpZihudWxsPT09Ynx8NiE9PWIudGFnKXJldHVybiBiPU9mKGMsYS5tb2RlLGQpLGIucmV0dXJuPWEsYjtiPWUoYixjLGQpO2IucmV0dXJuPWE7cmV0dXJuIGJ9ZnVuY3Rpb24gayhhLGIsYyxkKXtpZihudWxsIT09YiYmYi5lbGVtZW50VHlwZT09PWMudHlwZSlyZXR1cm4gZD1lKGIsYy5wcm9wcyxkKSxkLnJlZj1laChhLGIsYyksZC5yZXR1cm49YSxkO2Q9TGYoYy50eXBlLGMua2V5LGMucHJvcHMsbnVsbCxhLm1vZGUsZCk7ZC5yZWY9ZWgoYSxiLGMpO2QucmV0dXJuPWE7cmV0dXJuIGR9ZnVuY3Rpb24gbChhLGIsYyxkKXtpZihudWxsPT09Ynx8NCE9PWIudGFnfHxiLnN0YXRlTm9kZS5jb250YWluZXJJbmZvIT09Yy5jb250YWluZXJJbmZvfHxiLnN0YXRlTm9kZS5pbXBsZW1lbnRhdGlvbiE9PVxuYy5pbXBsZW1lbnRhdGlvbilyZXR1cm4gYj1QZihjLGEubW9kZSxkKSxiLnJldHVybj1hLGI7Yj1lKGIsYy5jaGlsZHJlbnx8W10sZCk7Yi5yZXR1cm49YTtyZXR1cm4gYn1mdW5jdGlvbiBtKGEsYixjLGQsZil7aWYobnVsbD09PWJ8fDchPT1iLnRhZylyZXR1cm4gYj1NZihjLGEubW9kZSxkLGYpLGIucmV0dXJuPWEsYjtiPWUoYixjLGQpO2IucmV0dXJuPWE7cmV0dXJuIGJ9ZnVuY3Rpb24gcChhLGIsYyl7aWYoXCJzdHJpbmdcIj09PXR5cGVvZiBifHxcIm51bWJlclwiPT09dHlwZW9mIGIpcmV0dXJuIGI9T2YoXCJcIitiLGEubW9kZSxjKSxiLnJldHVybj1hLGI7aWYoXCJvYmplY3RcIj09PXR5cGVvZiBiJiZudWxsIT09Yil7c3dpdGNoKGIuJCR0eXBlb2Ype2Nhc2UgbWM6cmV0dXJuIGM9TGYoYi50eXBlLGIua2V5LGIucHJvcHMsbnVsbCxhLm1vZGUsYyksYy5yZWY9ZWgoYSxudWxsLGIpLGMucmV0dXJuPWEsYztjYXNlIG5jOnJldHVybiBiPVBmKGIsYS5tb2RlLGMpLGIucmV0dXJuPWEsYn1pZihkaChiKXx8XG56YyhiKSlyZXR1cm4gYj1NZihiLGEubW9kZSxjLG51bGwpLGIucmV0dXJuPWEsYjtmaChhLGIpfXJldHVybiBudWxsfWZ1bmN0aW9uIHcoYSxiLGMsZCl7dmFyIGU9bnVsbCE9PWI/Yi5rZXk6bnVsbDtpZihcInN0cmluZ1wiPT09dHlwZW9mIGN8fFwibnVtYmVyXCI9PT10eXBlb2YgYylyZXR1cm4gbnVsbCE9PWU/bnVsbDpoKGEsYixcIlwiK2MsZCk7aWYoXCJvYmplY3RcIj09PXR5cGVvZiBjJiZudWxsIT09Yyl7c3dpdGNoKGMuJCR0eXBlb2Ype2Nhc2UgbWM6cmV0dXJuIGMua2V5PT09ZT9jLnR5cGU9PT1vYz9tKGEsYixjLnByb3BzLmNoaWxkcmVuLGQsZSk6ayhhLGIsYyxkKTpudWxsO2Nhc2UgbmM6cmV0dXJuIGMua2V5PT09ZT9sKGEsYixjLGQpOm51bGx9aWYoZGgoYyl8fHpjKGMpKXJldHVybiBudWxsIT09ZT9udWxsOm0oYSxiLGMsZCxudWxsKTtmaChhLGMpfXJldHVybiBudWxsfWZ1bmN0aW9uIEUoYSxiLGMsZCxlKXtpZihcInN0cmluZ1wiPT09dHlwZW9mIGR8fFwibnVtYmVyXCI9PT10eXBlb2YgZClyZXR1cm4gYT1cbmEuZ2V0KGMpfHxudWxsLGgoYixhLFwiXCIrZCxlKTtpZihcIm9iamVjdFwiPT09dHlwZW9mIGQmJm51bGwhPT1kKXtzd2l0Y2goZC4kJHR5cGVvZil7Y2FzZSBtYzpyZXR1cm4gYT1hLmdldChudWxsPT09ZC5rZXk/YzpkLmtleSl8fG51bGwsZC50eXBlPT09b2M/bShiLGEsZC5wcm9wcy5jaGlsZHJlbixlLGQua2V5KTprKGIsYSxkLGUpO2Nhc2UgbmM6cmV0dXJuIGE9YS5nZXQobnVsbD09PWQua2V5P2M6ZC5rZXkpfHxudWxsLGwoYixhLGQsZSl9aWYoZGgoZCl8fHpjKGQpKXJldHVybiBhPWEuZ2V0KGMpfHxudWxsLG0oYixhLGQsZSxudWxsKTtmaChiLGQpfXJldHVybiBudWxsfWZ1bmN0aW9uIHgoZSxnLGgsayl7Zm9yKHZhciBsPW51bGwsbT1udWxsLHE9Zyx2PWc9MCxCPW51bGw7bnVsbCE9PXEmJnY8aC5sZW5ndGg7disrKXtxLmluZGV4PnY/KEI9cSxxPW51bGwpOkI9cS5zaWJsaW5nO3ZhciB0PXcoZSxxLGhbdl0sayk7aWYobnVsbD09PXQpe251bGw9PT1xJiYocT1CKTticmVha31hJiZcbnEmJm51bGw9PT10LmFsdGVybmF0ZSYmYihlLHEpO2c9Zih0LGcsdik7bnVsbD09PW0/bD10Om0uc2libGluZz10O209dDtxPUJ9aWYodj09PWgubGVuZ3RoKXJldHVybiBjKGUscSksbDtpZihudWxsPT09cSl7Zm9yKDt2PGgubGVuZ3RoO3YrKylpZihxPXAoZSxoW3ZdLGspKWc9ZihxLGcsdiksbnVsbD09PW0/bD1xOm0uc2libGluZz1xLG09cTtyZXR1cm4gbH1mb3IocT1kKGUscSk7djxoLmxlbmd0aDt2KyspaWYoQj1FKHEsZSx2LGhbdl0saykpYSYmbnVsbCE9PUIuYWx0ZXJuYXRlJiZxLmRlbGV0ZShudWxsPT09Qi5rZXk/djpCLmtleSksZz1mKEIsZyx2KSxudWxsPT09bT9sPUI6bS5zaWJsaW5nPUIsbT1CO2EmJnEuZm9yRWFjaChmdW5jdGlvbihhKXtyZXR1cm4gYihlLGEpfSk7cmV0dXJuIGx9ZnVuY3Rpb24gRihlLGcsaCxrKXt2YXIgbD16YyhoKTtcImZ1bmN0aW9uXCIhPT10eXBlb2YgbD9yKFwiMTUwXCIpOnZvaWQgMDtoPWwuY2FsbChoKTtudWxsPT1oP3IoXCIxNTFcIik6dm9pZCAwO1xuZm9yKHZhciBtPWw9bnVsbCxxPWcsdj1nPTAsQj1udWxsLHQ9aC5uZXh0KCk7bnVsbCE9PXEmJiF0LmRvbmU7disrLHQ9aC5uZXh0KCkpe3EuaW5kZXg+dj8oQj1xLHE9bnVsbCk6Qj1xLnNpYmxpbmc7dmFyIHg9dyhlLHEsdC52YWx1ZSxrKTtpZihudWxsPT09eCl7cXx8KHE9Qik7YnJlYWt9YSYmcSYmbnVsbD09PXguYWx0ZXJuYXRlJiZiKGUscSk7Zz1mKHgsZyx2KTtudWxsPT09bT9sPXg6bS5zaWJsaW5nPXg7bT14O3E9Qn1pZih0LmRvbmUpcmV0dXJuIGMoZSxxKSxsO2lmKG51bGw9PT1xKXtmb3IoOyF0LmRvbmU7disrLHQ9aC5uZXh0KCkpdD1wKGUsdC52YWx1ZSxrKSxudWxsIT09dCYmKGc9Zih0LGcsdiksbnVsbD09PW0/bD10Om0uc2libGluZz10LG09dCk7cmV0dXJuIGx9Zm9yKHE9ZChlLHEpOyF0LmRvbmU7disrLHQ9aC5uZXh0KCkpdD1FKHEsZSx2LHQudmFsdWUsayksbnVsbCE9PXQmJihhJiZudWxsIT09dC5hbHRlcm5hdGUmJnEuZGVsZXRlKG51bGw9PT10LmtleT92OlxudC5rZXkpLGc9Zih0LGcsdiksbnVsbD09PW0/bD10Om0uc2libGluZz10LG09dCk7YSYmcS5mb3JFYWNoKGZ1bmN0aW9uKGEpe3JldHVybiBiKGUsYSl9KTtyZXR1cm4gbH1yZXR1cm4gZnVuY3Rpb24oYSxkLGYsaCl7dmFyIGs9XCJvYmplY3RcIj09PXR5cGVvZiBmJiZudWxsIT09ZiYmZi50eXBlPT09b2MmJm51bGw9PT1mLmtleTtrJiYoZj1mLnByb3BzLmNoaWxkcmVuKTt2YXIgbD1cIm9iamVjdFwiPT09dHlwZW9mIGYmJm51bGwhPT1mO2lmKGwpc3dpdGNoKGYuJCR0eXBlb2Ype2Nhc2UgbWM6YTp7bD1mLmtleTtmb3Ioaz1kO251bGwhPT1rOyl7aWYoay5rZXk9PT1sKWlmKDc9PT1rLnRhZz9mLnR5cGU9PT1vYzprLmVsZW1lbnRUeXBlPT09Zi50eXBlKXtjKGEsay5zaWJsaW5nKTtkPWUoayxmLnR5cGU9PT1vYz9mLnByb3BzLmNoaWxkcmVuOmYucHJvcHMsaCk7ZC5yZWY9ZWgoYSxrLGYpO2QucmV0dXJuPWE7YT1kO2JyZWFrIGF9ZWxzZXtjKGEsayk7YnJlYWt9ZWxzZSBiKGEsayk7az1cbmsuc2libGluZ31mLnR5cGU9PT1vYz8oZD1NZihmLnByb3BzLmNoaWxkcmVuLGEubW9kZSxoLGYua2V5KSxkLnJldHVybj1hLGE9ZCk6KGg9TGYoZi50eXBlLGYua2V5LGYucHJvcHMsbnVsbCxhLm1vZGUsaCksaC5yZWY9ZWgoYSxkLGYpLGgucmV0dXJuPWEsYT1oKX1yZXR1cm4gZyhhKTtjYXNlIG5jOmE6e2ZvcihrPWYua2V5O251bGwhPT1kOyl7aWYoZC5rZXk9PT1rKWlmKDQ9PT1kLnRhZyYmZC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbz09PWYuY29udGFpbmVySW5mbyYmZC5zdGF0ZU5vZGUuaW1wbGVtZW50YXRpb249PT1mLmltcGxlbWVudGF0aW9uKXtjKGEsZC5zaWJsaW5nKTtkPWUoZCxmLmNoaWxkcmVufHxbXSxoKTtkLnJldHVybj1hO2E9ZDticmVhayBhfWVsc2V7YyhhLGQpO2JyZWFrfWVsc2UgYihhLGQpO2Q9ZC5zaWJsaW5nfWQ9UGYoZixhLm1vZGUsaCk7ZC5yZXR1cm49YTthPWR9cmV0dXJuIGcoYSl9aWYoXCJzdHJpbmdcIj09PXR5cGVvZiBmfHxcIm51bWJlclwiPT09dHlwZW9mIGYpcmV0dXJuIGY9XG5cIlwiK2YsbnVsbCE9PWQmJjY9PT1kLnRhZz8oYyhhLGQuc2libGluZyksZD1lKGQsZixoKSxkLnJldHVybj1hLGE9ZCk6KGMoYSxkKSxkPU9mKGYsYS5tb2RlLGgpLGQucmV0dXJuPWEsYT1kKSxnKGEpO2lmKGRoKGYpKXJldHVybiB4KGEsZCxmLGgpO2lmKHpjKGYpKXJldHVybiBGKGEsZCxmLGgpO2wmJmZoKGEsZik7aWYoXCJ1bmRlZmluZWRcIj09PXR5cGVvZiBmJiYhaylzd2l0Y2goYS50YWcpe2Nhc2UgMTpjYXNlIDA6aD1hLnR5cGUscihcIjE1MlwiLGguZGlzcGxheU5hbWV8fGgubmFtZXx8XCJDb21wb25lbnRcIil9cmV0dXJuIGMoYSxkKX19dmFyIGhoPWdoKCEwKSxpaD1naCghMSksamg9bnVsbCxraD1udWxsLGxoPSExO1xuZnVuY3Rpb24gbWgoYSxiKXt2YXIgYz1OKDUsbnVsbCxudWxsLDApO2MuZWxlbWVudFR5cGU9XCJERUxFVEVEXCI7Yy50eXBlPVwiREVMRVRFRFwiO2Muc3RhdGVOb2RlPWI7Yy5yZXR1cm49YTtjLmVmZmVjdFRhZz04O251bGwhPT1hLmxhc3RFZmZlY3Q/KGEubGFzdEVmZmVjdC5uZXh0RWZmZWN0PWMsYS5sYXN0RWZmZWN0PWMpOmEuZmlyc3RFZmZlY3Q9YS5sYXN0RWZmZWN0PWN9ZnVuY3Rpb24gbmgoYSxiKXtzd2l0Y2goYS50YWcpe2Nhc2UgNTp2YXIgYz1hLnR5cGU7Yj0xIT09Yi5ub2RlVHlwZXx8Yy50b0xvd2VyQ2FzZSgpIT09Yi5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpP251bGw6YjtyZXR1cm4gbnVsbCE9PWI/KGEuc3RhdGVOb2RlPWIsITApOiExO2Nhc2UgNjpyZXR1cm4gYj1cIlwiPT09YS5wZW5kaW5nUHJvcHN8fDMhPT1iLm5vZGVUeXBlP251bGw6YixudWxsIT09Yj8oYS5zdGF0ZU5vZGU9YiwhMCk6ITE7ZGVmYXVsdDpyZXR1cm4hMX19XG5mdW5jdGlvbiBvaChhKXtpZihsaCl7dmFyIGI9a2g7aWYoYil7dmFyIGM9YjtpZighbmgoYSxiKSl7Yj1xZihjKTtpZighYnx8IW5oKGEsYikpe2EuZWZmZWN0VGFnfD0yO2xoPSExO2poPWE7cmV0dXJufW1oKGpoLGMpfWpoPWE7a2g9cmYoYil9ZWxzZSBhLmVmZmVjdFRhZ3w9MixsaD0hMSxqaD1hfX1mdW5jdGlvbiBwaChhKXtmb3IoYT1hLnJldHVybjtudWxsIT09YSYmNSE9PWEudGFnJiYzIT09YS50YWc7KWE9YS5yZXR1cm47amg9YX1mdW5jdGlvbiBxaChhKXtpZihhIT09amgpcmV0dXJuITE7aWYoIWxoKXJldHVybiBwaChhKSxsaD0hMCwhMTt2YXIgYj1hLnR5cGU7aWYoNSE9PWEudGFnfHxcImhlYWRcIiE9PWImJlwiYm9keVwiIT09YiYmIW5mKGIsYS5tZW1vaXplZFByb3BzKSlmb3IoYj1raDtiOyltaChhLGIpLGI9cWYoYik7cGgoYSk7a2g9amg/cWYoYS5zdGF0ZU5vZGUpOm51bGw7cmV0dXJuITB9ZnVuY3Rpb24gcmgoKXtraD1qaD1udWxsO2xoPSExfVxuZnVuY3Rpb24gc2goYSl7dmFyIGI9YS5fcmVzdWx0O3N3aXRjaChhLl9zdGF0dXMpe2Nhc2UgMTpyZXR1cm4gYjtjYXNlIDI6dGhyb3cgYjtjYXNlIDA6dGhyb3cgYjtkZWZhdWx0OnRocm93IGEuX3N0YXR1cz0wLGI9YS5fY3RvcixiPWIoKSxiLnRoZW4oZnVuY3Rpb24oYil7MD09PWEuX3N0YXR1cyYmKGI9Yi5kZWZhdWx0LGEuX3N0YXR1cz0xLGEuX3Jlc3VsdD1iKX0sZnVuY3Rpb24oYil7MD09PWEuX3N0YXR1cyYmKGEuX3N0YXR1cz0yLGEuX3Jlc3VsdD1iKX0pLGEuX3Jlc3VsdD1iLGI7fX12YXIgdGg9a2MuUmVhY3RDdXJyZW50T3duZXI7ZnVuY3Rpb24gUyhhLGIsYyxkKXtiLmNoaWxkPW51bGw9PT1hP2loKGIsbnVsbCxjLGQpOmhoKGIsYS5jaGlsZCxjLGQpfVxuZnVuY3Rpb24gdWgoYSxiLGMsZCxlKXtjPWMucmVuZGVyO3ZhciBmPWIucmVmO21nKGIsZSk7b2c9ZTtPPWI7cGc9bnVsbCE9PWE/YS5tZW1vaXplZFN0YXRlOm51bGw7dmFyIGc9YyhkLGYpO2c9eGcoYyxkLGcsZik7Yi5lZmZlY3RUYWd8PTE7UyhhLGIsZyxlKTtyZXR1cm4gYi5jaGlsZH1cbmZ1bmN0aW9uIHZoKGEsYixjLGQsZSxmKXtpZihudWxsPT09YSl7dmFyIGc9Yy50eXBlO2lmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiBnJiYhSWYoZykmJnZvaWQgMD09PWcuZGVmYXVsdFByb3BzJiZudWxsPT09Yy5jb21wYXJlKXJldHVybiBiLnRhZz0xNSxiLnR5cGU9Zyx3aChhLGIsZyxkLGUsZik7YT1MZihjLnR5cGUsbnVsbCxkLG51bGwsYi5tb2RlLGYpO2EucmVmPWIucmVmO2EucmV0dXJuPWI7cmV0dXJuIGIuY2hpbGQ9YX1nPWEuY2hpbGQ7aWYoMD09PWV8fGU+ZilpZihlPWcubWVtb2l6ZWRQcm9wcyxjPWMuY29tcGFyZSxjPW51bGwhPT1jP2M6RmQsYyhlLGQpJiZhLnJlZj09PWIucmVmKXJldHVybiB4aChhLGIsZik7YT1LZihnLGQsZik7YS5yZWY9Yi5yZWY7YS5yZXR1cm49YjtyZXR1cm4gYi5jaGlsZD1hfVxuZnVuY3Rpb24gd2goYSxiLGMsZCxlLGYpe3JldHVybiBudWxsIT09YSYmKDA9PT1lfHxlPmYpJiZGZChhLm1lbW9pemVkUHJvcHMsZCkmJmEucmVmPT09Yi5yZWY/eGgoYSxiLGYpOnloKGEsYixjLGQsZil9ZnVuY3Rpb24gemgoYSxiKXt2YXIgYz1iLnJlZjtpZihudWxsPT09YSYmbnVsbCE9PWN8fG51bGwhPT1hJiZhLnJlZiE9PWMpYi5lZmZlY3RUYWd8PTEyOH1mdW5jdGlvbiB5aChhLGIsYyxkLGUpe3ZhciBmPU0oYyk/dmY6Sy5jdXJyZW50O2Y9d2YoYixmKTttZyhiLGUpO29nPWU7Tz1iO3BnPW51bGwhPT1hP2EubWVtb2l6ZWRTdGF0ZTpudWxsO3ZhciBnPWMoZCxmKTtnPXhnKGMsZCxnLGYpO2IuZWZmZWN0VGFnfD0xO1MoYSxiLGcsZSk7cmV0dXJuIGIuY2hpbGR9XG5mdW5jdGlvbiBBaChhLGIsYyxkLGUpe2lmKE0oYykpe3ZhciBmPSEwO0JmKGIpfWVsc2UgZj0hMTttZyhiLGUpO2lmKG51bGw9PT1iLnN0YXRlTm9kZSludWxsIT09YSYmKGEuYWx0ZXJuYXRlPW51bGwsYi5hbHRlcm5hdGU9bnVsbCxiLmVmZmVjdFRhZ3w9MiksYWgoYixjLGQsZSksY2goYixjLGQsZSksZD0hMDtlbHNlIGlmKG51bGw9PT1hKXt2YXIgZz1iLnN0YXRlTm9kZSxoPWIubWVtb2l6ZWRQcm9wcztnLnByb3BzPWg7dmFyIGs9Zy5jb250ZXh0LGw9Yy5jb250ZXh0VHlwZTtcIm9iamVjdFwiPT09dHlwZW9mIGwmJm51bGwhPT1sP2w9V2cuY3VycmVudERpc3BhdGNoZXIucmVhZENvbnRleHQobCk6KGw9TShjKT92ZjpLLmN1cnJlbnQsbD13ZihiLGwpKTt2YXIgbT1jLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyxwPVwiZnVuY3Rpb25cIj09PXR5cGVvZiBtfHxcImZ1bmN0aW9uXCI9PT10eXBlb2YgZy5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZTtwfHxcImZ1bmN0aW9uXCIhPT10eXBlb2YgZy5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyYmXG5cImZ1bmN0aW9uXCIhPT10eXBlb2YgZy5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzfHwoaCE9PWR8fGshPT1sKSYmYmgoYixnLGQsbCk7VWY9ITE7dmFyIHc9Yi5tZW1vaXplZFN0YXRlO2s9Zy5zdGF0ZT13O3ZhciBFPWIudXBkYXRlUXVldWU7bnVsbCE9PUUmJihjZyhiLEUsZCxnLGUpLGs9Yi5tZW1vaXplZFN0YXRlKTtoIT09ZHx8dyE9PWt8fEwuY3VycmVudHx8VWY/KFwiZnVuY3Rpb25cIj09PXR5cGVvZiBtJiYoWWcoYixjLG0sZCksaz1iLm1lbW9pemVkU3RhdGUpLChoPVVmfHwkZyhiLGMsaCxkLHcsayxsKSk/KHB8fFwiZnVuY3Rpb25cIiE9PXR5cGVvZiBnLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQmJlwiZnVuY3Rpb25cIiE9PXR5cGVvZiBnLmNvbXBvbmVudFdpbGxNb3VudHx8KFwiZnVuY3Rpb25cIj09PXR5cGVvZiBnLmNvbXBvbmVudFdpbGxNb3VudCYmZy5jb21wb25lbnRXaWxsTW91bnQoKSxcImZ1bmN0aW9uXCI9PT10eXBlb2YgZy5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50JiZcbmcuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCgpKSxcImZ1bmN0aW9uXCI9PT10eXBlb2YgZy5jb21wb25lbnREaWRNb3VudCYmKGIuZWZmZWN0VGFnfD00KSk6KFwiZnVuY3Rpb25cIj09PXR5cGVvZiBnLmNvbXBvbmVudERpZE1vdW50JiYoYi5lZmZlY3RUYWd8PTQpLGIubWVtb2l6ZWRQcm9wcz1kLGIubWVtb2l6ZWRTdGF0ZT1rKSxnLnByb3BzPWQsZy5zdGF0ZT1rLGcuY29udGV4dD1sLGQ9aCk6KFwiZnVuY3Rpb25cIj09PXR5cGVvZiBnLmNvbXBvbmVudERpZE1vdW50JiYoYi5lZmZlY3RUYWd8PTQpLGQ9ITEpfWVsc2UgZz1iLnN0YXRlTm9kZSxoPWIubWVtb2l6ZWRQcm9wcyxnLnByb3BzPWgsaz1nLmNvbnRleHQsbD1jLmNvbnRleHRUeXBlLFwib2JqZWN0XCI9PT10eXBlb2YgbCYmbnVsbCE9PWw/bD1XZy5jdXJyZW50RGlzcGF0Y2hlci5yZWFkQ29udGV4dChsKToobD1NKGMpP3ZmOksuY3VycmVudCxsPXdmKGIsbCkpLG09Yy5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMsKHA9XCJmdW5jdGlvblwiPT09XG50eXBlb2YgbXx8XCJmdW5jdGlvblwiPT09dHlwZW9mIGcuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUpfHxcImZ1bmN0aW9uXCIhPT10eXBlb2YgZy5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyYmXCJmdW5jdGlvblwiIT09dHlwZW9mIGcuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc3x8KGghPT1kfHxrIT09bCkmJmJoKGIsZyxkLGwpLFVmPSExLGs9Yi5tZW1vaXplZFN0YXRlLHc9Zy5zdGF0ZT1rLEU9Yi51cGRhdGVRdWV1ZSxudWxsIT09RSYmKGNnKGIsRSxkLGcsZSksdz1iLm1lbW9pemVkU3RhdGUpLGghPT1kfHxrIT09d3x8TC5jdXJyZW50fHxVZj8oXCJmdW5jdGlvblwiPT09dHlwZW9mIG0mJihZZyhiLGMsbSxkKSx3PWIubWVtb2l6ZWRTdGF0ZSksKG09VWZ8fCRnKGIsYyxoLGQsayx3LGwpKT8ocHx8XCJmdW5jdGlvblwiIT09dHlwZW9mIGcuVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUmJlwiZnVuY3Rpb25cIiE9PXR5cGVvZiBnLmNvbXBvbmVudFdpbGxVcGRhdGV8fChcImZ1bmN0aW9uXCI9PT1cbnR5cGVvZiBnLmNvbXBvbmVudFdpbGxVcGRhdGUmJmcuY29tcG9uZW50V2lsbFVwZGF0ZShkLHcsbCksXCJmdW5jdGlvblwiPT09dHlwZW9mIGcuVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUmJmcuVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUoZCx3LGwpKSxcImZ1bmN0aW9uXCI9PT10eXBlb2YgZy5jb21wb25lbnREaWRVcGRhdGUmJihiLmVmZmVjdFRhZ3w9NCksXCJmdW5jdGlvblwiPT09dHlwZW9mIGcuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUmJihiLmVmZmVjdFRhZ3w9MjU2KSk6KFwiZnVuY3Rpb25cIiE9PXR5cGVvZiBnLmNvbXBvbmVudERpZFVwZGF0ZXx8aD09PWEubWVtb2l6ZWRQcm9wcyYmaz09PWEubWVtb2l6ZWRTdGF0ZXx8KGIuZWZmZWN0VGFnfD00KSxcImZ1bmN0aW9uXCIhPT10eXBlb2YgZy5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZXx8aD09PWEubWVtb2l6ZWRQcm9wcyYmaz09PWEubWVtb2l6ZWRTdGF0ZXx8KGIuZWZmZWN0VGFnfD0yNTYpLGIubWVtb2l6ZWRQcm9wcz1kLGIubWVtb2l6ZWRTdGF0ZT1cbncpLGcucHJvcHM9ZCxnLnN0YXRlPXcsZy5jb250ZXh0PWwsZD1tKTooXCJmdW5jdGlvblwiIT09dHlwZW9mIGcuY29tcG9uZW50RGlkVXBkYXRlfHxoPT09YS5tZW1vaXplZFByb3BzJiZrPT09YS5tZW1vaXplZFN0YXRlfHwoYi5lZmZlY3RUYWd8PTQpLFwiZnVuY3Rpb25cIiE9PXR5cGVvZiBnLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlfHxoPT09YS5tZW1vaXplZFByb3BzJiZrPT09YS5tZW1vaXplZFN0YXRlfHwoYi5lZmZlY3RUYWd8PTI1NiksZD0hMSk7cmV0dXJuIEJoKGEsYixjLGQsZixlKX1cbmZ1bmN0aW9uIEJoKGEsYixjLGQsZSxmKXt6aChhLGIpO3ZhciBnPTAhPT0oYi5lZmZlY3RUYWcmNjQpO2lmKCFkJiYhZylyZXR1cm4gZSYmQ2YoYixjLCExKSx4aChhLGIsZik7ZD1iLnN0YXRlTm9kZTt0aC5jdXJyZW50PWI7dmFyIGg9ZyYmXCJmdW5jdGlvblwiIT09dHlwZW9mIGMuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yP251bGw6ZC5yZW5kZXIoKTtiLmVmZmVjdFRhZ3w9MTtudWxsIT09YSYmZz8oYi5jaGlsZD1oaChiLGEuY2hpbGQsbnVsbCxmKSxiLmNoaWxkPWhoKGIsbnVsbCxoLGYpKTpTKGEsYixoLGYpO2IubWVtb2l6ZWRTdGF0ZT1kLnN0YXRlO2UmJkNmKGIsYywhMCk7cmV0dXJuIGIuY2hpbGR9ZnVuY3Rpb24gQ2goYSl7dmFyIGI9YS5zdGF0ZU5vZGU7Yi5wZW5kaW5nQ29udGV4dD96ZihhLGIucGVuZGluZ0NvbnRleHQsYi5wZW5kaW5nQ29udGV4dCE9PWIuY29udGV4dCk6Yi5jb250ZXh0JiZ6ZihhLGIuY29udGV4dCwhMSk7U2coYSxiLmNvbnRhaW5lckluZm8pfVxuZnVuY3Rpb24gRGgoYSxiKXtpZihhJiZhLmRlZmF1bHRQcm9wcyl7Yj1uKHt9LGIpO2E9YS5kZWZhdWx0UHJvcHM7Zm9yKHZhciBjIGluIGEpdm9pZCAwPT09YltjXSYmKGJbY109YVtjXSl9cmV0dXJuIGJ9XG5mdW5jdGlvbiBFaChhLGIsYyl7dmFyIGQ9Yi5tb2RlLGU9Yi5wZW5kaW5nUHJvcHMsZj1iLm1lbW9pemVkU3RhdGU7bnVsbCE9PWYmJihmLmFscmVhZHlDYXB0dXJlZD9udWxsIT09YSYmZj09PWEubWVtb2l6ZWRTdGF0ZT9mPXthbHJlYWR5Q2FwdHVyZWQ6ITAsZGlkVGltZW91dDohMCx0aW1lZE91dEF0OmYudGltZWRPdXRBdH06KGYuYWxyZWFkeUNhcHR1cmVkPSEwLGYuZGlkVGltZW91dD0hMCk6Zj1udWxsKTt2YXIgZz1udWxsIT09ZiYmZi5kaWRUaW1lb3V0O2lmKG51bGw9PT1hKWc/KGc9ZS5mYWxsYmFjayxlPU1mKG51bGwsZCwwLG51bGwpLGQ9TWYoZyxkLGMsbnVsbCksZS5zaWJsaW5nPWQsYz1lLGMucmV0dXJuPWQucmV0dXJuPWIpOmM9ZD1paChiLG51bGwsZS5jaGlsZHJlbixjKTtlbHNle3ZhciBoPWEubWVtb2l6ZWRTdGF0ZTtudWxsIT09aCYmaC5kaWRUaW1lb3V0PyhkPWEuY2hpbGQsYT1kLnNpYmxpbmcsZz8oYz1lLmZhbGxiYWNrLGQ9S2YoZCxkLnBlbmRpbmdQcm9wcyxcbjApLGQuZWZmZWN0VGFnfD0yLGU9ZC5zaWJsaW5nPUtmKGEsYyxhLmV4cGlyYXRpb25UaW1lKSxlLmVmZmVjdFRhZ3w9MixjPWQsZC5jaGlsZEV4cGlyYXRpb25UaW1lPTAsZD1lLGMucmV0dXJuPWQucmV0dXJuPWIpOihnPWEuY2hpbGQsZD1oaChiLGQuY2hpbGQsZS5jaGlsZHJlbixjKSxoaChiLGcsbnVsbCxjKSxjPWQpKTooYT1hLmNoaWxkLGc/KGc9ZS5mYWxsYmFjayxlPU1mKG51bGwsZCwwLG51bGwpLGUuZWZmZWN0VGFnfD0yLGUuY2hpbGQ9YSxhLnJldHVybj1lLGQ9ZS5zaWJsaW5nPU1mKGcsZCxjLG51bGwpLGQuZWZmZWN0VGFnfD0yLGM9ZSxlLmNoaWxkRXhwaXJhdGlvblRpbWU9MCxjLnJldHVybj1kLnJldHVybj1iKTpkPWM9aGgoYixhLGUuY2hpbGRyZW4sYykpfWIubWVtb2l6ZWRTdGF0ZT1mO2IuY2hpbGQ9YztyZXR1cm4gZH1cbmZ1bmN0aW9uIHhoKGEsYixjKXtudWxsIT09YSYmKGIuZmlyc3RDb250ZXh0RGVwZW5kZW5jeT1hLmZpcnN0Q29udGV4dERlcGVuZGVuY3kpO3ZhciBkPWIuY2hpbGRFeHBpcmF0aW9uVGltZTtpZigwPT09ZHx8ZD5jKXJldHVybiBudWxsO251bGwhPT1hJiZiLmNoaWxkIT09YS5jaGlsZD9yKFwiMTUzXCIpOnZvaWQgMDtpZihudWxsIT09Yi5jaGlsZCl7YT1iLmNoaWxkO2M9S2YoYSxhLnBlbmRpbmdQcm9wcyxhLmV4cGlyYXRpb25UaW1lKTtiLmNoaWxkPWM7Zm9yKGMucmV0dXJuPWI7bnVsbCE9PWEuc2libGluZzspYT1hLnNpYmxpbmcsYz1jLnNpYmxpbmc9S2YoYSxhLnBlbmRpbmdQcm9wcyxhLmV4cGlyYXRpb25UaW1lKSxjLnJldHVybj1iO2Muc2libGluZz1udWxsfXJldHVybiBiLmNoaWxkfVxuZnVuY3Rpb24gRmgoYSxiLGMpe3ZhciBkPWIuZXhwaXJhdGlvblRpbWU7aWYobnVsbCE9PWEmJmEubWVtb2l6ZWRQcm9wcz09PWIucGVuZGluZ1Byb3BzJiYhTC5jdXJyZW50JiYoMD09PWR8fGQ+Yykpe3N3aXRjaChiLnRhZyl7Y2FzZSAzOkNoKGIpO3JoKCk7YnJlYWs7Y2FzZSA1OlVnKGIpO2JyZWFrO2Nhc2UgMTpNKGIudHlwZSkmJkJmKGIpO2JyZWFrO2Nhc2UgNDpTZyhiLGIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8pO2JyZWFrO2Nhc2UgMTA6a2coYixiLm1lbW9pemVkUHJvcHMudmFsdWUpO2JyZWFrO2Nhc2UgMTM6aWYoZD1iLm1lbW9pemVkU3RhdGUsbnVsbCE9PWQmJmQuZGlkVGltZW91dCl7ZD1iLmNoaWxkLmNoaWxkRXhwaXJhdGlvblRpbWU7aWYoMCE9PWQmJmQ8PWMpcmV0dXJuIEVoKGEsYixjKTtiPXhoKGEsYixjKTtyZXR1cm4gbnVsbCE9PWI/Yi5zaWJsaW5nOm51bGx9fXJldHVybiB4aChhLGIsYyl9Yi5leHBpcmF0aW9uVGltZT0wO3N3aXRjaChiLnRhZyl7Y2FzZSAyOmQ9XG5iLmVsZW1lbnRUeXBlO251bGwhPT1hJiYoYS5hbHRlcm5hdGU9bnVsbCxiLmFsdGVybmF0ZT1udWxsLGIuZWZmZWN0VGFnfD0yKTthPWIucGVuZGluZ1Byb3BzO3ZhciBlPXdmKGIsSy5jdXJyZW50KTttZyhiLGMpO29nPWM7Tz1iO3BnPW51bGw7dmFyIGY9ZChhLGUpO2IuZWZmZWN0VGFnfD0xO2lmKFwib2JqZWN0XCI9PT10eXBlb2YgZiYmbnVsbCE9PWYmJlwiZnVuY3Rpb25cIj09PXR5cGVvZiBmLnJlbmRlciYmdm9pZCAwPT09Zi4kJHR5cGVvZil7Yi50YWc9MTt5ZygpO00oZCk/KGU9ITAsQmYoYikpOmU9ITE7Yi5tZW1vaXplZFN0YXRlPW51bGwhPT1mLnN0YXRlJiZ2b2lkIDAhPT1mLnN0YXRlP2Yuc3RhdGU6bnVsbDt2YXIgZz1kLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcztcImZ1bmN0aW9uXCI9PT10eXBlb2YgZyYmWWcoYixkLGcsYSk7Zi51cGRhdGVyPVpnO2Iuc3RhdGVOb2RlPWY7Zi5fcmVhY3RJbnRlcm5hbEZpYmVyPWI7Y2goYixkLGEsYyk7Yj1CaChudWxsLGIsZCwhMCxlLGMpfWVsc2UgYi50YWc9XG4wLGY9eGcoZCxhLGYsZSksUyhudWxsLGIsZixjKSxiPWIuY2hpbGQ7cmV0dXJuIGI7Y2FzZSAxNjpmPWIuZWxlbWVudFR5cGU7bnVsbCE9PWEmJihhLmFsdGVybmF0ZT1udWxsLGIuYWx0ZXJuYXRlPW51bGwsYi5lZmZlY3RUYWd8PTIpO2U9Yi5wZW5kaW5nUHJvcHM7YT1zaChmKTtiLnR5cGU9YTtmPWIudGFnPUpmKGEpO2U9RGgoYSxlKTtnPXZvaWQgMDtzd2l0Y2goZil7Y2FzZSAwOmc9eWgobnVsbCxiLGEsZSxjKTticmVhaztjYXNlIDE6Zz1BaChudWxsLGIsYSxlLGMpO2JyZWFrO2Nhc2UgMTE6Zz11aChudWxsLGIsYSxlLGMpO2JyZWFrO2Nhc2UgMTQ6Zz12aChudWxsLGIsYSxEaChhLnR5cGUsZSksZCxjKTticmVhaztkZWZhdWx0OnIoXCIyODNcIixhKX1yZXR1cm4gZztjYXNlIDA6cmV0dXJuIGQ9Yi50eXBlLGY9Yi5wZW5kaW5nUHJvcHMsZj1iLmVsZW1lbnRUeXBlPT09ZD9mOkRoKGQsZikseWgoYSxiLGQsZixjKTtjYXNlIDE6cmV0dXJuIGQ9Yi50eXBlLGY9Yi5wZW5kaW5nUHJvcHMsXG5mPWIuZWxlbWVudFR5cGU9PT1kP2Y6RGgoZCxmKSxBaChhLGIsZCxmLGMpO2Nhc2UgMzpDaChiKTtkPWIudXBkYXRlUXVldWU7bnVsbD09PWQ/cihcIjI4MlwiKTp2b2lkIDA7Zj1iLm1lbW9pemVkU3RhdGU7Zj1udWxsIT09Zj9mLmVsZW1lbnQ6bnVsbDtjZyhiLGQsYi5wZW5kaW5nUHJvcHMsbnVsbCxjKTtkPWIubWVtb2l6ZWRTdGF0ZS5lbGVtZW50O2lmKGQ9PT1mKXJoKCksYj14aChhLGIsYyk7ZWxzZXtmPWIuc3RhdGVOb2RlO2lmKGY9KG51bGw9PT1hfHxudWxsPT09YS5jaGlsZCkmJmYuaHlkcmF0ZSlraD1yZihiLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKSxqaD1iLGY9bGg9ITA7Zj8oYi5lZmZlY3RUYWd8PTIsYi5jaGlsZD1paChiLG51bGwsZCxjKSk6KFMoYSxiLGQsYykscmgoKSk7Yj1iLmNoaWxkfXJldHVybiBiO2Nhc2UgNTpyZXR1cm4gVWcoYiksbnVsbD09PWEmJm9oKGIpLGQ9Yi50eXBlLGY9Yi5wZW5kaW5nUHJvcHMsZT1udWxsIT09YT9hLm1lbW9pemVkUHJvcHM6bnVsbCxcbmc9Zi5jaGlsZHJlbixuZihkLGYpP2c9bnVsbDpudWxsIT09ZSYmbmYoZCxlKSYmKGIuZWZmZWN0VGFnfD0xNiksemgoYSxiKSwxMDczNzQxODIzIT09YyYmYi5tb2RlJjEmJmYuaGlkZGVuPyhiLmV4cGlyYXRpb25UaW1lPTEwNzM3NDE4MjMsYj1udWxsKTooUyhhLGIsZyxjKSxiPWIuY2hpbGQpLGI7Y2FzZSA2OnJldHVybiBudWxsPT09YSYmb2goYiksbnVsbDtjYXNlIDEzOnJldHVybiBFaChhLGIsYyk7Y2FzZSA0OnJldHVybiBTZyhiLGIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8pLGQ9Yi5wZW5kaW5nUHJvcHMsbnVsbD09PWE/Yi5jaGlsZD1oaChiLG51bGwsZCxjKTpTKGEsYixkLGMpLGIuY2hpbGQ7Y2FzZSAxMTpyZXR1cm4gZD1iLnR5cGUsZj1iLnBlbmRpbmdQcm9wcyxmPWIuZWxlbWVudFR5cGU9PT1kP2Y6RGgoZCxmKSx1aChhLGIsZCxmLGMpO2Nhc2UgNzpyZXR1cm4gUyhhLGIsYi5wZW5kaW5nUHJvcHMsYyksYi5jaGlsZDtjYXNlIDg6cmV0dXJuIFMoYSxiLGIucGVuZGluZ1Byb3BzLmNoaWxkcmVuLFxuYyksYi5jaGlsZDtjYXNlIDEyOnJldHVybiBTKGEsYixiLnBlbmRpbmdQcm9wcy5jaGlsZHJlbixjKSxiLmNoaWxkO2Nhc2UgMTA6YTp7ZD1iLnR5cGUuX2NvbnRleHQ7Zj1iLnBlbmRpbmdQcm9wcztnPWIubWVtb2l6ZWRQcm9wcztlPWYudmFsdWU7a2coYixlKTtpZihudWxsIT09Zyl7dmFyIGg9Zy52YWx1ZTtlPWg9PT1lJiYoMCE9PWh8fDEvaD09PTEvZSl8fGghPT1oJiZlIT09ZT8wOihcImZ1bmN0aW9uXCI9PT10eXBlb2YgZC5fY2FsY3VsYXRlQ2hhbmdlZEJpdHM/ZC5fY2FsY3VsYXRlQ2hhbmdlZEJpdHMoaCxlKToxMDczNzQxODIzKXwwO2lmKDA9PT1lKXtpZihnLmNoaWxkcmVuPT09Zi5jaGlsZHJlbiYmIUwuY3VycmVudCl7Yj14aChhLGIsYyk7YnJlYWsgYX19ZWxzZSBmb3IoZz1iLmNoaWxkLG51bGwhPT1nJiYoZy5yZXR1cm49Yik7bnVsbCE9PWc7KXtoPWcuZmlyc3RDb250ZXh0RGVwZW5kZW5jeTtpZihudWxsIT09aCl7ZG97aWYoaC5jb250ZXh0PT09ZCYmMCE9PShoLm9ic2VydmVkQml0cyZcbmUpKXtpZigxPT09Zy50YWcpe3ZhciBrPVhmKGMpO2sudGFnPTI7WmYoZyxrKX1pZigwPT09Zy5leHBpcmF0aW9uVGltZXx8Zy5leHBpcmF0aW9uVGltZT5jKWcuZXhwaXJhdGlvblRpbWU9YztrPWcuYWx0ZXJuYXRlO251bGwhPT1rJiYoMD09PWsuZXhwaXJhdGlvblRpbWV8fGsuZXhwaXJhdGlvblRpbWU+YykmJihrLmV4cGlyYXRpb25UaW1lPWMpO2Zvcih2YXIgbD1nLnJldHVybjtudWxsIT09bDspe2s9bC5hbHRlcm5hdGU7aWYoMD09PWwuY2hpbGRFeHBpcmF0aW9uVGltZXx8bC5jaGlsZEV4cGlyYXRpb25UaW1lPmMpbC5jaGlsZEV4cGlyYXRpb25UaW1lPWMsbnVsbCE9PWsmJigwPT09ay5jaGlsZEV4cGlyYXRpb25UaW1lfHxrLmNoaWxkRXhwaXJhdGlvblRpbWU+YykmJihrLmNoaWxkRXhwaXJhdGlvblRpbWU9Yyk7ZWxzZSBpZihudWxsIT09ayYmKDA9PT1rLmNoaWxkRXhwaXJhdGlvblRpbWV8fGsuY2hpbGRFeHBpcmF0aW9uVGltZT5jKSlrLmNoaWxkRXhwaXJhdGlvblRpbWU9XG5jO2Vsc2UgYnJlYWs7bD1sLnJldHVybn19az1nLmNoaWxkO2g9aC5uZXh0fXdoaWxlKG51bGwhPT1oKX1lbHNlIGs9MTA9PT1nLnRhZz9nLnR5cGU9PT1iLnR5cGU/bnVsbDpnLmNoaWxkOmcuY2hpbGQ7aWYobnVsbCE9PWspay5yZXR1cm49ZztlbHNlIGZvcihrPWc7bnVsbCE9PWs7KXtpZihrPT09Yil7az1udWxsO2JyZWFrfWc9ay5zaWJsaW5nO2lmKG51bGwhPT1nKXtnLnJldHVybj1rLnJldHVybjtrPWc7YnJlYWt9az1rLnJldHVybn1nPWt9fVMoYSxiLGYuY2hpbGRyZW4sYyk7Yj1iLmNoaWxkfXJldHVybiBiO2Nhc2UgOTpyZXR1cm4gZj1iLnR5cGUsZT1iLnBlbmRpbmdQcm9wcyxkPWUuY2hpbGRyZW4sbWcoYixjKSxmPW5nKGYsZS51bnN0YWJsZV9vYnNlcnZlZEJpdHMpLGQ9ZChmKSxiLmVmZmVjdFRhZ3w9MSxTKGEsYixkLGMpLGIuY2hpbGQ7Y2FzZSAxNDpyZXR1cm4gZj1iLnR5cGUsZT1EaChmLnR5cGUsYi5wZW5kaW5nUHJvcHMpLHZoKGEsYixmLGUsZCxjKTtjYXNlIDE1OnJldHVybiB3aChhLFxuYixiLnR5cGUsYi5wZW5kaW5nUHJvcHMsZCxjKTtjYXNlIDE3OnJldHVybiBkPWIudHlwZSxmPWIucGVuZGluZ1Byb3BzLGY9Yi5lbGVtZW50VHlwZT09PWQ/ZjpEaChkLGYpLG51bGwhPT1hJiYoYS5hbHRlcm5hdGU9bnVsbCxiLmFsdGVybmF0ZT1udWxsLGIuZWZmZWN0VGFnfD0yKSxiLnRhZz0xLE0oZCk/KGE9ITAsQmYoYikpOmE9ITEsbWcoYixjKSxhaChiLGQsZixjKSxjaChiLGQsZixjKSxCaChudWxsLGIsZCwhMCxhLGMpO2RlZmF1bHQ6cihcIjE1NlwiKX19ZnVuY3Rpb24gR2goYSl7YS5lZmZlY3RUYWd8PTR9dmFyIEhoPXZvaWQgMCxJaD12b2lkIDAsSmg9dm9pZCAwLEtoPXZvaWQgMDtcbkhoPWZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPWIuY2hpbGQ7bnVsbCE9PWM7KXtpZig1PT09Yy50YWd8fDY9PT1jLnRhZylhLmFwcGVuZENoaWxkKGMuc3RhdGVOb2RlKTtlbHNlIGlmKDQhPT1jLnRhZyYmbnVsbCE9PWMuY2hpbGQpe2MuY2hpbGQucmV0dXJuPWM7Yz1jLmNoaWxkO2NvbnRpbnVlfWlmKGM9PT1iKWJyZWFrO2Zvcig7bnVsbD09PWMuc2libGluZzspe2lmKG51bGw9PT1jLnJldHVybnx8Yy5yZXR1cm49PT1iKXJldHVybjtjPWMucmV0dXJufWMuc2libGluZy5yZXR1cm49Yy5yZXR1cm47Yz1jLnNpYmxpbmd9fTtJaD1mdW5jdGlvbigpe307XG5KaD1mdW5jdGlvbihhLGIsYyxkLGUpe3ZhciBmPWEubWVtb2l6ZWRQcm9wcztpZihmIT09ZCl7dmFyIGc9Yi5zdGF0ZU5vZGU7UmcoT2cuY3VycmVudCk7YT1udWxsO3N3aXRjaChjKXtjYXNlIFwiaW5wdXRcIjpmPU5jKGcsZik7ZD1OYyhnLGQpO2E9W107YnJlYWs7Y2FzZSBcIm9wdGlvblwiOmY9emUoZyxmKTtkPXplKGcsZCk7YT1bXTticmVhaztjYXNlIFwic2VsZWN0XCI6Zj1uKHt9LGYse3ZhbHVlOnZvaWQgMH0pO2Q9bih7fSxkLHt2YWx1ZTp2b2lkIDB9KTthPVtdO2JyZWFrO2Nhc2UgXCJ0ZXh0YXJlYVwiOmY9QmUoZyxmKTtkPUJlKGcsZCk7YT1bXTticmVhaztkZWZhdWx0OlwiZnVuY3Rpb25cIiE9PXR5cGVvZiBmLm9uQ2xpY2smJlwiZnVuY3Rpb25cIj09PXR5cGVvZiBkLm9uQ2xpY2smJihnLm9uY2xpY2s9VGUpfVFlKGMsZCk7Zz1jPXZvaWQgMDt2YXIgaD1udWxsO2ZvcihjIGluIGYpaWYoIWQuaGFzT3duUHJvcGVydHkoYykmJmYuaGFzT3duUHJvcGVydHkoYykmJm51bGwhPWZbY10paWYoXCJzdHlsZVwiPT09XG5jKXt2YXIgaz1mW2NdO2ZvcihnIGluIGspay5oYXNPd25Qcm9wZXJ0eShnKSYmKGh8fChoPXt9KSxoW2ddPVwiXCIpfWVsc2VcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCIhPT1jJiZcImNoaWxkcmVuXCIhPT1jJiZcInN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZ1wiIT09YyYmXCJzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmdcIiE9PWMmJlwiYXV0b0ZvY3VzXCIhPT1jJiYodWEuaGFzT3duUHJvcGVydHkoYyk/YXx8KGE9W10pOihhPWF8fFtdKS5wdXNoKGMsbnVsbCkpO2ZvcihjIGluIGQpe3ZhciBsPWRbY107az1udWxsIT1mP2ZbY106dm9pZCAwO2lmKGQuaGFzT3duUHJvcGVydHkoYykmJmwhPT1rJiYobnVsbCE9bHx8bnVsbCE9aykpaWYoXCJzdHlsZVwiPT09YylpZihrKXtmb3IoZyBpbiBrKSFrLmhhc093blByb3BlcnR5KGcpfHxsJiZsLmhhc093blByb3BlcnR5KGcpfHwoaHx8KGg9e30pLGhbZ109XCJcIik7Zm9yKGcgaW4gbClsLmhhc093blByb3BlcnR5KGcpJiZrW2ddIT09bFtnXSYmKGh8fFxuKGg9e30pLGhbZ109bFtnXSl9ZWxzZSBofHwoYXx8KGE9W10pLGEucHVzaChjLGgpKSxoPWw7ZWxzZVwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIj09PWM/KGw9bD9sLl9faHRtbDp2b2lkIDAsaz1rP2suX19odG1sOnZvaWQgMCxudWxsIT1sJiZrIT09bCYmKGE9YXx8W10pLnB1c2goYyxcIlwiK2wpKTpcImNoaWxkcmVuXCI9PT1jP2s9PT1sfHxcInN0cmluZ1wiIT09dHlwZW9mIGwmJlwibnVtYmVyXCIhPT10eXBlb2YgbHx8KGE9YXx8W10pLnB1c2goYyxcIlwiK2wpOlwic3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nXCIhPT1jJiZcInN1cHByZXNzSHlkcmF0aW9uV2FybmluZ1wiIT09YyYmKHVhLmhhc093blByb3BlcnR5KGMpPyhudWxsIT1sJiZTZShlLGMpLGF8fGs9PT1sfHwoYT1bXSkpOihhPWF8fFtdKS5wdXNoKGMsbCkpfWgmJihhPWF8fFtdKS5wdXNoKFwic3R5bGVcIixoKTtlPWE7KGIudXBkYXRlUXVldWU9ZSkmJkdoKGIpfX07S2g9ZnVuY3Rpb24oYSxiLGMsZCl7YyE9PWQmJkdoKGIpfTtcbmZ1bmN0aW9uIExoKGEsYil7dmFyIGM9Yi5zb3VyY2UsZD1iLnN0YWNrO251bGw9PT1kJiZudWxsIT09YyYmKGQ9QmMoYykpO251bGwhPT1jJiZBYyhjLnR5cGUpO2I9Yi52YWx1ZTtudWxsIT09YSYmMT09PWEudGFnJiZBYyhhLnR5cGUpO3RyeXtjb25zb2xlLmVycm9yKGIpfWNhdGNoKGUpe3NldFRpbWVvdXQoZnVuY3Rpb24oKXt0aHJvdyBlO30pfX1mdW5jdGlvbiBnaShhKXt2YXIgYj1hLnJlZjtpZihudWxsIT09YilpZihcImZ1bmN0aW9uXCI9PT10eXBlb2YgYil0cnl7YihudWxsKX1jYXRjaChjKXtoaShhLGMpfWVsc2UgYi5jdXJyZW50PW51bGx9XG5mdW5jdGlvbiBpaShhLGIsYyl7Yz1jLnVwZGF0ZVF1ZXVlO2M9bnVsbCE9PWM/Yy5sYXN0RWZmZWN0Om51bGw7aWYobnVsbCE9PWMpe3ZhciBkPWM9Yy5uZXh0O2Rve2lmKDAhPT0oZC50YWcmYSkpe3ZhciBlPWQuZGVzdHJveTtkLmRlc3Ryb3k9bnVsbDtudWxsIT09ZSYmZSgpfTAhPT0oZC50YWcmYikmJihlPWQuY3JlYXRlLGU9ZSgpLGQuZGVzdHJveT1cImZ1bmN0aW9uXCI9PT10eXBlb2YgZT9lOm51bGwpO2Q9ZC5uZXh0fXdoaWxlKGQhPT1jKX19XG5mdW5jdGlvbiBqaShhKXtcImZ1bmN0aW9uXCI9PT10eXBlb2YgRWYmJkVmKGEpO3N3aXRjaChhLnRhZyl7Y2FzZSAwOmNhc2UgMTE6Y2FzZSAxNDpjYXNlIDE1OnZhciBiPWEudXBkYXRlUXVldWU7aWYobnVsbCE9PWImJihiPWIubGFzdEVmZmVjdCxudWxsIT09Yikpe3ZhciBjPWI9Yi5uZXh0O2Rve3ZhciBkPWMuZGVzdHJveTtpZihudWxsIT09ZCl7dmFyIGU9YTt0cnl7ZCgpfWNhdGNoKGYpe2hpKGUsZil9fWM9Yy5uZXh0fXdoaWxlKGMhPT1iKX1icmVhaztjYXNlIDE6Z2koYSk7Yj1hLnN0YXRlTm9kZTtpZihcImZ1bmN0aW9uXCI9PT10eXBlb2YgYi5jb21wb25lbnRXaWxsVW5tb3VudCl0cnl7Yi5wcm9wcz1hLm1lbW9pemVkUHJvcHMsYi5zdGF0ZT1hLm1lbW9pemVkU3RhdGUsYi5jb21wb25lbnRXaWxsVW5tb3VudCgpfWNhdGNoKGYpe2hpKGEsZil9YnJlYWs7Y2FzZSA1OmdpKGEpO2JyZWFrO2Nhc2UgNDpraShhKX19XG5mdW5jdGlvbiBsaShhKXtyZXR1cm4gNT09PWEudGFnfHwzPT09YS50YWd8fDQ9PT1hLnRhZ31cbmZ1bmN0aW9uIG1pKGEpe2E6e2Zvcih2YXIgYj1hLnJldHVybjtudWxsIT09Yjspe2lmKGxpKGIpKXt2YXIgYz1iO2JyZWFrIGF9Yj1iLnJldHVybn1yKFwiMTYwXCIpO2M9dm9pZCAwfXZhciBkPWI9dm9pZCAwO3N3aXRjaChjLnRhZyl7Y2FzZSA1OmI9Yy5zdGF0ZU5vZGU7ZD0hMTticmVhaztjYXNlIDM6Yj1jLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO2Q9ITA7YnJlYWs7Y2FzZSA0OmI9Yy5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztkPSEwO2JyZWFrO2RlZmF1bHQ6cihcIjE2MVwiKX1jLmVmZmVjdFRhZyYxNiYmKExlKGIsXCJcIiksYy5lZmZlY3RUYWcmPS0xNyk7YTpiOmZvcihjPWE7Oyl7Zm9yKDtudWxsPT09Yy5zaWJsaW5nOyl7aWYobnVsbD09PWMucmV0dXJufHxsaShjLnJldHVybikpe2M9bnVsbDticmVhayBhfWM9Yy5yZXR1cm59Yy5zaWJsaW5nLnJldHVybj1jLnJldHVybjtmb3IoYz1jLnNpYmxpbmc7NSE9PWMudGFnJiY2IT09Yy50YWc7KXtpZihjLmVmZmVjdFRhZyYyKWNvbnRpbnVlIGI7XG5pZihudWxsPT09Yy5jaGlsZHx8ND09PWMudGFnKWNvbnRpbnVlIGI7ZWxzZSBjLmNoaWxkLnJldHVybj1jLGM9Yy5jaGlsZH1pZighKGMuZWZmZWN0VGFnJjIpKXtjPWMuc3RhdGVOb2RlO2JyZWFrIGF9fWZvcih2YXIgZT1hOzspe2lmKDU9PT1lLnRhZ3x8Nj09PWUudGFnKWlmKGMpaWYoZCl7dmFyIGY9YixnPWUuc3RhdGVOb2RlLGg9Yzs4PT09Zi5ub2RlVHlwZT9mLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGcsaCk6Zi5pbnNlcnRCZWZvcmUoZyxoKX1lbHNlIGIuaW5zZXJ0QmVmb3JlKGUuc3RhdGVOb2RlLGMpO2Vsc2UgZD8oZz1iLGg9ZS5zdGF0ZU5vZGUsOD09PWcubm9kZVR5cGU/KGY9Zy5wYXJlbnROb2RlLGYuaW5zZXJ0QmVmb3JlKGgsZykpOihmPWcsZi5hcHBlbmRDaGlsZChoKSksZz1nLl9yZWFjdFJvb3RDb250YWluZXIsbnVsbCE9PWcmJnZvaWQgMCE9PWd8fG51bGwhPT1mLm9uY2xpY2t8fChmLm9uY2xpY2s9VGUpKTpiLmFwcGVuZENoaWxkKGUuc3RhdGVOb2RlKTtcbmVsc2UgaWYoNCE9PWUudGFnJiZudWxsIT09ZS5jaGlsZCl7ZS5jaGlsZC5yZXR1cm49ZTtlPWUuY2hpbGQ7Y29udGludWV9aWYoZT09PWEpYnJlYWs7Zm9yKDtudWxsPT09ZS5zaWJsaW5nOyl7aWYobnVsbD09PWUucmV0dXJufHxlLnJldHVybj09PWEpcmV0dXJuO2U9ZS5yZXR1cm59ZS5zaWJsaW5nLnJldHVybj1lLnJldHVybjtlPWUuc2libGluZ319XG5mdW5jdGlvbiBraShhKXtmb3IodmFyIGI9YSxjPSExLGQ9dm9pZCAwLGU9dm9pZCAwOzspe2lmKCFjKXtjPWIucmV0dXJuO2E6Zm9yKDs7KXtudWxsPT09Yz9yKFwiMTYwXCIpOnZvaWQgMDtzd2l0Y2goYy50YWcpe2Nhc2UgNTpkPWMuc3RhdGVOb2RlO2U9ITE7YnJlYWsgYTtjYXNlIDM6ZD1jLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO2U9ITA7YnJlYWsgYTtjYXNlIDQ6ZD1jLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO2U9ITA7YnJlYWsgYX1jPWMucmV0dXJufWM9ITB9aWYoNT09PWIudGFnfHw2PT09Yi50YWcpe2E6Zm9yKHZhciBmPWIsZz1mOzspaWYoamkoZyksbnVsbCE9PWcuY2hpbGQmJjQhPT1nLnRhZylnLmNoaWxkLnJldHVybj1nLGc9Zy5jaGlsZDtlbHNle2lmKGc9PT1mKWJyZWFrO2Zvcig7bnVsbD09PWcuc2libGluZzspe2lmKG51bGw9PT1nLnJldHVybnx8Zy5yZXR1cm49PT1mKWJyZWFrIGE7Zz1nLnJldHVybn1nLnNpYmxpbmcucmV0dXJuPWcucmV0dXJuO2c9Zy5zaWJsaW5nfWU/XG4oZj1kLGc9Yi5zdGF0ZU5vZGUsOD09PWYubm9kZVR5cGU/Zi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGcpOmYucmVtb3ZlQ2hpbGQoZykpOmQucmVtb3ZlQ2hpbGQoYi5zdGF0ZU5vZGUpfWVsc2UgaWYoND09PWIudGFnPyhkPWIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8sZT0hMCk6amkoYiksbnVsbCE9PWIuY2hpbGQpe2IuY2hpbGQucmV0dXJuPWI7Yj1iLmNoaWxkO2NvbnRpbnVlfWlmKGI9PT1hKWJyZWFrO2Zvcig7bnVsbD09PWIuc2libGluZzspe2lmKG51bGw9PT1iLnJldHVybnx8Yi5yZXR1cm49PT1hKXJldHVybjtiPWIucmV0dXJuOzQ9PT1iLnRhZyYmKGM9ITEpfWIuc2libGluZy5yZXR1cm49Yi5yZXR1cm47Yj1iLnNpYmxpbmd9fVxuZnVuY3Rpb24gbmkoYSxiKXtzd2l0Y2goYi50YWcpe2Nhc2UgMDpjYXNlIDExOmNhc2UgMTQ6Y2FzZSAxNTppaSg0LDgsYik7YnJlYWs7Y2FzZSAxOmJyZWFrO2Nhc2UgNTp2YXIgYz1iLnN0YXRlTm9kZTtpZihudWxsIT1jKXt2YXIgZD1iLm1lbW9pemVkUHJvcHMsZT1udWxsIT09YT9hLm1lbW9pemVkUHJvcHM6ZDthPWIudHlwZTt2YXIgZj1iLnVwZGF0ZVF1ZXVlO2IudXBkYXRlUXVldWU9bnVsbDtpZihudWxsIT09Zil7Y1tMYV09ZDtcImlucHV0XCI9PT1hJiZcInJhZGlvXCI9PT1kLnR5cGUmJm51bGwhPWQubmFtZSYmUGMoYyxkKTtSZShhLGUpO2I9UmUoYSxkKTtmb3IoZT0wO2U8Zi5sZW5ndGg7ZSs9Mil7dmFyIGc9ZltlXSxoPWZbZSsxXTtcInN0eWxlXCI9PT1nP09lKGMsaCk6XCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiPT09Zz9LZShjLGgpOlwiY2hpbGRyZW5cIj09PWc/TGUoYyxoKTpMYyhjLGcsaCxiKX1zd2l0Y2goYSl7Y2FzZSBcImlucHV0XCI6UWMoYyxkKTticmVhaztjYXNlIFwidGV4dGFyZWFcIjpFZShjLFxuZCk7YnJlYWs7Y2FzZSBcInNlbGVjdFwiOmE9Yy5fd3JhcHBlclN0YXRlLndhc011bHRpcGxlLGMuX3dyYXBwZXJTdGF0ZS53YXNNdWx0aXBsZT0hIWQubXVsdGlwbGUsZj1kLnZhbHVlLG51bGwhPWY/QWUoYywhIWQubXVsdGlwbGUsZiwhMSk6YSE9PSEhZC5tdWx0aXBsZSYmKG51bGwhPWQuZGVmYXVsdFZhbHVlP0FlKGMsISFkLm11bHRpcGxlLGQuZGVmYXVsdFZhbHVlLCEwKTpBZShjLCEhZC5tdWx0aXBsZSxkLm11bHRpcGxlP1tdOlwiXCIsITEpKX19fWJyZWFrO2Nhc2UgNjpudWxsPT09Yi5zdGF0ZU5vZGU/cihcIjE2MlwiKTp2b2lkIDA7Yi5zdGF0ZU5vZGUubm9kZVZhbHVlPWIubWVtb2l6ZWRQcm9wczticmVhaztjYXNlIDM6YnJlYWs7Y2FzZSAxMjpicmVhaztjYXNlIDEzOmJyZWFrO2Nhc2UgMTc6YnJlYWs7ZGVmYXVsdDpyKFwiMTYzXCIpfX1cbmZ1bmN0aW9uIG9pKGEsYixjKXtjPVhmKGMpO2MudGFnPTM7Yy5wYXlsb2FkPXtlbGVtZW50Om51bGx9O3ZhciBkPWIudmFsdWU7Yy5jYWxsYmFjaz1mdW5jdGlvbigpe3BpKGQpO0xoKGEsYil9O3JldHVybiBjfVxuZnVuY3Rpb24gcWkoYSxiLGMpe2M9WGYoYyk7Yy50YWc9Mzt2YXIgZD1hLnR5cGUuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yO2lmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiBkKXt2YXIgZT1iLnZhbHVlO2MucGF5bG9hZD1mdW5jdGlvbigpe3JldHVybiBkKGUpfX12YXIgZj1hLnN0YXRlTm9kZTtudWxsIT09ZiYmXCJmdW5jdGlvblwiPT09dHlwZW9mIGYuY29tcG9uZW50RGlkQ2F0Y2gmJihjLmNhbGxiYWNrPWZ1bmN0aW9uKCl7XCJmdW5jdGlvblwiIT09dHlwZW9mIGQmJihudWxsPT09cmk/cmk9bmV3IFNldChbdGhpc10pOnJpLmFkZCh0aGlzKSk7dmFyIGM9Yi52YWx1ZSxlPWIuc3RhY2s7TGgoYSxiKTt0aGlzLmNvbXBvbmVudERpZENhdGNoKGMse2NvbXBvbmVudFN0YWNrOm51bGwhPT1lP2U6XCJcIn0pfSk7cmV0dXJuIGN9XG5mdW5jdGlvbiBzaShhKXtzd2l0Y2goYS50YWcpe2Nhc2UgMTpNKGEudHlwZSkmJnhmKGEpO3ZhciBiPWEuZWZmZWN0VGFnO3JldHVybiBiJjIwNDg/KGEuZWZmZWN0VGFnPWImLTIwNDl8NjQsYSk6bnVsbDtjYXNlIDM6cmV0dXJuIFRnKGEpLHlmKGEpLGI9YS5lZmZlY3RUYWcsMCE9PShiJjY0KT9yKFwiMjg1XCIpOnZvaWQgMCxhLmVmZmVjdFRhZz1iJi0yMDQ5fDY0LGE7Y2FzZSA1OnJldHVybiBWZyhhKSxudWxsO2Nhc2UgMTM6Yj1hLmVmZmVjdFRhZztpZihiJjIwNDgpe2EuZWZmZWN0VGFnPWImLTIwNDl8NjQ7Yj1hLmFsdGVybmF0ZTtiPW51bGwhPT1iP2IubWVtb2l6ZWRTdGF0ZTpudWxsO3ZhciBjPWEubWVtb2l6ZWRTdGF0ZTtudWxsPT09Yz9jPXthbHJlYWR5Q2FwdHVyZWQ6ITAsZGlkVGltZW91dDohMSx0aW1lZE91dEF0OjB9OmI9PT1jP2M9e2FscmVhZHlDYXB0dXJlZDohMCxkaWRUaW1lb3V0OmMuZGlkVGltZW91dCx0aW1lZE91dEF0OmMudGltZWRPdXRBdH06Yy5hbHJlYWR5Q2FwdHVyZWQ9XG4hMDthLm1lbW9pemVkU3RhdGU9YztyZXR1cm4gYX1yZXR1cm4gbnVsbDtjYXNlIDQ6cmV0dXJuIFRnKGEpLG51bGw7Y2FzZSAxMDpyZXR1cm4gbGcoYSksbnVsbDtkZWZhdWx0OnJldHVybiBudWxsfX1cbnZhciB0aT17cmVhZENvbnRleHQ6bmcsdXNlQ2FsbGJhY2s6ZnVuY3Rpb24oYSxiKXtPPXdnKCk7UT1CZygpO2I9dm9pZCAwIT09YiYmbnVsbCE9PWI/YjpbYV07dmFyIGM9US5tZW1vaXplZFN0YXRlO2lmKG51bGwhPT1jJiZJZyhiLGNbMV0pKXJldHVybiBjWzBdO1EubWVtb2l6ZWRTdGF0ZT1bYSxiXTtyZXR1cm4gYX0sdXNlQ29udGV4dDpmdW5jdGlvbihhLGIpe3dnKCk7cmV0dXJuIG5nKGEsYil9LHVzZUVmZmVjdDpmdW5jdGlvbihhLGIpe0hnKDUxNiwxOTIsYSxiKX0sdXNlSW1wZXJhdGl2ZU1ldGhvZHM6ZnVuY3Rpb24oYSxiLGMpe2M9bnVsbCE9PWMmJnZvaWQgMCE9PWM/Yy5jb25jYXQoW2FdKTpbYSxiXTtIZyg0LDM2LGZ1bmN0aW9uKCl7aWYoXCJmdW5jdGlvblwiPT09dHlwZW9mIGEpe3ZhciBjPWIoKTthKGMpO3JldHVybiBmdW5jdGlvbigpe3JldHVybiBhKG51bGwpfX1pZihudWxsIT09YSYmdm9pZCAwIT09YSlyZXR1cm4gYz1iKCksYS5jdXJyZW50PWMsZnVuY3Rpb24oKXthLmN1cnJlbnQ9XG5udWxsfX0sYyl9LHVzZUxheW91dEVmZmVjdDpmdW5jdGlvbihhLGIpe0hnKDQsMzYsYSxiKX0sdXNlTWVtbzpmdW5jdGlvbihhLGIpe089d2coKTtRPUJnKCk7Yj12b2lkIDAhPT1iJiZudWxsIT09Yj9iOlthXTt2YXIgYz1RLm1lbW9pemVkU3RhdGU7aWYobnVsbCE9PWMmJklnKGIsY1sxXSkpcmV0dXJuIGNbMF07YT1hKCk7US5tZW1vaXplZFN0YXRlPVthLGJdO3JldHVybiBhfSx1c2VNdXRhdGlvbkVmZmVjdDpmdW5jdGlvbihhLGIpe0hnKDI2MCwxMCxhLGIpfSx1c2VSZWR1Y2VyOkRnLHVzZVJlZjpmdW5jdGlvbihhKXtPPXdnKCk7UT1CZygpO251bGw9PT1RLm1lbW9pemVkU3RhdGU/KGE9e2N1cnJlbnQ6YX0sUS5tZW1vaXplZFN0YXRlPWEpOmE9US5tZW1vaXplZFN0YXRlO3JldHVybiBhfSx1c2VTdGF0ZTpmdW5jdGlvbihhKXtyZXR1cm4gRGcoQ2csYSl9fSx1aT1rYy5SZWFjdEN1cnJlbnRPd25lcix2aT0wLHdpPTAseGk9ITEsVD1udWxsLHlpPW51bGwsVT0wLHppPS0xLEFpPVxuITEsVj1udWxsLEJpPSExLENpPW51bGwsRGk9bnVsbCxFaT1udWxsLHJpPW51bGw7ZnVuY3Rpb24gRmkoKXtpZihudWxsIT09VClmb3IodmFyIGE9VC5yZXR1cm47bnVsbCE9PWE7KXt2YXIgYj1hO3N3aXRjaChiLnRhZyl7Y2FzZSAxOnZhciBjPWIudHlwZS5jaGlsZENvbnRleHRUeXBlcztudWxsIT09YyYmdm9pZCAwIT09YyYmeGYoYik7YnJlYWs7Y2FzZSAzOlRnKGIpO3lmKGIpO2JyZWFrO2Nhc2UgNTpWZyhiKTticmVhaztjYXNlIDQ6VGcoYik7YnJlYWs7Y2FzZSAxMDpsZyhiKX1hPWEucmV0dXJufXlpPW51bGw7VT0wO3ppPS0xO0FpPSExO1Q9bnVsbH1cbmZ1bmN0aW9uIEdpKGEsYil7RWk9RGk9Q2k9bnVsbDt2YXIgYz1XO1c9ITA7ZG97aWYoYi5lZmZlY3RUYWcmNTEyKXt2YXIgZD0hMSxlPXZvaWQgMDt0cnl7dmFyIGY9YjtpaSgxMjgsMCxmKTtpaSgwLDY0LGYpfWNhdGNoKGcpe2Q9ITAsZT1nfWQmJmhpKGIsZSl9Yj1iLm5leHRFZmZlY3R9d2hpbGUobnVsbCE9PWIpO1c9YztjPWEuZXhwaXJhdGlvblRpbWU7MCE9PWMmJkhpKGEsYyl9ZnVuY3Rpb24gTGcoKXtudWxsIT09RWkmJihiYS51bnN0YWJsZV9jYW5jZWxDYWxsYmFjayhEaSksRWkoKSl9XG5mdW5jdGlvbiBJaShhKXtmb3IoOzspe3ZhciBiPWEuYWx0ZXJuYXRlLGM9YS5yZXR1cm4sZD1hLnNpYmxpbmc7aWYoMD09PShhLmVmZmVjdFRhZyYxMDI0KSl7dmFyIGU9YjtiPWE7dmFyIGY9Yi5wZW5kaW5nUHJvcHM7c3dpdGNoKGIudGFnKXtjYXNlIDI6YnJlYWs7Y2FzZSAxNjpicmVhaztjYXNlIDE1OmNhc2UgMDpicmVhaztjYXNlIDE6TShiLnR5cGUpJiZ4ZihiKTticmVhaztjYXNlIDM6VGcoYik7eWYoYik7Zj1iLnN0YXRlTm9kZTtmLnBlbmRpbmdDb250ZXh0JiYoZi5jb250ZXh0PWYucGVuZGluZ0NvbnRleHQsZi5wZW5kaW5nQ29udGV4dD1udWxsKTtpZihudWxsPT09ZXx8bnVsbD09PWUuY2hpbGQpcWgoYiksYi5lZmZlY3RUYWcmPS0zO0loKGIpO2JyZWFrO2Nhc2UgNTpWZyhiKTt2YXIgZz1SZyhRZy5jdXJyZW50KSxoPWIudHlwZTtpZihudWxsIT09ZSYmbnVsbCE9Yi5zdGF0ZU5vZGUpSmgoZSxiLGgsZixnKSxlLnJlZiE9PWIucmVmJiYoYi5lZmZlY3RUYWd8PTEyOCk7XG5lbHNlIGlmKGYpe3ZhciBrPVJnKE9nLmN1cnJlbnQpO2lmKHFoKGIpKXtmPWI7ZT1mLnN0YXRlTm9kZTt2YXIgbD1mLnR5cGUsbT1mLm1lbW9pemVkUHJvcHMscD1nO2VbS2FdPWY7ZVtMYV09bTtoPXZvaWQgMDtnPWw7c3dpdGNoKGcpe2Nhc2UgXCJpZnJhbWVcIjpjYXNlIFwib2JqZWN0XCI6RyhcImxvYWRcIixlKTticmVhaztjYXNlIFwidmlkZW9cIjpjYXNlIFwiYXVkaW9cIjpmb3IobD0wO2w8Z2IubGVuZ3RoO2wrKylHKGdiW2xdLGUpO2JyZWFrO2Nhc2UgXCJzb3VyY2VcIjpHKFwiZXJyb3JcIixlKTticmVhaztjYXNlIFwiaW1nXCI6Y2FzZSBcImltYWdlXCI6Y2FzZSBcImxpbmtcIjpHKFwiZXJyb3JcIixlKTtHKFwibG9hZFwiLGUpO2JyZWFrO2Nhc2UgXCJmb3JtXCI6RyhcInJlc2V0XCIsZSk7RyhcInN1Ym1pdFwiLGUpO2JyZWFrO2Nhc2UgXCJkZXRhaWxzXCI6RyhcInRvZ2dsZVwiLGUpO2JyZWFrO2Nhc2UgXCJpbnB1dFwiOk9jKGUsbSk7RyhcImludmFsaWRcIixlKTtTZShwLFwib25DaGFuZ2VcIik7YnJlYWs7Y2FzZSBcInNlbGVjdFwiOmUuX3dyYXBwZXJTdGF0ZT1cbnt3YXNNdWx0aXBsZTohIW0ubXVsdGlwbGV9O0coXCJpbnZhbGlkXCIsZSk7U2UocCxcIm9uQ2hhbmdlXCIpO2JyZWFrO2Nhc2UgXCJ0ZXh0YXJlYVwiOkRlKGUsbSksRyhcImludmFsaWRcIixlKSxTZShwLFwib25DaGFuZ2VcIil9UWUoZyxtKTtsPW51bGw7Zm9yKGggaW4gbSltLmhhc093blByb3BlcnR5KGgpJiYoaz1tW2hdLFwiY2hpbGRyZW5cIj09PWg/XCJzdHJpbmdcIj09PXR5cGVvZiBrP2UudGV4dENvbnRlbnQhPT1rJiYobD1bXCJjaGlsZHJlblwiLGtdKTpcIm51bWJlclwiPT09dHlwZW9mIGsmJmUudGV4dENvbnRlbnQhPT1cIlwiK2smJihsPVtcImNoaWxkcmVuXCIsXCJcIitrXSk6dWEuaGFzT3duUHJvcGVydHkoaCkmJm51bGwhPWsmJlNlKHAsaCkpO3N3aXRjaChnKXtjYXNlIFwiaW5wdXRcIjplYyhlKTtTYyhlLG0sITApO2JyZWFrO2Nhc2UgXCJ0ZXh0YXJlYVwiOmVjKGUpO0ZlKGUsbSk7YnJlYWs7Y2FzZSBcInNlbGVjdFwiOmNhc2UgXCJvcHRpb25cIjpicmVhaztkZWZhdWx0OlwiZnVuY3Rpb25cIj09PXR5cGVvZiBtLm9uQ2xpY2smJlxuKGUub25jbGljaz1UZSl9aD1sO2YudXBkYXRlUXVldWU9aDtmPW51bGwhPT1oPyEwOiExO2YmJkdoKGIpfWVsc2V7bT1iO2U9aDtwPWY7bD05PT09Zy5ub2RlVHlwZT9nOmcub3duZXJEb2N1bWVudDtrPT09R2UuaHRtbCYmKGs9SGUoZSkpO2s9PT1HZS5odG1sP1wic2NyaXB0XCI9PT1lPyhlPWwuY3JlYXRlRWxlbWVudChcImRpdlwiKSxlLmlubmVySFRNTD1cIjxzY3JpcHQ+XFx4M2Mvc2NyaXB0PlwiLGw9ZS5yZW1vdmVDaGlsZChlLmZpcnN0Q2hpbGQpKTpcInN0cmluZ1wiPT09dHlwZW9mIHAuaXM/bD1sLmNyZWF0ZUVsZW1lbnQoZSx7aXM6cC5pc30pOihsPWwuY3JlYXRlRWxlbWVudChlKSxcInNlbGVjdFwiPT09ZSYmcC5tdWx0aXBsZSYmKGwubXVsdGlwbGU9ITApKTpsPWwuY3JlYXRlRWxlbWVudE5TKGssZSk7ZT1sO2VbS2FdPW07ZVtMYV09ZjtIaChlLGIsITEsITEpO3A9ZTtsPWg7bT1mO3ZhciB3PWcsRT1SZShsLG0pO3N3aXRjaChsKXtjYXNlIFwiaWZyYW1lXCI6Y2FzZSBcIm9iamVjdFwiOkcoXCJsb2FkXCIsXG5wKTtnPW07YnJlYWs7Y2FzZSBcInZpZGVvXCI6Y2FzZSBcImF1ZGlvXCI6Zm9yKGc9MDtnPGdiLmxlbmd0aDtnKyspRyhnYltnXSxwKTtnPW07YnJlYWs7Y2FzZSBcInNvdXJjZVwiOkcoXCJlcnJvclwiLHApO2c9bTticmVhaztjYXNlIFwiaW1nXCI6Y2FzZSBcImltYWdlXCI6Y2FzZSBcImxpbmtcIjpHKFwiZXJyb3JcIixwKTtHKFwibG9hZFwiLHApO2c9bTticmVhaztjYXNlIFwiZm9ybVwiOkcoXCJyZXNldFwiLHApO0coXCJzdWJtaXRcIixwKTtnPW07YnJlYWs7Y2FzZSBcImRldGFpbHNcIjpHKFwidG9nZ2xlXCIscCk7Zz1tO2JyZWFrO2Nhc2UgXCJpbnB1dFwiOk9jKHAsbSk7Zz1OYyhwLG0pO0coXCJpbnZhbGlkXCIscCk7U2UodyxcIm9uQ2hhbmdlXCIpO2JyZWFrO2Nhc2UgXCJvcHRpb25cIjpnPXplKHAsbSk7YnJlYWs7Y2FzZSBcInNlbGVjdFwiOnAuX3dyYXBwZXJTdGF0ZT17d2FzTXVsdGlwbGU6ISFtLm11bHRpcGxlfTtnPW4oe30sbSx7dmFsdWU6dm9pZCAwfSk7RyhcImludmFsaWRcIixwKTtTZSh3LFwib25DaGFuZ2VcIik7YnJlYWs7Y2FzZSBcInRleHRhcmVhXCI6RGUocCxcbm0pO2c9QmUocCxtKTtHKFwiaW52YWxpZFwiLHApO1NlKHcsXCJvbkNoYW5nZVwiKTticmVhaztkZWZhdWx0Omc9bX1RZShsLGcpO2s9dm9pZCAwO3ZhciB4PWwsRj1wLHY9Zztmb3IoayBpbiB2KWlmKHYuaGFzT3duUHJvcGVydHkoaykpe3ZhciBxPXZba107XCJzdHlsZVwiPT09az9PZShGLHEpOlwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIj09PWs/KHE9cT9xLl9faHRtbDp2b2lkIDAsbnVsbCE9cSYmS2UoRixxKSk6XCJjaGlsZHJlblwiPT09az9cInN0cmluZ1wiPT09dHlwZW9mIHE/KFwidGV4dGFyZWFcIiE9PXh8fFwiXCIhPT1xKSYmTGUoRixxKTpcIm51bWJlclwiPT09dHlwZW9mIHEmJkxlKEYsXCJcIitxKTpcInN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZ1wiIT09ayYmXCJzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmdcIiE9PWsmJlwiYXV0b0ZvY3VzXCIhPT1rJiYodWEuaGFzT3duUHJvcGVydHkoayk/bnVsbCE9cSYmU2UodyxrKTpudWxsIT1xJiZMYyhGLGsscSxFKSl9c3dpdGNoKGwpe2Nhc2UgXCJpbnB1dFwiOmVjKHApO1xuU2MocCxtLCExKTticmVhaztjYXNlIFwidGV4dGFyZWFcIjplYyhwKTtGZShwLG0pO2JyZWFrO2Nhc2UgXCJvcHRpb25cIjpudWxsIT1tLnZhbHVlJiZwLnNldEF0dHJpYnV0ZShcInZhbHVlXCIsXCJcIitNYyhtLnZhbHVlKSk7YnJlYWs7Y2FzZSBcInNlbGVjdFwiOmc9cDtnLm11bHRpcGxlPSEhbS5tdWx0aXBsZTtwPW0udmFsdWU7bnVsbCE9cD9BZShnLCEhbS5tdWx0aXBsZSxwLCExKTpudWxsIT1tLmRlZmF1bHRWYWx1ZSYmQWUoZywhIW0ubXVsdGlwbGUsbS5kZWZhdWx0VmFsdWUsITApO2JyZWFrO2RlZmF1bHQ6XCJmdW5jdGlvblwiPT09dHlwZW9mIGcub25DbGljayYmKHAub25jbGljaz1UZSl9KGY9bWYoaCxmKSkmJkdoKGIpO2Iuc3RhdGVOb2RlPWV9bnVsbCE9PWIucmVmJiYoYi5lZmZlY3RUYWd8PTEyOCl9ZWxzZSBudWxsPT09Yi5zdGF0ZU5vZGU/cihcIjE2NlwiKTp2b2lkIDA7YnJlYWs7Y2FzZSA2OmUmJm51bGwhPWIuc3RhdGVOb2RlP0toKGUsYixlLm1lbW9pemVkUHJvcHMsZik6KFwic3RyaW5nXCIhPT1cbnR5cGVvZiBmJiYobnVsbD09PWIuc3RhdGVOb2RlP3IoXCIxNjZcIik6dm9pZCAwKSxlPVJnKFFnLmN1cnJlbnQpLFJnKE9nLmN1cnJlbnQpLHFoKGIpPyhmPWIsaD1mLnN0YXRlTm9kZSxlPWYubWVtb2l6ZWRQcm9wcyxoW0thXT1mLChmPWgubm9kZVZhbHVlIT09ZSkmJkdoKGIpKTooaD1iLGY9KDk9PT1lLm5vZGVUeXBlP2U6ZS5vd25lckRvY3VtZW50KS5jcmVhdGVUZXh0Tm9kZShmKSxmW0thXT1iLGguc3RhdGVOb2RlPWYpKTticmVhaztjYXNlIDExOmJyZWFrO2Nhc2UgMTM6Zj1iLm1lbW9pemVkU3RhdGU7aD1udWxsIT09ZT9lLm1lbW9pemVkU3RhdGU6bnVsbDsobnVsbCE9PWYmJmYuZGlkVGltZW91dCkhPT0obnVsbCE9PWgmJmguZGlkVGltZW91dCkmJihiLmVmZmVjdFRhZ3w9NCk7YnJlYWs7Y2FzZSA3OmJyZWFrO2Nhc2UgODpicmVhaztjYXNlIDEyOmJyZWFrO2Nhc2UgNDpUZyhiKTtJaChiKTticmVhaztjYXNlIDEwOmxnKGIpO2JyZWFrO2Nhc2UgOTpicmVhaztjYXNlIDE0OmJyZWFrO1xuY2FzZSAxNzpNKGIudHlwZSkmJnhmKGIpO2JyZWFrO2RlZmF1bHQ6cihcIjE1NlwiKX1UPW51bGw7Yj1hO2lmKDEwNzM3NDE4MjM9PT1VfHwxMDczNzQxODIzIT09Yi5jaGlsZEV4cGlyYXRpb25UaW1lKXtmPTA7Zm9yKGg9Yi5jaGlsZDtudWxsIT09aDspe2U9aC5leHBpcmF0aW9uVGltZTtnPWguY2hpbGRFeHBpcmF0aW9uVGltZTtpZigwPT09Znx8MCE9PWUmJmU8ZilmPWU7aWYoMD09PWZ8fDAhPT1nJiZnPGYpZj1nO2g9aC5zaWJsaW5nfWIuY2hpbGRFeHBpcmF0aW9uVGltZT1mfW51bGwhPT1jJiYwPT09KGMuZWZmZWN0VGFnJjEwMjQpJiYobnVsbD09PWMuZmlyc3RFZmZlY3QmJihjLmZpcnN0RWZmZWN0PWEuZmlyc3RFZmZlY3QpLG51bGwhPT1hLmxhc3RFZmZlY3QmJihudWxsIT09Yy5sYXN0RWZmZWN0JiYoYy5sYXN0RWZmZWN0Lm5leHRFZmZlY3Q9YS5maXJzdEVmZmVjdCksYy5sYXN0RWZmZWN0PWEubGFzdEVmZmVjdCksMTxhLmVmZmVjdFRhZyYmKG51bGwhPT1jLmxhc3RFZmZlY3Q/XG5jLmxhc3RFZmZlY3QubmV4dEVmZmVjdD1hOmMuZmlyc3RFZmZlY3Q9YSxjLmxhc3RFZmZlY3Q9YSkpfWVsc2V7YT1zaShhLFUpO2lmKG51bGwhPT1hKXJldHVybiBhLmVmZmVjdFRhZyY9MTAyMyxhO251bGwhPT1jJiYoYy5maXJzdEVmZmVjdD1jLmxhc3RFZmZlY3Q9bnVsbCxjLmVmZmVjdFRhZ3w9MTAyNCl9aWYobnVsbCE9PWQpcmV0dXJuIGQ7aWYobnVsbCE9PWMpYT1jO2Vsc2UgYnJlYWt9cmV0dXJuIG51bGx9ZnVuY3Rpb24gSmkoYSl7dmFyIGI9RmgoYS5hbHRlcm5hdGUsYSxVKTthLm1lbW9pemVkUHJvcHM9YS5wZW5kaW5nUHJvcHM7bnVsbD09PWImJihiPUlpKGEpKTt1aS5jdXJyZW50PW51bGw7cmV0dXJuIGJ9XG5mdW5jdGlvbiBLaShhLGIsYyl7eGk/cihcIjI0M1wiKTp2b2lkIDA7TGcoKTt4aT0hMDt1aS5jdXJyZW50RGlzcGF0Y2hlcj10aTt2YXIgZD1hLm5leHRFeHBpcmF0aW9uVGltZVRvV29ya09uO2lmKGQhPT1VfHxhIT09eWl8fG51bGw9PT1UKUZpKCkseWk9YSxVPWQsVD1LZih5aS5jdXJyZW50LG51bGwsVSksYS5wZW5kaW5nQ29tbWl0RXhwaXJhdGlvblRpbWU9MDt2YXIgZT0hMTtkb3t0cnl7aWYoYilmb3IoO251bGwhPT1UJiYhTGkoKTspVD1KaShUKTtlbHNlIGZvcig7bnVsbCE9PVQ7KVQ9SmkoVCl9Y2F0Y2goRil7aWYoamc9aWc9aGc9bnVsbCx5ZygpLG51bGw9PT1UKWU9ITAscGkoRik7ZWxzZXtudWxsPT09VD9yKFwiMjcxXCIpOnZvaWQgMDt2YXIgZj1ULGc9Zi5yZXR1cm47aWYobnVsbD09PWcpZT0hMCxwaShGKTtlbHNle2E6e3ZhciBoPWEsaz1nLGw9ZixtPUY7Zz1VO2wuZWZmZWN0VGFnfD0xMDI0O2wuZmlyc3RFZmZlY3Q9bC5sYXN0RWZmZWN0PW51bGw7aWYobnVsbCE9PW0mJlxuXCJvYmplY3RcIj09PXR5cGVvZiBtJiZcImZ1bmN0aW9uXCI9PT10eXBlb2YgbS50aGVuKXt2YXIgcD1tO209azt2YXIgdz0tMSxFPS0xO2Rve2lmKDEzPT09bS50YWcpe3ZhciB4PW0uYWx0ZXJuYXRlO2lmKG51bGwhPT14JiYoeD14Lm1lbW9pemVkU3RhdGUsbnVsbCE9PXgmJnguZGlkVGltZW91dCkpe0U9MTAqKHgudGltZWRPdXRBdC0yKTticmVha314PW0ucGVuZGluZ1Byb3BzLm1heER1cmF0aW9uO2lmKFwibnVtYmVyXCI9PT10eXBlb2YgeClpZigwPj14KXc9MDtlbHNlIGlmKC0xPT09d3x8eDx3KXc9eH1tPW0ucmV0dXJufXdoaWxlKG51bGwhPT1tKTttPWs7ZG97aWYoeD0xMz09PW0udGFnKXZvaWQgMD09PW0ubWVtb2l6ZWRQcm9wcy5mYWxsYmFjaz94PSExOih4PW0ubWVtb2l6ZWRTdGF0ZSx4PW51bGw9PT14fHwheC5kaWRUaW1lb3V0KTtpZih4KXtrPU1pLmJpbmQobnVsbCxoLG0sbCwwPT09KG0ubW9kZSYxKT8xOmcpO3AudGhlbihrLGspO2lmKDA9PT0obS5tb2RlJjEpKXttLmVmZmVjdFRhZ3w9XG4zMjtTKGwuYWx0ZXJuYXRlLGwsbnVsbCxnKTtsLmVmZmVjdFRhZyY9LTEwMjU7bC5lZmZlY3RUYWcmPS05MzM7MT09PWwudGFnJiZudWxsPT09bC5hbHRlcm5hdGUmJihsLnRhZz0xNyk7YnJlYWsgYX0tMT09PXc/aD0xMDczNzQxODIzOigtMT09PUUmJihFPTEwKihUZihoLGcpLTIpLTVFMyksaD1FK3cpOzA8PWgmJnppPGgmJih6aT1oKTttLmVmZmVjdFRhZ3w9MjA0ODttLmV4cGlyYXRpb25UaW1lPWc7YnJlYWsgYX1tPW0ucmV0dXJufXdoaWxlKG51bGwhPT1tKTttPUVycm9yKFwiQW4gdXBkYXRlIHdhcyBzdXNwZW5kZWQsIGJ1dCBubyBwbGFjZWhvbGRlciBVSSB3YXMgcHJvdmlkZWQuXCIpfUFpPSEwO209ZmcobSxsKTtoPWs7ZG97c3dpdGNoKGgudGFnKXtjYXNlIDM6bD1tO2guZWZmZWN0VGFnfD0yMDQ4O2guZXhwaXJhdGlvblRpbWU9ZztnPW9pKGgsbCxnKTskZihoLGcpO2JyZWFrIGE7Y2FzZSAxOmlmKGw9bSxrPWgudHlwZSxwPWguc3RhdGVOb2RlLDA9PT0oaC5lZmZlY3RUYWcmXG42NCkmJihcImZ1bmN0aW9uXCI9PT10eXBlb2Ygay5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3J8fG51bGwhPT1wJiZcImZ1bmN0aW9uXCI9PT10eXBlb2YgcC5jb21wb25lbnREaWRDYXRjaCYmKG51bGw9PT1yaXx8IXJpLmhhcyhwKSkpKXtoLmVmZmVjdFRhZ3w9MjA0ODtoLmV4cGlyYXRpb25UaW1lPWc7Zz1xaShoLGwsZyk7JGYoaCxnKTticmVhayBhfX1oPWgucmV0dXJufXdoaWxlKG51bGwhPT1oKX1UPUlpKGYpO2NvbnRpbnVlfX19YnJlYWt9d2hpbGUoMSk7eGk9ITE7amc9aWc9aGc9dWkuY3VycmVudERpc3BhdGNoZXI9bnVsbDt5ZygpO2lmKGUpeWk9bnVsbCxhLmZpbmlzaGVkV29yaz1udWxsO2Vsc2UgaWYobnVsbCE9PVQpYS5maW5pc2hlZFdvcms9bnVsbDtlbHNle2I9YS5jdXJyZW50LmFsdGVybmF0ZTtudWxsPT09Yj9yKFwiMjgxXCIpOnZvaWQgMDt5aT1udWxsO2lmKEFpKXtlPWEubGF0ZXN0UGVuZGluZ1RpbWU7Zj1hLmxhdGVzdFN1c3BlbmRlZFRpbWU7Zz1hLmxhdGVzdFBpbmdlZFRpbWU7XG5pZigwIT09ZSYmZT5kfHwwIT09ZiYmZj5kfHwwIT09ZyYmZz5kKXtTZihhLGQpO05pKGEsYixkLGEuZXhwaXJhdGlvblRpbWUsLTEpO3JldHVybn1pZighYS5kaWRFcnJvciYmIWMpe2EuZGlkRXJyb3I9ITA7ZD1hLm5leHRFeHBpcmF0aW9uVGltZVRvV29ya09uPWQ7Yz1hLmV4cGlyYXRpb25UaW1lPTE7TmkoYSxiLGQsYywtMSk7cmV0dXJufX1jfHwtMT09PXppPyhhLnBlbmRpbmdDb21taXRFeHBpcmF0aW9uVGltZT1kLGEuZmluaXNoZWRXb3JrPWIpOihTZihhLGQpLGM9MTAqKFRmKGEsZCktMiksYzx6aSYmKHppPWMpLGM9MTAqKEpnKCktMiksYz16aS1jLE5pKGEsYixkLGEuZXhwaXJhdGlvblRpbWUsMD5jPzA6YykpfX1cbmZ1bmN0aW9uIGhpKGEsYil7Zm9yKHZhciBjPWEucmV0dXJuO251bGwhPT1jOyl7c3dpdGNoKGMudGFnKXtjYXNlIDE6dmFyIGQ9Yy5zdGF0ZU5vZGU7aWYoXCJmdW5jdGlvblwiPT09dHlwZW9mIGMudHlwZS5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3J8fFwiZnVuY3Rpb25cIj09PXR5cGVvZiBkLmNvbXBvbmVudERpZENhdGNoJiYobnVsbD09PXJpfHwhcmkuaGFzKGQpKSl7YT1mZyhiLGEpO2E9cWkoYyxhLDEpO1pmKGMsYSk7TWcoYywxKTtyZXR1cm59YnJlYWs7Y2FzZSAzOmE9ZmcoYixhKTthPW9pKGMsYSwxKTtaZihjLGEpO01nKGMsMSk7cmV0dXJufWM9Yy5yZXR1cm59Mz09PWEudGFnJiYoYz1mZyhiLGEpLGM9b2koYSxjLDEpLFpmKGEsYyksTWcoYSwxKSl9XG5mdW5jdGlvbiBLZyhhLGIpezAhPT13aT9hPXdpOnhpP2E9Qmk/MTpVOmIubW9kZSYxPyhhPU9pPzIrMTAqKCgoYS0yKzE1KS8xMHwwKSsxKToyKzI1KigoKGEtMis1MDApLzI1fDApKzEpLG51bGwhPT15aSYmYT09PVUmJihhKz0xKSk6YT0xO09pJiZhPlBpJiYoUGk9YSk7cmV0dXJuIGF9XG5mdW5jdGlvbiBNaShhLGIsYyxkKXt2YXIgZT1hLmVhcmxpZXN0U3VzcGVuZGVkVGltZTt2YXIgZj1hLmxhdGVzdFN1c3BlbmRlZFRpbWU7aWYoMCE9PWUmJmQ+PWUmJmQ8PWYpe2Y9ZT1kO2EuZGlkRXJyb3I9ITE7dmFyIGc9YS5sYXRlc3RQaW5nZWRUaW1lO2lmKDA9PT1nfHxnPGYpYS5sYXRlc3RQaW5nZWRUaW1lPWY7UmYoZixhKX1lbHNlIGU9SmcoKSxlPUtnKGUsYiksUWYoYSxlKTswIT09KGIubW9kZSYxKSYmYT09PXlpJiZVPT09ZCYmKHlpPW51bGwpO1FpKGIsZSk7MD09PShiLm1vZGUmMSkmJihRaShjLGUpLDE9PT1jLnRhZyYmbnVsbCE9PWMuc3RhdGVOb2RlJiYoYj1YZihlKSxiLnRhZz0yLFpmKGMsYikpKTtjPWEuZXhwaXJhdGlvblRpbWU7MCE9PWMmJkhpKGEsYyl9XG5mdW5jdGlvbiBRaShhLGIpe2lmKDA9PT1hLmV4cGlyYXRpb25UaW1lfHxhLmV4cGlyYXRpb25UaW1lPmIpYS5leHBpcmF0aW9uVGltZT1iO3ZhciBjPWEuYWx0ZXJuYXRlO251bGwhPT1jJiYoMD09PWMuZXhwaXJhdGlvblRpbWV8fGMuZXhwaXJhdGlvblRpbWU+YikmJihjLmV4cGlyYXRpb25UaW1lPWIpO3ZhciBkPWEucmV0dXJuLGU9bnVsbDtpZihudWxsPT09ZCYmMz09PWEudGFnKWU9YS5zdGF0ZU5vZGU7ZWxzZSBmb3IoO251bGwhPT1kOyl7Yz1kLmFsdGVybmF0ZTtpZigwPT09ZC5jaGlsZEV4cGlyYXRpb25UaW1lfHxkLmNoaWxkRXhwaXJhdGlvblRpbWU+YilkLmNoaWxkRXhwaXJhdGlvblRpbWU9YjtudWxsIT09YyYmKDA9PT1jLmNoaWxkRXhwaXJhdGlvblRpbWV8fGMuY2hpbGRFeHBpcmF0aW9uVGltZT5iKSYmKGMuY2hpbGRFeHBpcmF0aW9uVGltZT1iKTtpZihudWxsPT09ZC5yZXR1cm4mJjM9PT1kLnRhZyl7ZT1kLnN0YXRlTm9kZTticmVha31kPWQucmV0dXJufXJldHVybiBudWxsPT09XG5lP251bGw6ZX1mdW5jdGlvbiBNZyhhLGIpe2E9UWkoYSxiKTtudWxsIT09YSYmKCF4aSYmMCE9PVUmJmI8VSYmRmkoKSxRZihhLGIpLHhpJiYhQmkmJnlpPT09YXx8SGkoYSxhLmV4cGlyYXRpb25UaW1lKSxSaT5TaSYmKFJpPTAscihcIjE4NVwiKSkpfWZ1bmN0aW9uIFRpKGEsYixjLGQsZSl7dmFyIGY9d2k7d2k9MTt0cnl7cmV0dXJuIGEoYixjLGQsZSl9ZmluYWxseXt3aT1mfX12YXIgVWk9bnVsbCxYPW51bGwsVmk9MCxXaT12b2lkIDAsVz0hMSxYaT1udWxsLFk9MCxQaT0wLFlpPSExLFppPSExLCRpPW51bGwsYWo9bnVsbCxaPSExLGJqPSExLE9pPSExLGNqPW51bGwsZGo9YmEudW5zdGFibGVfbm93KCksZWo9KGRqLzEwfDApKzIsZmo9ZWosU2k9NTAsUmk9MCxnaj1udWxsLGhqPTE7ZnVuY3Rpb24gaWooKXtlaj0oKGJhLnVuc3RhYmxlX25vdygpLWRqKS8xMHwwKSsyfVxuZnVuY3Rpb24gamooYSxiKXtpZigwIT09Vmkpe2lmKGI+VmkpcmV0dXJuO251bGwhPT1XaSYmYmEudW5zdGFibGVfY2FuY2VsQ2FsbGJhY2soV2kpfVZpPWI7YT1iYS51bnN0YWJsZV9ub3coKS1kajtXaT1iYS51bnN0YWJsZV9zY2hlZHVsZUNhbGxiYWNrKGtqLHt0aW1lb3V0OjEwKihiLTIpLWF9KX1mdW5jdGlvbiBOaShhLGIsYyxkLGUpe2EuZXhwaXJhdGlvblRpbWU9ZDswIT09ZXx8TGkoKT8wPGUmJihhLnRpbWVvdXRIYW5kbGU9b2YobGouYmluZChudWxsLGEsYixjKSxlKSk6KGEucGVuZGluZ0NvbW1pdEV4cGlyYXRpb25UaW1lPWMsYS5maW5pc2hlZFdvcms9Yil9ZnVuY3Rpb24gbGooYSxiLGMpe2EucGVuZGluZ0NvbW1pdEV4cGlyYXRpb25UaW1lPWM7YS5maW5pc2hlZFdvcms9YjtpaigpO2ZqPWVqO21qKGEsYyl9ZnVuY3Rpb24gSmcoKXtpZihXKXJldHVybiBmajtuaigpO2lmKDA9PT1ZfHwxMDczNzQxODIzPT09WSlpaigpLGZqPWVqO3JldHVybiBman1cbmZ1bmN0aW9uIEhpKGEsYil7aWYobnVsbD09PWEubmV4dFNjaGVkdWxlZFJvb3QpYS5leHBpcmF0aW9uVGltZT1iLG51bGw9PT1YPyhVaT1YPWEsYS5uZXh0U2NoZWR1bGVkUm9vdD1hKTooWD1YLm5leHRTY2hlZHVsZWRSb290PWEsWC5uZXh0U2NoZWR1bGVkUm9vdD1VaSk7ZWxzZXt2YXIgYz1hLmV4cGlyYXRpb25UaW1lO2lmKDA9PT1jfHxiPGMpYS5leHBpcmF0aW9uVGltZT1ifVd8fChaP2JqJiYoWGk9YSxZPTEsb2ooYSwxLCEwKSk6MT09PWI/cGooMSxudWxsKTpqaihhLGIpKX1cbmZ1bmN0aW9uIG5qKCl7dmFyIGE9MCxiPW51bGw7aWYobnVsbCE9PVgpZm9yKHZhciBjPVgsZD1VaTtudWxsIT09ZDspe3ZhciBlPWQuZXhwaXJhdGlvblRpbWU7aWYoMD09PWUpe251bGw9PT1jfHxudWxsPT09WD9yKFwiMjQ0XCIpOnZvaWQgMDtpZihkPT09ZC5uZXh0U2NoZWR1bGVkUm9vdCl7VWk9WD1kLm5leHRTY2hlZHVsZWRSb290PW51bGw7YnJlYWt9ZWxzZSBpZihkPT09VWkpVWk9ZT1kLm5leHRTY2hlZHVsZWRSb290LFgubmV4dFNjaGVkdWxlZFJvb3Q9ZSxkLm5leHRTY2hlZHVsZWRSb290PW51bGw7ZWxzZSBpZihkPT09WCl7WD1jO1gubmV4dFNjaGVkdWxlZFJvb3Q9VWk7ZC5uZXh0U2NoZWR1bGVkUm9vdD1udWxsO2JyZWFrfWVsc2UgYy5uZXh0U2NoZWR1bGVkUm9vdD1kLm5leHRTY2hlZHVsZWRSb290LGQubmV4dFNjaGVkdWxlZFJvb3Q9bnVsbDtkPWMubmV4dFNjaGVkdWxlZFJvb3R9ZWxzZXtpZigwPT09YXx8ZTxhKWE9ZSxiPWQ7aWYoZD09PVgpYnJlYWs7aWYoMT09PVxuYSlicmVhaztjPWQ7ZD1kLm5leHRTY2hlZHVsZWRSb290fX1YaT1iO1k9YX1mdW5jdGlvbiBraihhKXtpZihhLmRpZFRpbWVvdXQmJm51bGwhPT1VaSl7aWooKTt2YXIgYj1VaTtkb3t2YXIgYz1iLmV4cGlyYXRpb25UaW1lOzAhPT1jJiZlaj49YyYmKGIubmV4dEV4cGlyYXRpb25UaW1lVG9Xb3JrT249ZWopO2I9Yi5uZXh0U2NoZWR1bGVkUm9vdH13aGlsZShiIT09VWkpfXBqKDAsYSl9XG5mdW5jdGlvbiBwaihhLGIpe2FqPWI7bmooKTtpZihudWxsIT09YWopZm9yKGlqKCksZmo9ZWo7bnVsbCE9PVhpJiYwIT09WSYmKDA9PT1hfHxhPj1ZKSYmKCFZaXx8ZWo+PVkpOylvaihYaSxZLGVqPj1ZKSxuaigpLGlqKCksZmo9ZWo7ZWxzZSBmb3IoO251bGwhPT1YaSYmMCE9PVkmJigwPT09YXx8YT49WSk7KW9qKFhpLFksITApLG5qKCk7bnVsbCE9PWFqJiYoVmk9MCxXaT1udWxsKTswIT09WSYmamooWGksWSk7YWo9bnVsbDtZaT0hMTtSaT0wO2dqPW51bGw7aWYobnVsbCE9PWNqKWZvcihhPWNqLGNqPW51bGwsYj0wO2I8YS5sZW5ndGg7YisrKXt2YXIgYz1hW2JdO3RyeXtjLl9vbkNvbXBsZXRlKCl9Y2F0Y2goZCl7Wml8fChaaT0hMCwkaT1kKX19aWYoWmkpdGhyb3cgYT0kaSwkaT1udWxsLFppPSExLGE7fWZ1bmN0aW9uIG1qKGEsYil7Vz9yKFwiMjUzXCIpOnZvaWQgMDtYaT1hO1k9YjtvaihhLGIsITApO3BqKDEsbnVsbCl9XG5mdW5jdGlvbiBvaihhLGIsYyl7Vz9yKFwiMjQ1XCIpOnZvaWQgMDtXPSEwO2lmKG51bGw9PT1hanx8Yyl7dmFyIGQ9YS5maW5pc2hlZFdvcms7bnVsbCE9PWQ/cWooYSxkLGIpOihhLmZpbmlzaGVkV29yaz1udWxsLGQ9YS50aW1lb3V0SGFuZGxlLC0xIT09ZCYmKGEudGltZW91dEhhbmRsZT0tMSxwZihkKSksS2koYSwhMSxjKSxkPWEuZmluaXNoZWRXb3JrLG51bGwhPT1kJiZxaihhLGQsYikpfWVsc2UgZD1hLmZpbmlzaGVkV29yayxudWxsIT09ZD9xaihhLGQsYik6KGEuZmluaXNoZWRXb3JrPW51bGwsZD1hLnRpbWVvdXRIYW5kbGUsLTEhPT1kJiYoYS50aW1lb3V0SGFuZGxlPS0xLHBmKGQpKSxLaShhLCEwLGMpLGQ9YS5maW5pc2hlZFdvcmssbnVsbCE9PWQmJihMaSgpP2EuZmluaXNoZWRXb3JrPWQ6cWooYSxkLGIpKSk7Vz0hMX1cbmZ1bmN0aW9uIHFqKGEsYixjKXt2YXIgZD1hLmZpcnN0QmF0Y2g7aWYobnVsbCE9PWQmJmQuX2V4cGlyYXRpb25UaW1lPD1jJiYobnVsbD09PWNqP2NqPVtkXTpjai5wdXNoKGQpLGQuX2RlZmVyKSl7YS5maW5pc2hlZFdvcms9YjthLmV4cGlyYXRpb25UaW1lPTA7cmV0dXJufWEuZmluaXNoZWRXb3JrPW51bGw7YT09PWdqP1JpKys6KGdqPWEsUmk9MCk7Qmk9eGk9ITA7YS5jdXJyZW50PT09Yj9yKFwiMTc3XCIpOnZvaWQgMDt2YXIgZT1hLnBlbmRpbmdDb21taXRFeHBpcmF0aW9uVGltZTswPT09ZT9yKFwiMjYxXCIpOnZvaWQgMDthLnBlbmRpbmdDb21taXRFeHBpcmF0aW9uVGltZT0wO3ZhciBmPWIuZXhwaXJhdGlvblRpbWUsZz1iLmNoaWxkRXhwaXJhdGlvblRpbWUsaD0wPT09Znx8MCE9PWcmJmc8Zj9nOmY7YS5kaWRFcnJvcj0hMTtpZigwPT09aClhLmVhcmxpZXN0UGVuZGluZ1RpbWU9MCxhLmxhdGVzdFBlbmRpbmdUaW1lPTAsYS5lYXJsaWVzdFN1c3BlbmRlZFRpbWU9MCxhLmxhdGVzdFN1c3BlbmRlZFRpbWU9XG4wLGEubGF0ZXN0UGluZ2VkVGltZT0wO2Vsc2V7dmFyIGs9YS5sYXRlc3RQZW5kaW5nVGltZTswIT09ayYmKGs8aD9hLmVhcmxpZXN0UGVuZGluZ1RpbWU9YS5sYXRlc3RQZW5kaW5nVGltZT0wOmEuZWFybGllc3RQZW5kaW5nVGltZTxoJiYoYS5lYXJsaWVzdFBlbmRpbmdUaW1lPWEubGF0ZXN0UGVuZGluZ1RpbWUpKTt2YXIgbD1hLmVhcmxpZXN0U3VzcGVuZGVkVGltZTswPT09bD9RZihhLGgpOmg+YS5sYXRlc3RTdXNwZW5kZWRUaW1lPyhhLmVhcmxpZXN0U3VzcGVuZGVkVGltZT0wLGEubGF0ZXN0U3VzcGVuZGVkVGltZT0wLGEubGF0ZXN0UGluZ2VkVGltZT0wLFFmKGEsaCkpOmg8bCYmUWYoYSxoKX1SZigwLGEpO3VpLmN1cnJlbnQ9bnVsbDtpZigxPGIuZWZmZWN0VGFnKWlmKG51bGwhPT1iLmxhc3RFZmZlY3Qpe2IubGFzdEVmZmVjdC5uZXh0RWZmZWN0PWI7dmFyIG09Yi5maXJzdEVmZmVjdH1lbHNlIG09YjtlbHNlIG09Yi5maXJzdEVmZmVjdDtVZT1jZTt2YXIgcD1vZSgpO2lmKHBlKHApKXtpZihcInNlbGVjdGlvblN0YXJ0XCJpblxucCl2YXIgdz17c3RhcnQ6cC5zZWxlY3Rpb25TdGFydCxlbmQ6cC5zZWxlY3Rpb25FbmR9O2Vsc2UgYTp7dmFyIEU9cC5vd25lckRvY3VtZW50LHg9RSYmRS5kZWZhdWx0Vmlld3x8d2luZG93LEY9eC5nZXRTZWxlY3Rpb24mJnguZ2V0U2VsZWN0aW9uKCk7aWYoRiYmMCE9PUYucmFuZ2VDb3VudCl7dmFyIHY9Ri5hbmNob3JOb2RlLHE9Ri5hbmNob3JPZmZzZXQsQj1GLmZvY3VzTm9kZSxDZT1GLmZvY3VzT2Zmc2V0O3RyeXt2Lm5vZGVUeXBlLEIubm9kZVR5cGV9Y2F0Y2goc2Ipe3c9bnVsbDticmVhayBhfXZhciBaYj0wLFpjPS0xLCRjPS0xLHZqPTAsd2o9MCx0PXAsJGI9bnVsbDtiOmZvcig7Oyl7Zm9yKHZhciBhZDs7KXt0IT09dnx8MCE9PXEmJjMhPT10Lm5vZGVUeXBlfHwoWmM9WmIrcSk7dCE9PUJ8fDAhPT1DZSYmMyE9PXQubm9kZVR5cGV8fCgkYz1aYitDZSk7Mz09PXQubm9kZVR5cGUmJihaYis9dC5ub2RlVmFsdWUubGVuZ3RoKTtpZihudWxsPT09KGFkPXQuZmlyc3RDaGlsZCkpYnJlYWs7XG4kYj10O3Q9YWR9Zm9yKDs7KXtpZih0PT09cClicmVhayBiOyRiPT09diYmKyt2aj09PXEmJihaYz1aYik7JGI9PT1CJiYrK3dqPT09Q2UmJigkYz1aYik7aWYobnVsbCE9PShhZD10Lm5leHRTaWJsaW5nKSlicmVhazt0PSRiOyRiPXQucGFyZW50Tm9kZX10PWFkfXc9LTE9PT1aY3x8LTE9PT0kYz9udWxsOntzdGFydDpaYyxlbmQ6JGN9fWVsc2Ugdz1udWxsfXZhciBNaD13fHx7c3RhcnQ6MCxlbmQ6MH19ZWxzZSBNaD1udWxsO2xmPXtmb2N1c2VkRWxlbTpwLHNlbGVjdGlvblJhbmdlOk1ofTtjZT0hMTtmb3IoVj1tO251bGwhPT1WOyl7dmFyIE5oPSExLE9oPXZvaWQgMDt0cnl7Zm9yKDtudWxsIT09Vjspe2lmKFYuZWZmZWN0VGFnJjI1NilhOnt2YXIgVmU9Vi5hbHRlcm5hdGUsdGI9Vjtzd2l0Y2godGIudGFnKXtjYXNlIDA6Y2FzZSAxMTpjYXNlIDE1OmlpKDIsMCx0Yik7YnJlYWsgYTtjYXNlIDE6aWYodGIuZWZmZWN0VGFnJjI1NiYmbnVsbCE9PVZlKXt2YXIgSWo9VmUubWVtb2l6ZWRQcm9wcyxcbkpqPVZlLm1lbW9pemVkU3RhdGUsbWQ9dGIuc3RhdGVOb2RlO21kLnByb3BzPXRiLm1lbW9pemVkUHJvcHM7bWQuc3RhdGU9dGIubWVtb2l6ZWRTdGF0ZTt2YXIgS2o9bWQuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoSWosSmopO21kLl9fcmVhY3RJbnRlcm5hbFNuYXBzaG90QmVmb3JlVXBkYXRlPUtqfWJyZWFrIGE7Y2FzZSAzOmNhc2UgNTpjYXNlIDY6Y2FzZSA0OmNhc2UgMTc6YnJlYWsgYTtkZWZhdWx0OnIoXCIxNjNcIil9fVY9Vi5uZXh0RWZmZWN0fX1jYXRjaChzYil7Tmg9ITAsT2g9c2J9TmgmJihudWxsPT09Vj9yKFwiMTc4XCIpOnZvaWQgMCxoaShWLE9oKSxudWxsIT09ViYmKFY9Vi5uZXh0RWZmZWN0KSl9Zm9yKFY9bTtudWxsIT09Vjspe3ZhciBQaD0hMSxRaD12b2lkIDA7dHJ5e2Zvcig7bnVsbCE9PVY7KXt2YXIgV2U9Vi5lZmZlY3RUYWc7V2UmMTYmJkxlKFYuc3RhdGVOb2RlLFwiXCIpO2lmKFdlJjEyOCl7dmFyIFJoPVYuYWx0ZXJuYXRlO2lmKG51bGwhPT1SaCl7dmFyIG5kPVxuUmgucmVmO251bGwhPT1uZCYmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiBuZD9uZChudWxsKTpuZC5jdXJyZW50PW51bGwpfX1zd2l0Y2goV2UmMTQpe2Nhc2UgMjptaShWKTtWLmVmZmVjdFRhZyY9LTM7YnJlYWs7Y2FzZSA2Om1pKFYpO1YuZWZmZWN0VGFnJj0tMztuaShWLmFsdGVybmF0ZSxWKTticmVhaztjYXNlIDQ6bmkoVi5hbHRlcm5hdGUsVik7YnJlYWs7Y2FzZSA4OnZhciBTaD1WO2tpKFNoKTt2YXIgZmM9U2g7ZmMucmV0dXJuPW51bGw7ZmMuY2hpbGQ9bnVsbDtmYy5hbHRlcm5hdGUmJihmYy5hbHRlcm5hdGUuY2hpbGQ9bnVsbCxmYy5hbHRlcm5hdGUucmV0dXJuPW51bGwpfVY9Vi5uZXh0RWZmZWN0fX1jYXRjaChzYil7UGg9ITAsUWg9c2J9UGgmJihudWxsPT09Vj9yKFwiMTc4XCIpOnZvaWQgMCxoaShWLFFoKSxudWxsIT09ViYmKFY9Vi5uZXh0RWZmZWN0KSl9dmFyIFRoPWxmLExqPW9lKCksSD1UaC5mb2N1c2VkRWxlbSx1Yj1UaC5zZWxlY3Rpb25SYW5nZTtpZihMaiE9PUgmJlxuSCYmSC5vd25lckRvY3VtZW50JiZuZShILm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LEgpKXtpZihudWxsIT09dWImJnBlKEgpKXt2YXIgVWg9dWIuc3RhcnQsWGU9dWIuZW5kO3ZvaWQgMD09PVhlJiYoWGU9VWgpO2lmKFwic2VsZWN0aW9uU3RhcnRcImluIEgpSC5zZWxlY3Rpb25TdGFydD1VaCxILnNlbGVjdGlvbkVuZD1NYXRoLm1pbihYZSxILnZhbHVlLmxlbmd0aCk7ZWxzZXt2YXIgWWU9SC5vd25lckRvY3VtZW50fHxkb2N1bWVudCxmYT0oWWUmJlllLmRlZmF1bHRWaWV3fHx3aW5kb3cpLmdldFNlbGVjdGlvbigpLFZoPUgudGV4dENvbnRlbnQubGVuZ3RoLHZiPU1hdGgubWluKHViLnN0YXJ0LFZoKSxnYz12b2lkIDA9PT11Yi5lbmQ/dmI6TWF0aC5taW4odWIuZW5kLFZoKTtpZighZmEuZXh0ZW5kJiZ2Yj5nYyl7dmFyIE1qPWdjO2djPXZiO3ZiPU1qfXZhciBoYz1tZShILHZiKSxVYT1tZShILGdjKTtpZihoYyYmVWEmJigxIT09ZmEucmFuZ2VDb3VudHx8ZmEuYW5jaG9yTm9kZSE9PVxuaGMubm9kZXx8ZmEuYW5jaG9yT2Zmc2V0IT09aGMub2Zmc2V0fHxmYS5mb2N1c05vZGUhPT1VYS5ub2RlfHxmYS5mb2N1c09mZnNldCE9PVVhLm9mZnNldCkpe3ZhciBvZD1ZZS5jcmVhdGVSYW5nZSgpO29kLnNldFN0YXJ0KGhjLm5vZGUsaGMub2Zmc2V0KTtmYS5yZW1vdmVBbGxSYW5nZXMoKTt2Yj5nYz8oZmEuYWRkUmFuZ2Uob2QpLGZhLmV4dGVuZChVYS5ub2RlLFVhLm9mZnNldCkpOihvZC5zZXRFbmQoVWEubm9kZSxVYS5vZmZzZXQpLGZhLmFkZFJhbmdlKG9kKSl9fX1mb3IodmFyIFplPVtdLHdiPUg7d2I9d2IucGFyZW50Tm9kZTspMT09PXdiLm5vZGVUeXBlJiZaZS5wdXNoKHtlbGVtZW50OndiLGxlZnQ6d2Iuc2Nyb2xsTGVmdCx0b3A6d2Iuc2Nyb2xsVG9wfSk7XCJmdW5jdGlvblwiPT09dHlwZW9mIEguZm9jdXMmJkguZm9jdXMoKTtmb3IodmFyICRlPTA7JGU8WmUubGVuZ3RoOyRlKyspe3ZhciBwZD1aZVskZV07cGQuZWxlbWVudC5zY3JvbGxMZWZ0PXBkLmxlZnQ7cGQuZWxlbWVudC5zY3JvbGxUb3A9XG5wZC50b3B9fWxmPW51bGw7Y2U9ISFVZTtVZT1udWxsO2EuY3VycmVudD1iO2ZvcihWPW07bnVsbCE9PVY7KXt2YXIgV2g9ITEsWGg9dm9pZCAwO3RyeXtmb3IodmFyIE5qPWEsT2o9ZTtudWxsIT09Vjspe3ZhciBhZj1WLmVmZmVjdFRhZztpZihhZiYzNil7dmFyIHFkPXZvaWQgMCx4Yj1WLmFsdGVybmF0ZSx5PVYsWWg9T2o7c3dpdGNoKHkudGFnKXtjYXNlIDA6Y2FzZSAxMTpjYXNlIDE1OmlpKDE2LDMyLHkpO3ZhciBiZj15LnVwZGF0ZVF1ZXVlO2lmKG51bGwhPT1iZil7dmFyIGNmPWJmLmNhbGxiYWNrTGlzdDtpZihudWxsIT09Y2Ype2JmLmNhbGxiYWNrTGlzdD1udWxsO2Zvcih2YXIgZGY9MDtkZjxjZi5sZW5ndGg7ZGYrKyl7dmFyIFpoPWNmW2RmXSxQaj1aaC5jYWxsYmFjaztaaC5jYWxsYmFjaz1udWxsO1BqKCl9fX1icmVhaztjYXNlIDE6dmFyIGhhPXkuc3RhdGVOb2RlO2lmKHkuZWZmZWN0VGFnJjQpaWYobnVsbD09PXhiKWhhLnByb3BzPXkubWVtb2l6ZWRQcm9wcyxoYS5zdGF0ZT1cbnkubWVtb2l6ZWRTdGF0ZSxoYS5jb21wb25lbnREaWRNb3VudCgpO2Vsc2V7dmFyIFFqPXhiLm1lbW9pemVkUHJvcHMsUmo9eGIubWVtb2l6ZWRTdGF0ZTtoYS5wcm9wcz15Lm1lbW9pemVkUHJvcHM7aGEuc3RhdGU9eS5tZW1vaXplZFN0YXRlO2hhLmNvbXBvbmVudERpZFVwZGF0ZShRaixSaixoYS5fX3JlYWN0SW50ZXJuYWxTbmFwc2hvdEJlZm9yZVVwZGF0ZSl9dmFyICRoPXkudXBkYXRlUXVldWU7bnVsbCE9PSRoJiYoaGEucHJvcHM9eS5tZW1vaXplZFByb3BzLGhhLnN0YXRlPXkubWVtb2l6ZWRTdGF0ZSxkZyh5LCRoLGhhLFloKSk7YnJlYWs7Y2FzZSAzOnZhciBhaT15LnVwZGF0ZVF1ZXVlO2lmKG51bGwhPT1haSl7dmFyIGVmPW51bGw7aWYobnVsbCE9PXkuY2hpbGQpc3dpdGNoKHkuY2hpbGQudGFnKXtjYXNlIDU6ZWY9eS5jaGlsZC5zdGF0ZU5vZGU7YnJlYWs7Y2FzZSAxOmVmPXkuY2hpbGQuc3RhdGVOb2RlfWRnKHksYWksZWYsWWgpfWJyZWFrO2Nhc2UgNTp2YXIgU2o9eS5zdGF0ZU5vZGU7XG5udWxsPT09eGImJnkuZWZmZWN0VGFnJjQmJm1mKHkudHlwZSx5Lm1lbW9pemVkUHJvcHMpJiZTai5mb2N1cygpO2JyZWFrO2Nhc2UgNjpicmVhaztjYXNlIDQ6YnJlYWs7Y2FzZSAxMjpicmVhaztjYXNlIDEzOmlmKHkuZWZmZWN0VGFnJjMyKXt5Lm1lbW9pemVkU3RhdGU9e2FscmVhZHlDYXB0dXJlZDohMCxkaWRUaW1lb3V0OiExLHRpbWVkT3V0QXQ6MH07TGcoKTtNZyh5LDEpO2JyZWFrfXZhciBiaT1udWxsIT09eGI/eGIubWVtb2l6ZWRTdGF0ZTpudWxsLGljPXkubWVtb2l6ZWRTdGF0ZSxUaj1udWxsIT09Ymk/YmkuZGlkVGltZW91dDohMSxmZj15O2lmKG51bGw9PT1pYylxZD0hMTtlbHNlIGlmKHFkPWljLmRpZFRpbWVvdXQpZmY9eS5jaGlsZCxpYy5hbHJlYWR5Q2FwdHVyZWQ9ITEsMD09PWljLnRpbWVkT3V0QXQmJihpYy50aW1lZE91dEF0PUpnKCkpO2lmKHFkIT09VGomJm51bGwhPT1mZilhOmZvcih2YXIgZ2Y9ZmYsY2k9cWQsQT1nZjs7KXtpZig1PT09QS50YWcpe3ZhciBVaj1cbkEuc3RhdGVOb2RlO2lmKGNpKVVqLnN0eWxlLmRpc3BsYXk9XCJub25lXCI7ZWxzZXt2YXIgVmo9QS5zdGF0ZU5vZGUscmQ9QS5tZW1vaXplZFByb3BzLnN0eWxlLFdqPXZvaWQgMCE9PXJkJiZudWxsIT09cmQmJnJkLmhhc093blByb3BlcnR5KFwiZGlzcGxheVwiKT9yZC5kaXNwbGF5Om51bGw7Vmouc3R5bGUuZGlzcGxheT1Xan19ZWxzZSBpZig2PT09QS50YWcpQS5zdGF0ZU5vZGUubm9kZVZhbHVlPWNpP1wiXCI6QS5tZW1vaXplZFByb3BzO2Vsc2UgaWYobnVsbCE9PUEuY2hpbGQpe0EuY2hpbGQucmV0dXJuPUE7QT1BLmNoaWxkO2NvbnRpbnVlfWlmKEE9PT1nZilicmVhayBhO2Zvcig7bnVsbD09PUEuc2libGluZzspe2lmKG51bGw9PT1BLnJldHVybnx8QS5yZXR1cm49PT1nZilicmVhayBhO0E9QS5yZXR1cm59QS5zaWJsaW5nLnJldHVybj1BLnJldHVybjtBPUEuc2libGluZ31icmVhaztjYXNlIDE3OmJyZWFrO2RlZmF1bHQ6cihcIjE2M1wiKX19aWYoYWYmMTI4KXt2YXIgc2Q9Vi5yZWY7XG5pZihudWxsIT09c2Qpe3ZhciBkaT1WLnN0YXRlTm9kZTtzd2l0Y2goVi50YWcpe2Nhc2UgNTp2YXIgaGY9ZGk7YnJlYWs7ZGVmYXVsdDpoZj1kaX1cImZ1bmN0aW9uXCI9PT10eXBlb2Ygc2Q/c2QoaGYpOnNkLmN1cnJlbnQ9aGZ9fWFmJjUxMiYmKENpPU5qKTtWPVYubmV4dEVmZmVjdH19Y2F0Y2goc2Ipe1doPSEwLFhoPXNifVdoJiYobnVsbD09PVY/cihcIjE3OFwiKTp2b2lkIDAsaGkoVixYaCksbnVsbCE9PVYmJihWPVYubmV4dEVmZmVjdCkpfWlmKG51bGwhPT1tJiZudWxsIT09Q2kpe3ZhciBlaT1HaS5iaW5kKG51bGwsYSxtKTtEaT1iYS51bnN0YWJsZV9zY2hlZHVsZUNhbGxiYWNrKGVpKTtFaT1laX14aT1CaT0hMTtcImZ1bmN0aW9uXCI9PT10eXBlb2YgRGYmJkRmKGIuc3RhdGVOb2RlKTt2YXIgamY9Yi5leHBpcmF0aW9uVGltZSxrZj1iLmNoaWxkRXhwaXJhdGlvblRpbWUsZmk9MD09PWpmfHwwIT09a2YmJmtmPGpmP2tmOmpmOzA9PT1maSYmKHJpPW51bGwpO2EuZXhwaXJhdGlvblRpbWU9XG5maTthLmZpbmlzaGVkV29yaz1udWxsfWZ1bmN0aW9uIExpKCl7cmV0dXJuIFlpPyEwOm51bGw9PT1hanx8YWoudGltZVJlbWFpbmluZygpPmhqPyExOllpPSEwfWZ1bmN0aW9uIHBpKGEpe251bGw9PT1YaT9yKFwiMjQ2XCIpOnZvaWQgMDtYaS5leHBpcmF0aW9uVGltZT0wO1ppfHwoWmk9ITAsJGk9YSl9ZnVuY3Rpb24gcmooYSxiKXt2YXIgYz1aO1o9ITA7dHJ5e3JldHVybiBhKGIpfWZpbmFsbHl7KFo9Yyl8fFd8fHBqKDEsbnVsbCl9fWZ1bmN0aW9uIHNqKGEsYil7aWYoWiYmIWJqKXtiaj0hMDt0cnl7cmV0dXJuIGEoYil9ZmluYWxseXtiaj0hMX19cmV0dXJuIGEoYil9ZnVuY3Rpb24gdGooYSxiLGMpe2lmKE9pKXJldHVybiBhKGIsYyk7Wnx8V3x8MD09PVBpfHwocGooUGksbnVsbCksUGk9MCk7dmFyIGQ9T2ksZT1aO1o9T2k9ITA7dHJ5e3JldHVybiBhKGIsYyl9ZmluYWxseXtPaT1kLChaPWUpfHxXfHxwaigxLG51bGwpfX1cbmZ1bmN0aW9uIHVqKGEsYixjLGQsZSl7dmFyIGY9Yi5jdXJyZW50O2E6aWYoYyl7Yz1jLl9yZWFjdEludGVybmFsRmliZXI7Yjp7Mj09PUdkKGMpJiYxPT09Yy50YWc/dm9pZCAwOnIoXCIxNzBcIik7dmFyIGc9Yztkb3tzd2l0Y2goZy50YWcpe2Nhc2UgMzpnPWcuc3RhdGVOb2RlLmNvbnRleHQ7YnJlYWsgYjtjYXNlIDE6aWYoTShnLnR5cGUpKXtnPWcuc3RhdGVOb2RlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0O2JyZWFrIGJ9fWc9Zy5yZXR1cm59d2hpbGUobnVsbCE9PWcpO3IoXCIxNzFcIik7Zz12b2lkIDB9aWYoMT09PWMudGFnKXt2YXIgaD1jLnR5cGU7aWYoTShoKSl7Yz1BZihjLGgsZyk7YnJlYWsgYX19Yz1nfWVsc2UgYz11ZjtudWxsPT09Yi5jb250ZXh0P2IuY29udGV4dD1jOmIucGVuZGluZ0NvbnRleHQ9YztiPWU7ZT1YZihkKTtlLnBheWxvYWQ9e2VsZW1lbnQ6YX07Yj12b2lkIDA9PT1iP251bGw6YjtudWxsIT09YiYmKGUuY2FsbGJhY2s9Yik7XG5MZygpO1pmKGYsZSk7TWcoZixkKTtyZXR1cm4gZH1mdW5jdGlvbiB4aihhLGIsYyxkKXt2YXIgZT1iLmN1cnJlbnQsZj1KZygpO2U9S2coZixlKTtyZXR1cm4gdWooYSxiLGMsZSxkKX1mdW5jdGlvbiB5aihhKXthPWEuY3VycmVudDtpZighYS5jaGlsZClyZXR1cm4gbnVsbDtzd2l0Y2goYS5jaGlsZC50YWcpe2Nhc2UgNTpyZXR1cm4gYS5jaGlsZC5zdGF0ZU5vZGU7ZGVmYXVsdDpyZXR1cm4gYS5jaGlsZC5zdGF0ZU5vZGV9fWZ1bmN0aW9uIHpqKGEsYixjKXt2YXIgZD0zPGFyZ3VtZW50cy5sZW5ndGgmJnZvaWQgMCE9PWFyZ3VtZW50c1szXT9hcmd1bWVudHNbM106bnVsbDtyZXR1cm57JCR0eXBlb2Y6bmMsa2V5Om51bGw9PWQ/bnVsbDpcIlwiK2QsY2hpbGRyZW46YSxjb250YWluZXJJbmZvOmIsaW1wbGVtZW50YXRpb246Y319XG5NYj1mdW5jdGlvbihhLGIsYyl7c3dpdGNoKGIpe2Nhc2UgXCJpbnB1dFwiOlFjKGEsYyk7Yj1jLm5hbWU7aWYoXCJyYWRpb1wiPT09Yy50eXBlJiZudWxsIT1iKXtmb3IoYz1hO2MucGFyZW50Tm9kZTspYz1jLnBhcmVudE5vZGU7Yz1jLnF1ZXJ5U2VsZWN0b3JBbGwoXCJpbnB1dFtuYW1lPVwiK0pTT04uc3RyaW5naWZ5KFwiXCIrYikrJ11bdHlwZT1cInJhZGlvXCJdJyk7Zm9yKGI9MDtiPGMubGVuZ3RoO2IrKyl7dmFyIGQ9Y1tiXTtpZihkIT09YSYmZC5mb3JtPT09YS5mb3JtKXt2YXIgZT1QYShkKTtlP3ZvaWQgMDpyKFwiOTBcIik7amMoZCk7UWMoZCxlKX19fWJyZWFrO2Nhc2UgXCJ0ZXh0YXJlYVwiOkVlKGEsYyk7YnJlYWs7Y2FzZSBcInNlbGVjdFwiOmI9Yy52YWx1ZSxudWxsIT1iJiZBZShhLCEhYy5tdWx0aXBsZSxiLCExKX19O1xuZnVuY3Rpb24gQWooYSl7dmFyIGI9MisyNSooKChKZygpLTIrNTAwKS8yNXwwKSsxKTtiPD12aSYmKGI9dmkrMSk7dGhpcy5fZXhwaXJhdGlvblRpbWU9dmk9Yjt0aGlzLl9yb290PWE7dGhpcy5fY2FsbGJhY2tzPXRoaXMuX25leHQ9bnVsbDt0aGlzLl9oYXNDaGlsZHJlbj10aGlzLl9kaWRDb21wbGV0ZT0hMTt0aGlzLl9jaGlsZHJlbj1udWxsO3RoaXMuX2RlZmVyPSEwfUFqLnByb3RvdHlwZS5yZW5kZXI9ZnVuY3Rpb24oYSl7dGhpcy5fZGVmZXI/dm9pZCAwOnIoXCIyNTBcIik7dGhpcy5faGFzQ2hpbGRyZW49ITA7dGhpcy5fY2hpbGRyZW49YTt2YXIgYj10aGlzLl9yb290Ll9pbnRlcm5hbFJvb3QsYz10aGlzLl9leHBpcmF0aW9uVGltZSxkPW5ldyBCajt1aihhLGIsbnVsbCxjLGQuX29uQ29tbWl0KTtyZXR1cm4gZH07XG5Bai5wcm90b3R5cGUudGhlbj1mdW5jdGlvbihhKXtpZih0aGlzLl9kaWRDb21wbGV0ZSlhKCk7ZWxzZXt2YXIgYj10aGlzLl9jYWxsYmFja3M7bnVsbD09PWImJihiPXRoaXMuX2NhbGxiYWNrcz1bXSk7Yi5wdXNoKGEpfX07XG5Bai5wcm90b3R5cGUuY29tbWl0PWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5fcm9vdC5faW50ZXJuYWxSb290LGI9YS5maXJzdEJhdGNoO3RoaXMuX2RlZmVyJiZudWxsIT09Yj92b2lkIDA6cihcIjI1MVwiKTtpZih0aGlzLl9oYXNDaGlsZHJlbil7dmFyIGM9dGhpcy5fZXhwaXJhdGlvblRpbWU7aWYoYiE9PXRoaXMpe3RoaXMuX2hhc0NoaWxkcmVuJiYoYz10aGlzLl9leHBpcmF0aW9uVGltZT1iLl9leHBpcmF0aW9uVGltZSx0aGlzLnJlbmRlcih0aGlzLl9jaGlsZHJlbikpO2Zvcih2YXIgZD1udWxsLGU9YjtlIT09dGhpczspZD1lLGU9ZS5fbmV4dDtudWxsPT09ZD9yKFwiMjUxXCIpOnZvaWQgMDtkLl9uZXh0PWUuX25leHQ7dGhpcy5fbmV4dD1iO2EuZmlyc3RCYXRjaD10aGlzfXRoaXMuX2RlZmVyPSExO21qKGEsYyk7Yj10aGlzLl9uZXh0O3RoaXMuX25leHQ9bnVsbDtiPWEuZmlyc3RCYXRjaD1iO251bGwhPT1iJiZiLl9oYXNDaGlsZHJlbiYmYi5yZW5kZXIoYi5fY2hpbGRyZW4pfWVsc2UgdGhpcy5fbmV4dD1cbm51bGwsdGhpcy5fZGVmZXI9ITF9O0FqLnByb3RvdHlwZS5fb25Db21wbGV0ZT1mdW5jdGlvbigpe2lmKCF0aGlzLl9kaWRDb21wbGV0ZSl7dGhpcy5fZGlkQ29tcGxldGU9ITA7dmFyIGE9dGhpcy5fY2FsbGJhY2tzO2lmKG51bGwhPT1hKWZvcih2YXIgYj0wO2I8YS5sZW5ndGg7YisrKSgwLGFbYl0pKCl9fTtmdW5jdGlvbiBCaigpe3RoaXMuX2NhbGxiYWNrcz1udWxsO3RoaXMuX2RpZENvbW1pdD0hMTt0aGlzLl9vbkNvbW1pdD10aGlzLl9vbkNvbW1pdC5iaW5kKHRoaXMpfUJqLnByb3RvdHlwZS50aGVuPWZ1bmN0aW9uKGEpe2lmKHRoaXMuX2RpZENvbW1pdClhKCk7ZWxzZXt2YXIgYj10aGlzLl9jYWxsYmFja3M7bnVsbD09PWImJihiPXRoaXMuX2NhbGxiYWNrcz1bXSk7Yi5wdXNoKGEpfX07XG5Cai5wcm90b3R5cGUuX29uQ29tbWl0PWZ1bmN0aW9uKCl7aWYoIXRoaXMuX2RpZENvbW1pdCl7dGhpcy5fZGlkQ29tbWl0PSEwO3ZhciBhPXRoaXMuX2NhbGxiYWNrcztpZihudWxsIT09YSlmb3IodmFyIGI9MDtiPGEubGVuZ3RoO2IrKyl7dmFyIGM9YVtiXTtcImZ1bmN0aW9uXCIhPT10eXBlb2YgYz9yKFwiMTkxXCIsYyk6dm9pZCAwO2MoKX19fTtcbmZ1bmN0aW9uIENqKGEsYixjKXtiPU4oMyxudWxsLG51bGwsYj8zOjApO2E9e2N1cnJlbnQ6Yixjb250YWluZXJJbmZvOmEscGVuZGluZ0NoaWxkcmVuOm51bGwsZWFybGllc3RQZW5kaW5nVGltZTowLGxhdGVzdFBlbmRpbmdUaW1lOjAsZWFybGllc3RTdXNwZW5kZWRUaW1lOjAsbGF0ZXN0U3VzcGVuZGVkVGltZTowLGxhdGVzdFBpbmdlZFRpbWU6MCxkaWRFcnJvcjohMSxwZW5kaW5nQ29tbWl0RXhwaXJhdGlvblRpbWU6MCxmaW5pc2hlZFdvcms6bnVsbCx0aW1lb3V0SGFuZGxlOi0xLGNvbnRleHQ6bnVsbCxwZW5kaW5nQ29udGV4dDpudWxsLGh5ZHJhdGU6YyxuZXh0RXhwaXJhdGlvblRpbWVUb1dvcmtPbjowLGV4cGlyYXRpb25UaW1lOjAsZmlyc3RCYXRjaDpudWxsLG5leHRTY2hlZHVsZWRSb290Om51bGx9O3RoaXMuX2ludGVybmFsUm9vdD1iLnN0YXRlTm9kZT1hfVxuQ2oucHJvdG90eXBlLnJlbmRlcj1mdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMuX2ludGVybmFsUm9vdCxkPW5ldyBCajtiPXZvaWQgMD09PWI/bnVsbDpiO251bGwhPT1iJiZkLnRoZW4oYik7eGooYSxjLG51bGwsZC5fb25Db21taXQpO3JldHVybiBkfTtDai5wcm90b3R5cGUudW5tb3VudD1mdW5jdGlvbihhKXt2YXIgYj10aGlzLl9pbnRlcm5hbFJvb3QsYz1uZXcgQmo7YT12b2lkIDA9PT1hP251bGw6YTtudWxsIT09YSYmYy50aGVuKGEpO3hqKG51bGwsYixudWxsLGMuX29uQ29tbWl0KTtyZXR1cm4gY307Q2oucHJvdG90eXBlLmxlZ2FjeV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcj1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9dGhpcy5faW50ZXJuYWxSb290LGU9bmV3IEJqO2M9dm9pZCAwPT09Yz9udWxsOmM7bnVsbCE9PWMmJmUudGhlbihjKTt4aihiLGQsYSxlLl9vbkNvbW1pdCk7cmV0dXJuIGV9O1xuQ2oucHJvdG90eXBlLmNyZWF0ZUJhdGNoPWZ1bmN0aW9uKCl7dmFyIGE9bmV3IEFqKHRoaXMpLGI9YS5fZXhwaXJhdGlvblRpbWUsYz10aGlzLl9pbnRlcm5hbFJvb3QsZD1jLmZpcnN0QmF0Y2g7aWYobnVsbD09PWQpYy5maXJzdEJhdGNoPWEsYS5fbmV4dD1udWxsO2Vsc2V7Zm9yKGM9bnVsbDtudWxsIT09ZCYmZC5fZXhwaXJhdGlvblRpbWU8PWI7KWM9ZCxkPWQuX25leHQ7YS5fbmV4dD1kO251bGwhPT1jJiYoYy5fbmV4dD1hKX1yZXR1cm4gYX07ZnVuY3Rpb24gRGooYSl7cmV0dXJuISghYXx8MSE9PWEubm9kZVR5cGUmJjkhPT1hLm5vZGVUeXBlJiYxMSE9PWEubm9kZVR5cGUmJig4IT09YS5ub2RlVHlwZXx8XCIgcmVhY3QtbW91bnQtcG9pbnQtdW5zdGFibGUgXCIhPT1hLm5vZGVWYWx1ZSkpfVNiPXJqO1RiPXRqO1ViPWZ1bmN0aW9uKCl7V3x8MD09PVBpfHwocGooUGksbnVsbCksUGk9MCl9O1xuZnVuY3Rpb24gRWooYSxiKXtifHwoYj1hPzk9PT1hLm5vZGVUeXBlP2EuZG9jdW1lbnRFbGVtZW50OmEuZmlyc3RDaGlsZDpudWxsLGI9ISghYnx8MSE9PWIubm9kZVR5cGV8fCFiLmhhc0F0dHJpYnV0ZShcImRhdGEtcmVhY3Ryb290XCIpKSk7aWYoIWIpZm9yKHZhciBjO2M9YS5sYXN0Q2hpbGQ7KWEucmVtb3ZlQ2hpbGQoYyk7cmV0dXJuIG5ldyBDaihhLCExLGIpfVxuZnVuY3Rpb24gRmooYSxiLGMsZCxlKXtEaihjKT92b2lkIDA6cihcIjIwMFwiKTt2YXIgZj1jLl9yZWFjdFJvb3RDb250YWluZXI7aWYoZil7aWYoXCJmdW5jdGlvblwiPT09dHlwZW9mIGUpe3ZhciBnPWU7ZT1mdW5jdGlvbigpe3ZhciBhPXlqKGYuX2ludGVybmFsUm9vdCk7Zy5jYWxsKGEpfX1udWxsIT1hP2YubGVnYWN5X3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKGEsYixlKTpmLnJlbmRlcihiLGUpfWVsc2V7Zj1jLl9yZWFjdFJvb3RDb250YWluZXI9RWooYyxkKTtpZihcImZ1bmN0aW9uXCI9PT10eXBlb2YgZSl7dmFyIGg9ZTtlPWZ1bmN0aW9uKCl7dmFyIGE9eWooZi5faW50ZXJuYWxSb290KTtoLmNhbGwoYSl9fXNqKGZ1bmN0aW9uKCl7bnVsbCE9YT9mLmxlZ2FjeV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihhLGIsZSk6Zi5yZW5kZXIoYixlKX0pfXJldHVybiB5aihmLl9pbnRlcm5hbFJvb3QpfVxuZnVuY3Rpb24gR2ooYSxiKXt2YXIgYz0yPGFyZ3VtZW50cy5sZW5ndGgmJnZvaWQgMCE9PWFyZ3VtZW50c1syXT9hcmd1bWVudHNbMl06bnVsbDtEaihiKT92b2lkIDA6cihcIjIwMFwiKTtyZXR1cm4gemooYSxiLG51bGwsYyl9XG52YXIgSGo9e2NyZWF0ZVBvcnRhbDpHaixmaW5kRE9NTm9kZTpmdW5jdGlvbihhKXtpZihudWxsPT1hKXJldHVybiBudWxsO2lmKDE9PT1hLm5vZGVUeXBlKXJldHVybiBhO3ZhciBiPWEuX3JlYWN0SW50ZXJuYWxGaWJlcjt2b2lkIDA9PT1iJiYoXCJmdW5jdGlvblwiPT09dHlwZW9mIGEucmVuZGVyP3IoXCIxODhcIik6cihcIjI2OFwiLE9iamVjdC5rZXlzKGEpKSk7YT1KZChiKTthPW51bGw9PT1hP251bGw6YS5zdGF0ZU5vZGU7cmV0dXJuIGF9LGh5ZHJhdGU6ZnVuY3Rpb24oYSxiLGMpe3JldHVybiBGaihudWxsLGEsYiwhMCxjKX0scmVuZGVyOmZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gRmoobnVsbCxhLGIsITEsYyl9LHVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyOmZ1bmN0aW9uKGEsYixjLGQpe251bGw9PWF8fHZvaWQgMD09PWEuX3JlYWN0SW50ZXJuYWxGaWJlcj9yKFwiMzhcIik6dm9pZCAwO3JldHVybiBGaihhLGIsYywhMSxkKX0sdW5tb3VudENvbXBvbmVudEF0Tm9kZTpmdW5jdGlvbihhKXtEaihhKT9cbnZvaWQgMDpyKFwiNDBcIik7cmV0dXJuIGEuX3JlYWN0Um9vdENvbnRhaW5lcj8oc2ooZnVuY3Rpb24oKXtGaihudWxsLG51bGwsYSwhMSxmdW5jdGlvbigpe2EuX3JlYWN0Um9vdENvbnRhaW5lcj1udWxsfSl9KSwhMCk6ITF9LHVuc3RhYmxlX2NyZWF0ZVBvcnRhbDpmdW5jdGlvbigpe3JldHVybiBHai5hcHBseSh2b2lkIDAsYXJndW1lbnRzKX0sdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXM6cmosdW5zdGFibGVfaW50ZXJhY3RpdmVVcGRhdGVzOnRqLGZsdXNoU3luYzpmdW5jdGlvbihhLGIpe1c/cihcIjE4N1wiKTp2b2lkIDA7dmFyIGM9WjtaPSEwO3RyeXtyZXR1cm4gVGkoYSxiKX1maW5hbGx5e1o9YyxwaigxLG51bGwpfX0sdW5zdGFibGVfZmx1c2hDb250cm9sbGVkOmZ1bmN0aW9uKGEpe3ZhciBiPVo7Wj0hMDt0cnl7VGkoYSl9ZmluYWxseXsoWj1iKXx8V3x8cGooMSxudWxsKX19LF9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEOntFdmVudHM6W05hLFxuT2EsUGEsR2EuaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lLHNhLFdhLGZ1bmN0aW9uKGEpe0JhKGEsVmEpfSxRYixSYixlZSxJYV19LGNyZWF0ZVJvb3Q6ZnVuY3Rpb24oYSxiKXtEaihhKT92b2lkIDA6cihcIjI3OFwiKTtyZXR1cm4gbmV3IENqKGEsITAsbnVsbCE9YiYmITA9PT1iLmh5ZHJhdGUpfX07KGZ1bmN0aW9uKGEpe3ZhciBiPWEuZmluZEZpYmVyQnlIb3N0SW5zdGFuY2U7cmV0dXJuIEdmKG4oe30sYSx7ZmluZEhvc3RJbnN0YW5jZUJ5RmliZXI6ZnVuY3Rpb24oYSl7YT1KZChhKTtyZXR1cm4gbnVsbD09PWE/bnVsbDphLnN0YXRlTm9kZX0sZmluZEZpYmVyQnlIb3N0SW5zdGFuY2U6ZnVuY3Rpb24oYSl7cmV0dXJuIGI/YihhKTpudWxsfX0pKX0pKHtmaW5kRmliZXJCeUhvc3RJbnN0YW5jZTpNYSxidW5kbGVUeXBlOjAsdmVyc2lvbjpcIjE2LjcuMC1hbHBoYS4wXCIscmVuZGVyZXJQYWNrYWdlTmFtZTpcInJlYWN0LWRvbVwifSk7XG52YXIgWGo9e2RlZmF1bHQ6SGp9LFlqPVhqJiZIanx8WGo7bW9kdWxlLmV4cG9ydHM9WWouZGVmYXVsdHx8WWo7XG4iLCIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvc2NoZWR1bGVyLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3NjaGVkdWxlci5kZXZlbG9wbWVudC5qcycpO1xufVxuIiwiLyoqIEBsaWNlbnNlIFJlYWN0IHYwLjExLjNcbiAqIHNjaGVkdWxlci5wcm9kdWN0aW9uLm1pbi5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cyxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgZD1udWxsLGY9ITEsaD0zLGs9LTEsbD0tMSxtPSExLG49ITE7ZnVuY3Rpb24gcCgpe2lmKCFtKXt2YXIgYT1kLmV4cGlyYXRpb25UaW1lO24/cSgpOm49ITA7cih0LGEpfX1cbmZ1bmN0aW9uIHUoKXt2YXIgYT1kLGI9ZC5uZXh0O2lmKGQ9PT1iKWQ9bnVsbDtlbHNle3ZhciBjPWQucHJldmlvdXM7ZD1jLm5leHQ9YjtiLnByZXZpb3VzPWN9YS5uZXh0PWEucHJldmlvdXM9bnVsbDtjPWEuY2FsbGJhY2s7Yj1hLmV4cGlyYXRpb25UaW1lO2E9YS5wcmlvcml0eUxldmVsO3ZhciBlPWgsUT1sO2g9YTtsPWI7dHJ5e3ZhciBnPWMoKX1maW5hbGx5e2g9ZSxsPVF9aWYoXCJmdW5jdGlvblwiPT09dHlwZW9mIGcpaWYoZz17Y2FsbGJhY2s6Zyxwcmlvcml0eUxldmVsOmEsZXhwaXJhdGlvblRpbWU6YixuZXh0Om51bGwscHJldmlvdXM6bnVsbH0sbnVsbD09PWQpZD1nLm5leHQ9Zy5wcmV2aW91cz1nO2Vsc2V7Yz1udWxsO2E9ZDtkb3tpZihhLmV4cGlyYXRpb25UaW1lPj1iKXtjPWE7YnJlYWt9YT1hLm5leHR9d2hpbGUoYSE9PWQpO251bGw9PT1jP2M9ZDpjPT09ZCYmKGQ9ZyxwKCkpO2I9Yy5wcmV2aW91cztiLm5leHQ9Yy5wcmV2aW91cz1nO2cubmV4dD1jO2cucHJldmlvdXM9XG5ifX1mdW5jdGlvbiB2KCl7aWYoLTE9PT1rJiZudWxsIT09ZCYmMT09PWQucHJpb3JpdHlMZXZlbCl7bT0hMDt0cnl7ZG8gdSgpO3doaWxlKG51bGwhPT1kJiYxPT09ZC5wcmlvcml0eUxldmVsKX1maW5hbGx5e209ITEsbnVsbCE9PWQ/cCgpOm49ITF9fX1mdW5jdGlvbiB0KGEpe209ITA7dmFyIGI9ZjtmPWE7dHJ5e2lmKGEpZm9yKDtudWxsIT09ZDspe3ZhciBjPWV4cG9ydHMudW5zdGFibGVfbm93KCk7aWYoZC5leHBpcmF0aW9uVGltZTw9Yyl7ZG8gdSgpO3doaWxlKG51bGwhPT1kJiZkLmV4cGlyYXRpb25UaW1lPD1jKX1lbHNlIGJyZWFrfWVsc2UgaWYobnVsbCE9PWQpe2RvIHUoKTt3aGlsZShudWxsIT09ZCYmIXcoKSl9fWZpbmFsbHl7bT0hMSxmPWIsbnVsbCE9PWQ/cCgpOm49ITEsdigpfX1cbnZhciB4PURhdGUseT1cImZ1bmN0aW9uXCI9PT10eXBlb2Ygc2V0VGltZW91dD9zZXRUaW1lb3V0OnZvaWQgMCx6PVwiZnVuY3Rpb25cIj09PXR5cGVvZiBjbGVhclRpbWVvdXQ/Y2xlYXJUaW1lb3V0OnZvaWQgMCxBPVwiZnVuY3Rpb25cIj09PXR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWU/cmVxdWVzdEFuaW1hdGlvbkZyYW1lOnZvaWQgMCxCPVwiZnVuY3Rpb25cIj09PXR5cGVvZiBjYW5jZWxBbmltYXRpb25GcmFtZT9jYW5jZWxBbmltYXRpb25GcmFtZTp2b2lkIDAsQyxEO2Z1bmN0aW9uIEUoYSl7Qz1BKGZ1bmN0aW9uKGIpe3ooRCk7YShiKX0pO0Q9eShmdW5jdGlvbigpe0IoQyk7YShleHBvcnRzLnVuc3RhYmxlX25vdygpKX0sMTAwKX1cbmlmKFwib2JqZWN0XCI9PT10eXBlb2YgcGVyZm9ybWFuY2UmJlwiZnVuY3Rpb25cIj09PXR5cGVvZiBwZXJmb3JtYW5jZS5ub3cpe3ZhciBGPXBlcmZvcm1hbmNlO2V4cG9ydHMudW5zdGFibGVfbm93PWZ1bmN0aW9uKCl7cmV0dXJuIEYubm93KCl9fWVsc2UgZXhwb3J0cy51bnN0YWJsZV9ub3c9ZnVuY3Rpb24oKXtyZXR1cm4geC5ub3coKX07dmFyIHIscSx3LEc9bnVsbDtcInVuZGVmaW5lZFwiIT09dHlwZW9mIHdpbmRvdz9HPXdpbmRvdzpcInVuZGVmaW5lZFwiIT09dHlwZW9mIGdsb2JhbCYmKEc9Z2xvYmFsKTtcbmlmKEcmJkcuX3NjaGVkTW9jayl7dmFyIEg9Ry5fc2NoZWRNb2NrO3I9SFswXTtxPUhbMV07dz1IWzJdO2V4cG9ydHMudW5zdGFibGVfbm93PUhbM119ZWxzZSBpZihcInVuZGVmaW5lZFwiPT09dHlwZW9mIHdpbmRvd3x8XCJmdW5jdGlvblwiIT09dHlwZW9mIE1lc3NhZ2VDaGFubmVsKXt2YXIgST1udWxsLEo9ZnVuY3Rpb24oYSl7aWYobnVsbCE9PUkpdHJ5e0koYSl9ZmluYWxseXtJPW51bGx9fTtyPWZ1bmN0aW9uKGEpe251bGwhPT1JP3NldFRpbWVvdXQociwwLGEpOihJPWEsc2V0VGltZW91dChKLDAsITEpKX07cT1mdW5jdGlvbigpe0k9bnVsbH07dz1mdW5jdGlvbigpe3JldHVybiExfX1lbHNle1widW5kZWZpbmVkXCIhPT10eXBlb2YgY29uc29sZSYmKFwiZnVuY3Rpb25cIiE9PXR5cGVvZiBBJiZjb25zb2xlLmVycm9yKFwiVGhpcyBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUuIE1ha2Ugc3VyZSB0aGF0IHlvdSBsb2FkIGEgcG9seWZpbGwgaW4gb2xkZXIgYnJvd3NlcnMuIGh0dHBzOi8vZmIubWUvcmVhY3QtcG9seWZpbGxzXCIpLFxuXCJmdW5jdGlvblwiIT09dHlwZW9mIEImJmNvbnNvbGUuZXJyb3IoXCJUaGlzIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IGNhbmNlbEFuaW1hdGlvbkZyYW1lLiBNYWtlIHN1cmUgdGhhdCB5b3UgbG9hZCBhIHBvbHlmaWxsIGluIG9sZGVyIGJyb3dzZXJzLiBodHRwczovL2ZiLm1lL3JlYWN0LXBvbHlmaWxsc1wiKSk7dmFyIEs9bnVsbCxMPSExLE09LTEsTj0hMSxPPSExLFA9MCxSPTMzLFM9MzM7dz1mdW5jdGlvbigpe3JldHVybiBQPD1leHBvcnRzLnVuc3RhYmxlX25vdygpfTt2YXIgVD1uZXcgTWVzc2FnZUNoYW5uZWwsVT1ULnBvcnQyO1QucG9ydDEub25tZXNzYWdlPWZ1bmN0aW9uKCl7TD0hMTt2YXIgYT1LLGI9TTtLPW51bGw7TT0tMTt2YXIgYz1leHBvcnRzLnVuc3RhYmxlX25vdygpLGU9ITE7aWYoMD49UC1jKWlmKC0xIT09YiYmYjw9YyllPSEwO2Vsc2V7Tnx8KE49ITAsRShWKSk7Sz1hO009YjtyZXR1cm59aWYobnVsbCE9PWEpe089ITA7dHJ5e2EoZSl9ZmluYWxseXtPPSExfX19O1xudmFyIFY9ZnVuY3Rpb24oYSl7aWYobnVsbCE9PUspe0UoVik7dmFyIGI9YS1QK1M7YjxTJiZSPFM/KDg+YiYmKGI9OCksUz1iPFI/UjpiKTpSPWI7UD1hK1M7THx8KEw9ITAsVS5wb3N0TWVzc2FnZSh2b2lkIDApKX1lbHNlIE49ITF9O3I9ZnVuY3Rpb24oYSxiKXtLPWE7TT1iO098fDA+Yj9VLnBvc3RNZXNzYWdlKHZvaWQgMCk6Tnx8KE49ITAsRShWKSl9O3E9ZnVuY3Rpb24oKXtLPW51bGw7TD0hMTtNPS0xfX1leHBvcnRzLnVuc3RhYmxlX0ltbWVkaWF0ZVByaW9yaXR5PTE7ZXhwb3J0cy51bnN0YWJsZV9Vc2VyQmxvY2tpbmdQcmlvcml0eT0yO2V4cG9ydHMudW5zdGFibGVfTm9ybWFsUHJpb3JpdHk9MztleHBvcnRzLnVuc3RhYmxlX0lkbGVQcmlvcml0eT01O2V4cG9ydHMudW5zdGFibGVfTG93UHJpb3JpdHk9NDtcbmV4cG9ydHMudW5zdGFibGVfcnVuV2l0aFByaW9yaXR5PWZ1bmN0aW9uKGEsYil7c3dpdGNoKGEpe2Nhc2UgMTpjYXNlIDI6Y2FzZSAzOmNhc2UgNDpjYXNlIDU6YnJlYWs7ZGVmYXVsdDphPTN9dmFyIGM9aCxlPWs7aD1hO2s9ZXhwb3J0cy51bnN0YWJsZV9ub3coKTt0cnl7cmV0dXJuIGIoKX1maW5hbGx5e2g9YyxrPWUsdigpfX07XG5leHBvcnRzLnVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2s9ZnVuY3Rpb24oYSxiKXt2YXIgYz0tMSE9PWs/azpleHBvcnRzLnVuc3RhYmxlX25vdygpO2lmKFwib2JqZWN0XCI9PT10eXBlb2YgYiYmbnVsbCE9PWImJlwibnVtYmVyXCI9PT10eXBlb2YgYi50aW1lb3V0KWI9YytiLnRpbWVvdXQ7ZWxzZSBzd2l0Y2goaCl7Y2FzZSAxOmI9YystMTticmVhaztjYXNlIDI6Yj1jKzI1MDticmVhaztjYXNlIDU6Yj1jKzEwNzM3NDE4MjM7YnJlYWs7Y2FzZSA0OmI9YysxRTQ7YnJlYWs7ZGVmYXVsdDpiPWMrNUUzfWE9e2NhbGxiYWNrOmEscHJpb3JpdHlMZXZlbDpoLGV4cGlyYXRpb25UaW1lOmIsbmV4dDpudWxsLHByZXZpb3VzOm51bGx9O2lmKG51bGw9PT1kKWQ9YS5uZXh0PWEucHJldmlvdXM9YSxwKCk7ZWxzZXtjPW51bGw7dmFyIGU9ZDtkb3tpZihlLmV4cGlyYXRpb25UaW1lPmIpe2M9ZTticmVha31lPWUubmV4dH13aGlsZShlIT09ZCk7bnVsbD09PWM/Yz1kOmM9PT1kJiYoZD1hLHAoKSk7XG5iPWMucHJldmlvdXM7Yi5uZXh0PWMucHJldmlvdXM9YTthLm5leHQ9YzthLnByZXZpb3VzPWJ9cmV0dXJuIGF9O2V4cG9ydHMudW5zdGFibGVfY2FuY2VsQ2FsbGJhY2s9ZnVuY3Rpb24oYSl7dmFyIGI9YS5uZXh0O2lmKG51bGwhPT1iKXtpZihiPT09YSlkPW51bGw7ZWxzZXthPT09ZCYmKGQ9Yik7dmFyIGM9YS5wcmV2aW91cztjLm5leHQ9YjtiLnByZXZpb3VzPWN9YS5uZXh0PWEucHJldmlvdXM9bnVsbH19O2V4cG9ydHMudW5zdGFibGVfd3JhcENhbGxiYWNrPWZ1bmN0aW9uKGEpe3ZhciBiPWg7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIGM9aCxlPWs7aD1iO2s9ZXhwb3J0cy51bnN0YWJsZV9ub3coKTt0cnl7cmV0dXJuIGEuYXBwbHkodGhpcyxhcmd1bWVudHMpfWZpbmFsbHl7aD1jLGs9ZSx2KCl9fX07ZXhwb3J0cy51bnN0YWJsZV9nZXRDdXJyZW50UHJpb3JpdHlMZXZlbD1mdW5jdGlvbigpe3JldHVybiBofTtcbmV4cG9ydHMudW5zdGFibGVfc2hvdWxkWWllbGQ9ZnVuY3Rpb24oKXtyZXR1cm4hZiYmKG51bGwhPT1kJiZkLmV4cGlyYXRpb25UaW1lPGx8fHcoKSl9O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBCcm93c2VyRlMuQkZTUmVxdWlyZSgncHJvY2VzcycpO1xuIiwiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiQnJvd3NlckZTXCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcIkJyb3dzZXJGU1wiXSA9IGZhY3RvcnkoKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKCkge1xucmV0dXJuIFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL3VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24iLCIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0ZXhwb3J0czoge30sXG4gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuIFx0XHRcdGxvYWRlZDogZmFsc2VcbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL2Jvb3RzdHJhcCA3NTk5NzY5YTA2ZDE2Nzg2YThjNyIsIi8qKlxuICogU3RhbmRhcmQgbGliYyBlcnJvciBjb2Rlcy4gQWRkIG1vcmUgdG8gdGhpcyBlbnVtIGFuZCBFcnJvclN0cmluZ3MgYXMgdGhleSBhcmVcbiAqIG5lZWRlZC5cbiAqIEB1cmwgaHR0cDovL3d3dy5nbnUub3JnL3NvZnR3YXJlL2xpYmMvbWFudWFsL2h0bWxfbm9kZS9FcnJvci1Db2Rlcy5odG1sXG4gKi9cbmV4cG9ydCBlbnVtIEVycm9yQ29kZSB7XG4gIEVQRVJNICAgICA9IDEsXG4gIEVOT0VOVCAgICA9IDIsXG4gIEVJTyAgICAgICA9IDUsXG4gIEVCQURGICAgICA9IDksXG4gIEVBQ0NFUyAgICA9IDEzLFxuICBFQlVTWSAgICAgPSAxNixcbiAgRUVYSVNUICAgID0gMTcsXG4gIEVOT1RESVIgICA9IDIwLFxuICBFSVNESVIgICAgPSAyMSxcbiAgRUlOVkFMICAgID0gMjIsXG4gIEVGQklHICAgICA9IDI3LFxuICBFTk9TUEMgICAgPSAyOCxcbiAgRVJPRlMgICAgID0gMzAsXG4gIEVOT1RFTVBUWSA9IDM5LFxuICBFTk9UU1VQICAgPSA5NSxcbn1cbi8qIHRzbGludDpkaXNhYmxlOnZhcmlhYmxlLW5hbWUgKi9cbi8qKlxuICogU3RyaW5ncyBhc3NvY2lhdGVkIHdpdGggZWFjaCBlcnJvciBjb2RlLlxuICogQGhpZGRlblxuICovXG5leHBvcnQgY29uc3QgRXJyb3JTdHJpbmdzOiB7W2NvZGU6IHN0cmluZ106IHN0cmluZzsgW2NvZGU6IG51bWJlcl06IHN0cmluZzsgfSA9IHt9O1xuRXJyb3JTdHJpbmdzW0Vycm9yQ29kZS5FUEVSTV0gPSAnT3BlcmF0aW9uIG5vdCBwZXJtaXR0ZWQuJztcbkVycm9yU3RyaW5nc1tFcnJvckNvZGUuRU5PRU5UXSA9ICdObyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5Lic7XG5FcnJvclN0cmluZ3NbRXJyb3JDb2RlLkVJT10gPSAnSW5wdXQvb3V0cHV0IGVycm9yLic7XG5FcnJvclN0cmluZ3NbRXJyb3JDb2RlLkVCQURGXSA9ICdCYWQgZmlsZSBkZXNjcmlwdG9yLic7XG5FcnJvclN0cmluZ3NbRXJyb3JDb2RlLkVBQ0NFU10gPSAnUGVybWlzc2lvbiBkZW5pZWQuJztcbkVycm9yU3RyaW5nc1tFcnJvckNvZGUuRUJVU1ldID0gJ1Jlc291cmNlIGJ1c3kgb3IgbG9ja2VkLic7XG5FcnJvclN0cmluZ3NbRXJyb3JDb2RlLkVFWElTVF0gPSAnRmlsZSBleGlzdHMuJztcbkVycm9yU3RyaW5nc1tFcnJvckNvZGUuRU5PVERJUl0gPSAnRmlsZSBpcyBub3QgYSBkaXJlY3RvcnkuJztcbkVycm9yU3RyaW5nc1tFcnJvckNvZGUuRUlTRElSXSA9ICdGaWxlIGlzIGEgZGlyZWN0b3J5Lic7XG5FcnJvclN0cmluZ3NbRXJyb3JDb2RlLkVJTlZBTF0gPSAnSW52YWxpZCBhcmd1bWVudC4nO1xuRXJyb3JTdHJpbmdzW0Vycm9yQ29kZS5FRkJJR10gPSAnRmlsZSBpcyB0b28gYmlnLic7XG5FcnJvclN0cmluZ3NbRXJyb3JDb2RlLkVOT1NQQ10gPSAnTm8gc3BhY2UgbGVmdCBvbiBkaXNrLic7XG5FcnJvclN0cmluZ3NbRXJyb3JDb2RlLkVST0ZTXSA9ICdDYW5ub3QgbW9kaWZ5IGEgcmVhZC1vbmx5IGZpbGUgc3lzdGVtLic7XG5FcnJvclN0cmluZ3NbRXJyb3JDb2RlLkVOT1RFTVBUWV0gPSAnRGlyZWN0b3J5IGlzIG5vdCBlbXB0eS4nO1xuRXJyb3JTdHJpbmdzW0Vycm9yQ29kZS5FTk9UU1VQXSA9ICdPcGVyYXRpb24gaXMgbm90IHN1cHBvcnRlZC4nO1xuLyogdHNsaW50OmVuYWJsZTp2YXJpYWJsZS1uYW1lICovXG5cbi8qKlxuICogUmVwcmVzZW50cyBhIEJyb3dzZXJGUyBlcnJvci4gUGFzc2VkIGJhY2sgdG8gYXBwbGljYXRpb25zIGFmdGVyIGEgZmFpbGVkXG4gKiBjYWxsIHRvIHRoZSBCcm93c2VyRlMgQVBJLlxuICovXG5leHBvcnQgY2xhc3MgQXBpRXJyb3IgZXh0ZW5kcyBFcnJvciBpbXBsZW1lbnRzIE5vZGVKUy5FcnJub0V4Y2VwdGlvbiB7XG4gIHB1YmxpYyBzdGF0aWMgZnJvbUpTT04oanNvbjogYW55KTogQXBpRXJyb3Ige1xuICAgIGNvbnN0IGVyciA9IG5ldyBBcGlFcnJvcigwKTtcbiAgICBlcnIuZXJybm8gPSBqc29uLmVycm5vO1xuICAgIGVyci5jb2RlID0ganNvbi5jb2RlO1xuICAgIGVyci5wYXRoID0ganNvbi5wYXRoO1xuICAgIGVyci5zdGFjayA9IGpzb24uc3RhY2s7XG4gICAgZXJyLm1lc3NhZ2UgPSBqc29uLm1lc3NhZ2U7XG4gICAgcmV0dXJuIGVycjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIEFwaUVycm9yIG9iamVjdCBmcm9tIGEgYnVmZmVyLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBmcm9tQnVmZmVyKGJ1ZmZlcjogQnVmZmVyLCBpOiBudW1iZXIgPSAwKTogQXBpRXJyb3Ige1xuICAgIHJldHVybiBBcGlFcnJvci5mcm9tSlNPTihKU09OLnBhcnNlKGJ1ZmZlci50b1N0cmluZygndXRmOCcsIGkgKyA0LCBpICsgNCArIGJ1ZmZlci5yZWFkVUludDMyTEUoaSkpKSk7XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIEZpbGVFcnJvcihjb2RlOiBFcnJvckNvZGUsIHA6IHN0cmluZyk6IEFwaUVycm9yIHtcbiAgICByZXR1cm4gbmV3IEFwaUVycm9yKGNvZGUsIEVycm9yU3RyaW5nc1tjb2RlXSwgcCk7XG4gIH1cbiAgcHVibGljIHN0YXRpYyBFTk9FTlQocGF0aDogc3RyaW5nKTogQXBpRXJyb3Ige1xuICAgIHJldHVybiB0aGlzLkZpbGVFcnJvcihFcnJvckNvZGUuRU5PRU5ULCBwYXRoKTtcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgRUVYSVNUKHBhdGg6IHN0cmluZyk6IEFwaUVycm9yIHtcbiAgICByZXR1cm4gdGhpcy5GaWxlRXJyb3IoRXJyb3JDb2RlLkVFWElTVCwgcGF0aCk7XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIEVJU0RJUihwYXRoOiBzdHJpbmcpOiBBcGlFcnJvciB7XG4gICAgcmV0dXJuIHRoaXMuRmlsZUVycm9yKEVycm9yQ29kZS5FSVNESVIsIHBhdGgpO1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyBFTk9URElSKHBhdGg6IHN0cmluZyk6IEFwaUVycm9yIHtcbiAgICByZXR1cm4gdGhpcy5GaWxlRXJyb3IoRXJyb3JDb2RlLkVOT1RESVIsIHBhdGgpO1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyBFUEVSTShwYXRoOiBzdHJpbmcpOiBBcGlFcnJvciB7XG4gICAgcmV0dXJuIHRoaXMuRmlsZUVycm9yKEVycm9yQ29kZS5FUEVSTSwgcGF0aCk7XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIEVOT1RFTVBUWShwYXRoOiBzdHJpbmcpOiBBcGlFcnJvciB7XG4gICAgcmV0dXJuIHRoaXMuRmlsZUVycm9yKEVycm9yQ29kZS5FTk9URU1QVFksIHBhdGgpO1xuICB9XG5cbiAgcHVibGljIGVycm5vOiBFcnJvckNvZGU7XG4gIHB1YmxpYyBjb2RlOiBzdHJpbmc7XG4gIHB1YmxpYyBwYXRoOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gIC8vIFVuc3VwcG9ydGVkLlxuICBwdWJsaWMgc3lzY2FsbDogc3RyaW5nID0gXCJcIjtcbiAgcHVibGljIHN0YWNrOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG5cbiAgLyoqXG4gICAqIFJlcHJlc2VudHMgYSBCcm93c2VyRlMgZXJyb3IuIFBhc3NlZCBiYWNrIHRvIGFwcGxpY2F0aW9ucyBhZnRlciBhIGZhaWxlZFxuICAgKiBjYWxsIHRvIHRoZSBCcm93c2VyRlMgQVBJLlxuICAgKlxuICAgKiBFcnJvciBjb2RlcyBtaXJyb3IgdGhvc2UgcmV0dXJuZWQgYnkgcmVndWxhciBVbml4IGZpbGUgb3BlcmF0aW9ucywgd2hpY2ggaXNcbiAgICogd2hhdCBOb2RlIHJldHVybnMuXG4gICAqIEBjb25zdHJ1Y3RvciBBcGlFcnJvclxuICAgKiBAcGFyYW0gdHlwZSBUaGUgdHlwZSBvZiB0aGUgZXJyb3IuXG4gICAqIEBwYXJhbSBbbWVzc2FnZV0gQSBkZXNjcmlwdGl2ZSBlcnJvciBtZXNzYWdlLlxuICAgKi9cbiAgY29uc3RydWN0b3IodHlwZTogRXJyb3JDb2RlLCBtZXNzYWdlOiBzdHJpbmcgPSBFcnJvclN0cmluZ3NbdHlwZV0sIHBhdGg/OiBzdHJpbmcpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLmVycm5vID0gdHlwZTtcbiAgICB0aGlzLmNvZGUgPSBFcnJvckNvZGVbdHlwZV07XG4gICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICB0aGlzLnN0YWNrID0gbmV3IEVycm9yKCkuc3RhY2s7XG4gICAgdGhpcy5tZXNzYWdlID0gYEVycm9yOiAke3RoaXMuY29kZX06ICR7bWVzc2FnZX0ke3RoaXMucGF0aCA/IGAsICcke3RoaXMucGF0aH0nYCA6ICcnfWA7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiBBIGZyaWVuZGx5IGVycm9yIG1lc3NhZ2UuXG4gICAqL1xuICBwdWJsaWMgdG9TdHJpbmcoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlO1xuICB9XG5cbiAgcHVibGljIHRvSlNPTigpOiBhbnkge1xuICAgIHJldHVybiB7XG4gICAgICBlcnJubzogdGhpcy5lcnJubyxcbiAgICAgIGNvZGU6IHRoaXMuY29kZSxcbiAgICAgIHBhdGg6IHRoaXMucGF0aCxcbiAgICAgIHN0YWNrOiB0aGlzLnN0YWNrLFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXcml0ZXMgdGhlIEFQSSBlcnJvciBpbnRvIGEgYnVmZmVyLlxuICAgKi9cbiAgcHVibGljIHdyaXRlVG9CdWZmZXIoYnVmZmVyOiBCdWZmZXIgPSBCdWZmZXIuYWxsb2ModGhpcy5idWZmZXJTaXplKCkpLCBpOiBudW1iZXIgPSAwKTogQnVmZmVyIHtcbiAgICBjb25zdCBieXRlc1dyaXR0ZW4gPSBidWZmZXIud3JpdGUoSlNPTi5zdHJpbmdpZnkodGhpcy50b0pTT04oKSksIGkgKyA0KTtcbiAgICBidWZmZXIud3JpdGVVSW50MzJMRShieXRlc1dyaXR0ZW4sIGkpO1xuICAgIHJldHVybiBidWZmZXI7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHNpemUgb2YgdGhlIEFQSSBlcnJvciBpbiBidWZmZXItZm9ybSBpbiBieXRlcy5cbiAgICovXG4gIHB1YmxpYyBidWZmZXJTaXplKCk6IG51bWJlciB7XG4gICAgLy8gNCBieXRlcyBmb3Igc3RyaW5nIGxlbmd0aC5cbiAgICByZXR1cm4gNCArIEJ1ZmZlci5ieXRlTGVuZ3RoKEpTT04uc3RyaW5naWZ5KHRoaXMudG9KU09OKCkpKTtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uLy4uLy4uLy4uL3NyYy9jb3JlL2FwaV9lcnJvci50cyIsImltcG9ydCB7RXJyb3JDb2RlLCBBcGlFcnJvcn0gZnJvbSAnLi9hcGlfZXJyb3InO1xuXG5leHBvcnQgZW51bSBBY3Rpb25UeXBlIHtcbiAgLy8gSW5kaWNhdGVzIHRoYXQgdGhlIGNvZGUgc2hvdWxkIG5vdCBkbyBhbnl0aGluZy5cbiAgTk9QID0gMCxcbiAgLy8gSW5kaWNhdGVzIHRoYXQgdGhlIGNvZGUgc2hvdWxkIHRocm93IGFuIGV4Y2VwdGlvbi5cbiAgVEhST1dfRVhDRVBUSU9OID0gMSxcbiAgLy8gSW5kaWNhdGVzIHRoYXQgdGhlIGNvZGUgc2hvdWxkIHRydW5jYXRlIHRoZSBmaWxlLCBidXQgb25seSBpZiBpdCBpcyBhIGZpbGUuXG4gIFRSVU5DQVRFX0ZJTEUgPSAyLFxuICAvLyBJbmRpY2F0ZXMgdGhhdCB0aGUgY29kZSBzaG91bGQgY3JlYXRlIHRoZSBmaWxlLlxuICBDUkVBVEVfRklMRSA9IDNcbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIG9uZSBvZiB0aGUgZm9sbG93aW5nIGZpbGUgZmxhZ3MuIEEgY29udmVuaWVuY2Ugb2JqZWN0LlxuICpcbiAqICogYCdyJ2AgLSBPcGVuIGZpbGUgZm9yIHJlYWRpbmcuIEFuIGV4Y2VwdGlvbiBvY2N1cnMgaWYgdGhlIGZpbGUgZG9lcyBub3QgZXhpc3QuXG4gKiAqIGAncisnYCAtIE9wZW4gZmlsZSBmb3IgcmVhZGluZyBhbmQgd3JpdGluZy4gQW4gZXhjZXB0aW9uIG9jY3VycyBpZiB0aGUgZmlsZSBkb2VzIG5vdCBleGlzdC5cbiAqICogYCdycydgIC0gT3BlbiBmaWxlIGZvciByZWFkaW5nIGluIHN5bmNocm9ub3VzIG1vZGUuIEluc3RydWN0cyB0aGUgZmlsZXN5c3RlbSB0byBub3QgY2FjaGUgd3JpdGVzLlxuICogKiBgJ3JzKydgIC0gT3BlbiBmaWxlIGZvciByZWFkaW5nIGFuZCB3cml0aW5nLCBhbmQgb3BlbnMgdGhlIGZpbGUgaW4gc3luY2hyb25vdXMgbW9kZS5cbiAqICogYCd3J2AgLSBPcGVuIGZpbGUgZm9yIHdyaXRpbmcuIFRoZSBmaWxlIGlzIGNyZWF0ZWQgKGlmIGl0IGRvZXMgbm90IGV4aXN0KSBvciB0cnVuY2F0ZWQgKGlmIGl0IGV4aXN0cykuXG4gKiAqIGAnd3gnYCAtIExpa2UgJ3cnIGJ1dCBvcGVucyB0aGUgZmlsZSBpbiBleGNsdXNpdmUgbW9kZS5cbiAqICogYCd3KydgIC0gT3BlbiBmaWxlIGZvciByZWFkaW5nIGFuZCB3cml0aW5nLiBUaGUgZmlsZSBpcyBjcmVhdGVkIChpZiBpdCBkb2VzIG5vdCBleGlzdCkgb3IgdHJ1bmNhdGVkIChpZiBpdCBleGlzdHMpLlxuICogKiBgJ3d4KydgIC0gTGlrZSAndysnIGJ1dCBvcGVucyB0aGUgZmlsZSBpbiBleGNsdXNpdmUgbW9kZS5cbiAqICogYCdhJ2AgLSBPcGVuIGZpbGUgZm9yIGFwcGVuZGluZy4gVGhlIGZpbGUgaXMgY3JlYXRlZCBpZiBpdCBkb2VzIG5vdCBleGlzdC5cbiAqICogYCdheCdgIC0gTGlrZSAnYScgYnV0IG9wZW5zIHRoZSBmaWxlIGluIGV4Y2x1c2l2ZSBtb2RlLlxuICogKiBgJ2ErJ2AgLSBPcGVuIGZpbGUgZm9yIHJlYWRpbmcgYW5kIGFwcGVuZGluZy4gVGhlIGZpbGUgaXMgY3JlYXRlZCBpZiBpdCBkb2VzIG5vdCBleGlzdC5cbiAqICogYCdheCsnYCAtIExpa2UgJ2ErJyBidXQgb3BlbnMgdGhlIGZpbGUgaW4gZXhjbHVzaXZlIG1vZGUuXG4gKlxuICogRXhjbHVzaXZlIG1vZGUgZW5zdXJlcyB0aGF0IHRoZSBmaWxlIHBhdGggaXMgbmV3bHkgY3JlYXRlZC5cbiAqL1xuZXhwb3J0IGNsYXNzIEZpbGVGbGFnIHtcbiAgLy8gQ29udGFpbnMgY2FjaGVkIEZpbGVNb2RlIGluc3RhbmNlcy5cbiAgcHJpdmF0ZSBzdGF0aWMgZmxhZ0NhY2hlOiB7IFttb2RlOiBzdHJpbmddOiBGaWxlRmxhZyB9ID0ge307XG4gIC8vIEFycmF5IG9mIHZhbGlkIG1vZGUgc3RyaW5ncy5cbiAgcHJpdmF0ZSBzdGF0aWMgdmFsaWRGbGFnU3RycyA9IFsncicsICdyKycsICdycycsICdycysnLCAndycsICd3eCcsICd3KycsICd3eCsnLCAnYScsICdheCcsICdhKycsICdheCsnXTtcblxuICAvKipcbiAgICogR2V0IGFuIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGdpdmVuIGZpbGUgZmxhZy5cbiAgICogQHBhcmFtIG1vZGVTdHIgVGhlIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGZsYWdcbiAgICogQHJldHVybiBUaGUgRmlsZUZsYWcgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgZmxhZ1xuICAgKiBAdGhyb3cgd2hlbiB0aGUgZmxhZyBzdHJpbmcgaXMgaW52YWxpZFxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBnZXRGaWxlRmxhZyhmbGFnU3RyOiBzdHJpbmcpOiBGaWxlRmxhZyB7XG4gICAgLy8gQ2hlY2sgY2FjaGUgZmlyc3QuXG4gICAgaWYgKEZpbGVGbGFnLmZsYWdDYWNoZS5oYXNPd25Qcm9wZXJ0eShmbGFnU3RyKSkge1xuICAgICAgcmV0dXJuIEZpbGVGbGFnLmZsYWdDYWNoZVtmbGFnU3RyXTtcbiAgICB9XG4gICAgcmV0dXJuIEZpbGVGbGFnLmZsYWdDYWNoZVtmbGFnU3RyXSA9IG5ldyBGaWxlRmxhZyhmbGFnU3RyKTtcbiAgfVxuXG4gIHByaXZhdGUgZmxhZ1N0cjogc3RyaW5nO1xuICAvKipcbiAgICogVGhpcyBzaG91bGQgbmV2ZXIgYmUgY2FsbGVkIGRpcmVjdGx5LlxuICAgKiBAcGFyYW0gbW9kZVN0ciBUaGUgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgbW9kZVxuICAgKiBAdGhyb3cgd2hlbiB0aGUgbW9kZSBzdHJpbmcgaXMgaW52YWxpZFxuICAgKi9cbiAgY29uc3RydWN0b3IoZmxhZ1N0cjogc3RyaW5nKSB7XG4gICAgdGhpcy5mbGFnU3RyID0gZmxhZ1N0cjtcbiAgICBpZiAoRmlsZUZsYWcudmFsaWRGbGFnU3Rycy5pbmRleE9mKGZsYWdTdHIpIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEFwaUVycm9yKEVycm9yQ29kZS5FSU5WQUwsIFwiSW52YWxpZCBmbGFnOiBcIiArIGZsYWdTdHIpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHVuZGVybHlpbmcgZmxhZyBzdHJpbmcgZm9yIHRoaXMgZmxhZy5cbiAgICovXG4gIHB1YmxpYyBnZXRGbGFnU3RyaW5nKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuZmxhZ1N0cjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGZpbGUgaXMgcmVhZGFibGUuXG4gICAqL1xuICBwdWJsaWMgaXNSZWFkYWJsZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5mbGFnU3RyLmluZGV4T2YoJ3InKSAhPT0gLTEgfHwgdGhpcy5mbGFnU3RyLmluZGV4T2YoJysnKSAhPT0gLTE7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZmlsZSBpcyB3cml0ZWFibGUuXG4gICAqL1xuICBwdWJsaWMgaXNXcml0ZWFibGUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuZmxhZ1N0ci5pbmRleE9mKCd3JykgIT09IC0xIHx8IHRoaXMuZmxhZ1N0ci5pbmRleE9mKCdhJykgIT09IC0xIHx8IHRoaXMuZmxhZ1N0ci5pbmRleE9mKCcrJykgIT09IC0xO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGZpbGUgbW9kZSBzaG91bGQgdHJ1bmNhdGUuXG4gICAqL1xuICBwdWJsaWMgaXNUcnVuY2F0aW5nKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmZsYWdTdHIuaW5kZXhPZigndycpICE9PSAtMTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBmaWxlIGlzIGFwcGVuZGFibGUuXG4gICAqL1xuICBwdWJsaWMgaXNBcHBlbmRhYmxlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmZsYWdTdHIuaW5kZXhPZignYScpICE9PSAtMTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBmaWxlIGlzIG9wZW4gaW4gc3luY2hyb25vdXMgbW9kZS5cbiAgICovXG4gIHB1YmxpYyBpc1N5bmNocm9ub3VzKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmZsYWdTdHIuaW5kZXhPZigncycpICE9PSAtMTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBmaWxlIGlzIG9wZW4gaW4gZXhjbHVzaXZlIG1vZGUuXG4gICAqL1xuICBwdWJsaWMgaXNFeGNsdXNpdmUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuZmxhZ1N0ci5pbmRleE9mKCd4JykgIT09IC0xO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIG9uZSBvZiB0aGUgc3RhdGljIGZpZWxkcyBvbiB0aGlzIG9iamVjdCB0aGF0IGluZGljYXRlcyB0aGVcbiAgICogYXBwcm9wcmlhdGUgcmVzcG9uc2UgdG8gdGhlIHBhdGggZXhpc3RpbmcuXG4gICAqL1xuICBwdWJsaWMgcGF0aEV4aXN0c0FjdGlvbigpOiBBY3Rpb25UeXBlIHtcbiAgICBpZiAodGhpcy5pc0V4Y2x1c2l2ZSgpKSB7XG4gICAgICByZXR1cm4gQWN0aW9uVHlwZS5USFJPV19FWENFUFRJT047XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzVHJ1bmNhdGluZygpKSB7XG4gICAgICByZXR1cm4gQWN0aW9uVHlwZS5UUlVOQ0FURV9GSUxFO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gQWN0aW9uVHlwZS5OT1A7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIG9uZSBvZiB0aGUgc3RhdGljIGZpZWxkcyBvbiB0aGlzIG9iamVjdCB0aGF0IGluZGljYXRlcyB0aGVcbiAgICogYXBwcm9wcmlhdGUgcmVzcG9uc2UgdG8gdGhlIHBhdGggbm90IGV4aXN0aW5nLlxuICAgKi9cbiAgcHVibGljIHBhdGhOb3RFeGlzdHNBY3Rpb24oKTogQWN0aW9uVHlwZSB7XG4gICAgaWYgKCh0aGlzLmlzV3JpdGVhYmxlKCkgfHwgdGhpcy5pc0FwcGVuZGFibGUoKSkgJiYgdGhpcy5mbGFnU3RyICE9PSAncisnKSB7XG4gICAgICByZXR1cm4gQWN0aW9uVHlwZS5DUkVBVEVfRklMRTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIEFjdGlvblR5cGUuVEhST1dfRVhDRVBUSU9OO1xuICAgIH1cbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uLy4uLy4uLy4uL3NyYy9jb3JlL2ZpbGVfZmxhZy50cyIsImltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzJztcblxuLyoqXG4gKiBJbmRpY2F0ZXMgdGhlIHR5cGUgb2YgdGhlIGdpdmVuIGZpbGUuIEFwcGxpZWQgdG8gJ21vZGUnLlxuICovXG5leHBvcnQgZW51bSBGaWxlVHlwZSB7XG4gIEZJTEUgPSAweDgwMDAsXG4gIERJUkVDVE9SWSA9IDB4NDAwMCxcbiAgU1lNTElOSyA9IDB4QTAwMFxufVxuXG4vKipcbiAqIEVtdWxhdGlvbiBvZiBOb2RlJ3MgYGZzLlN0YXRzYCBvYmplY3QuXG4gKlxuICogQXR0cmlidXRlIGRlc2NyaXB0aW9ucyBhcmUgZnJvbSBgbWFuIDIgc3RhdCdcbiAqIEBzZWUgaHR0cDovL25vZGVqcy5vcmcvYXBpL2ZzLmh0bWwjZnNfY2xhc3NfZnNfc3RhdHNcbiAqIEBzZWUgaHR0cDovL21hbjcub3JnL2xpbnV4L21hbi1wYWdlcy9tYW4yL3N0YXQuMi5odG1sXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0YXRzIGltcGxlbWVudHMgZnMuU3RhdHMge1xuICBwdWJsaWMgc3RhdGljIGZyb21CdWZmZXIoYnVmZmVyOiBCdWZmZXIpOiBTdGF0cyB7XG4gICAgY29uc3Qgc2l6ZSA9IGJ1ZmZlci5yZWFkVUludDMyTEUoMCksXG4gICAgICBtb2RlID0gYnVmZmVyLnJlYWRVSW50MzJMRSg0KSxcbiAgICAgIGF0aW1lID0gYnVmZmVyLnJlYWREb3VibGVMRSg4KSxcbiAgICAgIG10aW1lID0gYnVmZmVyLnJlYWREb3VibGVMRSgxNiksXG4gICAgICBjdGltZSA9IGJ1ZmZlci5yZWFkRG91YmxlTEUoMjQpO1xuXG4gICAgcmV0dXJuIG5ldyBTdGF0cyhtb2RlICYgMHhGMDAwLCBzaXplLCBtb2RlICYgMHhGRkYsIG5ldyBEYXRlKGF0aW1lKSwgbmV3IERhdGUobXRpbWUpLCBuZXcgRGF0ZShjdGltZSkpO1xuICB9XG5cbiAgcHVibGljIGJsb2NrczogbnVtYmVyO1xuICBwdWJsaWMgbW9kZTogbnVtYmVyO1xuICAvKipcbiAgICogVU5TVVBQT1JURUQgQVRUUklCVVRFU1xuICAgKiBJIGFzc3VtZSBubyBvbmUgaXMgZ29pbmcgdG8gbmVlZCB0aGVzZSBkZXRhaWxzLCBhbHRob3VnaCB3ZSBjb3VsZCBmYWtlXG4gICAqIGFwcHJvcHJpYXRlIHZhbHVlcyBpZiBuZWVkIGJlLlxuICAgKi9cbiAgLy8gSUQgb2YgZGV2aWNlIGNvbnRhaW5pbmcgZmlsZVxuICBwdWJsaWMgZGV2OiBudW1iZXIgPSAwO1xuICAvLyBpbm9kZSBudW1iZXJcbiAgcHVibGljIGlubzogbnVtYmVyID0gMDtcbiAgLy8gZGV2aWNlIElEIChpZiBzcGVjaWFsIGZpbGUpXG4gIHB1YmxpYyByZGV2OiBudW1iZXIgPSAwO1xuICAvLyBudW1iZXIgb2YgaGFyZCBsaW5rc1xuICBwdWJsaWMgbmxpbms6IG51bWJlciA9IDE7XG4gIC8vIGJsb2Nrc2l6ZSBmb3IgZmlsZSBzeXN0ZW0gSS9PXG4gIHB1YmxpYyBibGtzaXplOiBudW1iZXIgPSA0MDk2O1xuICAvLyBAdG9kbyBNYXliZSBzdXBwb3J0IHRoZXNlPyBhdG0sIGl0J3MgYSBvbmUtdXNlciBmaWxlc3lzdGVtLlxuICAvLyB1c2VyIElEIG9mIG93bmVyXG4gIHB1YmxpYyB1aWQ6IG51bWJlciA9IDA7XG4gIC8vIGdyb3VwIElEIG9mIG93bmVyXG4gIHB1YmxpYyBnaWQ6IG51bWJlciA9IDA7XG4gIC8vIHRpbWUgZmlsZSB3YXMgY3JlYXRlZCAoY3VycmVudGx5IHVuc3VwcG9ydGVkKVxuICBwdWJsaWMgYmlydGh0aW1lOiBEYXRlID0gbmV3IERhdGUoMCk7XG4gIC8vIFhYWDogU29tZSBmaWxlIHN5c3RlbXMgc3Rhc2ggZGF0YSBvbiBzdGF0cyBvYmplY3RzLlxuICBwdWJsaWMgZmlsZURhdGE6IEJ1ZmZlciB8IG51bGw9IG51bGw7XG5cbiAgLyoqXG4gICAqIFByb3ZpZGVzIGluZm9ybWF0aW9uIGFib3V0IGEgcGFydGljdWxhciBlbnRyeSBpbiB0aGUgZmlsZSBzeXN0ZW0uXG4gICAqIEBwYXJhbSBbTnVtYmVyXSBpdGVtX3R5cGUgdHlwZSBvZiB0aGUgaXRlbSAoRklMRSwgRElSRUNUT1JZLCBTWU1MSU5LLCBvciBTT0NLRVQpXG4gICAqIEBwYXJhbSBbTnVtYmVyXSBzaXplIFNpemUgb2YgdGhlIGl0ZW0gaW4gYnl0ZXMuIEZvciBkaXJlY3Rvcmllcy9zeW1saW5rcyxcbiAgICogICB0aGlzIGlzIG5vcm1hbGx5IHRoZSBzaXplIG9mIHRoZSBzdHJ1Y3QgdGhhdCByZXByZXNlbnRzIHRoZSBpdGVtLlxuICAgKiBAcGFyYW0gW051bWJlcl0gbW9kZSBVbml4LXN0eWxlIGZpbGUgbW9kZSAoZS5nLiAwbzY0NClcbiAgICogQHBhcmFtIFtEYXRlP10gYXRpbWUgdGltZSBvZiBsYXN0IGFjY2Vzc1xuICAgKiBAcGFyYW0gW0RhdGU/XSBtdGltZSB0aW1lIG9mIGxhc3QgbW9kaWZpY2F0aW9uXG4gICAqIEBwYXJhbSBbRGF0ZT9dIGN0aW1lIHRpbWUgb2YgY3JlYXRpb25cbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgIGl0ZW1UeXBlOiBGaWxlVHlwZSxcbiAgICBwdWJsaWMgc2l6ZTogbnVtYmVyLFxuICAgIG1vZGU/OiBudW1iZXIsXG4gICAgcHVibGljIGF0aW1lOiBEYXRlID0gbmV3IERhdGUoKSxcbiAgICBwdWJsaWMgbXRpbWU6IERhdGUgPSBuZXcgRGF0ZSgpLFxuICAgIHB1YmxpYyBjdGltZTogRGF0ZSA9IG5ldyBEYXRlKCkpIHtcbiAgICBpZiAoIW1vZGUpIHtcbiAgICAgIHN3aXRjaCAoaXRlbVR5cGUpIHtcbiAgICAgICAgY2FzZSBGaWxlVHlwZS5GSUxFOlxuICAgICAgICAgIHRoaXMubW9kZSA9IDB4MWE0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEZpbGVUeXBlLkRJUkVDVE9SWTpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aGlzLm1vZGUgPSAweDFmZjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5tb2RlID0gbW9kZTtcbiAgICB9XG4gICAgLy8gbnVtYmVyIG9mIDUxMkIgYmxvY2tzIGFsbG9jYXRlZFxuICAgIHRoaXMuYmxvY2tzID0gTWF0aC5jZWlsKHNpemUgLyA1MTIpO1xuICAgIC8vIENoZWNrIGlmIG1vZGUgYWxzbyBpbmNsdWRlcyB0b3AtbW9zdCBiaXRzLCB3aGljaCBpbmRpY2F0ZSB0aGUgZmlsZSdzXG4gICAgLy8gdHlwZS5cbiAgICBpZiAodGhpcy5tb2RlIDwgMHgxMDAwKSB7XG4gICAgICB0aGlzLm1vZGUgfD0gaXRlbVR5cGU7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHRvQnVmZmVyKCk6IEJ1ZmZlciB7XG4gICAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDMyKTtcbiAgICBidWZmZXIud3JpdGVVSW50MzJMRSh0aGlzLnNpemUsIDApO1xuICAgIGJ1ZmZlci53cml0ZVVJbnQzMkxFKHRoaXMubW9kZSwgNCk7XG4gICAgYnVmZmVyLndyaXRlRG91YmxlTEUodGhpcy5hdGltZS5nZXRUaW1lKCksIDgpO1xuICAgIGJ1ZmZlci53cml0ZURvdWJsZUxFKHRoaXMubXRpbWUuZ2V0VGltZSgpLCAxNik7XG4gICAgYnVmZmVyLndyaXRlRG91YmxlTEUodGhpcy5jdGltZS5nZXRUaW1lKCksIDI0KTtcbiAgICByZXR1cm4gYnVmZmVyO1xuICB9XG5cbiAgLyoqXG4gICAqICoqTm9uc3RhbmRhcmQqKjogQ2xvbmUgdGhlIHN0YXRzIG9iamVjdC5cbiAgICogQHJldHVybiBbQnJvd3NlckZTLm5vZGUuZnMuU3RhdHNdXG4gICAqL1xuICBwdWJsaWMgY2xvbmUoKTogU3RhdHMge1xuICAgIHJldHVybiBuZXcgU3RhdHModGhpcy5tb2RlICYgMHhGMDAwLCB0aGlzLnNpemUsIHRoaXMubW9kZSAmIDB4RkZGLCB0aGlzLmF0aW1lLCB0aGlzLm10aW1lLCB0aGlzLmN0aW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIFtCb29sZWFuXSBUcnVlIGlmIHRoaXMgaXRlbSBpcyBhIGZpbGUuXG4gICAqL1xuICBwdWJsaWMgaXNGaWxlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAodGhpcy5tb2RlICYgMHhGMDAwKSA9PT0gRmlsZVR5cGUuRklMRTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIFtCb29sZWFuXSBUcnVlIGlmIHRoaXMgaXRlbSBpcyBhIGRpcmVjdG9yeS5cbiAgICovXG4gIHB1YmxpYyBpc0RpcmVjdG9yeSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gKHRoaXMubW9kZSAmIDB4RjAwMCkgPT09IEZpbGVUeXBlLkRJUkVDVE9SWTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIFtCb29sZWFuXSBUcnVlIGlmIHRoaXMgaXRlbSBpcyBhIHN5bWJvbGljIGxpbmsgKG9ubHkgdmFsaWQgdGhyb3VnaCBsc3RhdClcbiAgICovXG4gIHB1YmxpYyBpc1N5bWJvbGljTGluaygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gKHRoaXMubW9kZSAmIDB4RjAwMCkgPT09IEZpbGVUeXBlLlNZTUxJTks7XG4gIH1cblxuICAvKipcbiAgICogQ2hhbmdlIHRoZSBtb2RlIG9mIHRoZSBmaWxlLiBXZSB1c2UgdGhpcyBoZWxwZXIgZnVuY3Rpb24gdG8gcHJldmVudCBtZXNzaW5nXG4gICAqIHVwIHRoZSB0eXBlIG9mIHRoZSBmaWxlLCB3aGljaCBpcyBlbmNvZGVkIGluIG1vZGUuXG4gICAqL1xuICBwdWJsaWMgY2htb2QobW9kZTogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5tb2RlID0gKHRoaXMubW9kZSAmIDB4RjAwMCkgfCBtb2RlO1xuICB9XG5cbiAgLy8gV2UgZG9uJ3Qgc3VwcG9ydCB0aGUgZm9sbG93aW5nIHR5cGVzIG9mIGZpbGVzLlxuXG4gIHB1YmxpYyBpc1NvY2tldCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBwdWJsaWMgaXNCbG9ja0RldmljZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBwdWJsaWMgaXNDaGFyYWN0ZXJEZXZpY2UoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcHVibGljIGlzRklGTygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi8uLi8uLi8uLi9zcmMvY29yZS9ub2RlX2ZzX3N0YXRzLnRzIiwiaW1wb3J0IHtGaWxlfSBmcm9tICcuL2ZpbGUnO1xuaW1wb3J0IHtBcGlFcnJvciwgRXJyb3JDb2RlfSBmcm9tICcuL2FwaV9lcnJvcic7XG5pbXBvcnQge0ZpbGVTeXN0ZW0sIEJGU09uZUFyZ0NhbGxiYWNrLCBCRlNDYWxsYmFjaywgQkZTVGhyZWVBcmdDYWxsYmFja30gZnJvbSAnLi9maWxlX3N5c3RlbSc7XG5pbXBvcnQge0ZpbGVGbGFnfSBmcm9tICcuL2ZpbGVfZmxhZyc7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IFN0YXRzIGZyb20gJy4vbm9kZV9mc19zdGF0cyc7XG5cbi8vIFR5cGluZyBpbmZvIG9ubHkuXG5pbXBvcnQgKiBhcyBfZnMgZnJvbSAnZnMnO1xuXG4vKipcbiAqIFdyYXBzIGEgY2FsbGJhY2sgZnVuY3Rpb24uIFVzZWQgZm9yIHVuaXQgdGVzdGluZy4gRGVmYXVsdHMgdG8gYSBOT1AuXG4gKiBAaGlkZGVuXG4gKi9cbmxldCB3cmFwQ2IgPSBmdW5jdGlvbjxUIGV4dGVuZHMgRnVuY3Rpb24+KGNiOiBULCBudW1BcmdzOiBudW1iZXIpOiBUIHtcbiAgcmV0dXJuIGNiO1xufTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydFJvb3QoZnM/OiBGaWxlU3lzdGVtIHwgbnVsbCk6IEZpbGVTeXN0ZW0ge1xuICBpZiAoZnMpIHtcbiAgICByZXR1cm4gZnM7XG4gIH1cbiAgdGhyb3cgbmV3IEFwaUVycm9yKEVycm9yQ29kZS5FSU8sIGBJbml0aWFsaXplIEJyb3dzZXJGUyB3aXRoIGEgZmlsZSBzeXN0ZW0gdXNpbmcgQnJvd3NlckZTLmluaXRpYWxpemUoZmlsZXN5c3RlbSlgKTtcbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZU1vZGUobW9kZTogbnVtYmVyIHwgc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZCwgZGVmOiBudW1iZXIpOiBudW1iZXIge1xuICBzd2l0Y2ggKHR5cGVvZiBtb2RlKSB7XG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIC8vIChwYXRoLCBmbGFnLCBtb2RlLCBjYj8pXG4gICAgICByZXR1cm4gPG51bWJlcj4gbW9kZTtcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgLy8gKHBhdGgsIGZsYWcsIG1vZGVTdHJpbmcsIGNiPylcbiAgICAgIGNvbnN0IHRydWVNb2RlID0gcGFyc2VJbnQoPHN0cmluZz4gbW9kZSwgOCk7XG4gICAgICBpZiAoIWlzTmFOKHRydWVNb2RlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZU1vZGU7XG4gICAgICB9XG4gICAgICAvLyBJbnZhbGlkIHN0cmluZy5cbiAgICAgIHJldHVybiBkZWY7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBkZWY7XG4gIH1cbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZVRpbWUodGltZTogbnVtYmVyIHwgRGF0ZSk6IERhdGUge1xuICBpZiAodGltZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICByZXR1cm4gdGltZTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdGltZSA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gbmV3IERhdGUodGltZSAqIDEwMDApO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBBcGlFcnJvcihFcnJvckNvZGUuRUlOVkFMLCBgSW52YWxpZCB0aW1lLmApO1xuICB9XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5mdW5jdGlvbiBub3JtYWxpemVQYXRoKHA6IHN0cmluZyk6IHN0cmluZyB7XG4gIC8vIE5vZGUgZG9lc24ndCBhbGxvdyBudWxsIGNoYXJhY3RlcnMgaW4gcGF0aHMuXG4gIGlmIChwLmluZGV4T2YoJ1xcdTAwMDAnKSA+PSAwKSB7XG4gICAgdGhyb3cgbmV3IEFwaUVycm9yKEVycm9yQ29kZS5FSU5WQUwsICdQYXRoIG11c3QgYmUgYSBzdHJpbmcgd2l0aG91dCBudWxsIGJ5dGVzLicpO1xuICB9IGVsc2UgaWYgKHAgPT09ICcnKSB7XG4gICAgdGhyb3cgbmV3IEFwaUVycm9yKEVycm9yQ29kZS5FSU5WQUwsICdQYXRoIG11c3Qgbm90IGJlIGVtcHR5LicpO1xuICB9XG4gIHJldHVybiBwYXRoLnJlc29sdmUocCk7XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5mdW5jdGlvbiBub3JtYWxpemVPcHRpb25zKG9wdGlvbnM6IGFueSwgZGVmRW5jOiBzdHJpbmcgfCBudWxsLCBkZWZGbGFnOiBzdHJpbmcsIGRlZk1vZGU6IG51bWJlciB8IG51bGwpOiB7ZW5jb2Rpbmc6IHN0cmluZzsgZmxhZzogc3RyaW5nOyBtb2RlOiBudW1iZXJ9IHtcbiAgc3dpdGNoICh0eXBlb2Ygb3B0aW9ucykge1xuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICByZXR1cm4ge1xuICAgICAgICBlbmNvZGluZzogdHlwZW9mIG9wdGlvbnNbJ2VuY29kaW5nJ10gIT09ICd1bmRlZmluZWQnID8gb3B0aW9uc1snZW5jb2RpbmcnXSA6IGRlZkVuYyxcbiAgICAgICAgZmxhZzogdHlwZW9mIG9wdGlvbnNbJ2ZsYWcnXSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zWydmbGFnJ10gOiBkZWZGbGFnLFxuICAgICAgICBtb2RlOiBub3JtYWxpemVNb2RlKG9wdGlvbnNbJ21vZGUnXSwgZGVmTW9kZSEpXG4gICAgICB9O1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICByZXR1cm4ge1xuICAgICAgICBlbmNvZGluZzogb3B0aW9ucyxcbiAgICAgICAgZmxhZzogZGVmRmxhZyxcbiAgICAgICAgbW9kZTogZGVmTW9kZSFcbiAgICAgIH07XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVuY29kaW5nOiBkZWZFbmMhLFxuICAgICAgICBmbGFnOiBkZWZGbGFnLFxuICAgICAgICBtb2RlOiBkZWZNb2RlIVxuICAgICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBkZWZhdWx0IGNhbGxiYWNrIGlzIGEgTk9QLlxuICogQGhpZGRlblxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbm9wQ2IoKSB7XG4gIC8vIE5PUC5cbn1cblxuLyoqXG4gKiBUaGUgbm9kZSBmcm9udGVuZCB0byBhbGwgZmlsZXN5c3RlbXMuXG4gKiBUaGlzIGxheWVyIGhhbmRsZXM6XG4gKlxuICogKiBTYW5pdHkgY2hlY2tpbmcgaW5wdXRzLlxuICogKiBOb3JtYWxpemluZyBwYXRocy5cbiAqICogUmVzZXR0aW5nIHN0YWNrIGRlcHRoIGZvciBhc3luY2hyb25vdXMgb3BlcmF0aW9ucyB3aGljaCBtYXkgbm90IGdvIHRocm91Z2hcbiAqICAgdGhlIGJyb3dzZXIgYnkgd3JhcHBpbmcgYWxsIGlucHV0IGNhbGxiYWNrcyB1c2luZyBgc2V0SW1tZWRpYXRlYC5cbiAqICogUGVyZm9ybWluZyB0aGUgcmVxdWVzdGVkIG9wZXJhdGlvbiB0aHJvdWdoIHRoZSBmaWxlc3lzdGVtIG9yIHRoZSBmaWxlXG4gKiAgIGRlc2NyaXB0b3IsIGFzIGFwcHJvcHJpYXRlLlxuICogKiBIYW5kbGluZyBvcHRpb25hbCBhcmd1bWVudHMgYW5kIHNldHRpbmcgZGVmYXVsdCBhcmd1bWVudHMuXG4gKiBAc2VlIGh0dHA6Ly9ub2RlanMub3JnL2FwaS9mcy5odG1sXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZTIHtcbiAgLyogdHNsaW50OmRpc2FibGU6dmFyaWFibGUtbmFtZSAqL1xuICAvLyBFeHBvcnRlZCBmcy5TdGF0cy5cbiAgcHVibGljIHN0YXRpYyBTdGF0cyA9IFN0YXRzO1xuICAvKiB0c2xpbnQ6ZW5hYmxlOnZhcmlhYmxlLW5hbWUgKi9cblxuICBwdWJsaWMgRl9PSzogbnVtYmVyID0gMDtcbiAgcHVibGljIFJfT0s6IG51bWJlciA9IDQ7XG4gIHB1YmxpYyBXX09LOiBudW1iZXIgPSAyO1xuICBwdWJsaWMgWF9PSzogbnVtYmVyID0gMTtcblxuICBwcml2YXRlIHJvb3Q6IEZpbGVTeXN0ZW0gfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBmZE1hcDoge1tmZDogbnVtYmVyXTogRmlsZX0gPSB7fTtcbiAgcHJpdmF0ZSBuZXh0RmQgPSAxMDA7XG5cbiAgcHVibGljIGluaXRpYWxpemUocm9vdEZTOiBGaWxlU3lzdGVtKTogRmlsZVN5c3RlbSB7XG4gICAgaWYgKCEoPGFueT4gcm9vdEZTKS5jb25zdHJ1Y3Rvci5pc0F2YWlsYWJsZSgpKSB7XG4gICAgICB0aHJvdyBuZXcgQXBpRXJyb3IoRXJyb3JDb2RlLkVJTlZBTCwgJ1RyaWVkIHRvIGluc3RhbnRpYXRlIEJyb3dzZXJGUyB3aXRoIGFuIHVuYXZhaWxhYmxlIGZpbGUgc3lzdGVtLicpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5yb290ID0gcm9vdEZTO1xuICB9XG5cbiAgLyoqXG4gICAqIGNvbnZlcnRzIERhdGUgb3IgbnVtYmVyIHRvIGEgZnJhY3Rpb25hbCBVTklYIHRpbWVzdGFtcFxuICAgKiBHcmFiYmVkIGZyb20gTm9kZUpTIHNvdXJjZXMgKGxpYi9mcy5qcylcbiAgICovXG4gIHB1YmxpYyBfdG9Vbml4VGltZXN0YW1wKHRpbWU6IERhdGUgfCBudW1iZXIpOiBudW1iZXIge1xuICAgIGlmICh0eXBlb2YgdGltZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiB0aW1lO1xuICAgIH0gZWxzZSBpZiAodGltZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgIHJldHVybiB0aW1lLmdldFRpbWUoKSAvIDEwMDA7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBwYXJzZSB0aW1lOiBcIiArIHRpbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqICoqTk9OU1RBTkRBUkQqKjogR3JhYiB0aGUgRmlsZVN5c3RlbSBpbnN0YW5jZSB0aGF0IGJhY2tzIHRoaXMgQVBJLlxuICAgKiBAcmV0dXJuIFtCcm93c2VyRlMuRmlsZVN5c3RlbSB8IG51bGxdIFJldHVybnMgbnVsbCBpZiB0aGUgZmlsZSBzeXN0ZW0gaGFzXG4gICAqICAgbm90IGJlZW4gaW5pdGlhbGl6ZWQuXG4gICAqL1xuICBwdWJsaWMgZ2V0Um9vdEZTKCk6IEZpbGVTeXN0ZW0gfCBudWxsIHtcbiAgICBpZiAodGhpcy5yb290KSB7XG4gICAgICByZXR1cm4gdGhpcy5yb290O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICAvLyBGSUxFIE9SIERJUkVDVE9SWSBNRVRIT0RTXG5cbiAgLyoqXG4gICAqIEFzeW5jaHJvbm91cyByZW5hbWUuIE5vIGFyZ3VtZW50cyBvdGhlciB0aGFuIGEgcG9zc2libGUgZXhjZXB0aW9uIGFyZSBnaXZlblxuICAgKiB0byB0aGUgY29tcGxldGlvbiBjYWxsYmFjay5cbiAgICogQHBhcmFtIG9sZFBhdGhcbiAgICogQHBhcmFtIG5ld1BhdGhcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL1xuICBwdWJsaWMgcmVuYW1lKG9sZFBhdGg6IHN0cmluZywgbmV3UGF0aDogc3RyaW5nLCBjYjogQkZTT25lQXJnQ2FsbGJhY2sgPSBub3BDYik6IHZvaWQge1xuICAgIGNvbnN0IG5ld0NiID0gd3JhcENiKGNiLCAxKTtcbiAgICB0cnkge1xuICAgICAgYXNzZXJ0Um9vdCh0aGlzLnJvb3QpLnJlbmFtZShub3JtYWxpemVQYXRoKG9sZFBhdGgpLCBub3JtYWxpemVQYXRoKG5ld1BhdGgpLCBuZXdDYik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgbmV3Q2IoZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN5bmNocm9ub3VzIHJlbmFtZS5cbiAgICogQHBhcmFtIG9sZFBhdGhcbiAgICogQHBhcmFtIG5ld1BhdGhcbiAgICovXG4gIHB1YmxpYyByZW5hbWVTeW5jKG9sZFBhdGg6IHN0cmluZywgbmV3UGF0aDogc3RyaW5nKTogdm9pZCB7XG4gICAgYXNzZXJ0Um9vdCh0aGlzLnJvb3QpLnJlbmFtZVN5bmMobm9ybWFsaXplUGF0aChvbGRQYXRoKSwgbm9ybWFsaXplUGF0aChuZXdQYXRoKSk7XG4gIH1cblxuICAvKipcbiAgICogVGVzdCB3aGV0aGVyIG9yIG5vdCB0aGUgZ2l2ZW4gcGF0aCBleGlzdHMgYnkgY2hlY2tpbmcgd2l0aCB0aGUgZmlsZSBzeXN0ZW0uXG4gICAqIFRoZW4gY2FsbCB0aGUgY2FsbGJhY2sgYXJndW1lbnQgd2l0aCBlaXRoZXIgdHJ1ZSBvciBmYWxzZS5cbiAgICogQGV4YW1wbGUgU2FtcGxlIGludm9jYXRpb25cbiAgICogICBmcy5leGlzdHMoJy9ldGMvcGFzc3dkJywgZnVuY3Rpb24gKGV4aXN0cykge1xuICAgKiAgICAgdXRpbC5kZWJ1ZyhleGlzdHMgPyBcIml0J3MgdGhlcmVcIiA6IFwibm8gcGFzc3dkIVwiKTtcbiAgICogICB9KTtcbiAgICogQHBhcmFtIHBhdGhcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL1xuICBwdWJsaWMgZXhpc3RzKHBhdGg6IHN0cmluZywgY2I6IChleGlzdHM6IGJvb2xlYW4pID0+IGFueSA9IG5vcENiKTogdm9pZCB7XG4gICAgY29uc3QgbmV3Q2IgPSB3cmFwQ2IoY2IsIDEpO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXNzZXJ0Um9vdCh0aGlzLnJvb3QpLmV4aXN0cyhub3JtYWxpemVQYXRoKHBhdGgpLCBuZXdDYik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gRG9lc24ndCByZXR1cm4gYW4gZXJyb3IuIElmIHNvbWV0aGluZyBiYWQgaGFwcGVucywgd2UgYXNzdW1lIGl0IGp1c3RcbiAgICAgIC8vIGRvZXNuJ3QgZXhpc3QuXG4gICAgICByZXR1cm4gbmV3Q2IoZmFsc2UpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUZXN0IHdoZXRoZXIgb3Igbm90IHRoZSBnaXZlbiBwYXRoIGV4aXN0cyBieSBjaGVja2luZyB3aXRoIHRoZSBmaWxlIHN5c3RlbS5cbiAgICogQHBhcmFtIHBhdGhcbiAgICogQHJldHVybiBbYm9vbGVhbl1cbiAgICovXG4gIHB1YmxpYyBleGlzdHNTeW5jKHBhdGg6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXNzZXJ0Um9vdCh0aGlzLnJvb3QpLmV4aXN0c1N5bmMobm9ybWFsaXplUGF0aChwYXRoKSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gRG9lc24ndCByZXR1cm4gYW4gZXJyb3IuIElmIHNvbWV0aGluZyBiYWQgaGFwcGVucywgd2UgYXNzdW1lIGl0IGp1c3RcbiAgICAgIC8vIGRvZXNuJ3QgZXhpc3QuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFzeW5jaHJvbm91cyBgc3RhdGAuXG4gICAqIEBwYXJhbSBwYXRoXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKi9cbiAgcHVibGljIHN0YXQocGF0aDogc3RyaW5nLCBjYjogQkZTQ2FsbGJhY2s8U3RhdHM+ID0gbm9wQ2IpOiB2b2lkIHtcbiAgICBjb25zdCBuZXdDYiA9IHdyYXBDYihjYiwgMik7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhc3NlcnRSb290KHRoaXMucm9vdCkuc3RhdChub3JtYWxpemVQYXRoKHBhdGgpLCBmYWxzZSwgbmV3Q2IpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBuZXdDYihlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3luY2hyb25vdXMgYHN0YXRgLlxuICAgKiBAcGFyYW0gcGF0aFxuICAgKiBAcmV0dXJuIFtCcm93c2VyRlMubm9kZS5mcy5TdGF0c11cbiAgICovXG4gIHB1YmxpYyBzdGF0U3luYyhwYXRoOiBzdHJpbmcpOiBTdGF0cyB7XG4gICAgcmV0dXJuIGFzc2VydFJvb3QodGhpcy5yb290KS5zdGF0U3luYyhub3JtYWxpemVQYXRoKHBhdGgpLCBmYWxzZSk7XG4gIH1cblxuICAvKipcbiAgICogQXN5bmNocm9ub3VzIGBsc3RhdGAuXG4gICAqIGBsc3RhdCgpYCBpcyBpZGVudGljYWwgdG8gYHN0YXQoKWAsIGV4Y2VwdCB0aGF0IGlmIHBhdGggaXMgYSBzeW1ib2xpYyBsaW5rLFxuICAgKiB0aGVuIHRoZSBsaW5rIGl0c2VsZiBpcyBzdGF0LWVkLCBub3QgdGhlIGZpbGUgdGhhdCBpdCByZWZlcnMgdG8uXG4gICAqIEBwYXJhbSBwYXRoXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKi9cbiAgcHVibGljIGxzdGF0KHBhdGg6IHN0cmluZywgY2I6IEJGU0NhbGxiYWNrPFN0YXRzPiA9IG5vcENiKTogdm9pZCB7XG4gICAgY29uc3QgbmV3Q2IgPSB3cmFwQ2IoY2IsIDIpO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXNzZXJ0Um9vdCh0aGlzLnJvb3QpLnN0YXQobm9ybWFsaXplUGF0aChwYXRoKSwgdHJ1ZSwgbmV3Q2IpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBuZXdDYihlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3luY2hyb25vdXMgYGxzdGF0YC5cbiAgICogYGxzdGF0KClgIGlzIGlkZW50aWNhbCB0byBgc3RhdCgpYCwgZXhjZXB0IHRoYXQgaWYgcGF0aCBpcyBhIHN5bWJvbGljIGxpbmssXG4gICAqIHRoZW4gdGhlIGxpbmsgaXRzZWxmIGlzIHN0YXQtZWQsIG5vdCB0aGUgZmlsZSB0aGF0IGl0IHJlZmVycyB0by5cbiAgICogQHBhcmFtIHBhdGhcbiAgICogQHJldHVybiBbQnJvd3NlckZTLm5vZGUuZnMuU3RhdHNdXG4gICAqL1xuICBwdWJsaWMgbHN0YXRTeW5jKHBhdGg6IHN0cmluZyk6IFN0YXRzIHtcbiAgICByZXR1cm4gYXNzZXJ0Um9vdCh0aGlzLnJvb3QpLnN0YXRTeW5jKG5vcm1hbGl6ZVBhdGgocGF0aCksIHRydWUpO1xuICB9XG5cbiAgLy8gRklMRS1PTkxZIE1FVEhPRFNcblxuICAvKipcbiAgICogQXN5bmNocm9ub3VzIGB0cnVuY2F0ZWAuXG4gICAqIEBwYXJhbSBwYXRoXG4gICAqIEBwYXJhbSBsZW5cbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL1xuICBwdWJsaWMgdHJ1bmNhdGUocGF0aDogc3RyaW5nLCBjYj86IEJGU09uZUFyZ0NhbGxiYWNrKTogdm9pZDtcbiAgcHVibGljIHRydW5jYXRlKHBhdGg6IHN0cmluZywgbGVuOiBudW1iZXIsIGNiPzogQkZTT25lQXJnQ2FsbGJhY2spOiB2b2lkO1xuICBwdWJsaWMgdHJ1bmNhdGUocGF0aDogc3RyaW5nLCBhcmcyOiBhbnkgPSAwLCBjYjogQkZTT25lQXJnQ2FsbGJhY2sgPSBub3BDYik6IHZvaWQge1xuICAgIGxldCBsZW4gPSAwO1xuICAgIGlmICh0eXBlb2YgYXJnMiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2IgPSBhcmcyO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZzIgPT09ICdudW1iZXInKSB7XG4gICAgICBsZW4gPSBhcmcyO1xuICAgIH1cblxuICAgIGNvbnN0IG5ld0NiID0gd3JhcENiKGNiLCAxKTtcbiAgICB0cnkge1xuICAgICAgaWYgKGxlbiA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEFwaUVycm9yKEVycm9yQ29kZS5FSU5WQUwpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFzc2VydFJvb3QodGhpcy5yb290KS50cnVuY2F0ZShub3JtYWxpemVQYXRoKHBhdGgpLCBsZW4sIG5ld0NiKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gbmV3Q2IoZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN5bmNocm9ub3VzIGB0cnVuY2F0ZWAuXG4gICAqIEBwYXJhbSBwYXRoXG4gICAqIEBwYXJhbSBsZW5cbiAgICovXG4gIHB1YmxpYyB0cnVuY2F0ZVN5bmMocGF0aDogc3RyaW5nLCBsZW46IG51bWJlciA9IDApOiB2b2lkIHtcbiAgICBpZiAobGVuIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEFwaUVycm9yKEVycm9yQ29kZS5FSU5WQUwpO1xuICAgIH1cbiAgICByZXR1cm4gYXNzZXJ0Um9vdCh0aGlzLnJvb3QpLnRydW5jYXRlU3luYyhub3JtYWxpemVQYXRoKHBhdGgpLCBsZW4pO1xuICB9XG5cbiAgLyoqXG4gICAqIEFzeW5jaHJvbm91cyBgdW5saW5rYC5cbiAgICogQHBhcmFtIHBhdGhcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL1xuICBwdWJsaWMgdW5saW5rKHBhdGg6IHN0cmluZywgY2I6IEJGU09uZUFyZ0NhbGxiYWNrID0gbm9wQ2IpOiB2b2lkIHtcbiAgICBjb25zdCBuZXdDYiA9IHdyYXBDYihjYiwgMSk7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhc3NlcnRSb290KHRoaXMucm9vdCkudW5saW5rKG5vcm1hbGl6ZVBhdGgocGF0aCksIG5ld0NiKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gbmV3Q2IoZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN5bmNocm9ub3VzIGB1bmxpbmtgLlxuICAgKiBAcGFyYW0gcGF0aFxuICAgKi9cbiAgcHVibGljIHVubGlua1N5bmMocGF0aDogc3RyaW5nKTogdm9pZCB7XG4gICAgcmV0dXJuIGFzc2VydFJvb3QodGhpcy5yb290KS51bmxpbmtTeW5jKG5vcm1hbGl6ZVBhdGgocGF0aCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFzeW5jaHJvbm91cyBmaWxlIG9wZW4uXG4gICAqIEV4Y2x1c2l2ZSBtb2RlIGVuc3VyZXMgdGhhdCBwYXRoIGlzIG5ld2x5IGNyZWF0ZWQuXG4gICAqXG4gICAqIGBmbGFnc2AgY2FuIGJlOlxuICAgKlxuICAgKiAqIGAncidgIC0gT3BlbiBmaWxlIGZvciByZWFkaW5nLiBBbiBleGNlcHRpb24gb2NjdXJzIGlmIHRoZSBmaWxlIGRvZXMgbm90IGV4aXN0LlxuICAgKiAqIGAncisnYCAtIE9wZW4gZmlsZSBmb3IgcmVhZGluZyBhbmQgd3JpdGluZy4gQW4gZXhjZXB0aW9uIG9jY3VycyBpZiB0aGUgZmlsZSBkb2VzIG5vdCBleGlzdC5cbiAgICogKiBgJ3JzJ2AgLSBPcGVuIGZpbGUgZm9yIHJlYWRpbmcgaW4gc3luY2hyb25vdXMgbW9kZS4gSW5zdHJ1Y3RzIHRoZSBmaWxlc3lzdGVtIHRvIG5vdCBjYWNoZSB3cml0ZXMuXG4gICAqICogYCdycysnYCAtIE9wZW4gZmlsZSBmb3IgcmVhZGluZyBhbmQgd3JpdGluZywgYW5kIG9wZW5zIHRoZSBmaWxlIGluIHN5bmNocm9ub3VzIG1vZGUuXG4gICAqICogYCd3J2AgLSBPcGVuIGZpbGUgZm9yIHdyaXRpbmcuIFRoZSBmaWxlIGlzIGNyZWF0ZWQgKGlmIGl0IGRvZXMgbm90IGV4aXN0KSBvciB0cnVuY2F0ZWQgKGlmIGl0IGV4aXN0cykuXG4gICAqICogYCd3eCdgIC0gTGlrZSAndycgYnV0IG9wZW5zIHRoZSBmaWxlIGluIGV4Y2x1c2l2ZSBtb2RlLlxuICAgKiAqIGAndysnYCAtIE9wZW4gZmlsZSBmb3IgcmVhZGluZyBhbmQgd3JpdGluZy4gVGhlIGZpbGUgaXMgY3JlYXRlZCAoaWYgaXQgZG9lcyBub3QgZXhpc3QpIG9yIHRydW5jYXRlZCAoaWYgaXQgZXhpc3RzKS5cbiAgICogKiBgJ3d4KydgIC0gTGlrZSAndysnIGJ1dCBvcGVucyB0aGUgZmlsZSBpbiBleGNsdXNpdmUgbW9kZS5cbiAgICogKiBgJ2EnYCAtIE9wZW4gZmlsZSBmb3IgYXBwZW5kaW5nLiBUaGUgZmlsZSBpcyBjcmVhdGVkIGlmIGl0IGRvZXMgbm90IGV4aXN0LlxuICAgKiAqIGAnYXgnYCAtIExpa2UgJ2EnIGJ1dCBvcGVucyB0aGUgZmlsZSBpbiBleGNsdXNpdmUgbW9kZS5cbiAgICogKiBgJ2ErJ2AgLSBPcGVuIGZpbGUgZm9yIHJlYWRpbmcgYW5kIGFwcGVuZGluZy4gVGhlIGZpbGUgaXMgY3JlYXRlZCBpZiBpdCBkb2VzIG5vdCBleGlzdC5cbiAgICogKiBgJ2F4KydgIC0gTGlrZSAnYSsnIGJ1dCBvcGVucyB0aGUgZmlsZSBpbiBleGNsdXNpdmUgbW9kZS5cbiAgICpcbiAgICogQHNlZSBodHRwOi8vd3d3Lm1hbnBhZ2V6LmNvbS9tYW4vMi9vcGVuL1xuICAgKiBAcGFyYW0gcGF0aFxuICAgKiBAcGFyYW0gZmxhZ3NcbiAgICogQHBhcmFtIG1vZGUgZGVmYXVsdHMgdG8gYDA2NDRgXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKi9cbiAgcHVibGljIG9wZW4ocGF0aDogc3RyaW5nLCBmbGFnOiBzdHJpbmcsIGNiPzogQkZTQ2FsbGJhY2s8bnVtYmVyPik6IHZvaWQ7XG4gIHB1YmxpYyBvcGVuKHBhdGg6IHN0cmluZywgZmxhZzogc3RyaW5nLCBtb2RlOiBudW1iZXJ8c3RyaW5nLCBjYj86IEJGU0NhbGxiYWNrPG51bWJlcj4pOiB2b2lkO1xuICBwdWJsaWMgb3BlbihwYXRoOiBzdHJpbmcsIGZsYWc6IHN0cmluZywgYXJnMj86IGFueSwgY2I6IEJGU0NhbGxiYWNrPG51bWJlcj4gPSBub3BDYik6IHZvaWQge1xuICAgIGNvbnN0IG1vZGUgPSBub3JtYWxpemVNb2RlKGFyZzIsIDB4MWE0KTtcbiAgICBjYiA9IHR5cGVvZiBhcmcyID09PSAnZnVuY3Rpb24nID8gYXJnMiA6IGNiO1xuICAgIGNvbnN0IG5ld0NiID0gd3JhcENiKGNiLCAyKTtcbiAgICB0cnkge1xuICAgICAgYXNzZXJ0Um9vdCh0aGlzLnJvb3QpLm9wZW4obm9ybWFsaXplUGF0aChwYXRoKSwgRmlsZUZsYWcuZ2V0RmlsZUZsYWcoZmxhZyksIG1vZGUsIChlOiBBcGlFcnJvciwgZmlsZT86IEZpbGUpID0+IHtcbiAgICAgICAgaWYgKGZpbGUpIHtcbiAgICAgICAgICBuZXdDYihlLCB0aGlzLmdldEZkRm9yRmlsZShmaWxlKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3Q2IoZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIG5ld0NiKGUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTeW5jaHJvbm91cyBmaWxlIG9wZW4uXG4gICAqIEBzZWUgaHR0cDovL3d3dy5tYW5wYWdlei5jb20vbWFuLzIvb3Blbi9cbiAgICogQHBhcmFtIHBhdGhcbiAgICogQHBhcmFtIGZsYWdzXG4gICAqIEBwYXJhbSBtb2RlIGRlZmF1bHRzIHRvIGAwNjQ0YFxuICAgKiBAcmV0dXJuIFtCcm93c2VyRlMuRmlsZV1cbiAgICovXG4gIHB1YmxpYyBvcGVuU3luYyhwYXRoOiBzdHJpbmcsIGZsYWc6IHN0cmluZywgbW9kZTogbnVtYmVyfHN0cmluZyA9IDB4MWE0KTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5nZXRGZEZvckZpbGUoXG4gICAgICBhc3NlcnRSb290KHRoaXMucm9vdCkub3BlblN5bmMobm9ybWFsaXplUGF0aChwYXRoKSwgRmlsZUZsYWcuZ2V0RmlsZUZsYWcoZmxhZyksIG5vcm1hbGl6ZU1vZGUobW9kZSwgMHgxYTQpKSk7XG4gIH1cblxuICAvKipcbiAgICogQXN5bmNocm9ub3VzbHkgcmVhZHMgdGhlIGVudGlyZSBjb250ZW50cyBvZiBhIGZpbGUuXG4gICAqIEBleGFtcGxlIFVzYWdlIGV4YW1wbGVcbiAgICogICBmcy5yZWFkRmlsZSgnL2V0Yy9wYXNzd2QnLCBmdW5jdGlvbiAoZXJyLCBkYXRhKSB7XG4gICAqICAgICBpZiAoZXJyKSB0aHJvdyBlcnI7XG4gICAqICAgICBjb25zb2xlLmxvZyhkYXRhKTtcbiAgICogICB9KTtcbiAgICogQHBhcmFtIGZpbGVuYW1lXG4gICAqIEBwYXJhbSBvcHRpb25zXG4gICAqIEBvcHRpb24gb3B0aW9ucyBbU3RyaW5nXSBlbmNvZGluZyBUaGUgc3RyaW5nIGVuY29kaW5nIGZvciB0aGUgZmlsZSBjb250ZW50cy4gRGVmYXVsdHMgdG8gYG51bGxgLlxuICAgKiBAb3B0aW9uIG9wdGlvbnMgW1N0cmluZ10gZmxhZyBEZWZhdWx0cyB0byBgJ3InYC5cbiAgICogQHBhcmFtIGNhbGxiYWNrIElmIG5vIGVuY29kaW5nIGlzIHNwZWNpZmllZCwgdGhlbiB0aGUgcmF3IGJ1ZmZlciBpcyByZXR1cm5lZC5cbiAgICovXG4gIHB1YmxpYyByZWFkRmlsZShmaWxlbmFtZTogc3RyaW5nLCBjYjogQkZTQ2FsbGJhY2s8QnVmZmVyPik6IHZvaWQ7XG4gIHB1YmxpYyByZWFkRmlsZShmaWxlbmFtZTogc3RyaW5nLCBvcHRpb25zOiB7IGZsYWc/OiBzdHJpbmc7IH0sIGNhbGxiYWNrOiBCRlNDYWxsYmFjazxCdWZmZXI+KTogdm9pZDtcbiAgcHVibGljIHJlYWRGaWxlKGZpbGVuYW1lOiBzdHJpbmcsIG9wdGlvbnM6IHsgZW5jb2Rpbmc6IHN0cmluZzsgZmxhZz86IHN0cmluZzsgfSwgY2FsbGJhY2s6IEJGU0NhbGxiYWNrPHN0cmluZz4pOiB2b2lkO1xuICBwdWJsaWMgcmVhZEZpbGUoZmlsZW5hbWU6IHN0cmluZywgZW5jb2Rpbmc6IHN0cmluZywgY2I/OiBCRlNDYWxsYmFjazxzdHJpbmc+KTogdm9pZDtcbiAgcHVibGljIHJlYWRGaWxlKGZpbGVuYW1lOiBzdHJpbmcsIGFyZzI6IGFueSA9IHt9LCBjYjogQkZTQ2FsbGJhY2s8QnVmZmVyIHwgc3RyaW5nPiA9IG5vcENiICkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSBub3JtYWxpemVPcHRpb25zKGFyZzIsIG51bGwsICdyJywgbnVsbCk7XG4gICAgY2IgPSB0eXBlb2YgYXJnMiA9PT0gJ2Z1bmN0aW9uJyA/IGFyZzIgOiBjYjtcbiAgICBjb25zdCBuZXdDYiA9IHdyYXBDYihjYiwgMik7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGZsYWcgPSBGaWxlRmxhZy5nZXRGaWxlRmxhZyhvcHRpb25zWydmbGFnJ10pO1xuICAgICAgaWYgKCFmbGFnLmlzUmVhZGFibGUoKSkge1xuICAgICAgICByZXR1cm4gbmV3Q2IobmV3IEFwaUVycm9yKEVycm9yQ29kZS5FSU5WQUwsICdGbGFnIHBhc3NlZCB0byByZWFkRmlsZSBtdXN0IGFsbG93IGZvciByZWFkaW5nLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhc3NlcnRSb290KHRoaXMucm9vdCkucmVhZEZpbGUobm9ybWFsaXplUGF0aChmaWxlbmFtZSksIG9wdGlvbnMuZW5jb2RpbmcsIGZsYWcsIG5ld0NiKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gbmV3Q2IoZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN5bmNocm9ub3VzbHkgcmVhZHMgdGhlIGVudGlyZSBjb250ZW50cyBvZiBhIGZpbGUuXG4gICAqIEBwYXJhbSBmaWxlbmFtZVxuICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgKiBAb3B0aW9uIG9wdGlvbnMgW1N0cmluZ10gZW5jb2RpbmcgVGhlIHN0cmluZyBlbmNvZGluZyBmb3IgdGhlIGZpbGUgY29udGVudHMuIERlZmF1bHRzIHRvIGBudWxsYC5cbiAgICogQG9wdGlvbiBvcHRpb25zIFtTdHJpbmddIGZsYWcgRGVmYXVsdHMgdG8gYCdyJ2AuXG4gICAqIEByZXR1cm4gW1N0cmluZyB8IEJyb3dzZXJGUy5ub2RlLkJ1ZmZlcl1cbiAgICovXG4gIHB1YmxpYyByZWFkRmlsZVN5bmMoZmlsZW5hbWU6IHN0cmluZywgb3B0aW9ucz86IHsgZmxhZz86IHN0cmluZzsgfSk6IEJ1ZmZlcjtcbiAgcHVibGljIHJlYWRGaWxlU3luYyhmaWxlbmFtZTogc3RyaW5nLCBvcHRpb25zOiB7IGVuY29kaW5nOiBzdHJpbmc7IGZsYWc/OiBzdHJpbmc7IH0pOiBzdHJpbmc7XG4gIHB1YmxpYyByZWFkRmlsZVN5bmMoZmlsZW5hbWU6IHN0cmluZywgZW5jb2Rpbmc6IHN0cmluZyk6IHN0cmluZztcbiAgcHVibGljIHJlYWRGaWxlU3luYyhmaWxlbmFtZTogc3RyaW5nLCBhcmcyOiBhbnkgPSB7fSk6IGFueSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IG5vcm1hbGl6ZU9wdGlvbnMoYXJnMiwgbnVsbCwgJ3InLCBudWxsKTtcbiAgICBjb25zdCBmbGFnID0gRmlsZUZsYWcuZ2V0RmlsZUZsYWcob3B0aW9ucy5mbGFnKTtcbiAgICBpZiAoIWZsYWcuaXNSZWFkYWJsZSgpKSB7XG4gICAgICB0aHJvdyBuZXcgQXBpRXJyb3IoRXJyb3JDb2RlLkVJTlZBTCwgJ0ZsYWcgcGFzc2VkIHRvIHJlYWRGaWxlIG11c3QgYWxsb3cgZm9yIHJlYWRpbmcuJyk7XG4gICAgfVxuICAgIHJldHVybiBhc3NlcnRSb290KHRoaXMucm9vdCkucmVhZEZpbGVTeW5jKG5vcm1hbGl6ZVBhdGgoZmlsZW5hbWUpLCBvcHRpb25zLmVuY29kaW5nLCBmbGFnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBc3luY2hyb25vdXNseSB3cml0ZXMgZGF0YSB0byBhIGZpbGUsIHJlcGxhY2luZyB0aGUgZmlsZSBpZiBpdCBhbHJlYWR5XG4gICAqIGV4aXN0cy5cbiAgICpcbiAgICogVGhlIGVuY29kaW5nIG9wdGlvbiBpcyBpZ25vcmVkIGlmIGRhdGEgaXMgYSBidWZmZXIuXG4gICAqXG4gICAqIEBleGFtcGxlIFVzYWdlIGV4YW1wbGVcbiAgICogICBmcy53cml0ZUZpbGUoJ21lc3NhZ2UudHh0JywgJ0hlbGxvIE5vZGUnLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAqICAgICBpZiAoZXJyKSB0aHJvdyBlcnI7XG4gICAqICAgICBjb25zb2xlLmxvZygnSXRcXCdzIHNhdmVkIScpO1xuICAgKiAgIH0pO1xuICAgKiBAcGFyYW0gZmlsZW5hbWVcbiAgICogQHBhcmFtIGRhdGFcbiAgICogQHBhcmFtIG9wdGlvbnNcbiAgICogQG9wdGlvbiBvcHRpb25zIFtTdHJpbmddIGVuY29kaW5nIERlZmF1bHRzIHRvIGAndXRmOCdgLlxuICAgKiBAb3B0aW9uIG9wdGlvbnMgW051bWJlcl0gbW9kZSBEZWZhdWx0cyB0byBgMDY0NGAuXG4gICAqIEBvcHRpb24gb3B0aW9ucyBbU3RyaW5nXSBmbGFnIERlZmF1bHRzIHRvIGAndydgLlxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIHB1YmxpYyB3cml0ZUZpbGUoZmlsZW5hbWU6IHN0cmluZywgZGF0YTogYW55LCBjYj86IEJGU09uZUFyZ0NhbGxiYWNrKTogdm9pZDtcbiAgcHVibGljIHdyaXRlRmlsZShmaWxlbmFtZTogc3RyaW5nLCBkYXRhOiBhbnksIGVuY29kaW5nPzogc3RyaW5nLCBjYj86IEJGU09uZUFyZ0NhbGxiYWNrKTogdm9pZDtcbiAgcHVibGljIHdyaXRlRmlsZShmaWxlbmFtZTogc3RyaW5nLCBkYXRhOiBhbnksIG9wdGlvbnM/OiB7IGVuY29kaW5nPzogc3RyaW5nOyBtb2RlPzogc3RyaW5nIHwgbnVtYmVyOyBmbGFnPzogc3RyaW5nOyB9LCBjYj86IEJGU09uZUFyZ0NhbGxiYWNrKTogdm9pZDtcbiAgcHVibGljIHdyaXRlRmlsZShmaWxlbmFtZTogc3RyaW5nLCBkYXRhOiBhbnksIGFyZzM6IGFueSA9IHt9LCBjYjogQkZTT25lQXJnQ2FsbGJhY2sgPSBub3BDYik6IHZvaWQge1xuICAgIGNvbnN0IG9wdGlvbnMgPSBub3JtYWxpemVPcHRpb25zKGFyZzMsICd1dGY4JywgJ3cnLCAweDFhNCk7XG4gICAgY2IgPSB0eXBlb2YgYXJnMyA9PT0gJ2Z1bmN0aW9uJyA/IGFyZzMgOiBjYjtcbiAgICBjb25zdCBuZXdDYiA9IHdyYXBDYihjYiwgMSk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGZsYWcgPSBGaWxlRmxhZy5nZXRGaWxlRmxhZyhvcHRpb25zLmZsYWcpO1xuICAgICAgaWYgKCFmbGFnLmlzV3JpdGVhYmxlKCkpIHtcbiAgICAgICAgcmV0dXJuIG5ld0NiKG5ldyBBcGlFcnJvcihFcnJvckNvZGUuRUlOVkFMLCAnRmxhZyBwYXNzZWQgdG8gd3JpdGVGaWxlIG11c3QgYWxsb3cgZm9yIHdyaXRpbmcuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFzc2VydFJvb3QodGhpcy5yb290KS53cml0ZUZpbGUobm9ybWFsaXplUGF0aChmaWxlbmFtZSksIGRhdGEsIG9wdGlvbnMuZW5jb2RpbmcsIGZsYWcsIG9wdGlvbnMubW9kZSwgbmV3Q2IpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBuZXdDYihlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3luY2hyb25vdXNseSB3cml0ZXMgZGF0YSB0byBhIGZpbGUsIHJlcGxhY2luZyB0aGUgZmlsZSBpZiBpdCBhbHJlYWR5XG4gICAqIGV4aXN0cy5cbiAgICpcbiAgICogVGhlIGVuY29kaW5nIG9wdGlvbiBpcyBpZ25vcmVkIGlmIGRhdGEgaXMgYSBidWZmZXIuXG4gICAqIEBwYXJhbSBmaWxlbmFtZVxuICAgKiBAcGFyYW0gZGF0YVxuICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgKiBAb3B0aW9uIG9wdGlvbnMgW1N0cmluZ10gZW5jb2RpbmcgRGVmYXVsdHMgdG8gYCd1dGY4J2AuXG4gICAqIEBvcHRpb24gb3B0aW9ucyBbTnVtYmVyXSBtb2RlIERlZmF1bHRzIHRvIGAwNjQ0YC5cbiAgICogQG9wdGlvbiBvcHRpb25zIFtTdHJpbmddIGZsYWcgRGVmYXVsdHMgdG8gYCd3J2AuXG4gICAqL1xuICBwdWJsaWMgd3JpdGVGaWxlU3luYyhmaWxlbmFtZTogc3RyaW5nLCBkYXRhOiBhbnksIG9wdGlvbnM/OiB7IGVuY29kaW5nPzogc3RyaW5nOyBtb2RlPzogbnVtYmVyIHwgc3RyaW5nOyBmbGFnPzogc3RyaW5nOyB9KTogdm9pZDtcbiAgcHVibGljIHdyaXRlRmlsZVN5bmMoZmlsZW5hbWU6IHN0cmluZywgZGF0YTogYW55LCBlbmNvZGluZz86IHN0cmluZyk6IHZvaWQ7XG4gIHB1YmxpYyB3cml0ZUZpbGVTeW5jKGZpbGVuYW1lOiBzdHJpbmcsIGRhdGE6IGFueSwgYXJnMz86IGFueSk6IHZvaWQge1xuICAgIGNvbnN0IG9wdGlvbnMgPSBub3JtYWxpemVPcHRpb25zKGFyZzMsICd1dGY4JywgJ3cnLCAweDFhNCk7XG4gICAgY29uc3QgZmxhZyA9IEZpbGVGbGFnLmdldEZpbGVGbGFnKG9wdGlvbnMuZmxhZyk7XG4gICAgaWYgKCFmbGFnLmlzV3JpdGVhYmxlKCkpIHtcbiAgICAgIHRocm93IG5ldyBBcGlFcnJvcihFcnJvckNvZGUuRUlOVkFMLCAnRmxhZyBwYXNzZWQgdG8gd3JpdGVGaWxlIG11c3QgYWxsb3cgZm9yIHdyaXRpbmcuJyk7XG4gICAgfVxuICAgIHJldHVybiBhc3NlcnRSb290KHRoaXMucm9vdCkud3JpdGVGaWxlU3luYyhub3JtYWxpemVQYXRoKGZpbGVuYW1lKSwgZGF0YSwgb3B0aW9ucy5lbmNvZGluZywgZmxhZywgb3B0aW9ucy5tb2RlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBc3luY2hyb25vdXNseSBhcHBlbmQgZGF0YSB0byBhIGZpbGUsIGNyZWF0aW5nIHRoZSBmaWxlIGlmIGl0IG5vdCB5ZXRcbiAgICogZXhpc3RzLlxuICAgKlxuICAgKiBAZXhhbXBsZSBVc2FnZSBleGFtcGxlXG4gICAqICAgZnMuYXBwZW5kRmlsZSgnbWVzc2FnZS50eHQnLCAnZGF0YSB0byBhcHBlbmQnLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAqICAgICBpZiAoZXJyKSB0aHJvdyBlcnI7XG4gICAqICAgICBjb25zb2xlLmxvZygnVGhlIFwiZGF0YSB0byBhcHBlbmRcIiB3YXMgYXBwZW5kZWQgdG8gZmlsZSEnKTtcbiAgICogICB9KTtcbiAgICogQHBhcmFtIGZpbGVuYW1lXG4gICAqIEBwYXJhbSBkYXRhXG4gICAqIEBwYXJhbSBvcHRpb25zXG4gICAqIEBvcHRpb24gb3B0aW9ucyBbU3RyaW5nXSBlbmNvZGluZyBEZWZhdWx0cyB0byBgJ3V0ZjgnYC5cbiAgICogQG9wdGlvbiBvcHRpb25zIFtOdW1iZXJdIG1vZGUgRGVmYXVsdHMgdG8gYDA2NDRgLlxuICAgKiBAb3B0aW9uIG9wdGlvbnMgW1N0cmluZ10gZmxhZyBEZWZhdWx0cyB0byBgJ2EnYC5cbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL1xuICBwdWJsaWMgYXBwZW5kRmlsZShmaWxlbmFtZTogc3RyaW5nLCBkYXRhOiBhbnksIGNiPzogQkZTT25lQXJnQ2FsbGJhY2spOiB2b2lkO1xuICBwdWJsaWMgYXBwZW5kRmlsZShmaWxlbmFtZTogc3RyaW5nLCBkYXRhOiBhbnksIG9wdGlvbnM/OiB7IGVuY29kaW5nPzogc3RyaW5nOyBtb2RlPzogbnVtYmVyfHN0cmluZzsgZmxhZz86IHN0cmluZzsgfSwgY2I/OiBCRlNPbmVBcmdDYWxsYmFjayk6IHZvaWQ7XG4gIHB1YmxpYyBhcHBlbmRGaWxlKGZpbGVuYW1lOiBzdHJpbmcsIGRhdGE6IGFueSwgZW5jb2Rpbmc/OiBzdHJpbmcsIGNiPzogQkZTT25lQXJnQ2FsbGJhY2spOiB2b2lkO1xuICBwdWJsaWMgYXBwZW5kRmlsZShmaWxlbmFtZTogc3RyaW5nLCBkYXRhOiBhbnksIGFyZzM/OiBhbnksIGNiOiBCRlNPbmVBcmdDYWxsYmFjayA9IG5vcENiKTogdm9pZCB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IG5vcm1hbGl6ZU9wdGlvbnMoYXJnMywgJ3V0ZjgnLCAnYScsIDB4MWE0KTtcbiAgICBjYiA9IHR5cGVvZiBhcmczID09PSAnZnVuY3Rpb24nID8gYXJnMyA6IGNiO1xuICAgIGNvbnN0IG5ld0NiID0gd3JhcENiKGNiLCAxKTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZmxhZyA9IEZpbGVGbGFnLmdldEZpbGVGbGFnKG9wdGlvbnMuZmxhZyk7XG4gICAgICBpZiAoIWZsYWcuaXNBcHBlbmRhYmxlKCkpIHtcbiAgICAgICAgcmV0dXJuIG5ld0NiKG5ldyBBcGlFcnJvcihFcnJvckNvZGUuRUlOVkFMLCAnRmxhZyBwYXNzZWQgdG8gYXBwZW5kRmlsZSBtdXN0IGFsbG93IGZvciBhcHBlbmRpbmcuJykpO1xuICAgICAgfVxuICAgICAgYXNzZXJ0Um9vdCh0aGlzLnJvb3QpLmFwcGVuZEZpbGUobm9ybWFsaXplUGF0aChmaWxlbmFtZSksIGRhdGEsIG9wdGlvbnMuZW5jb2RpbmcsIGZsYWcsIG9wdGlvbnMubW9kZSwgbmV3Q2IpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIG5ld0NiKGUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBc3luY2hyb25vdXNseSBhcHBlbmQgZGF0YSB0byBhIGZpbGUsIGNyZWF0aW5nIHRoZSBmaWxlIGlmIGl0IG5vdCB5ZXRcbiAgICogZXhpc3RzLlxuICAgKlxuICAgKiBAZXhhbXBsZSBVc2FnZSBleGFtcGxlXG4gICAqICAgZnMuYXBwZW5kRmlsZSgnbWVzc2FnZS50eHQnLCAnZGF0YSB0byBhcHBlbmQnLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAqICAgICBpZiAoZXJyKSB0aHJvdyBlcnI7XG4gICAqICAgICBjb25zb2xlLmxvZygnVGhlIFwiZGF0YSB0byBhcHBlbmRcIiB3YXMgYXBwZW5kZWQgdG8gZmlsZSEnKTtcbiAgICogICB9KTtcbiAgICogQHBhcmFtIGZpbGVuYW1lXG4gICAqIEBwYXJhbSBkYXRhXG4gICAqIEBwYXJhbSBvcHRpb25zXG4gICAqIEBvcHRpb24gb3B0aW9ucyBbU3RyaW5nXSBlbmNvZGluZyBEZWZhdWx0cyB0byBgJ3V0ZjgnYC5cbiAgICogQG9wdGlvbiBvcHRpb25zIFtOdW1iZXJdIG1vZGUgRGVmYXVsdHMgdG8gYDA2NDRgLlxuICAgKiBAb3B0aW9uIG9wdGlvbnMgW1N0cmluZ10gZmxhZyBEZWZhdWx0cyB0byBgJ2EnYC5cbiAgICovXG4gIHB1YmxpYyBhcHBlbmRGaWxlU3luYyhmaWxlbmFtZTogc3RyaW5nLCBkYXRhOiBhbnksIG9wdGlvbnM/OiB7IGVuY29kaW5nPzogc3RyaW5nOyBtb2RlPzogbnVtYmVyIHwgc3RyaW5nOyBmbGFnPzogc3RyaW5nOyB9KTogdm9pZDtcbiAgcHVibGljIGFwcGVuZEZpbGVTeW5jKGZpbGVuYW1lOiBzdHJpbmcsIGRhdGE6IGFueSwgZW5jb2Rpbmc/OiBzdHJpbmcpOiB2b2lkO1xuICBwdWJsaWMgYXBwZW5kRmlsZVN5bmMoZmlsZW5hbWU6IHN0cmluZywgZGF0YTogYW55LCBhcmczPzogYW55KTogdm9pZCB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IG5vcm1hbGl6ZU9wdGlvbnMoYXJnMywgJ3V0ZjgnLCAnYScsIDB4MWE0KTtcbiAgICBjb25zdCBmbGFnID0gRmlsZUZsYWcuZ2V0RmlsZUZsYWcob3B0aW9ucy5mbGFnKTtcbiAgICBpZiAoIWZsYWcuaXNBcHBlbmRhYmxlKCkpIHtcbiAgICAgIHRocm93IG5ldyBBcGlFcnJvcihFcnJvckNvZGUuRUlOVkFMLCAnRmxhZyBwYXNzZWQgdG8gYXBwZW5kRmlsZSBtdXN0IGFsbG93IGZvciBhcHBlbmRpbmcuJyk7XG4gICAgfVxuICAgIHJldHVybiBhc3NlcnRSb290KHRoaXMucm9vdCkuYXBwZW5kRmlsZVN5bmMobm9ybWFsaXplUGF0aChmaWxlbmFtZSksIGRhdGEsIG9wdGlvbnMuZW5jb2RpbmcsIGZsYWcsIG9wdGlvbnMubW9kZSk7XG4gIH1cblxuICAvLyBGSUxFIERFU0NSSVBUT1IgTUVUSE9EU1xuXG4gIC8qKlxuICAgKiBBc3luY2hyb25vdXMgYGZzdGF0YC5cbiAgICogYGZzdGF0KClgIGlzIGlkZW50aWNhbCB0byBgc3RhdCgpYCwgZXhjZXB0IHRoYXQgdGhlIGZpbGUgdG8gYmUgc3RhdC1lZCBpc1xuICAgKiBzcGVjaWZpZWQgYnkgdGhlIGZpbGUgZGVzY3JpcHRvciBgZmRgLlxuICAgKiBAcGFyYW0gZmRcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL1xuICBwdWJsaWMgZnN0YXQoZmQ6IG51bWJlciwgY2I6IEJGU0NhbGxiYWNrPFN0YXRzPiA9IG5vcENiKTogdm9pZCB7XG4gICAgY29uc3QgbmV3Q2IgPSB3cmFwQ2IoY2IsIDIpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBmaWxlID0gdGhpcy5mZDJmaWxlKGZkKTtcbiAgICAgIGZpbGUuc3RhdChuZXdDYik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgbmV3Q2IoZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN5bmNocm9ub3VzIGBmc3RhdGAuXG4gICAqIGBmc3RhdCgpYCBpcyBpZGVudGljYWwgdG8gYHN0YXQoKWAsIGV4Y2VwdCB0aGF0IHRoZSBmaWxlIHRvIGJlIHN0YXQtZWQgaXNcbiAgICogc3BlY2lmaWVkIGJ5IHRoZSBmaWxlIGRlc2NyaXB0b3IgYGZkYC5cbiAgICogQHBhcmFtIGZkXG4gICAqIEByZXR1cm4gW0Jyb3dzZXJGUy5ub2RlLmZzLlN0YXRzXVxuICAgKi9cbiAgcHVibGljIGZzdGF0U3luYyhmZDogbnVtYmVyKTogU3RhdHMge1xuICAgIHJldHVybiB0aGlzLmZkMmZpbGUoZmQpLnN0YXRTeW5jKCk7XG4gIH1cblxuICAvKipcbiAgICogQXN5bmNocm9ub3VzIGNsb3NlLlxuICAgKiBAcGFyYW0gZmRcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL1xuICBwdWJsaWMgY2xvc2UoZmQ6IG51bWJlciwgY2I6IEJGU09uZUFyZ0NhbGxiYWNrID0gbm9wQ2IpOiB2b2lkIHtcbiAgICBjb25zdCBuZXdDYiA9IHdyYXBDYihjYiwgMSk7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuZmQyZmlsZShmZCkuY2xvc2UoKGU6IEFwaUVycm9yKSA9PiB7XG4gICAgICAgIGlmICghZSkge1xuICAgICAgICAgIHRoaXMuY2xvc2VGZChmZCk7XG4gICAgICAgIH1cbiAgICAgICAgbmV3Q2IoZSk7XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBuZXdDYihlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3luY2hyb25vdXMgY2xvc2UuXG4gICAqIEBwYXJhbSBmZFxuICAgKi9cbiAgcHVibGljIGNsb3NlU3luYyhmZDogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5mZDJmaWxlKGZkKS5jbG9zZVN5bmMoKTtcbiAgICB0aGlzLmNsb3NlRmQoZmQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFzeW5jaHJvbm91cyBmdHJ1bmNhdGUuXG4gICAqIEBwYXJhbSBmZFxuICAgKiBAcGFyYW0gbGVuXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKi9cbiAgcHVibGljIGZ0cnVuY2F0ZShmZDogbnVtYmVyLCBjYj86IEJGU09uZUFyZ0NhbGxiYWNrKTogdm9pZDtcbiAgcHVibGljIGZ0cnVuY2F0ZShmZDogbnVtYmVyLCBsZW4/OiBudW1iZXIsIGNiPzogQkZTT25lQXJnQ2FsbGJhY2spOiB2b2lkO1xuICBwdWJsaWMgZnRydW5jYXRlKGZkOiBudW1iZXIsIGFyZzI/OiBhbnksIGNiOiBCRlNPbmVBcmdDYWxsYmFjayA9IG5vcENiKTogdm9pZCB7XG4gICAgY29uc3QgbGVuZ3RoID0gdHlwZW9mIGFyZzIgPT09ICdudW1iZXInID8gYXJnMiA6IDA7XG4gICAgY2IgPSB0eXBlb2YgYXJnMiA9PT0gJ2Z1bmN0aW9uJyA/IGFyZzIgOiBjYjtcbiAgICBjb25zdCBuZXdDYiA9IHdyYXBDYihjYiwgMSk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGZpbGUgPSB0aGlzLmZkMmZpbGUoZmQpO1xuICAgICAgaWYgKGxlbmd0aCA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEFwaUVycm9yKEVycm9yQ29kZS5FSU5WQUwpO1xuICAgICAgfVxuICAgICAgZmlsZS50cnVuY2F0ZShsZW5ndGgsIG5ld0NiKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBuZXdDYihlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3luY2hyb25vdXMgZnRydW5jYXRlLlxuICAgKiBAcGFyYW0gZmRcbiAgICogQHBhcmFtIGxlblxuICAgKi9cbiAgcHVibGljIGZ0cnVuY2F0ZVN5bmMoZmQ6IG51bWJlciwgbGVuOiBudW1iZXIgPSAwKTogdm9pZCB7XG4gICAgY29uc3QgZmlsZSA9IHRoaXMuZmQyZmlsZShmZCk7XG4gICAgaWYgKGxlbiA8IDApIHtcbiAgICAgIHRocm93IG5ldyBBcGlFcnJvcihFcnJvckNvZGUuRUlOVkFMKTtcbiAgICB9XG4gICAgZmlsZS50cnVuY2F0ZVN5bmMobGVuKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBc3luY2hyb25vdXMgZnN5bmMuXG4gICAqIEBwYXJhbSBmZFxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIHB1YmxpYyBmc3luYyhmZDogbnVtYmVyLCBjYjogQkZTT25lQXJnQ2FsbGJhY2sgPSBub3BDYik6IHZvaWQge1xuICAgIGNvbnN0IG5ld0NiID0gd3JhcENiKGNiLCAxKTtcbiAgICB0cnkge1xuICAgICAgdGhpcy5mZDJmaWxlKGZkKS5zeW5jKG5ld0NiKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBuZXdDYihlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3luY2hyb25vdXMgZnN5bmMuXG4gICAqIEBwYXJhbSBmZFxuICAgKi9cbiAgcHVibGljIGZzeW5jU3luYyhmZDogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5mZDJmaWxlKGZkKS5zeW5jU3luYygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFzeW5jaHJvbm91cyBmZGF0YXN5bmMuXG4gICAqIEBwYXJhbSBmZFxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIHB1YmxpYyBmZGF0YXN5bmMoZmQ6IG51bWJlciwgY2I6IEJGU09uZUFyZ0NhbGxiYWNrID0gbm9wQ2IpOiB2b2lkIHtcbiAgICBjb25zdCBuZXdDYiA9IHdyYXBDYihjYiwgMSk7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuZmQyZmlsZShmZCkuZGF0YXN5bmMobmV3Q2IpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIG5ld0NiKGUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTeW5jaHJvbm91cyBmZGF0YXN5bmMuXG4gICAqIEBwYXJhbSBmZFxuICAgKi9cbiAgcHVibGljIGZkYXRhc3luY1N5bmMoZmQ6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMuZmQyZmlsZShmZCkuZGF0YXN5bmNTeW5jKCk7XG4gIH1cblxuICAvKipcbiAgICogV3JpdGUgYnVmZmVyIHRvIHRoZSBmaWxlIHNwZWNpZmllZCBieSBgZmRgLlxuICAgKiBOb3RlIHRoYXQgaXQgaXMgdW5zYWZlIHRvIHVzZSBmcy53cml0ZSBtdWx0aXBsZSB0aW1lcyBvbiB0aGUgc2FtZSBmaWxlXG4gICAqIHdpdGhvdXQgd2FpdGluZyBmb3IgdGhlIGNhbGxiYWNrLlxuICAgKiBAcGFyYW0gZmRcbiAgICogQHBhcmFtIGJ1ZmZlciBCdWZmZXIgY29udGFpbmluZyB0aGUgZGF0YSB0byB3cml0ZSB0b1xuICAgKiAgIHRoZSBmaWxlLlxuICAgKiBAcGFyYW0gb2Zmc2V0IE9mZnNldCBpbiB0aGUgYnVmZmVyIHRvIHN0YXJ0IHJlYWRpbmcgZGF0YSBmcm9tLlxuICAgKiBAcGFyYW0gbGVuZ3RoIFRoZSBhbW91bnQgb2YgYnl0ZXMgdG8gd3JpdGUgdG8gdGhlIGZpbGUuXG4gICAqIEBwYXJhbSBwb3NpdGlvbiBPZmZzZXQgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBmaWxlIHdoZXJlIHRoaXNcbiAgICogICBkYXRhIHNob3VsZCBiZSB3cml0dGVuLiBJZiBwb3NpdGlvbiBpcyBudWxsLCB0aGUgZGF0YSB3aWxsIGJlIHdyaXR0ZW4gYXRcbiAgICogICB0aGUgY3VycmVudCBwb3NpdGlvbi5cbiAgICogQHBhcmFtIGNhbGxiYWNrIFRoZSBudW1iZXIgc3BlY2lmaWVzIHRoZSBudW1iZXIgb2YgYnl0ZXMgd3JpdHRlbiBpbnRvIHRoZSBmaWxlLlxuICAgKi9cbiAgcHVibGljIHdyaXRlKGZkOiBudW1iZXIsIGJ1ZmZlcjogQnVmZmVyLCBvZmZzZXQ6IG51bWJlciwgbGVuZ3RoOiBudW1iZXIsIGNiPzogQkZTVGhyZWVBcmdDYWxsYmFjazxudW1iZXIsIEJ1ZmZlcj4pOiB2b2lkO1xuICBwdWJsaWMgd3JpdGUoZmQ6IG51bWJlciwgYnVmZmVyOiBCdWZmZXIsIG9mZnNldDogbnVtYmVyLCBsZW5ndGg6IG51bWJlciwgcG9zaXRpb246IG51bWJlciB8IG51bGwsIGNiPzogQkZTVGhyZWVBcmdDYWxsYmFjazxudW1iZXIsIEJ1ZmZlcj4pOiB2b2lkO1xuICBwdWJsaWMgd3JpdGUoZmQ6IG51bWJlciwgZGF0YTogYW55LCBjYj86IEJGU1RocmVlQXJnQ2FsbGJhY2s8bnVtYmVyLCBzdHJpbmc+KTogdm9pZDtcbiAgcHVibGljIHdyaXRlKGZkOiBudW1iZXIsIGRhdGE6IGFueSwgcG9zaXRpb246IG51bWJlciB8IG51bGwsIGNiPzogQkZTVGhyZWVBcmdDYWxsYmFjazxudW1iZXIsIHN0cmluZz4pOiB2b2lkO1xuICBwdWJsaWMgd3JpdGUoZmQ6IG51bWJlciwgZGF0YTogYW55LCBwb3NpdGlvbjogbnVtYmVyIHwgbnVsbCwgZW5jb2Rpbmc6IHN0cmluZywgY2I/OiBCRlNUaHJlZUFyZ0NhbGxiYWNrPG51bWJlciwgc3RyaW5nPik6IHZvaWQ7XG4gIHB1YmxpYyB3cml0ZShmZDogbnVtYmVyLCBhcmcyOiBhbnksIGFyZzM/OiBhbnksIGFyZzQ/OiBhbnksIGFyZzU/OiBhbnksIGNiOiBCRlNUaHJlZUFyZ0NhbGxiYWNrPG51bWJlciwgQnVmZmVyIHwgc3RyaW5nPiA9IG5vcENiKTogdm9pZCB7XG4gICAgbGV0IGJ1ZmZlcjogQnVmZmVyLCBvZmZzZXQ6IG51bWJlciwgbGVuZ3RoOiBudW1iZXIsIHBvc2l0aW9uOiBudW1iZXIgfCBudWxsID0gbnVsbDtcbiAgICBpZiAodHlwZW9mIGFyZzIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBTaWduYXR1cmUgMTogKGZkLCBzdHJpbmcsIFtwb3NpdGlvbj8sIFtlbmNvZGluZz9dXSwgY2I/KVxuICAgICAgbGV0IGVuY29kaW5nID0gJ3V0ZjgnO1xuICAgICAgc3dpdGNoICh0eXBlb2YgYXJnMykge1xuICAgICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgICAgLy8gKGZkLCBzdHJpbmcsIGNiKVxuICAgICAgICAgIGNiID0gYXJnMztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAvLyAoZmQsIHN0cmluZywgcG9zaXRpb24sIGVuY29kaW5nPywgY2I/KVxuICAgICAgICAgIHBvc2l0aW9uID0gYXJnMztcbiAgICAgICAgICBlbmNvZGluZyA9IHR5cGVvZiBhcmc0ID09PSAnc3RyaW5nJyA/IGFyZzQgOiAndXRmOCc7XG4gICAgICAgICAgY2IgPSB0eXBlb2YgYXJnNSA9PT0gJ2Z1bmN0aW9uJyA/IGFyZzUgOiBjYjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAvLyAuLi50cnkgdG8gZmluZCB0aGUgY2FsbGJhY2sgYW5kIGdldCBvdXQgb2YgaGVyZSFcbiAgICAgICAgICBjYiA9IHR5cGVvZiBhcmc0ID09PSAnZnVuY3Rpb24nID8gYXJnNCA6IHR5cGVvZiBhcmc1ID09PSAnZnVuY3Rpb24nID8gYXJnNSA6IGNiO1xuICAgICAgICAgIHJldHVybiBjYihuZXcgQXBpRXJyb3IoRXJyb3JDb2RlLkVJTlZBTCwgJ0ludmFsaWQgYXJndW1lbnRzLicpKTtcbiAgICAgIH1cbiAgICAgIGJ1ZmZlciA9IEJ1ZmZlci5mcm9tKGFyZzIsIGVuY29kaW5nKTtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgICBsZW5ndGggPSBidWZmZXIubGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTaWduYXR1cmUgMjogKGZkLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbj8sIGNiPylcbiAgICAgIGJ1ZmZlciA9IGFyZzI7XG4gICAgICBvZmZzZXQgPSBhcmczO1xuICAgICAgbGVuZ3RoID0gYXJnNDtcbiAgICAgIHBvc2l0aW9uID0gdHlwZW9mIGFyZzUgPT09ICdudW1iZXInID8gYXJnNSA6IG51bGw7XG4gICAgICBjYiA9IHR5cGVvZiBhcmc1ID09PSAnZnVuY3Rpb24nID8gYXJnNSA6IGNiO1xuICAgIH1cblxuICAgIGNvbnN0IG5ld0NiID0gd3JhcENiKGNiLCAzKTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZmlsZSA9IHRoaXMuZmQyZmlsZShmZCk7XG4gICAgICBpZiAocG9zaXRpb24gPT09IHVuZGVmaW5lZCB8fCBwb3NpdGlvbiA9PT0gbnVsbCkge1xuICAgICAgICBwb3NpdGlvbiA9IGZpbGUuZ2V0UG9zKCkhO1xuICAgICAgfVxuICAgICAgZmlsZS53cml0ZShidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbiwgbmV3Q2IpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIG5ld0NiKGUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBXcml0ZSBidWZmZXIgdG8gdGhlIGZpbGUgc3BlY2lmaWVkIGJ5IGBmZGAuXG4gICAqIE5vdGUgdGhhdCBpdCBpcyB1bnNhZmUgdG8gdXNlIGZzLndyaXRlIG11bHRpcGxlIHRpbWVzIG9uIHRoZSBzYW1lIGZpbGVcbiAgICogd2l0aG91dCB3YWl0aW5nIGZvciBpdCB0byByZXR1cm4uXG4gICAqIEBwYXJhbSBmZFxuICAgKiBAcGFyYW0gYnVmZmVyIEJ1ZmZlciBjb250YWluaW5nIHRoZSBkYXRhIHRvIHdyaXRlIHRvXG4gICAqICAgdGhlIGZpbGUuXG4gICAqIEBwYXJhbSBvZmZzZXQgT2Zmc2V0IGluIHRoZSBidWZmZXIgdG8gc3RhcnQgcmVhZGluZyBkYXRhIGZyb20uXG4gICAqIEBwYXJhbSBsZW5ndGggVGhlIGFtb3VudCBvZiBieXRlcyB0byB3cml0ZSB0byB0aGUgZmlsZS5cbiAgICogQHBhcmFtIHBvc2l0aW9uIE9mZnNldCBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGZpbGUgd2hlcmUgdGhpc1xuICAgKiAgIGRhdGEgc2hvdWxkIGJlIHdyaXR0ZW4uIElmIHBvc2l0aW9uIGlzIG51bGwsIHRoZSBkYXRhIHdpbGwgYmUgd3JpdHRlbiBhdFxuICAgKiAgIHRoZSBjdXJyZW50IHBvc2l0aW9uLlxuICAgKi9cbiAgcHVibGljIHdyaXRlU3luYyhmZDogbnVtYmVyLCBidWZmZXI6IEJ1ZmZlciwgb2Zmc2V0OiBudW1iZXIsIGxlbmd0aDogbnVtYmVyLCBwb3NpdGlvbj86IG51bWJlciB8IG51bGwpOiBudW1iZXI7XG4gIHB1YmxpYyB3cml0ZVN5bmMoZmQ6IG51bWJlciwgZGF0YTogc3RyaW5nLCBwb3NpdGlvbj86IG51bWJlciB8IG51bGwsIGVuY29kaW5nPzogc3RyaW5nKTogbnVtYmVyO1xuICBwdWJsaWMgd3JpdGVTeW5jKGZkOiBudW1iZXIsIGFyZzI6IGFueSwgYXJnMz86IGFueSwgYXJnND86IGFueSwgYXJnNT86IGFueSk6IG51bWJlciB7XG4gICAgbGV0IGJ1ZmZlcjogQnVmZmVyLCBvZmZzZXQ6IG51bWJlciA9IDAsIGxlbmd0aDogbnVtYmVyLCBwb3NpdGlvbjogbnVtYmVyIHwgbnVsbDtcbiAgICBpZiAodHlwZW9mIGFyZzIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBTaWduYXR1cmUgMTogKGZkLCBzdHJpbmcsIFtwb3NpdGlvbj8sIFtlbmNvZGluZz9dXSlcbiAgICAgIHBvc2l0aW9uID0gdHlwZW9mIGFyZzMgPT09ICdudW1iZXInID8gYXJnMyA6IG51bGw7XG4gICAgICBjb25zdCBlbmNvZGluZyA9IHR5cGVvZiBhcmc0ID09PSAnc3RyaW5nJyA/IGFyZzQgOiAndXRmOCc7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgICAgYnVmZmVyID0gQnVmZmVyLmZyb20oYXJnMiwgZW5jb2RpbmcpO1xuICAgICAgbGVuZ3RoID0gYnVmZmVyLmxlbmd0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU2lnbmF0dXJlIDI6IChmZCwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24/KVxuICAgICAgYnVmZmVyID0gYXJnMjtcbiAgICAgIG9mZnNldCA9IGFyZzM7XG4gICAgICBsZW5ndGggPSBhcmc0O1xuICAgICAgcG9zaXRpb24gPSB0eXBlb2YgYXJnNSA9PT0gJ251bWJlcicgPyBhcmc1IDogbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCBmaWxlID0gdGhpcy5mZDJmaWxlKGZkKTtcbiAgICBpZiAocG9zaXRpb24gPT09IHVuZGVmaW5lZCB8fCBwb3NpdGlvbiA9PT0gbnVsbCkge1xuICAgICAgcG9zaXRpb24gPSBmaWxlLmdldFBvcygpITtcbiAgICB9XG4gICAgcmV0dXJuIGZpbGUud3JpdGVTeW5jKGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkIGRhdGEgZnJvbSB0aGUgZmlsZSBzcGVjaWZpZWQgYnkgYGZkYC5cbiAgICogQHBhcmFtIGJ1ZmZlciBUaGUgYnVmZmVyIHRoYXQgdGhlIGRhdGEgd2lsbCBiZVxuICAgKiAgIHdyaXR0ZW4gdG8uXG4gICAqIEBwYXJhbSBvZmZzZXQgVGhlIG9mZnNldCB3aXRoaW4gdGhlIGJ1ZmZlciB3aGVyZSB3cml0aW5nIHdpbGxcbiAgICogICBzdGFydC5cbiAgICogQHBhcmFtIGxlbmd0aCBBbiBpbnRlZ2VyIHNwZWNpZnlpbmcgdGhlIG51bWJlciBvZiBieXRlcyB0byByZWFkLlxuICAgKiBAcGFyYW0gcG9zaXRpb24gQW4gaW50ZWdlciBzcGVjaWZ5aW5nIHdoZXJlIHRvIGJlZ2luIHJlYWRpbmcgZnJvbVxuICAgKiAgIGluIHRoZSBmaWxlLiBJZiBwb3NpdGlvbiBpcyBudWxsLCBkYXRhIHdpbGwgYmUgcmVhZCBmcm9tIHRoZSBjdXJyZW50IGZpbGVcbiAgICogICBwb3NpdGlvbi5cbiAgICogQHBhcmFtIGNhbGxiYWNrIFRoZSBudW1iZXIgaXMgdGhlIG51bWJlciBvZiBieXRlcyByZWFkXG4gICAqL1xuICBwdWJsaWMgcmVhZChmZDogbnVtYmVyLCBsZW5ndGg6IG51bWJlciwgcG9zaXRpb246IG51bWJlciB8IG51bGwsIGVuY29kaW5nOiBzdHJpbmcsIGNiPzogQkZTVGhyZWVBcmdDYWxsYmFjazxzdHJpbmcsIG51bWJlcj4pOiB2b2lkO1xuICBwdWJsaWMgcmVhZChmZDogbnVtYmVyLCBidWZmZXI6IEJ1ZmZlciwgb2Zmc2V0OiBudW1iZXIsIGxlbmd0aDogbnVtYmVyLCBwb3NpdGlvbjogbnVtYmVyIHwgbnVsbCwgY2I/OiBCRlNUaHJlZUFyZ0NhbGxiYWNrPG51bWJlciwgQnVmZmVyPik6IHZvaWQ7XG4gIHB1YmxpYyByZWFkKGZkOiBudW1iZXIsIGFyZzI6IGFueSwgYXJnMzogYW55LCBhcmc0OiBhbnksIGFyZzU/OiBhbnksIGNiOiBCRlNUaHJlZUFyZ0NhbGxiYWNrPHN0cmluZywgbnVtYmVyPiB8IEJGU1RocmVlQXJnQ2FsbGJhY2s8bnVtYmVyLCBCdWZmZXI+ID0gbm9wQ2IpOiB2b2lkIHtcbiAgICBsZXQgcG9zaXRpb246IG51bWJlciB8IG51bGwsIG9mZnNldDogbnVtYmVyLCBsZW5ndGg6IG51bWJlciwgYnVmZmVyOiBCdWZmZXIsIG5ld0NiOiBCRlNUaHJlZUFyZ0NhbGxiYWNrPG51bWJlciwgQnVmZmVyPjtcbiAgICBpZiAodHlwZW9mIGFyZzIgPT09ICdudW1iZXInKSB7XG4gICAgICAvLyBsZWdhY3kgaW50ZXJmYWNlXG4gICAgICAvLyAoZmQsIGxlbmd0aCwgcG9zaXRpb24sIGVuY29kaW5nLCBjYWxsYmFjaylcbiAgICAgIGxlbmd0aCA9IGFyZzI7XG4gICAgICBwb3NpdGlvbiA9IGFyZzM7XG4gICAgICBjb25zdCBlbmNvZGluZyA9IGFyZzQ7XG4gICAgICBjYiA9IHR5cGVvZiBhcmc1ID09PSAnZnVuY3Rpb24nID8gYXJnNSA6IGNiO1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYyhsZW5ndGgpO1xuICAgICAgLy8gWFhYOiBJbmVmZmljaWVudC5cbiAgICAgIC8vIFdyYXAgdGhlIGNiIHNvIHdlIHNoZWx0ZXIgdXBwZXIgbGF5ZXJzIG9mIHRoZSBBUEkgZnJvbSB0aGVzZVxuICAgICAgLy8gc2hlbmFuaWdhbnMuXG4gICAgICBuZXdDYiA9IHdyYXBDYigoZXJyPzogQXBpRXJyb3IgfCBudWxsLCBieXRlc1JlYWQ/OiBudW1iZXIsIGJ1Zj86IEJ1ZmZlcikgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgcmV0dXJuICg8RnVuY3Rpb24+IGNiKShlcnIpO1xuICAgICAgICB9XG4gICAgICAgICg8QkZTVGhyZWVBcmdDYWxsYmFjazxzdHJpbmcsIG51bWJlcj4+IGNiKShlcnIsIGJ1ZiEudG9TdHJpbmcoZW5jb2RpbmcpLCBieXRlc1JlYWQhKTtcbiAgICAgIH0sIDMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBidWZmZXIgPSBhcmcyO1xuICAgICAgb2Zmc2V0ID0gYXJnMztcbiAgICAgIGxlbmd0aCA9IGFyZzQ7XG4gICAgICBwb3NpdGlvbiA9IGFyZzU7XG4gICAgICBuZXdDYiA9IHdyYXBDYig8QkZTVGhyZWVBcmdDYWxsYmFjazxudW1iZXIsIEJ1ZmZlcj4+IGNiLCAzKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgZmlsZSA9IHRoaXMuZmQyZmlsZShmZCk7XG4gICAgICBpZiAocG9zaXRpb24gPT09IHVuZGVmaW5lZCB8fCBwb3NpdGlvbiA9PT0gbnVsbCkge1xuICAgICAgICBwb3NpdGlvbiA9IGZpbGUuZ2V0UG9zKCkhO1xuICAgICAgfVxuICAgICAgZmlsZS5yZWFkKGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uLCBuZXdDYik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgbmV3Q2IoZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlYWQgZGF0YSBmcm9tIHRoZSBmaWxlIHNwZWNpZmllZCBieSBgZmRgLlxuICAgKiBAcGFyYW0gZmRcbiAgICogQHBhcmFtIGJ1ZmZlciBUaGUgYnVmZmVyIHRoYXQgdGhlIGRhdGEgd2lsbCBiZVxuICAgKiAgIHdyaXR0ZW4gdG8uXG4gICAqIEBwYXJhbSBvZmZzZXQgVGhlIG9mZnNldCB3aXRoaW4gdGhlIGJ1ZmZlciB3aGVyZSB3cml0aW5nIHdpbGxcbiAgICogICBzdGFydC5cbiAgICogQHBhcmFtIGxlbmd0aCBBbiBpbnRlZ2VyIHNwZWNpZnlpbmcgdGhlIG51bWJlciBvZiBieXRlcyB0byByZWFkLlxuICAgKiBAcGFyYW0gcG9zaXRpb24gQW4gaW50ZWdlciBzcGVjaWZ5aW5nIHdoZXJlIHRvIGJlZ2luIHJlYWRpbmcgZnJvbVxuICAgKiAgIGluIHRoZSBmaWxlLiBJZiBwb3NpdGlvbiBpcyBudWxsLCBkYXRhIHdpbGwgYmUgcmVhZCBmcm9tIHRoZSBjdXJyZW50IGZpbGVcbiAgICogICBwb3NpdGlvbi5cbiAgICogQHJldHVybiBbTnVtYmVyXVxuICAgKi9cbiAgcHVibGljIHJlYWRTeW5jKGZkOiBudW1iZXIsIGxlbmd0aDogbnVtYmVyLCBwb3NpdGlvbjogbnVtYmVyLCBlbmNvZGluZzogc3RyaW5nKTogc3RyaW5nO1xuICBwdWJsaWMgcmVhZFN5bmMoZmQ6IG51bWJlciwgYnVmZmVyOiBCdWZmZXIsIG9mZnNldDogbnVtYmVyLCBsZW5ndGg6IG51bWJlciwgcG9zaXRpb246IG51bWJlcik6IG51bWJlcjtcbiAgcHVibGljIHJlYWRTeW5jKGZkOiBudW1iZXIsIGFyZzI6IGFueSwgYXJnMzogYW55LCBhcmc0OiBhbnksIGFyZzU/OiBhbnkpOiBhbnkge1xuICAgIGxldCBzaGVuYW5pZ2FucyA9IGZhbHNlO1xuICAgIGxldCBidWZmZXI6IEJ1ZmZlciwgb2Zmc2V0OiBudW1iZXIsIGxlbmd0aDogbnVtYmVyLCBwb3NpdGlvbjogbnVtYmVyLCBlbmNvZGluZzogc3RyaW5nID0gJ3V0ZjgnO1xuICAgIGlmICh0eXBlb2YgYXJnMiA9PT0gJ251bWJlcicpIHtcbiAgICAgIGxlbmd0aCA9IGFyZzI7XG4gICAgICBwb3NpdGlvbiA9IGFyZzM7XG4gICAgICBlbmNvZGluZyA9IGFyZzQ7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgICAgYnVmZmVyID0gQnVmZmVyLmFsbG9jKGxlbmd0aCk7XG4gICAgICBzaGVuYW5pZ2FucyA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1ZmZlciA9IGFyZzI7XG4gICAgICBvZmZzZXQgPSBhcmczO1xuICAgICAgbGVuZ3RoID0gYXJnNDtcbiAgICAgIHBvc2l0aW9uID0gYXJnNTtcbiAgICB9XG4gICAgY29uc3QgZmlsZSA9IHRoaXMuZmQyZmlsZShmZCk7XG4gICAgaWYgKHBvc2l0aW9uID09PSB1bmRlZmluZWQgfHwgcG9zaXRpb24gPT09IG51bGwpIHtcbiAgICAgIHBvc2l0aW9uID0gZmlsZS5nZXRQb3MoKSE7XG4gICAgfVxuXG4gICAgY29uc3QgcnYgPSBmaWxlLnJlYWRTeW5jKGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uKTtcbiAgICBpZiAoIXNoZW5hbmlnYW5zKSB7XG4gICAgICByZXR1cm4gcnY7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBbYnVmZmVyLnRvU3RyaW5nKGVuY29kaW5nKSwgcnZdO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBc3luY2hyb25vdXMgYGZjaG93bmAuXG4gICAqIEBwYXJhbSBmZFxuICAgKiBAcGFyYW0gdWlkXG4gICAqIEBwYXJhbSBnaWRcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL1xuICBwdWJsaWMgZmNob3duKGZkOiBudW1iZXIsIHVpZDogbnVtYmVyLCBnaWQ6IG51bWJlciwgY2FsbGJhY2s6IEJGU09uZUFyZ0NhbGxiYWNrID0gbm9wQ2IpOiB2b2lkIHtcbiAgICBjb25zdCBuZXdDYiA9IHdyYXBDYihjYWxsYmFjaywgMSk7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuZmQyZmlsZShmZCkuY2hvd24odWlkLCBnaWQsIG5ld0NiKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBuZXdDYihlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3luY2hyb25vdXMgYGZjaG93bmAuXG4gICAqIEBwYXJhbSBmZFxuICAgKiBAcGFyYW0gdWlkXG4gICAqIEBwYXJhbSBnaWRcbiAgICovXG4gIHB1YmxpYyBmY2hvd25TeW5jKGZkOiBudW1iZXIsIHVpZDogbnVtYmVyLCBnaWQ6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMuZmQyZmlsZShmZCkuY2hvd25TeW5jKHVpZCwgZ2lkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBc3luY2hyb25vdXMgYGZjaG1vZGAuXG4gICAqIEBwYXJhbSBmZFxuICAgKiBAcGFyYW0gbW9kZVxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIHB1YmxpYyBmY2htb2QoZmQ6IG51bWJlciwgbW9kZTogc3RyaW5nIHwgbnVtYmVyLCBjYjogQkZTT25lQXJnQ2FsbGJhY2spOiB2b2lkIHtcbiAgICBjb25zdCBuZXdDYiA9IHdyYXBDYihjYiwgMSk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IG51bU1vZGUgPSB0eXBlb2YgbW9kZSA9PT0gJ3N0cmluZycgPyBwYXJzZUludChtb2RlLCA4KSA6IG1vZGU7XG4gICAgICB0aGlzLmZkMmZpbGUoZmQpLmNobW9kKG51bU1vZGUsIG5ld0NiKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBuZXdDYihlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3luY2hyb25vdXMgYGZjaG1vZGAuXG4gICAqIEBwYXJhbSBmZFxuICAgKiBAcGFyYW0gbW9kZVxuICAgKi9cbiAgcHVibGljIGZjaG1vZFN5bmMoZmQ6IG51bWJlciwgbW9kZTogbnVtYmVyIHwgc3RyaW5nKTogdm9pZCB7XG4gICAgY29uc3QgbnVtTW9kZSA9IHR5cGVvZiBtb2RlID09PSAnc3RyaW5nJyA/IHBhcnNlSW50KG1vZGUsIDgpIDogbW9kZTtcbiAgICB0aGlzLmZkMmZpbGUoZmQpLmNobW9kU3luYyhudW1Nb2RlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGFuZ2UgdGhlIGZpbGUgdGltZXN0YW1wcyBvZiBhIGZpbGUgcmVmZXJlbmNlZCBieSB0aGUgc3VwcGxpZWQgZmlsZVxuICAgKiBkZXNjcmlwdG9yLlxuICAgKiBAcGFyYW0gZmRcbiAgICogQHBhcmFtIGF0aW1lXG4gICAqIEBwYXJhbSBtdGltZVxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIHB1YmxpYyBmdXRpbWVzKGZkOiBudW1iZXIsIGF0aW1lOiBudW1iZXIgfCBEYXRlLCBtdGltZTogbnVtYmVyIHwgRGF0ZSwgY2I6IEJGU09uZUFyZ0NhbGxiYWNrID0gbm9wQ2IpOiB2b2lkIHtcbiAgICBjb25zdCBuZXdDYiA9IHdyYXBDYihjYiwgMSk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGZpbGUgPSB0aGlzLmZkMmZpbGUoZmQpO1xuICAgICAgaWYgKHR5cGVvZiBhdGltZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgYXRpbWUgPSBuZXcgRGF0ZShhdGltZSAqIDEwMDApO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBtdGltZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgbXRpbWUgPSBuZXcgRGF0ZShtdGltZSAqIDEwMDApO1xuICAgICAgfVxuICAgICAgZmlsZS51dGltZXMoYXRpbWUsIG10aW1lLCBuZXdDYik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgbmV3Q2IoZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENoYW5nZSB0aGUgZmlsZSB0aW1lc3RhbXBzIG9mIGEgZmlsZSByZWZlcmVuY2VkIGJ5IHRoZSBzdXBwbGllZCBmaWxlXG4gICAqIGRlc2NyaXB0b3IuXG4gICAqIEBwYXJhbSBmZFxuICAgKiBAcGFyYW0gYXRpbWVcbiAgICogQHBhcmFtIG10aW1lXG4gICAqL1xuICBwdWJsaWMgZnV0aW1lc1N5bmMoZmQ6IG51bWJlciwgYXRpbWU6IG51bWJlciB8IERhdGUsIG10aW1lOiBudW1iZXIgfCBEYXRlKTogdm9pZCB7XG4gICAgdGhpcy5mZDJmaWxlKGZkKS51dGltZXNTeW5jKG5vcm1hbGl6ZVRpbWUoYXRpbWUpLCBub3JtYWxpemVUaW1lKG10aW1lKSk7XG4gIH1cblxuICAvLyBESVJFQ1RPUlktT05MWSBNRVRIT0RTXG5cbiAgLyoqXG4gICAqIEFzeW5jaHJvbm91cyBgcm1kaXJgLlxuICAgKiBAcGFyYW0gcGF0aFxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIHB1YmxpYyBybWRpcihwYXRoOiBzdHJpbmcsIGNiOiBCRlNPbmVBcmdDYWxsYmFjayA9IG5vcENiKTogdm9pZCB7XG4gICAgY29uc3QgbmV3Q2IgPSB3cmFwQ2IoY2IsIDEpO1xuICAgIHRyeSB7XG4gICAgICBwYXRoID0gbm9ybWFsaXplUGF0aChwYXRoKTtcbiAgICAgIGFzc2VydFJvb3QodGhpcy5yb290KS5ybWRpcihwYXRoLCBuZXdDYik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgbmV3Q2IoZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN5bmNocm9ub3VzIGBybWRpcmAuXG4gICAqIEBwYXJhbSBwYXRoXG4gICAqL1xuICBwdWJsaWMgcm1kaXJTeW5jKHBhdGg6IHN0cmluZyk6IHZvaWQge1xuICAgIHBhdGggPSBub3JtYWxpemVQYXRoKHBhdGgpO1xuICAgIHJldHVybiBhc3NlcnRSb290KHRoaXMucm9vdCkucm1kaXJTeW5jKHBhdGgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFzeW5jaHJvbm91cyBgbWtkaXJgLlxuICAgKiBAcGFyYW0gcGF0aFxuICAgKiBAcGFyYW0gbW9kZSBkZWZhdWx0cyB0byBgMDc3N2BcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL1xuICBwdWJsaWMgbWtkaXIocGF0aDogc3RyaW5nLCBtb2RlPzogYW55LCBjYjogQkZTT25lQXJnQ2FsbGJhY2sgPSBub3BDYik6IHZvaWQge1xuICAgIGlmICh0eXBlb2YgbW9kZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2IgPSBtb2RlO1xuICAgICAgbW9kZSA9IDB4MWZmO1xuICAgIH1cbiAgICBjb25zdCBuZXdDYiA9IHdyYXBDYihjYiwgMSk7XG4gICAgdHJ5IHtcbiAgICAgIHBhdGggPSBub3JtYWxpemVQYXRoKHBhdGgpO1xuICAgICAgYXNzZXJ0Um9vdCh0aGlzLnJvb3QpLm1rZGlyKHBhdGgsIG1vZGUsIG5ld0NiKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBuZXdDYihlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3luY2hyb25vdXMgYG1rZGlyYC5cbiAgICogQHBhcmFtIHBhdGhcbiAgICogQHBhcmFtIG1vZGUgZGVmYXVsdHMgdG8gYDA3NzdgXG4gICAqL1xuICBwdWJsaWMgbWtkaXJTeW5jKHBhdGg6IHN0cmluZywgbW9kZT86IG51bWJlciB8IHN0cmluZyk6IHZvaWQge1xuICAgIGFzc2VydFJvb3QodGhpcy5yb290KS5ta2RpclN5bmMobm9ybWFsaXplUGF0aChwYXRoKSwgbm9ybWFsaXplTW9kZShtb2RlLCAweDFmZikpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFzeW5jaHJvbm91cyBgcmVhZGRpcmAuIFJlYWRzIHRoZSBjb250ZW50cyBvZiBhIGRpcmVjdG9yeS5cbiAgICogVGhlIGNhbGxiYWNrIGdldHMgdHdvIGFyZ3VtZW50cyBgKGVyciwgZmlsZXMpYCB3aGVyZSBgZmlsZXNgIGlzIGFuIGFycmF5IG9mXG4gICAqIHRoZSBuYW1lcyBvZiB0aGUgZmlsZXMgaW4gdGhlIGRpcmVjdG9yeSBleGNsdWRpbmcgYCcuJ2AgYW5kIGAnLi4nYC5cbiAgICogQHBhcmFtIHBhdGhcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL1xuICBwdWJsaWMgcmVhZGRpcihwYXRoOiBzdHJpbmcsIGNiOiBCRlNDYWxsYmFjazxzdHJpbmdbXT4gPSBub3BDYik6IHZvaWQge1xuICAgIGNvbnN0IG5ld0NiID0gPChlcnI6IEFwaUVycm9yLCBmaWxlcz86IHN0cmluZ1tdKSA9PiB2b2lkPiB3cmFwQ2IoY2IsIDIpO1xuICAgIHRyeSB7XG4gICAgICBwYXRoID0gbm9ybWFsaXplUGF0aChwYXRoKTtcbiAgICAgIGFzc2VydFJvb3QodGhpcy5yb290KS5yZWFkZGlyKHBhdGgsIG5ld0NiKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBuZXdDYihlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3luY2hyb25vdXMgYHJlYWRkaXJgLiBSZWFkcyB0aGUgY29udGVudHMgb2YgYSBkaXJlY3RvcnkuXG4gICAqIEBwYXJhbSBwYXRoXG4gICAqIEByZXR1cm4gW1N0cmluZ1tdXVxuICAgKi9cbiAgcHVibGljIHJlYWRkaXJTeW5jKHBhdGg6IHN0cmluZyk6IHN0cmluZ1tdIHtcbiAgICBwYXRoID0gbm9ybWFsaXplUGF0aChwYXRoKTtcbiAgICByZXR1cm4gYXNzZXJ0Um9vdCh0aGlzLnJvb3QpLnJlYWRkaXJTeW5jKHBhdGgpO1xuICB9XG5cbiAgLy8gU1lNTElOSyBNRVRIT0RTXG5cbiAgLyoqXG4gICAqIEFzeW5jaHJvbm91cyBgbGlua2AuXG4gICAqIEBwYXJhbSBzcmNwYXRoXG4gICAqIEBwYXJhbSBkc3RwYXRoXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKi9cbiAgcHVibGljIGxpbmsoc3JjcGF0aDogc3RyaW5nLCBkc3RwYXRoOiBzdHJpbmcsIGNiOiBCRlNPbmVBcmdDYWxsYmFjayA9IG5vcENiKTogdm9pZCB7XG4gICAgY29uc3QgbmV3Q2IgPSB3cmFwQ2IoY2IsIDEpO1xuICAgIHRyeSB7XG4gICAgICBzcmNwYXRoID0gbm9ybWFsaXplUGF0aChzcmNwYXRoKTtcbiAgICAgIGRzdHBhdGggPSBub3JtYWxpemVQYXRoKGRzdHBhdGgpO1xuICAgICAgYXNzZXJ0Um9vdCh0aGlzLnJvb3QpLmxpbmsoc3JjcGF0aCwgZHN0cGF0aCwgbmV3Q2IpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIG5ld0NiKGUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTeW5jaHJvbm91cyBgbGlua2AuXG4gICAqIEBwYXJhbSBzcmNwYXRoXG4gICAqIEBwYXJhbSBkc3RwYXRoXG4gICAqL1xuICBwdWJsaWMgbGlua1N5bmMoc3JjcGF0aDogc3RyaW5nLCBkc3RwYXRoOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBzcmNwYXRoID0gbm9ybWFsaXplUGF0aChzcmNwYXRoKTtcbiAgICBkc3RwYXRoID0gbm9ybWFsaXplUGF0aChkc3RwYXRoKTtcbiAgICByZXR1cm4gYXNzZXJ0Um9vdCh0aGlzLnJvb3QpLmxpbmtTeW5jKHNyY3BhdGgsIGRzdHBhdGgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFzeW5jaHJvbm91cyBgc3ltbGlua2AuXG4gICAqIEBwYXJhbSBzcmNwYXRoXG4gICAqIEBwYXJhbSBkc3RwYXRoXG4gICAqIEBwYXJhbSB0eXBlIGNhbiBiZSBlaXRoZXIgYCdkaXInYCBvciBgJ2ZpbGUnYCAoZGVmYXVsdCBpcyBgJ2ZpbGUnYClcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL1xuICBwdWJsaWMgc3ltbGluayhzcmNwYXRoOiBzdHJpbmcsIGRzdHBhdGg6IHN0cmluZywgY2I/OiBCRlNPbmVBcmdDYWxsYmFjayk6IHZvaWQ7XG4gIHB1YmxpYyBzeW1saW5rKHNyY3BhdGg6IHN0cmluZywgZHN0cGF0aDogc3RyaW5nLCB0eXBlPzogc3RyaW5nLCBjYj86IEJGU09uZUFyZ0NhbGxiYWNrKTogdm9pZDtcbiAgcHVibGljIHN5bWxpbmsoc3JjcGF0aDogc3RyaW5nLCBkc3RwYXRoOiBzdHJpbmcsIGFyZzM/OiBhbnksIGNiOiBCRlNPbmVBcmdDYWxsYmFjayA9IG5vcENiKTogdm9pZCB7XG4gICAgY29uc3QgdHlwZSA9IHR5cGVvZiBhcmczID09PSAnc3RyaW5nJyA/IGFyZzMgOiAnZmlsZSc7XG4gICAgY2IgPSB0eXBlb2YgYXJnMyA9PT0gJ2Z1bmN0aW9uJyA/IGFyZzMgOiBjYjtcbiAgICBjb25zdCBuZXdDYiA9IHdyYXBDYihjYiwgMSk7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0eXBlICE9PSAnZmlsZScgJiYgdHlwZSAhPT0gJ2RpcicpIHtcbiAgICAgICAgcmV0dXJuIG5ld0NiKG5ldyBBcGlFcnJvcihFcnJvckNvZGUuRUlOVkFMLCBcIkludmFsaWQgdHlwZTogXCIgKyB0eXBlKSk7XG4gICAgICB9XG4gICAgICBzcmNwYXRoID0gbm9ybWFsaXplUGF0aChzcmNwYXRoKTtcbiAgICAgIGRzdHBhdGggPSBub3JtYWxpemVQYXRoKGRzdHBhdGgpO1xuICAgICAgYXNzZXJ0Um9vdCh0aGlzLnJvb3QpLnN5bWxpbmsoc3JjcGF0aCwgZHN0cGF0aCwgdHlwZSwgbmV3Q2IpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIG5ld0NiKGUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTeW5jaHJvbm91cyBgc3ltbGlua2AuXG4gICAqIEBwYXJhbSBzcmNwYXRoXG4gICAqIEBwYXJhbSBkc3RwYXRoXG4gICAqIEBwYXJhbSB0eXBlIGNhbiBiZSBlaXRoZXIgYCdkaXInYCBvciBgJ2ZpbGUnYCAoZGVmYXVsdCBpcyBgJ2ZpbGUnYClcbiAgICovXG4gIHB1YmxpYyBzeW1saW5rU3luYyhzcmNwYXRoOiBzdHJpbmcsIGRzdHBhdGg6IHN0cmluZywgdHlwZT86IHN0cmluZyk6IHZvaWQge1xuICAgIGlmICghdHlwZSkge1xuICAgICAgdHlwZSA9ICdmaWxlJztcbiAgICB9IGVsc2UgaWYgKHR5cGUgIT09ICdmaWxlJyAmJiB0eXBlICE9PSAnZGlyJykge1xuICAgICAgdGhyb3cgbmV3IEFwaUVycm9yKEVycm9yQ29kZS5FSU5WQUwsIFwiSW52YWxpZCB0eXBlOiBcIiArIHR5cGUpO1xuICAgIH1cbiAgICBzcmNwYXRoID0gbm9ybWFsaXplUGF0aChzcmNwYXRoKTtcbiAgICBkc3RwYXRoID0gbm9ybWFsaXplUGF0aChkc3RwYXRoKTtcbiAgICByZXR1cm4gYXNzZXJ0Um9vdCh0aGlzLnJvb3QpLnN5bWxpbmtTeW5jKHNyY3BhdGgsIGRzdHBhdGgsIHR5cGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFzeW5jaHJvbm91cyByZWFkbGluay5cbiAgICogQHBhcmFtIHBhdGhcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL1xuICBwdWJsaWMgcmVhZGxpbmsocGF0aDogc3RyaW5nLCBjYjogQkZTQ2FsbGJhY2s8c3RyaW5nPiA9IG5vcENiKTogdm9pZCB7XG4gICAgY29uc3QgbmV3Q2IgPSB3cmFwQ2IoY2IsIDIpO1xuICAgIHRyeSB7XG4gICAgICBwYXRoID0gbm9ybWFsaXplUGF0aChwYXRoKTtcbiAgICAgIGFzc2VydFJvb3QodGhpcy5yb290KS5yZWFkbGluayhwYXRoLCBuZXdDYik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgbmV3Q2IoZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN5bmNocm9ub3VzIHJlYWRsaW5rLlxuICAgKiBAcGFyYW0gcGF0aFxuICAgKiBAcmV0dXJuIFtTdHJpbmddXG4gICAqL1xuICBwdWJsaWMgcmVhZGxpbmtTeW5jKHBhdGg6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcGF0aCA9IG5vcm1hbGl6ZVBhdGgocGF0aCk7XG4gICAgcmV0dXJuIGFzc2VydFJvb3QodGhpcy5yb290KS5yZWFkbGlua1N5bmMocGF0aCk7XG4gIH1cblxuICAvLyBQUk9QRVJUWSBPUEVSQVRJT05TXG5cbiAgLyoqXG4gICAqIEFzeW5jaHJvbm91cyBgY2hvd25gLlxuICAgKiBAcGFyYW0gcGF0aFxuICAgKiBAcGFyYW0gdWlkXG4gICAqIEBwYXJhbSBnaWRcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL1xuICBwdWJsaWMgY2hvd24ocGF0aDogc3RyaW5nLCB1aWQ6IG51bWJlciwgZ2lkOiBudW1iZXIsIGNiOiBCRlNPbmVBcmdDYWxsYmFjayA9IG5vcENiKTogdm9pZCB7XG4gICAgY29uc3QgbmV3Q2IgPSB3cmFwQ2IoY2IsIDEpO1xuICAgIHRyeSB7XG4gICAgICBwYXRoID0gbm9ybWFsaXplUGF0aChwYXRoKTtcbiAgICAgIGFzc2VydFJvb3QodGhpcy5yb290KS5jaG93bihwYXRoLCBmYWxzZSwgdWlkLCBnaWQsIG5ld0NiKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBuZXdDYihlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3luY2hyb25vdXMgYGNob3duYC5cbiAgICogQHBhcmFtIHBhdGhcbiAgICogQHBhcmFtIHVpZFxuICAgKiBAcGFyYW0gZ2lkXG4gICAqL1xuICBwdWJsaWMgY2hvd25TeW5jKHBhdGg6IHN0cmluZywgdWlkOiBudW1iZXIsIGdpZDogbnVtYmVyKTogdm9pZCB7XG4gICAgcGF0aCA9IG5vcm1hbGl6ZVBhdGgocGF0aCk7XG4gICAgYXNzZXJ0Um9vdCh0aGlzLnJvb3QpLmNob3duU3luYyhwYXRoLCBmYWxzZSwgdWlkLCBnaWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFzeW5jaHJvbm91cyBgbGNob3duYC5cbiAgICogQHBhcmFtIHBhdGhcbiAgICogQHBhcmFtIHVpZFxuICAgKiBAcGFyYW0gZ2lkXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKi9cbiAgcHVibGljIGxjaG93bihwYXRoOiBzdHJpbmcsIHVpZDogbnVtYmVyLCBnaWQ6IG51bWJlciwgY2I6IEJGU09uZUFyZ0NhbGxiYWNrID0gbm9wQ2IpOiB2b2lkIHtcbiAgICBjb25zdCBuZXdDYiA9IHdyYXBDYihjYiwgMSk7XG4gICAgdHJ5IHtcbiAgICAgIHBhdGggPSBub3JtYWxpemVQYXRoKHBhdGgpO1xuICAgICAgYXNzZXJ0Um9vdCh0aGlzLnJvb3QpLmNob3duKHBhdGgsIHRydWUsIHVpZCwgZ2lkLCBuZXdDYik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgbmV3Q2IoZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN5bmNocm9ub3VzIGBsY2hvd25gLlxuICAgKiBAcGFyYW0gcGF0aFxuICAgKiBAcGFyYW0gdWlkXG4gICAqIEBwYXJhbSBnaWRcbiAgICovXG4gIHB1YmxpYyBsY2hvd25TeW5jKHBhdGg6IHN0cmluZywgdWlkOiBudW1iZXIsIGdpZDogbnVtYmVyKTogdm9pZCB7XG4gICAgcGF0aCA9IG5vcm1hbGl6ZVBhdGgocGF0aCk7XG4gICAgYXNzZXJ0Um9vdCh0aGlzLnJvb3QpLmNob3duU3luYyhwYXRoLCB0cnVlLCB1aWQsIGdpZCk7XG4gIH1cblxuICAvKipcbiAgICogQXN5bmNocm9ub3VzIGBjaG1vZGAuXG4gICAqIEBwYXJhbSBwYXRoXG4gICAqIEBwYXJhbSBtb2RlXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKi9cbiAgcHVibGljIGNobW9kKHBhdGg6IHN0cmluZywgbW9kZTogbnVtYmVyIHwgc3RyaW5nLCBjYjogQkZTT25lQXJnQ2FsbGJhY2sgPSBub3BDYik6IHZvaWQge1xuICAgIGNvbnN0IG5ld0NiID0gd3JhcENiKGNiLCAxKTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgbnVtTW9kZSA9IG5vcm1hbGl6ZU1vZGUobW9kZSwgLTEpO1xuICAgICAgaWYgKG51bU1vZGUgPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBBcGlFcnJvcihFcnJvckNvZGUuRUlOVkFMLCBgSW52YWxpZCBtb2RlLmApO1xuICAgICAgfVxuICAgICAgYXNzZXJ0Um9vdCh0aGlzLnJvb3QpLmNobW9kKG5vcm1hbGl6ZVBhdGgocGF0aCksIGZhbHNlLCBudW1Nb2RlLCBuZXdDYik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgbmV3Q2IoZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN5bmNocm9ub3VzIGBjaG1vZGAuXG4gICAqIEBwYXJhbSBwYXRoXG4gICAqIEBwYXJhbSBtb2RlXG4gICAqL1xuICBwdWJsaWMgY2htb2RTeW5jKHBhdGg6IHN0cmluZywgbW9kZTogc3RyaW5nIHwgbnVtYmVyKTogdm9pZCB7XG4gICAgY29uc3QgbnVtTW9kZSA9IG5vcm1hbGl6ZU1vZGUobW9kZSwgLTEpO1xuICAgIGlmIChudW1Nb2RlIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEFwaUVycm9yKEVycm9yQ29kZS5FSU5WQUwsIGBJbnZhbGlkIG1vZGUuYCk7XG4gICAgfVxuICAgIHBhdGggPSBub3JtYWxpemVQYXRoKHBhdGgpO1xuICAgIGFzc2VydFJvb3QodGhpcy5yb290KS5jaG1vZFN5bmMocGF0aCwgZmFsc2UsIG51bU1vZGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFzeW5jaHJvbm91cyBgbGNobW9kYC5cbiAgICogQHBhcmFtIHBhdGhcbiAgICogQHBhcmFtIG1vZGVcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL1xuICBwdWJsaWMgbGNobW9kKHBhdGg6IHN0cmluZywgbW9kZTogbnVtYmVyIHwgc3RyaW5nLCBjYjogQkZTT25lQXJnQ2FsbGJhY2sgPSBub3BDYik6IHZvaWQge1xuICAgIGNvbnN0IG5ld0NiID0gd3JhcENiKGNiLCAxKTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgbnVtTW9kZSA9IG5vcm1hbGl6ZU1vZGUobW9kZSwgLTEpO1xuICAgICAgaWYgKG51bU1vZGUgPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBBcGlFcnJvcihFcnJvckNvZGUuRUlOVkFMLCBgSW52YWxpZCBtb2RlLmApO1xuICAgICAgfVxuICAgICAgYXNzZXJ0Um9vdCh0aGlzLnJvb3QpLmNobW9kKG5vcm1hbGl6ZVBhdGgocGF0aCksIHRydWUsIG51bU1vZGUsIG5ld0NiKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBuZXdDYihlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3luY2hyb25vdXMgYGxjaG1vZGAuXG4gICAqIEBwYXJhbSBwYXRoXG4gICAqIEBwYXJhbSBtb2RlXG4gICAqL1xuICBwdWJsaWMgbGNobW9kU3luYyhwYXRoOiBzdHJpbmcsIG1vZGU6IG51bWJlciB8IHN0cmluZyk6IHZvaWQge1xuICAgIGNvbnN0IG51bU1vZGUgPSBub3JtYWxpemVNb2RlKG1vZGUsIC0xKTtcbiAgICBpZiAobnVtTW9kZSA8IDEpIHtcbiAgICAgIHRocm93IG5ldyBBcGlFcnJvcihFcnJvckNvZGUuRUlOVkFMLCBgSW52YWxpZCBtb2RlLmApO1xuICAgIH1cbiAgICBhc3NlcnRSb290KHRoaXMucm9vdCkuY2htb2RTeW5jKG5vcm1hbGl6ZVBhdGgocGF0aCksIHRydWUsIG51bU1vZGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoYW5nZSBmaWxlIHRpbWVzdGFtcHMgb2YgdGhlIGZpbGUgcmVmZXJlbmNlZCBieSB0aGUgc3VwcGxpZWQgcGF0aC5cbiAgICogQHBhcmFtIHBhdGhcbiAgICogQHBhcmFtIGF0aW1lXG4gICAqIEBwYXJhbSBtdGltZVxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIHB1YmxpYyB1dGltZXMocGF0aDogc3RyaW5nLCBhdGltZTogbnVtYmVyIHwgRGF0ZSwgbXRpbWU6IG51bWJlciB8IERhdGUsIGNiOiBCRlNPbmVBcmdDYWxsYmFjayA9IG5vcENiKTogdm9pZCB7XG4gICAgY29uc3QgbmV3Q2IgPSB3cmFwQ2IoY2IsIDEpO1xuICAgIHRyeSB7XG4gICAgICBhc3NlcnRSb290KHRoaXMucm9vdCkudXRpbWVzKG5vcm1hbGl6ZVBhdGgocGF0aCksIG5vcm1hbGl6ZVRpbWUoYXRpbWUpLCBub3JtYWxpemVUaW1lKG10aW1lKSwgbmV3Q2IpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIG5ld0NiKGUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDaGFuZ2UgZmlsZSB0aW1lc3RhbXBzIG9mIHRoZSBmaWxlIHJlZmVyZW5jZWQgYnkgdGhlIHN1cHBsaWVkIHBhdGguXG4gICAqIEBwYXJhbSBwYXRoXG4gICAqIEBwYXJhbSBhdGltZVxuICAgKiBAcGFyYW0gbXRpbWVcbiAgICovXG4gIHB1YmxpYyB1dGltZXNTeW5jKHBhdGg6IHN0cmluZywgYXRpbWU6IG51bWJlciB8IERhdGUsIG10aW1lOiBudW1iZXIgfCBEYXRlKTogdm9pZCB7XG4gICAgYXNzZXJ0Um9vdCh0aGlzLnJvb3QpLnV0aW1lc1N5bmMobm9ybWFsaXplUGF0aChwYXRoKSwgbm9ybWFsaXplVGltZShhdGltZSksIG5vcm1hbGl6ZVRpbWUobXRpbWUpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBc3luY2hyb25vdXMgYHJlYWxwYXRoYC4gVGhlIGNhbGxiYWNrIGdldHMgdHdvIGFyZ3VtZW50c1xuICAgKiBgKGVyciwgcmVzb2x2ZWRQYXRoKWAuIE1heSB1c2UgYHByb2Nlc3MuY3dkYCB0byByZXNvbHZlIHJlbGF0aXZlIHBhdGhzLlxuICAgKlxuICAgKiBAZXhhbXBsZSBVc2FnZSBleGFtcGxlXG4gICAqICAgbGV0IGNhY2hlID0geycvZXRjJzonL3ByaXZhdGUvZXRjJ307XG4gICAqICAgZnMucmVhbHBhdGgoJy9ldGMvcGFzc3dkJywgY2FjaGUsIGZ1bmN0aW9uIChlcnIsIHJlc29sdmVkUGF0aCkge1xuICAgKiAgICAgaWYgKGVycikgdGhyb3cgZXJyO1xuICAgKiAgICAgY29uc29sZS5sb2cocmVzb2x2ZWRQYXRoKTtcbiAgICogICB9KTtcbiAgICpcbiAgICogQHBhcmFtIHBhdGhcbiAgICogQHBhcmFtIGNhY2hlIEFuIG9iamVjdCBsaXRlcmFsIG9mIG1hcHBlZCBwYXRocyB0aGF0IGNhbiBiZSB1c2VkIHRvXG4gICAqICAgZm9yY2UgYSBzcGVjaWZpYyBwYXRoIHJlc29sdXRpb24gb3IgYXZvaWQgYWRkaXRpb25hbCBgZnMuc3RhdGAgY2FsbHMgZm9yXG4gICAqICAga25vd24gcmVhbCBwYXRocy5cbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL1xuICBwdWJsaWMgcmVhbHBhdGgocGF0aDogc3RyaW5nLCBjYj86IEJGU0NhbGxiYWNrPHN0cmluZz4pOiB2b2lkO1xuICBwdWJsaWMgcmVhbHBhdGgocGF0aDogc3RyaW5nLCBjYWNoZToge1twYXRoOiBzdHJpbmddOiBzdHJpbmd9LCBjYjogQkZTQ2FsbGJhY2s8c3RyaW5nPik6IHZvaWQ7XG4gIHB1YmxpYyByZWFscGF0aChwYXRoOiBzdHJpbmcsIGFyZzI/OiBhbnksIGNiOiBCRlNDYWxsYmFjazxzdHJpbmc+ID0gbm9wQ2IpOiB2b2lkIHtcbiAgICBjb25zdCBjYWNoZSA9IHR5cGVvZihhcmcyKSA9PT0gJ29iamVjdCcgPyBhcmcyIDoge307XG4gICAgY2IgPSB0eXBlb2YoYXJnMikgPT09ICdmdW5jdGlvbicgPyBhcmcyIDogbm9wQ2I7XG4gICAgY29uc3QgbmV3Q2IgPSA8KGVycjogQXBpRXJyb3IsIHJlc29sdmVkUGF0aD86IHN0cmluZykgPT4gYW55PiB3cmFwQ2IoY2IsIDIpO1xuICAgIHRyeSB7XG4gICAgICBwYXRoID0gbm9ybWFsaXplUGF0aChwYXRoKTtcbiAgICAgIGFzc2VydFJvb3QodGhpcy5yb290KS5yZWFscGF0aChwYXRoLCBjYWNoZSwgbmV3Q2IpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIG5ld0NiKGUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTeW5jaHJvbm91cyBgcmVhbHBhdGhgLlxuICAgKiBAcGFyYW0gcGF0aFxuICAgKiBAcGFyYW0gY2FjaGUgQW4gb2JqZWN0IGxpdGVyYWwgb2YgbWFwcGVkIHBhdGhzIHRoYXQgY2FuIGJlIHVzZWQgdG9cbiAgICogICBmb3JjZSBhIHNwZWNpZmljIHBhdGggcmVzb2x1dGlvbiBvciBhdm9pZCBhZGRpdGlvbmFsIGBmcy5zdGF0YCBjYWxscyBmb3JcbiAgICogICBrbm93biByZWFsIHBhdGhzLlxuICAgKiBAcmV0dXJuIFtTdHJpbmddXG4gICAqL1xuICBwdWJsaWMgcmVhbHBhdGhTeW5jKHBhdGg6IHN0cmluZywgY2FjaGU6IHtbcGF0aDogc3RyaW5nXTogc3RyaW5nfSA9IHt9KTogc3RyaW5nIHtcbiAgICBwYXRoID0gbm9ybWFsaXplUGF0aChwYXRoKTtcbiAgICByZXR1cm4gYXNzZXJ0Um9vdCh0aGlzLnJvb3QpLnJlYWxwYXRoU3luYyhwYXRoLCBjYWNoZSk7XG4gIH1cblxuICBwdWJsaWMgd2F0Y2hGaWxlKGZpbGVuYW1lOiBzdHJpbmcsIGxpc3RlbmVyOiAoY3VycjogU3RhdHMsIHByZXY6IFN0YXRzKSA9PiB2b2lkKTogdm9pZDtcbiAgcHVibGljIHdhdGNoRmlsZShmaWxlbmFtZTogc3RyaW5nLCBvcHRpb25zOiB7IHBlcnNpc3RlbnQ/OiBib29sZWFuOyBpbnRlcnZhbD86IG51bWJlcjsgfSwgbGlzdGVuZXI6IChjdXJyOiBTdGF0cywgcHJldjogU3RhdHMpID0+IHZvaWQpOiB2b2lkO1xuICBwdWJsaWMgd2F0Y2hGaWxlKGZpbGVuYW1lOiBzdHJpbmcsIGFyZzI6IGFueSwgbGlzdGVuZXI6IChjdXJyOiBTdGF0cywgcHJldjogU3RhdHMpID0+IHZvaWQgPSBub3BDYik6IHZvaWQge1xuICAgIHRocm93IG5ldyBBcGlFcnJvcihFcnJvckNvZGUuRU5PVFNVUCk7XG4gIH1cblxuICBwdWJsaWMgdW53YXRjaEZpbGUoZmlsZW5hbWU6IHN0cmluZywgbGlzdGVuZXI6IChjdXJyOiBTdGF0cywgcHJldjogU3RhdHMpID0+IHZvaWQgPSBub3BDYik6IHZvaWQge1xuICAgIHRocm93IG5ldyBBcGlFcnJvcihFcnJvckNvZGUuRU5PVFNVUCk7XG4gIH1cblxuICBwdWJsaWMgd2F0Y2goZmlsZW5hbWU6IHN0cmluZywgbGlzdGVuZXI/OiAoZXZlbnQ6IHN0cmluZywgZmlsZW5hbWU6IHN0cmluZykgPT4gYW55KTogX2ZzLkZTV2F0Y2hlcjtcbiAgcHVibGljIHdhdGNoKGZpbGVuYW1lOiBzdHJpbmcsIG9wdGlvbnM6IHsgcGVyc2lzdGVudD86IGJvb2xlYW47IH0sIGxpc3RlbmVyPzogKGV2ZW50OiBzdHJpbmcsIGZpbGVuYW1lOiBzdHJpbmcpID0+IGFueSk6IF9mcy5GU1dhdGNoZXI7XG4gIHB1YmxpYyB3YXRjaChmaWxlbmFtZTogc3RyaW5nLCBhcmcyOiBhbnksIGxpc3RlbmVyOiAoZXZlbnQ6IHN0cmluZywgZmlsZW5hbWU6IHN0cmluZykgPT4gYW55ID0gbm9wQ2IpOiBfZnMuRlNXYXRjaGVyIHtcbiAgICB0aHJvdyBuZXcgQXBpRXJyb3IoRXJyb3JDb2RlLkVOT1RTVVApO1xuICB9XG5cbiAgcHVibGljIGFjY2VzcyhwYXRoOiBzdHJpbmcsIGNhbGxiYWNrOiAoZXJyOiBBcGlFcnJvcikgPT4gdm9pZCk6IHZvaWQ7XG4gIHB1YmxpYyBhY2Nlc3MocGF0aDogc3RyaW5nLCBtb2RlOiBudW1iZXIsIGNhbGxiYWNrOiAoZXJyOiBBcGlFcnJvcikgPT4gdm9pZCk6IHZvaWQ7XG4gIHB1YmxpYyBhY2Nlc3MocGF0aDogc3RyaW5nLCBhcmcyOiBhbnksIGNiOiAoZTogQXBpRXJyb3IpID0+IHZvaWQgPSBub3BDYik6IHZvaWQge1xuICAgIHRocm93IG5ldyBBcGlFcnJvcihFcnJvckNvZGUuRU5PVFNVUCk7XG4gIH1cblxuICBwdWJsaWMgYWNjZXNzU3luYyhwYXRoOiBzdHJpbmcsIG1vZGU/OiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aHJvdyBuZXcgQXBpRXJyb3IoRXJyb3JDb2RlLkVOT1RTVVApO1xuICB9XG5cbiAgcHVibGljIGNyZWF0ZVJlYWRTdHJlYW0ocGF0aDogc3RyaW5nLCBvcHRpb25zPzoge1xuICAgICAgICBmbGFncz86IHN0cmluZztcbiAgICAgICAgZW5jb2Rpbmc/OiBzdHJpbmc7XG4gICAgICAgIGZkPzogbnVtYmVyO1xuICAgICAgICBtb2RlPzogbnVtYmVyO1xuICAgICAgICBhdXRvQ2xvc2U/OiBib29sZWFuO1xuICAgIH0pOiBfZnMuUmVhZFN0cmVhbSB7XG4gICAgdGhyb3cgbmV3IEFwaUVycm9yKEVycm9yQ29kZS5FTk9UU1VQKTtcbiAgfVxuXG4gIHB1YmxpYyBjcmVhdGVXcml0ZVN0cmVhbShwYXRoOiBzdHJpbmcsIG9wdGlvbnM/OiB7XG4gICAgICAgIGZsYWdzPzogc3RyaW5nO1xuICAgICAgICBlbmNvZGluZz86IHN0cmluZztcbiAgICAgICAgZmQ/OiBudW1iZXI7XG4gICAgICAgIG1vZGU/OiBudW1iZXI7XG4gICAgfSk6IF9mcy5Xcml0ZVN0cmVhbSB7XG4gICAgdGhyb3cgbmV3IEFwaUVycm9yKEVycm9yQ29kZS5FTk9UU1VQKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGb3IgdW5pdCB0ZXN0aW5nLiBQYXNzZXMgYWxsIGluY29taW5nIGNhbGxiYWNrcyB0byBjYldyYXBwZXIgZm9yIHdyYXBwaW5nLlxuICAgKi9cbiAgcHVibGljIHdyYXBDYWxsYmFja3MoY2JXcmFwcGVyOiAoY2I6IEZ1bmN0aW9uLCBhcmdzOiBudW1iZXIpID0+IEZ1bmN0aW9uKSB7XG4gICAgd3JhcENiID0gY2JXcmFwcGVyO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRGZEZvckZpbGUoZmlsZTogRmlsZSk6IG51bWJlciB7XG4gICAgY29uc3QgZmQgPSB0aGlzLm5leHRGZCsrO1xuICAgIHRoaXMuZmRNYXBbZmRdID0gZmlsZTtcbiAgICByZXR1cm4gZmQ7XG4gIH1cbiAgcHJpdmF0ZSBmZDJmaWxlKGZkOiBudW1iZXIpOiBGaWxlIHtcbiAgICBjb25zdCBydiA9IHRoaXMuZmRNYXBbZmRdO1xuICAgIGlmIChydikge1xuICAgICAgcmV0dXJuIHJ2O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgQXBpRXJyb3IoRXJyb3JDb2RlLkVCQURGLCAnSW52YWxpZCBmaWxlIGRlc2NyaXB0b3IuJyk7XG4gICAgfVxuICB9XG4gIHByaXZhdGUgY2xvc2VGZChmZDogbnVtYmVyKTogdm9pZCB7XG4gICAgZGVsZXRlIHRoaXMuZmRNYXBbZmRdO1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRlNNb2R1bGUgZXh0ZW5kcyBGUyB7XG4gIC8qKlxuICAgKiBUaGUgRlMgY29uc3RydWN0b3IuXG4gICAqL1xuICBGUzogdHlwZW9mIEZTO1xuICAvKipcbiAgICogUmV0cmlldmUgdGhlIEZTIG9iamVjdCBiYWNraW5nIHRoZSBmcyBtb2R1bGUuXG4gICAqL1xuICBnZXRGU01vZHVsZSgpOiBGUztcbiAgLyoqXG4gICAqIFNldCB0aGUgRlMgb2JqZWN0IGJhY2tpbmcgdGhlIGZzIG1vZHVsZS5cbiAgICovXG4gIGNoYW5nZUZTTW9kdWxlKG5ld0ZzOiBGUyk6IHZvaWQ7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vLi4vLi4vLi4vc3JjL2NvcmUvRlMudHMiLCJpbXBvcnQge2RlZmF1bHQgYXMgRlMsIEZTTW9kdWxlfSBmcm9tICcuL0ZTJztcblxuLy8gTWFudWFsbHkgZXhwb3J0IHRoZSBpbmRpdmlkdWFsIHB1YmxpYyBmdW5jdGlvbnMgb2YgZnMuXG4vLyBSZXF1aXJlZCBiZWNhdXNlIHNvbWUgY29kZSB3aWxsIGludm9rZSBmdW5jdGlvbnMgb2ZmIG9mIHRoZSBtb2R1bGUuXG4vLyBlLmcuOlxuLy8gbGV0IHdyaXRlRmlsZSA9IGZzLndyaXRlRmlsZTtcbi8vIHdyaXRlRmlsZSguLi4pXG5cbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgZnM6IGFueSA9IG5ldyBGUygpO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IF9mc01vY2s6IEZTTW9kdWxlID0gPGFueT4ge307XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgZnNQcm90byA9IEZTLnByb3RvdHlwZTtcbk9iamVjdC5rZXlzKGZzUHJvdG8pLmZvckVhY2goKGtleSkgPT4ge1xuICBpZiAodHlwZW9mIGZzW2tleV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAoPGFueT4gX2ZzTW9jaylba2V5XSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICg8RnVuY3Rpb24+IGZzW2tleV0pLmFwcGx5KGZzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgKDxhbnk+IF9mc01vY2spW2tleV0gPSBmc1trZXldO1xuICB9XG59KTtcblxuX2ZzTW9ja1snY2hhbmdlRlNNb2R1bGUnXSA9IGZ1bmN0aW9uKG5ld0ZzOiBGUyk6IHZvaWQge1xuICBmcyA9IG5ld0ZzO1xufTtcbl9mc01vY2tbJ2dldEZTTW9kdWxlJ10gPSBmdW5jdGlvbigpOiBGUyB7XG4gIHJldHVybiBmcztcbn07XG5fZnNNb2NrWydGUyddID0gRlM7XG5cbmV4cG9ydCBkZWZhdWx0IF9mc01vY2s7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vLi4vLi4vLi4vc3JjL2NvcmUvbm9kZV9mcy50cyIsIi8qXG4gKiBMZXZlbnNodGVpbiBkaXN0YW5jZSwgZnJvbSB0aGUgYGpzLWxldmVuc2h0ZWluYCBOUE0gbW9kdWxlLlxuICogQ29waWVkIGhlcmUgdG8gYXZvaWQgY29tcGxleGl0eSBvZiBhZGRpbmcgYW5vdGhlciBDb21tb25KUyBtb2R1bGUgZGVwZW5kZW5jeS5cbiAqL1xuXG5mdW5jdGlvbiBfbWluKGQwOiBudW1iZXIsIGQxOiBudW1iZXIsIGQyOiBudW1iZXIsIGJ4OiBudW1iZXIsIGF5OiBudW1iZXIpOiBudW1iZXIge1xuICByZXR1cm4gZDAgPCBkMSB8fCBkMiA8IGQxXG4gICAgICA/IGQwID4gZDJcbiAgICAgICAgICA/IGQyICsgMVxuICAgICAgICAgIDogZDAgKyAxXG4gICAgICA6IGJ4ID09PSBheVxuICAgICAgICAgID8gZDFcbiAgICAgICAgICA6IGQxICsgMTtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIGxldmVuc2h0ZWluIGRpc3RhbmNlLlxuICogQHBhcmFtIGFcbiAqIEBwYXJhbSBiXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGxldmVuc2h0ZWluKGE6IHN0cmluZywgYjogc3RyaW5nKTogbnVtYmVyIHtcbiAgaWYgKGEgPT09IGIpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIGlmIChhLmxlbmd0aCA+IGIubGVuZ3RoKSB7XG4gICAgY29uc3QgdG1wID0gYTtcbiAgICBhID0gYjtcbiAgICBiID0gdG1wO1xuICB9XG5cbiAgbGV0IGxhID0gYS5sZW5ndGg7XG4gIGxldCBsYiA9IGIubGVuZ3RoO1xuXG4gIHdoaWxlIChsYSA+IDAgJiYgKGEuY2hhckNvZGVBdChsYSAtIDEpID09PSBiLmNoYXJDb2RlQXQobGIgLSAxKSkpIHtcbiAgICBsYS0tO1xuICAgIGxiLS07XG4gIH1cblxuICBsZXQgb2Zmc2V0ID0gMDtcblxuICB3aGlsZSAob2Zmc2V0IDwgbGEgJiYgKGEuY2hhckNvZGVBdChvZmZzZXQpID09PSBiLmNoYXJDb2RlQXQob2Zmc2V0KSkpIHtcbiAgICBvZmZzZXQrKztcbiAgfVxuXG4gIGxhIC09IG9mZnNldDtcbiAgbGIgLT0gb2Zmc2V0O1xuXG4gIGlmIChsYSA9PT0gMCB8fCBsYiA9PT0gMSkge1xuICAgIHJldHVybiBsYjtcbiAgfVxuXG4gIGNvbnN0IHZlY3RvciA9IG5ldyBBcnJheTxudW1iZXI+KGxhIDw8IDEpO1xuXG4gIGZvciAobGV0IHkgPSAwOyB5IDwgbGE7ICkge1xuICAgIHZlY3RvcltsYSArIHldID0gYS5jaGFyQ29kZUF0KG9mZnNldCArIHkpO1xuICAgIHZlY3Rvclt5XSA9ICsreTtcbiAgfVxuXG4gIGxldCB4OiBudW1iZXI7XG4gIGxldCBkMDogbnVtYmVyO1xuICBsZXQgZDE6IG51bWJlcjtcbiAgbGV0IGQyOiBudW1iZXI7XG4gIGxldCBkMzogbnVtYmVyO1xuICBmb3IgKHggPSAwOyAoeCArIDMpIDwgbGI7ICkge1xuICAgIGNvbnN0IGJ4MCA9IGIuY2hhckNvZGVBdChvZmZzZXQgKyAoZDAgPSB4KSk7XG4gICAgY29uc3QgYngxID0gYi5jaGFyQ29kZUF0KG9mZnNldCArIChkMSA9IHggKyAxKSk7XG4gICAgY29uc3QgYngyID0gYi5jaGFyQ29kZUF0KG9mZnNldCArIChkMiA9IHggKyAyKSk7XG4gICAgY29uc3QgYngzID0gYi5jaGFyQ29kZUF0KG9mZnNldCArIChkMyA9IHggKyAzKSk7XG4gICAgbGV0IGRkID0gKHggKz0gNCk7XG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCBsYTsgKSB7XG4gICAgICBjb25zdCBheSA9IHZlY3RvcltsYSArIHldO1xuICAgICAgY29uc3QgZHkgPSB2ZWN0b3JbeV07XG4gICAgICBkMCA9IF9taW4oZHksIGQwLCBkMSwgYngwLCBheSk7XG4gICAgICBkMSA9IF9taW4oZDAsIGQxLCBkMiwgYngxLCBheSk7XG4gICAgICBkMiA9IF9taW4oZDEsIGQyLCBkMywgYngyLCBheSk7XG4gICAgICBkZCA9IF9taW4oZDIsIGQzLCBkZCwgYngzLCBheSk7XG4gICAgICB2ZWN0b3JbeSsrXSA9IGRkO1xuICAgICAgZDMgPSBkMjtcbiAgICAgIGQyID0gZDE7XG4gICAgICBkMSA9IGQwO1xuICAgICAgZDAgPSBkeTtcbiAgICB9XG4gIH1cblxuICBsZXQgZGQ6IG51bWJlciA9IDA7XG4gIGZvciAoOyB4IDwgbGI7ICkge1xuICAgIGNvbnN0IGJ4MCA9IGIuY2hhckNvZGVBdChvZmZzZXQgKyAoZDAgPSB4KSk7XG4gICAgZGQgPSArK3g7XG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCBsYTsgeSsrKSB7XG4gICAgICBjb25zdCBkeSA9IHZlY3Rvclt5XTtcbiAgICAgIHZlY3Rvclt5XSA9IGRkID0gZHkgPCBkMCB8fCBkZCA8IGQwXG4gICAgICAgICAgPyBkeSA+IGRkID8gZGQgKyAxIDogZHkgKyAxXG4gICAgICAgICAgOiBieDAgPT09IHZlY3RvcltsYSArIHldXG4gICAgICAgICAgICAgID8gZDBcbiAgICAgICAgICAgICAgOiBkMCArIDE7XG4gICAgICBkMCA9IGR5O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkZDtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi8uLi8uLi8uLi9zcmMvY29yZS9sZXZlbnNodGVpbi50cyIsIi8qKlxuICogR3JhYiBiYWcgb2YgdXRpbGl0eSBmdW5jdGlvbnMgdXNlZCBhY3Jvc3MgdGhlIGNvZGUuXG4gKi9cbmltcG9ydCB7RmlsZVN5c3RlbSwgQkZTT25lQXJnQ2FsbGJhY2ssIEZpbGVTeXN0ZW1Db25zdHJ1Y3Rvcn0gZnJvbSAnLi9maWxlX3N5c3RlbSc7XG5pbXBvcnQge0Vycm9yQ29kZSwgQXBpRXJyb3J9IGZyb20gJy4vYXBpX2Vycm9yJztcbmltcG9ydCBsZXZlbnNodGVpbiBmcm9tICcuL2xldmVuc2h0ZWluJztcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBkZXByZWNhdGlvbk1lc3NhZ2UocHJpbnQ6IGJvb2xlYW4sIGZzTmFtZTogc3RyaW5nLCBvcHRzOiBhbnkpOiB2b2lkIHtcbiAgaWYgKHByaW50KSB7XG4gICAgY29uc29sZS53YXJuKGBbJHtmc05hbWV9XSBEaXJlY3QgZmlsZSBzeXN0ZW0gY29uc3RydWN0b3IgdXNhZ2UgaXMgZGVwcmVjYXRlZCBmb3IgdGhpcyBmaWxlIHN5c3RlbSwgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uLiBQbGVhc2UgdXNlIHRoZSAnJHtmc05hbWV9LkNyZWF0ZSgke0pTT04uc3RyaW5naWZ5KG9wdHMpfSwgY2FsbGJhY2spJyBtZXRob2QgaW5zdGVhZC4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qdmlsay9Ccm93c2VyRlMvaXNzdWVzLzE3NiBmb3IgbW9yZSBkZXRhaWxzLmApO1xuICB9XG59XG5cbi8qKlxuICogQ2hlY2tzIGZvciBhbnkgSUUgdmVyc2lvbiwgaW5jbHVkaW5nIElFMTEgd2hpY2ggcmVtb3ZlZCBNU0lFIGZyb20gdGhlXG4gKiB1c2VyQWdlbnQgc3RyaW5nLlxuICogQGhpZGRlblxuICovXG5leHBvcnQgY29uc3QgaXNJRTogYm9vbGVhbiA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09IFwidW5kZWZpbmVkXCIgJiYgISEoLyhtc2llKSAoW1xcdy5dKykvLmV4ZWMobmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpKSB8fCBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ1RyaWRlbnQnKSAhPT0gLTEpO1xuXG4vKipcbiAqIENoZWNrIGlmIHdlJ3JlIGluIGEgd2ViIHdvcmtlci5cbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGNvbnN0IGlzV2ViV29ya2VyOiBib29sZWFuID0gdHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIjtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQXJyYXlpc2g8VD4ge1xuICBbaWR4OiBudW1iZXJdOiBUO1xuICBsZW5ndGg6IG51bWJlcjtcbn1cblxuLyoqXG4gKiBUaHJvd3MgYW4gZXhjZXB0aW9uLiBDYWxsZWQgb24gY29kZSBwYXRocyB0aGF0IHNob3VsZCBiZSBpbXBvc3NpYmxlLlxuICogQGhpZGRlblxuICovXG5leHBvcnQgZnVuY3Rpb24gZmFpbCgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKFwiQkZTIGhhcyByZWFjaGVkIGFuIGltcG9zc2libGUgY29kZSBwYXRoOyBwbGVhc2UgZmlsZSBhIGJ1Zy5cIik7XG59XG5cbi8qKlxuICogU3luY2hyb25vdXMgcmVjdXJzaXZlIG1ha2VkaXIuXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBta2RpcnBTeW5jKHA6IHN0cmluZywgbW9kZTogbnVtYmVyLCBmczogRmlsZVN5c3RlbSk6IHZvaWQge1xuICBpZiAoIWZzLmV4aXN0c1N5bmMocCkpIHtcbiAgICBta2RpcnBTeW5jKHBhdGguZGlybmFtZShwKSwgbW9kZSwgZnMpO1xuICAgIGZzLm1rZGlyU3luYyhwLCBtb2RlKTtcbiAgfVxufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgYnVmZmVyIGludG8gYW4gYXJyYXkgYnVmZmVyLiBBdHRlbXB0cyB0byBkbyBzbyBpbiBhXG4gKiB6ZXJvLWNvcHkgbWFubmVyLCBlLmcuIHRoZSBhcnJheSByZWZlcmVuY2VzIHRoZSBzYW1lIG1lbW9yeS5cbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ1ZmZlcjJBcnJheUJ1ZmZlcihidWZmOiBCdWZmZXIpOiBBcnJheUJ1ZmZlciB7XG4gIGNvbnN0IHU4ID0gYnVmZmVyMlVpbnQ4YXJyYXkoYnVmZiksXG4gICAgdThvZmZzZXQgPSB1OC5ieXRlT2Zmc2V0LFxuICAgIHU4TGVuID0gdTguYnl0ZUxlbmd0aDtcbiAgaWYgKHU4b2Zmc2V0ID09PSAwICYmIHU4TGVuID09PSB1OC5idWZmZXIuYnl0ZUxlbmd0aCkge1xuICAgIHJldHVybiB1OC5idWZmZXI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHU4LmJ1ZmZlci5zbGljZSh1OG9mZnNldCwgdThvZmZzZXQgKyB1OExlbik7XG4gIH1cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIGJ1ZmZlciBpbnRvIGEgVWludDhBcnJheS4gQXR0ZW1wdHMgdG8gZG8gc28gaW4gYVxuICogemVyby1jb3B5IG1hbm5lciwgZS5nLiB0aGUgYXJyYXkgcmVmZXJlbmNlcyB0aGUgc2FtZSBtZW1vcnkuXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBidWZmZXIyVWludDhhcnJheShidWZmOiBCdWZmZXIpOiBVaW50OEFycmF5IHtcbiAgaWYgKGJ1ZmYgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgLy8gQkZTICYgTm9kZSB2NC4wIGJ1ZmZlcnMgKmFyZSogVWludDhBcnJheXMuXG4gICAgcmV0dXJuIDxhbnk+IGJ1ZmY7XG4gIH0gZWxzZSB7XG4gICAgLy8gVWludDhBcnJheXMgY2FuIGJlIGNvbnN0cnVjdGVkIGZyb20gYXJyYXlpc2ggbnVtYmVycy5cbiAgICAvLyBBdCB0aGlzIHBvaW50LCB3ZSBhc3N1bWUgdGhpcyBpc24ndCBhIEJGUyBhcnJheS5cbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnVmZik7XG4gIH1cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gYXJyYXlpc2ggb2JqZWN0IGludG8gYSBCdWZmZXIuIEF0dGVtcHRzIHRvXG4gKiBiZSB6ZXJvLWNvcHkuXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcnJheWlzaDJCdWZmZXIoYXJyOiBBcnJheWlzaDxudW1iZXI+KTogQnVmZmVyIHtcbiAgaWYgKGFyciBpbnN0YW5jZW9mIEJ1ZmZlcikge1xuICAgIHJldHVybiBhcnI7XG4gIH0gZWxzZSBpZiAoYXJyIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgIHJldHVybiB1aW50OEFycmF5MkJ1ZmZlcihhcnIpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSg8bnVtYmVyW10+IGFycik7XG4gIH1cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gVWludDhBcnJheSBpbnRvIGEgQnVmZmVyLiBBdHRlbXB0cyB0byBiZSB6ZXJvLWNvcHkuXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1aW50OEFycmF5MkJ1ZmZlcih1ODogVWludDhBcnJheSk6IEJ1ZmZlciB7XG4gIGlmICh1OCBpbnN0YW5jZW9mIEJ1ZmZlcikge1xuICAgIHJldHVybiB1ODtcbiAgfSBlbHNlIGlmICh1OC5ieXRlT2Zmc2V0ID09PSAwICYmIHU4LmJ5dGVMZW5ndGggPT09IHU4LmJ1ZmZlci5ieXRlTGVuZ3RoKSB7XG4gICAgcmV0dXJuIGFycmF5QnVmZmVyMkJ1ZmZlcih1OC5idWZmZXIpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSh1OC5idWZmZXIsIHU4LmJ5dGVPZmZzZXQsIHU4LmJ5dGVMZW5ndGgpO1xuICB9XG59XG5cbi8qKlxuICogQ29udmVydHMgdGhlIGdpdmVuIGFycmF5IGJ1ZmZlciBpbnRvIGEgQnVmZmVyLiBBdHRlbXB0cyB0byBiZVxuICogemVyby1jb3B5LlxuICogQGhpZGRlblxuICovXG5leHBvcnQgZnVuY3Rpb24gYXJyYXlCdWZmZXIyQnVmZmVyKGFiOiBBcnJheUJ1ZmZlcik6IEJ1ZmZlciB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShhYik7XG59XG5cbi8qKlxuICogQ29waWVzIGEgc2xpY2Ugb2YgdGhlIGdpdmVuIGJ1ZmZlclxuICogQGhpZGRlblxuICovXG5leHBvcnQgZnVuY3Rpb24gY29weWluZ1NsaWNlKGJ1ZmY6IEJ1ZmZlciwgc3RhcnQ6IG51bWJlciA9IDAsIGVuZCA9IGJ1ZmYubGVuZ3RoKTogQnVmZmVyIHtcbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPCAwIHx8IGVuZCA+IGJ1ZmYubGVuZ3RoIHx8IHN0YXJ0ID4gZW5kKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBzbGljZSBib3VuZHMgb24gYnVmZmVyIG9mIGxlbmd0aCAke2J1ZmYubGVuZ3RofTogWyR7c3RhcnR9LCAke2VuZH1dYCk7XG4gIH1cbiAgaWYgKGJ1ZmYubGVuZ3RoID09PSAwKSB7XG4gICAgLy8gQXZvaWQgczAgY29ybmVyIGNhc2UgaW4gQXJyYXlCdWZmZXIgY2FzZS5cbiAgICByZXR1cm4gZW1wdHlCdWZmZXIoKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCB1OCA9IGJ1ZmZlcjJVaW50OGFycmF5KGJ1ZmYpLFxuICAgICAgczAgPSBidWZmWzBdLFxuICAgICAgbmV3UzAgPSAoczAgKyAxKSAlIDB4RkY7XG5cbiAgICBidWZmWzBdID0gbmV3UzA7XG4gICAgaWYgKHU4WzBdID09PSBuZXdTMCkge1xuICAgICAgLy8gU2FtZSBtZW1vcnkuIFJldmVydCAmIGNvcHkuXG4gICAgICB1OFswXSA9IHMwO1xuICAgICAgcmV0dXJuIHVpbnQ4QXJyYXkyQnVmZmVyKHU4LnNsaWNlKHN0YXJ0LCBlbmQpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmV2ZXJ0LlxuICAgICAgYnVmZlswXSA9IHMwO1xuICAgICAgcmV0dXJuIHVpbnQ4QXJyYXkyQnVmZmVyKHU4LnN1YmFycmF5KHN0YXJ0LCBlbmQpKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBlbXB0eUJ1ZmY6IEJ1ZmZlciB8IG51bGwgPSBudWxsO1xuLyoqXG4gKiBSZXR1cm5zIGFuIGVtcHR5IGJ1ZmZlci5cbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVtcHR5QnVmZmVyKCk6IEJ1ZmZlciB7XG4gIGlmIChlbXB0eUJ1ZmYpIHtcbiAgICByZXR1cm4gZW1wdHlCdWZmO1xuICB9XG4gIHJldHVybiBlbXB0eUJ1ZmYgPSBCdWZmZXIuYWxsb2MoMCk7XG59XG5cbi8qKlxuICogT3B0aW9uIHZhbGlkYXRvciBmb3IgYSBCdWZmZXIgZmlsZSBzeXN0ZW0gb3B0aW9uLlxuICogQGhpZGRlblxuICovXG5leHBvcnQgZnVuY3Rpb24gYnVmZmVyVmFsaWRhdG9yKHY6IG9iamVjdCwgY2I6IEJGU09uZUFyZ0NhbGxiYWNrKTogdm9pZCB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodikpIHtcbiAgICBjYigpO1xuICB9IGVsc2Uge1xuICAgIGNiKG5ldyBBcGlFcnJvcihFcnJvckNvZGUuRUlOVkFMLCBgb3B0aW9uIG11c3QgYmUgYSBCdWZmZXIuYCkpO1xuICB9XG59XG5cbi8qKlxuICogQ2hlY2tzIHRoYXQgdGhlIGdpdmVuIG9wdGlvbnMgb2JqZWN0IGlzIHZhbGlkIGZvciB0aGUgZmlsZSBzeXN0ZW0gb3B0aW9ucy5cbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrT3B0aW9ucyhmc1R5cGU6IEZpbGVTeXN0ZW1Db25zdHJ1Y3Rvciwgb3B0czogYW55LCBjYjogQkZTT25lQXJnQ2FsbGJhY2spOiB2b2lkIHtcbiAgY29uc3Qgb3B0c0luZm8gPSBmc1R5cGUuT3B0aW9ucztcbiAgY29uc3QgZnNOYW1lID0gZnNUeXBlLk5hbWU7XG5cbiAgbGV0IHBlbmRpbmdWYWxpZGF0b3JzID0gMDtcbiAgbGV0IGNhbGxiYWNrQ2FsbGVkID0gZmFsc2U7XG4gIGxldCBsb29wRW5kZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gdmFsaWRhdG9yQ2FsbGJhY2soZT86IEFwaUVycm9yKTogdm9pZCB7XG4gICAgaWYgKCFjYWxsYmFja0NhbGxlZCkge1xuICAgICAgaWYgKGUpIHtcbiAgICAgICAgY2FsbGJhY2tDYWxsZWQgPSB0cnVlO1xuICAgICAgICBjYihlKTtcbiAgICAgIH1cbiAgICAgIHBlbmRpbmdWYWxpZGF0b3JzLS07XG4gICAgICBpZiAocGVuZGluZ1ZhbGlkYXRvcnMgPT09IDAgJiYgbG9vcEVuZGVkKSB7XG4gICAgICAgIGNiKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQ2hlY2sgZm9yIHJlcXVpcmVkIG9wdGlvbnMuXG4gIGZvciAoY29uc3Qgb3B0TmFtZSBpbiBvcHRzSW5mbykge1xuICAgIGlmIChvcHRzSW5mby5oYXNPd25Qcm9wZXJ0eShvcHROYW1lKSkge1xuICAgICAgY29uc3Qgb3B0ID0gb3B0c0luZm9bb3B0TmFtZV07XG4gICAgICBjb25zdCBwcm92aWRlZFZhbHVlID0gb3B0c1tvcHROYW1lXTtcblxuICAgICAgaWYgKHByb3ZpZGVkVmFsdWUgPT09IHVuZGVmaW5lZCB8fCBwcm92aWRlZFZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIGlmICghb3B0Lm9wdGlvbmFsKSB7XG4gICAgICAgICAgLy8gUmVxdWlyZWQgb3B0aW9uLCBub3QgcHJvdmlkZWQuXG4gICAgICAgICAgLy8gQW55IGluY29ycmVjdCBvcHRpb25zIHByb3ZpZGVkPyBXaGljaCBvbmVzIGFyZSBjbG9zZSB0byB0aGUgcHJvdmlkZWQgb25lP1xuICAgICAgICAgIC8vIChlZGl0IGRpc3RhbmNlIDUgPT09IGNsb3NlKVxuICAgICAgICAgIGNvbnN0IGluY29ycmVjdE9wdGlvbnMgPSBPYmplY3Qua2V5cyhvcHRzKS5maWx0ZXIoKG8pID0+ICEobyBpbiBvcHRzSW5mbykpLm1hcCgoYTogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4ge3N0cjogYSwgZGlzdGFuY2U6IGxldmVuc2h0ZWluKG9wdE5hbWUsIGEpfTtcbiAgICAgICAgICB9KS5maWx0ZXIoKG8pID0+IG8uZGlzdGFuY2UgPCA1KS5zb3J0KChhLCBiKSA9PiBhLmRpc3RhbmNlIC0gYi5kaXN0YW5jZSk7XG4gICAgICAgICAgLy8gVmFsaWRhdG9ycyBtYXkgYmUgc3luY2hyb25vdXMuXG4gICAgICAgICAgaWYgKGNhbGxiYWNrQ2FsbGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhbGxiYWNrQ2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gY2IobmV3IEFwaUVycm9yKEVycm9yQ29kZS5FSU5WQUwsIGBbJHtmc05hbWV9XSBSZXF1aXJlZCBvcHRpb24gJyR7b3B0TmFtZX0nIG5vdCBwcm92aWRlZC4ke2luY29ycmVjdE9wdGlvbnMubGVuZ3RoID4gMCA/IGAgWW91IHByb3ZpZGVkIHVucmVjb2duaXplZCBvcHRpb24gJyR7aW5jb3JyZWN0T3B0aW9uc1swXS5zdHJ9JzsgcGVyaGFwcyB5b3UgbWVhbnQgdG8gdHlwZSAnJHtvcHROYW1lfScuYCA6ICcnfVxcbk9wdGlvbiBkZXNjcmlwdGlvbjogJHtvcHQuZGVzY3JpcHRpb259YCkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEVsc2U6IE9wdGlvbmFsIG9wdGlvbiwgbm90IHByb3ZpZGVkLiBUaGF0IGlzIE9LLlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gT3B0aW9uIHByb3ZpZGVkISBDaGVjayB0eXBlLlxuICAgICAgICBsZXQgdHlwZU1hdGNoZXMgPSBmYWxzZTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob3B0LnR5cGUpKSB7XG4gICAgICAgICAgdHlwZU1hdGNoZXMgPSBvcHQudHlwZS5pbmRleE9mKHR5cGVvZihwcm92aWRlZFZhbHVlKSkgIT09IC0xO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHR5cGVNYXRjaGVzID0gdHlwZW9mKHByb3ZpZGVkVmFsdWUpID09PSBvcHQudHlwZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXR5cGVNYXRjaGVzKSB7XG4gICAgICAgICAgLy8gVmFsaWRhdG9ycyBtYXkgYmUgc3luY2hyb25vdXMuXG4gICAgICAgICAgaWYgKGNhbGxiYWNrQ2FsbGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhbGxiYWNrQ2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gY2IobmV3IEFwaUVycm9yKEVycm9yQ29kZS5FSU5WQUwsIGBbJHtmc05hbWV9XSBWYWx1ZSBwcm92aWRlZCBmb3Igb3B0aW9uICR7b3B0TmFtZX0gaXMgbm90IHRoZSBwcm9wZXIgdHlwZS4gRXhwZWN0ZWQgJHtBcnJheS5pc0FycmF5KG9wdC50eXBlKSA/IGBvbmUgb2YgeyR7b3B0LnR5cGUuam9pbihcIiwgXCIpfX1gIDogb3B0LnR5cGV9LCBidXQgcmVjZWl2ZWQgJHt0eXBlb2YocHJvdmlkZWRWYWx1ZSl9XFxuT3B0aW9uIGRlc2NyaXB0aW9uOiAke29wdC5kZXNjcmlwdGlvbn1gKSk7XG4gICAgICAgIH0gZWxzZSBpZiAob3B0LnZhbGlkYXRvcikge1xuICAgICAgICAgIHBlbmRpbmdWYWxpZGF0b3JzKys7XG4gICAgICAgICAgb3B0LnZhbGlkYXRvcihwcm92aWRlZFZhbHVlLCB2YWxpZGF0b3JDYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT3RoZXJ3aXNlOiBBbGwgZ29vZCFcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgbG9vcEVuZGVkID0gdHJ1ZTtcbiAgaWYgKHBlbmRpbmdWYWxpZGF0b3JzID09PSAwICYmICFjYWxsYmFja0NhbGxlZCkge1xuICAgIGNiKCk7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi8uLi8uLi8uLi9zcmMvY29yZS91dGlsLnRzIiwiLyoqXG4gKiBEZWZpbmVzIGFuIEVtc2NyaXB0ZW4gZmlsZSBzeXN0ZW0gb2JqZWN0IGZvciB1c2UgaW4gdGhlIEVtc2NyaXB0ZW4gdmlydHVhbFxuICogZmlsZXN5c3RlbS4gQWxsb3dzIHlvdSB0byB1c2Ugc3luY2hyb25vdXMgQnJvd3NlckZTIGZpbGUgc3lzdGVtcyBmcm9tIHdpdGhpblxuICogRW1zY3JpcHRlbi5cbiAqXG4gKiBZb3UgY2FuIGNvbnN0cnVjdCBhIEJGU0Vtc2NyaXB0ZW5GUywgbW91bnQgaXQgdXNpbmcgaXRzIG1vdW50IGNvbW1hbmQsXG4gKiBhbmQgdGhlbiBtb3VudCBpdCBpbnRvIEVtc2NyaXB0ZW4uXG4gKlxuICogQWRhcHRlZCBmcm9tIEVtc2NyaXB0ZW4ncyBOb2RlRlM6XG4gKiBodHRwczovL3Jhdy5naXRodWIuY29tL2tyaXBrZW4vZW1zY3JpcHRlbi9tYXN0ZXIvc3JjL2xpYnJhcnlfbm9kZWZzLmpzXG4gKi9cbmltcG9ydCBGUyBmcm9tICcuLi9jb3JlL0ZTJztcbmltcG9ydCBmcyBmcm9tICcuLi9jb3JlL25vZGVfZnMnO1xuaW1wb3J0IE5vZGVTdGF0cyBmcm9tICcuLi9jb3JlL25vZGVfZnNfc3RhdHMnO1xuaW1wb3J0IHt1aW50OEFycmF5MkJ1ZmZlcn0gZnJvbSAnLi4vY29yZS91dGlsJztcblxuZXhwb3J0IGludGVyZmFjZSBTdGF0cyB7XG4gIGRldjogbnVtYmVyO1xuICBpbm86IG51bWJlcjtcbiAgbW9kZTogbnVtYmVyO1xuICBubGluazogbnVtYmVyO1xuICB1aWQ6IG51bWJlcjtcbiAgZ2lkOiBudW1iZXI7XG4gIHJkZXY6IG51bWJlcjtcbiAgc2l6ZTogbnVtYmVyO1xuICBibGtzaXplOiBudW1iZXI7XG4gIGJsb2NrczogbnVtYmVyO1xuICBhdGltZTogRGF0ZTtcbiAgbXRpbWU6IERhdGU7XG4gIGN0aW1lOiBEYXRlO1xuICB0aW1lc3RhbXA/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRW1zY3JpcHRlbkZTTm9kZSB7XG4gIG5hbWU6IHN0cmluZztcbiAgbW9kZTogbnVtYmVyO1xuICBwYXJlbnQ6IEVtc2NyaXB0ZW5GU05vZGU7XG4gIG1vdW50OiB7b3B0czoge3Jvb3Q6IHN0cmluZ319O1xuICBzdHJlYW1fb3BzOiBFbXNjcmlwdGVuU3RyZWFtT3BzO1xuICBub2RlX29wczogRW1zY3JpcHRlbk5vZGVPcHM7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRW1zY3JpcHRlblN0cmVhbSB7XG4gIG5vZGU6IEVtc2NyaXB0ZW5GU05vZGU7XG4gIG5mZDogYW55O1xuICBmbGFnczogc3RyaW5nO1xuICBwb3NpdGlvbjogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEVtc2NyaXB0ZW5Ob2RlT3BzIHtcbiAgZ2V0YXR0cihub2RlOiBFbXNjcmlwdGVuRlNOb2RlKTogU3RhdHM7XG4gIHNldGF0dHIobm9kZTogRW1zY3JpcHRlbkZTTm9kZSwgYXR0cjogU3RhdHMpOiB2b2lkO1xuICBsb29rdXAocGFyZW50OiBFbXNjcmlwdGVuRlNOb2RlLCBuYW1lOiBzdHJpbmcpOiBFbXNjcmlwdGVuRlNOb2RlO1xuICBta25vZChwYXJlbnQ6IEVtc2NyaXB0ZW5GU05vZGUsIG5hbWU6IHN0cmluZywgbW9kZTogbnVtYmVyLCBkZXY6IGFueSk6IEVtc2NyaXB0ZW5GU05vZGU7XG4gIHJlbmFtZShvbGROb2RlOiBFbXNjcmlwdGVuRlNOb2RlLCBuZXdEaXI6IEVtc2NyaXB0ZW5GU05vZGUsIG5ld05hbWU6IHN0cmluZyk6IHZvaWQ7XG4gIHVubGluayhwYXJlbnQ6IEVtc2NyaXB0ZW5GU05vZGUsIG5hbWU6IHN0cmluZyk6IHZvaWQ7XG4gIHJtZGlyKHBhcmVudDogRW1zY3JpcHRlbkZTTm9kZSwgbmFtZTogc3RyaW5nKTogdm9pZDtcbiAgcmVhZGRpcihub2RlOiBFbXNjcmlwdGVuRlNOb2RlKTogc3RyaW5nW107XG4gIHN5bWxpbmsocGFyZW50OiBFbXNjcmlwdGVuRlNOb2RlLCBuZXdOYW1lOiBzdHJpbmcsIG9sZFBhdGg6IHN0cmluZyk6IHZvaWQ7XG4gIHJlYWRsaW5rKG5vZGU6IEVtc2NyaXB0ZW5GU05vZGUpOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRW1zY3JpcHRlblN0cmVhbU9wcyB7XG4gIG9wZW4oc3RyZWFtOiBFbXNjcmlwdGVuU3RyZWFtKTogdm9pZDtcbiAgY2xvc2Uoc3RyZWFtOiBFbXNjcmlwdGVuU3RyZWFtKTogdm9pZDtcbiAgcmVhZChzdHJlYW06IEVtc2NyaXB0ZW5TdHJlYW0sIGJ1ZmZlcjogVWludDhBcnJheSwgb2Zmc2V0OiBudW1iZXIsIGxlbmd0aDogbnVtYmVyLCBwb3NpdGlvbjogbnVtYmVyKTogbnVtYmVyO1xuICB3cml0ZShzdHJlYW06IEVtc2NyaXB0ZW5TdHJlYW0sIGJ1ZmZlcjogVWludDhBcnJheSwgb2Zmc2V0OiBudW1iZXIsIGxlbmd0aDogbnVtYmVyLCBwb3NpdGlvbjogbnVtYmVyKTogbnVtYmVyO1xuICBsbHNlZWsoc3RyZWFtOiBFbXNjcmlwdGVuU3RyZWFtLCBvZmZzZXQ6IG51bWJlciwgd2hlbmNlOiBudW1iZXIpOiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRW1zY3JpcHRlbkZTIHtcbiAgbm9kZV9vcHM6IEVtc2NyaXB0ZW5Ob2RlT3BzO1xuICBzdHJlYW1fb3BzOiBFbXNjcmlwdGVuU3RyZWFtT3BzO1xuICBtb3VudChtb3VudDoge29wdHM6IHtyb290OiBzdHJpbmd9fSk6IEVtc2NyaXB0ZW5GU05vZGU7XG4gIGNyZWF0ZU5vZGUocGFyZW50OiBFbXNjcmlwdGVuRlNOb2RlLCBuYW1lOiBzdHJpbmcsIG1vZGU6IG51bWJlciwgZGV2PzogYW55KTogRW1zY3JpcHRlbkZTTm9kZTtcbiAgZ2V0TW9kZShwYXRoOiBzdHJpbmcpOiBudW1iZXI7XG4gIHJlYWxQYXRoKG5vZGU6IEVtc2NyaXB0ZW5GU05vZGUpOiBzdHJpbmc7XG59XG5cbmNsYXNzIEJGU0Vtc2NyaXB0ZW5TdHJlYW1PcHMgaW1wbGVtZW50cyBFbXNjcmlwdGVuU3RyZWFtT3BzIHtcbiAgcHJpdmF0ZSBGUzogYW55O1xuICBwcml2YXRlIFBBVEg6IGFueTtcbiAgcHJpdmF0ZSBFUlJOT19DT0RFUzogYW55O1xuICBwcml2YXRlIG5vZGVmczogRlM7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBmczogQkZTRW1zY3JpcHRlbkZTKSB7XG4gICAgdGhpcy5ub2RlZnMgPSBmcy5nZXROb2RlRlMoKTtcbiAgICB0aGlzLkZTID0gZnMuZ2V0RlMoKTtcbiAgICB0aGlzLlBBVEggPSBmcy5nZXRQQVRIKCk7XG4gICAgdGhpcy5FUlJOT19DT0RFUyA9IGZzLmdldEVSUk5PX0NPREVTKCk7XG4gIH1cblxuICBwdWJsaWMgb3BlbihzdHJlYW06IEVtc2NyaXB0ZW5TdHJlYW0pOiB2b2lkIHtcbiAgICBjb25zdCBwYXRoID0gdGhpcy5mcy5yZWFsUGF0aChzdHJlYW0ubm9kZSk7XG4gICAgY29uc3QgRlMgPSB0aGlzLkZTO1xuICAgIHRyeSB7XG4gICAgICBpZiAoRlMuaXNGaWxlKHN0cmVhbS5ub2RlLm1vZGUpKSB7XG4gICAgICAgIHN0cmVhbS5uZmQgPSB0aGlzLm5vZGVmcy5vcGVuU3luYyhwYXRoLCB0aGlzLmZzLmZsYWdzVG9QZXJtaXNzaW9uU3RyaW5nKHN0cmVhbS5mbGFncykpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmICghZS5jb2RlKSB7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcih0aGlzLkVSUk5PX0NPREVTW2UuY29kZV0pO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBjbG9zZShzdHJlYW06IEVtc2NyaXB0ZW5TdHJlYW0pOiB2b2lkIHtcbiAgICBjb25zdCBGUyA9IHRoaXMuRlM7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChGUy5pc0ZpbGUoc3RyZWFtLm5vZGUubW9kZSkgJiYgc3RyZWFtLm5mZCkge1xuICAgICAgICB0aGlzLm5vZGVmcy5jbG9zZVN5bmMoc3RyZWFtLm5mZCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKCFlLmNvZGUpIHtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKHRoaXMuRVJSTk9fQ09ERVNbZS5jb2RlXSk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHJlYWQoc3RyZWFtOiBFbXNjcmlwdGVuU3RyZWFtLCBidWZmZXI6IFVpbnQ4QXJyYXksIG9mZnNldDogbnVtYmVyLCBsZW5ndGg6IG51bWJlciwgcG9zaXRpb246IG51bWJlcik6IG51bWJlciB7XG4gICAgLy8gQXZvaWQgY29weWluZyBvdmVyaGVhZCBieSByZWFkaW5nIGRpcmVjdGx5IGludG8gYnVmZmVyLlxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gdGhpcy5ub2RlZnMucmVhZFN5bmMoc3RyZWFtLm5mZCwgdWludDhBcnJheTJCdWZmZXIoYnVmZmVyKSwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgdGhpcy5GUy5FcnJub0Vycm9yKHRoaXMuRVJSTk9fQ09ERVNbZS5jb2RlXSk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHdyaXRlKHN0cmVhbTogRW1zY3JpcHRlblN0cmVhbSwgYnVmZmVyOiBVaW50OEFycmF5LCBvZmZzZXQ6IG51bWJlciwgbGVuZ3RoOiBudW1iZXIsIHBvc2l0aW9uOiBudW1iZXIpOiBudW1iZXIge1xuICAgIC8vIEF2b2lkIGNvcHlpbmcgb3ZlcmhlYWQuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB0aGlzLm5vZGVmcy53cml0ZVN5bmMoc3RyZWFtLm5mZCwgdWludDhBcnJheTJCdWZmZXIoYnVmZmVyKSwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgdGhpcy5GUy5FcnJub0Vycm9yKHRoaXMuRVJSTk9fQ09ERVNbZS5jb2RlXSk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGxsc2VlayhzdHJlYW06IEVtc2NyaXB0ZW5TdHJlYW0sIG9mZnNldDogbnVtYmVyLCB3aGVuY2U6IG51bWJlcik6IG51bWJlciB7XG4gICAgbGV0IHBvc2l0aW9uID0gb2Zmc2V0O1xuICAgIGlmICh3aGVuY2UgPT09IDEpIHsgIC8vIFNFRUtfQ1VSLlxuICAgICAgcG9zaXRpb24gKz0gc3RyZWFtLnBvc2l0aW9uO1xuICAgIH0gZWxzZSBpZiAod2hlbmNlID09PSAyKSB7ICAvLyBTRUVLX0VORC5cbiAgICAgIGlmICh0aGlzLkZTLmlzRmlsZShzdHJlYW0ubm9kZS5tb2RlKSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHN0YXQgPSB0aGlzLm5vZGVmcy5mc3RhdFN5bmMoc3RyZWFtLm5mZCk7XG4gICAgICAgICAgcG9zaXRpb24gKz0gc3RhdC5zaXplO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IHRoaXMuRlMuRXJybm9FcnJvcih0aGlzLkVSUk5PX0NPREVTW2UuY29kZV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBvc2l0aW9uIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IHRoaXMuRlMuRXJybm9FcnJvcih0aGlzLkVSUk5PX0NPREVTLkVJTlZBTCk7XG4gICAgfVxuXG4gICAgc3RyZWFtLnBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgcmV0dXJuIHBvc2l0aW9uO1xuICB9XG59XG5cbmNsYXNzIEJGU0Vtc2NyaXB0ZW5Ob2RlT3BzIGltcGxlbWVudHMgRW1zY3JpcHRlbk5vZGVPcHMge1xuICBwcml2YXRlIEZTOiBhbnk7XG4gIHByaXZhdGUgUEFUSDogYW55O1xuICBwcml2YXRlIEVSUk5PX0NPREVTOiBhbnk7XG4gIHByaXZhdGUgbm9kZWZzOiBGUztcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGZzOiBCRlNFbXNjcmlwdGVuRlMpIHtcbiAgICB0aGlzLm5vZGVmcyA9IGZzLmdldE5vZGVGUygpO1xuICAgIHRoaXMuRlMgPSBmcy5nZXRGUygpO1xuICAgIHRoaXMuUEFUSCA9IGZzLmdldFBBVEgoKTtcbiAgICB0aGlzLkVSUk5PX0NPREVTID0gZnMuZ2V0RVJSTk9fQ09ERVMoKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRhdHRyKG5vZGU6IEVtc2NyaXB0ZW5GU05vZGUpOiBTdGF0cyB7XG4gICAgY29uc3QgcGF0aCA9IHRoaXMuZnMucmVhbFBhdGgobm9kZSk7XG4gICAgbGV0IHN0YXQ6IE5vZGVTdGF0cztcbiAgICB0cnkge1xuICAgICAgc3RhdCA9IHRoaXMubm9kZWZzLmxzdGF0U3luYyhwYXRoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoIWUuY29kZSkge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IHRoaXMuRlMuRXJybm9FcnJvcih0aGlzLkVSUk5PX0NPREVTW2UuY29kZV0pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgZGV2OiBzdGF0LmRldixcbiAgICAgIGlubzogc3RhdC5pbm8sXG4gICAgICBtb2RlOiBzdGF0Lm1vZGUsXG4gICAgICBubGluazogc3RhdC5ubGluayxcbiAgICAgIHVpZDogc3RhdC51aWQsXG4gICAgICBnaWQ6IHN0YXQuZ2lkLFxuICAgICAgcmRldjogc3RhdC5yZGV2LFxuICAgICAgc2l6ZTogc3RhdC5zaXplLFxuICAgICAgYXRpbWU6IHN0YXQuYXRpbWUsXG4gICAgICBtdGltZTogc3RhdC5tdGltZSxcbiAgICAgIGN0aW1lOiBzdGF0LmN0aW1lLFxuICAgICAgYmxrc2l6ZTogc3RhdC5ibGtzaXplLFxuICAgICAgYmxvY2tzOiBzdGF0LmJsb2Nrc1xuICAgIH07XG4gIH1cblxuICBwdWJsaWMgc2V0YXR0cihub2RlOiBFbXNjcmlwdGVuRlNOb2RlLCBhdHRyOiBTdGF0cyk6IHZvaWQge1xuICAgIGNvbnN0IHBhdGggPSB0aGlzLmZzLnJlYWxQYXRoKG5vZGUpO1xuICAgIHRyeSB7XG4gICAgICBpZiAoYXR0ci5tb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5ub2RlZnMuY2htb2RTeW5jKHBhdGgsIGF0dHIubW9kZSk7XG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgY29tbW9uIG5vZGUgc3RydWN0dXJlIG1vZGUgYXMgd2VsbFxuICAgICAgICBub2RlLm1vZGUgPSBhdHRyLm1vZGU7XG4gICAgICB9XG4gICAgICBpZiAoYXR0ci50aW1lc3RhbXAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBkYXRlID0gbmV3IERhdGUoYXR0ci50aW1lc3RhbXApO1xuICAgICAgICB0aGlzLm5vZGVmcy51dGltZXNTeW5jKHBhdGgsIGRhdGUsIGRhdGUpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmICghZS5jb2RlKSB7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgICAvLyBJZ25vcmUgbm90IHN1cHBvcnRlZCBlcnJvcnMuIEVtc2NyaXB0ZW4gZG9lcyB1dGltZXNTeW5jIHdoZW4gaXRcbiAgICAgIC8vIHdyaXRlcyBmaWxlcywgYnV0IG5ldmVyIHJlYWxseSByZXF1aXJlcyB0aGUgdmFsdWUgdG8gYmUgc2V0LlxuICAgICAgaWYgKGUuY29kZSAhPT0gXCJFTk9UU1VQXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IHRoaXMuRlMuRXJybm9FcnJvcih0aGlzLkVSUk5PX0NPREVTW2UuY29kZV0pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYXR0ci5zaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMubm9kZWZzLnRydW5jYXRlU3luYyhwYXRoLCBhdHRyLnNpemUpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoIWUuY29kZSkge1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IHRoaXMuRlMuRXJybm9FcnJvcih0aGlzLkVSUk5PX0NPREVTW2UuY29kZV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBsb29rdXAocGFyZW50OiBFbXNjcmlwdGVuRlNOb2RlLCBuYW1lOiBzdHJpbmcpOiBFbXNjcmlwdGVuRlNOb2RlIHtcbiAgICBjb25zdCBwYXRoID0gdGhpcy5QQVRILmpvaW4yKHRoaXMuZnMucmVhbFBhdGgocGFyZW50KSwgbmFtZSk7XG4gICAgY29uc3QgbW9kZSA9IHRoaXMuZnMuZ2V0TW9kZShwYXRoKTtcbiAgICByZXR1cm4gdGhpcy5mcy5jcmVhdGVOb2RlKHBhcmVudCwgbmFtZSwgbW9kZSk7XG4gIH1cblxuICBwdWJsaWMgbWtub2QocGFyZW50OiBFbXNjcmlwdGVuRlNOb2RlLCBuYW1lOiBzdHJpbmcsIG1vZGU6IG51bWJlciwgZGV2OiBhbnkpOiBFbXNjcmlwdGVuRlNOb2RlIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5mcy5jcmVhdGVOb2RlKHBhcmVudCwgbmFtZSwgbW9kZSwgZGV2KTtcbiAgICAvLyBjcmVhdGUgdGhlIGJhY2tpbmcgbm9kZSBmb3IgdGhpcyBpbiB0aGUgZnMgcm9vdCBhcyB3ZWxsXG4gICAgY29uc3QgcGF0aCA9IHRoaXMuZnMucmVhbFBhdGgobm9kZSk7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0aGlzLkZTLmlzRGlyKG5vZGUubW9kZSkpIHtcbiAgICAgICAgdGhpcy5ub2RlZnMubWtkaXJTeW5jKHBhdGgsIG5vZGUubW9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm5vZGVmcy53cml0ZUZpbGVTeW5jKHBhdGgsICcnLCB7IG1vZGU6IG5vZGUubW9kZSB9KTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoIWUuY29kZSkge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IHRoaXMuRlMuRXJybm9FcnJvcih0aGlzLkVSUk5PX0NPREVTW2UuY29kZV0pO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIHB1YmxpYyByZW5hbWUob2xkTm9kZTogRW1zY3JpcHRlbkZTTm9kZSwgbmV3RGlyOiBFbXNjcmlwdGVuRlNOb2RlLCBuZXdOYW1lOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBjb25zdCBvbGRQYXRoID0gdGhpcy5mcy5yZWFsUGF0aChvbGROb2RlKTtcbiAgICBjb25zdCBuZXdQYXRoID0gdGhpcy5QQVRILmpvaW4yKHRoaXMuZnMucmVhbFBhdGgobmV3RGlyKSwgbmV3TmFtZSk7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMubm9kZWZzLnJlbmFtZVN5bmMob2xkUGF0aCwgbmV3UGF0aCk7XG4gICAgICAvLyBUaGlzIGxvZ2ljIGlzIG1pc3NpbmcgZnJvbSB0aGUgb3JpZ2luYWwgTm9kZUZTLFxuICAgICAgLy8gY2F1c2luZyBFbXNjcmlwdGVuJ3MgZmlsZXN5c3RlbSB0byB0aGluayB0aGF0IHRoZSBvbGQgZmlsZSBzdGlsbCBleGlzdHMuXG4gICAgICBvbGROb2RlLm5hbWUgPSBuZXdOYW1lO1xuICAgICAgb2xkTm9kZS5wYXJlbnQgPSBuZXdEaXI7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKCFlLmNvZGUpIHtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyB0aGlzLkZTLkVycm5vRXJyb3IodGhpcy5FUlJOT19DT0RFU1tlLmNvZGVdKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgdW5saW5rKHBhcmVudDogRW1zY3JpcHRlbkZTTm9kZSwgbmFtZTogc3RyaW5nKTogdm9pZCB7XG4gICAgY29uc3QgcGF0aCA9IHRoaXMuUEFUSC5qb2luMih0aGlzLmZzLnJlYWxQYXRoKHBhcmVudCksIG5hbWUpO1xuICAgIHRyeSB7XG4gICAgICB0aGlzLm5vZGVmcy51bmxpbmtTeW5jKHBhdGgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmICghZS5jb2RlKSB7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgdGhpcy5GUy5FcnJub0Vycm9yKHRoaXMuRVJSTk9fQ09ERVNbZS5jb2RlXSk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHJtZGlyKHBhcmVudDogRW1zY3JpcHRlbkZTTm9kZSwgbmFtZTogc3RyaW5nKSB7XG4gICAgY29uc3QgcGF0aCA9IHRoaXMuUEFUSC5qb2luMih0aGlzLmZzLnJlYWxQYXRoKHBhcmVudCksIG5hbWUpO1xuICAgIHRyeSB7XG4gICAgICB0aGlzLm5vZGVmcy5ybWRpclN5bmMocGF0aCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKCFlLmNvZGUpIHtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyB0aGlzLkZTLkVycm5vRXJyb3IodGhpcy5FUlJOT19DT0RFU1tlLmNvZGVdKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgcmVhZGRpcihub2RlOiBFbXNjcmlwdGVuRlNOb2RlKTogc3RyaW5nW10ge1xuICAgIGNvbnN0IHBhdGggPSB0aGlzLmZzLnJlYWxQYXRoKG5vZGUpO1xuICAgIHRyeSB7XG4gICAgICAvLyBOb2RlIGRvZXMgbm90IGxpc3QgLiBhbmQgLi4gaW4gZGlyZWN0b3J5IGxpc3RpbmdzLFxuICAgICAgLy8gYnV0IEVtc2NyaXB0ZW4gZXhwZWN0cyBpdC5cbiAgICAgIGNvbnN0IGNvbnRlbnRzID0gdGhpcy5ub2RlZnMucmVhZGRpclN5bmMocGF0aCk7XG4gICAgICBjb250ZW50cy5wdXNoKCcuJywgJy4uJyk7XG4gICAgICByZXR1cm4gY29udGVudHM7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKCFlLmNvZGUpIHtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyB0aGlzLkZTLkVycm5vRXJyb3IodGhpcy5FUlJOT19DT0RFU1tlLmNvZGVdKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgc3ltbGluayhwYXJlbnQ6IEVtc2NyaXB0ZW5GU05vZGUsIG5ld05hbWU6IHN0cmluZywgb2xkUGF0aDogc3RyaW5nKTogdm9pZCB7XG4gICAgY29uc3QgbmV3UGF0aCA9IHRoaXMuUEFUSC5qb2luMih0aGlzLmZzLnJlYWxQYXRoKHBhcmVudCksIG5ld05hbWUpO1xuICAgIHRyeSB7XG4gICAgICB0aGlzLm5vZGVmcy5zeW1saW5rU3luYyhvbGRQYXRoLCBuZXdQYXRoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoIWUuY29kZSkge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IHRoaXMuRlMuRXJybm9FcnJvcih0aGlzLkVSUk5PX0NPREVTW2UuY29kZV0pO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyByZWFkbGluayhub2RlOiBFbXNjcmlwdGVuRlNOb2RlKTogc3RyaW5nIHtcbiAgICBjb25zdCBwYXRoID0gdGhpcy5mcy5yZWFsUGF0aChub2RlKTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHRoaXMubm9kZWZzLnJlYWRsaW5rU3luYyhwYXRoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoIWUuY29kZSkge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IHRoaXMuRlMuRXJybm9FcnJvcih0aGlzLkVSUk5PX0NPREVTW2UuY29kZV0pO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCRlNFbXNjcmlwdGVuRlMgaW1wbGVtZW50cyBFbXNjcmlwdGVuRlMge1xuICAvLyBUaGlzIG1hcHMgdGhlIGludGVnZXIgcGVybWlzc2lvbiBtb2RlcyBmcm9tIGh0dHA6Ly9saW51eC5kaWUubmV0L21hbi8zL29wZW5cbiAgLy8gdG8gbm9kZS5qcy1zcGVjaWZpYyBmaWxlIG9wZW4gcGVybWlzc2lvbiBzdHJpbmdzIGF0IGh0dHA6Ly9ub2RlanMub3JnL2FwaS9mcy5odG1sI2ZzX2ZzX29wZW5fcGF0aF9mbGFnc19tb2RlX2NhbGxiYWNrXG4gIHB1YmxpYyBmbGFnc1RvUGVybWlzc2lvblN0cmluZ01hcCA9IHtcbiAgICAwLypPX1JET05MWSovOiAncicsXG4gICAgMS8qT19XUk9OTFkqLzogJ3IrJyxcbiAgICAyLypPX1JEV1IqLzogJ3IrJyxcbiAgICA2NC8qT19DUkVBVCovOiAncicsXG4gICAgNjUvKk9fV1JPTkxZfE9fQ1JFQVQqLzogJ3IrJyxcbiAgICA2Ni8qT19SRFdSfE9fQ1JFQVQqLzogJ3IrJyxcbiAgICAxMjkvKk9fV1JPTkxZfE9fRVhDTCovOiAncngrJyxcbiAgICAxOTMvKk9fV1JPTkxZfE9fQ1JFQVR8T19FWENMKi86ICdyeCsnLFxuICAgIDUxNC8qT19SRFdSfE9fVFJVTkMqLzogJ3crJyxcbiAgICA1NzcvKk9fV1JPTkxZfE9fQ1JFQVR8T19UUlVOQyovOiAndycsXG4gICAgNTc4LypPX0NSRUFUfE9fUkRXUnxPX1RSVU5DKi86ICd3KycsXG4gICAgNzA1LypPX1dST05MWXxPX0NSRUFUfE9fRVhDTHxPX1RSVU5DKi86ICd3eCcsXG4gICAgNzA2LypPX1JEV1J8T19DUkVBVHxPX0VYQ0x8T19UUlVOQyovOiAnd3grJyxcbiAgICAxMDI0LypPX0FQUEVORCovOiAnYScsXG4gICAgMTAyNS8qT19XUk9OTFl8T19BUFBFTkQqLzogJ2EnLFxuICAgIDEwMjYvKk9fUkRXUnxPX0FQUEVORCovOiAnYSsnLFxuICAgIDEwODkvKk9fV1JPTkxZfE9fQ1JFQVR8T19BUFBFTkQqLzogJ2EnLFxuICAgIDEwOTAvKk9fUkRXUnxPX0NSRUFUfE9fQVBQRU5EKi86ICdhKycsXG4gICAgMTE1My8qT19XUk9OTFl8T19FWENMfE9fQVBQRU5EKi86ICdheCcsXG4gICAgMTE1NC8qT19SRFdSfE9fRVhDTHxPX0FQUEVORCovOiAnYXgrJyxcbiAgICAxMjE3LypPX1dST05MWXxPX0NSRUFUfE9fRVhDTHxPX0FQUEVORCovOiAnYXgnLFxuICAgIDEyMTgvKk9fUkRXUnxPX0NSRUFUfE9fRVhDTHxPX0FQUEVORCovOiAnYXgrJyxcbiAgICA0MDk2LypPX1JET05MWXxPX0RTWU5DKi86ICdycycsXG4gICAgNDA5OC8qT19SRFdSfE9fRFNZTkMqLzogJ3JzKydcbiAgfTtcbiAgLyogdHNsaW50OmRpc2FibGU6dmFyaWFibGUtbmFtZSAqL1xuICBwdWJsaWMgbm9kZV9vcHM6IEVtc2NyaXB0ZW5Ob2RlT3BzO1xuICBwdWJsaWMgc3RyZWFtX29wczogRW1zY3JpcHRlblN0cmVhbU9wcztcbiAgLyogdHNsaW50OmVuYWJsZTp2YXJpYWJsZS1uYW1lICovXG5cbiAgcHJpdmF0ZSBGUzogYW55O1xuICBwcml2YXRlIFBBVEg6IGFueTtcbiAgcHJpdmF0ZSBFUlJOT19DT0RFUzogYW55O1xuICBwcml2YXRlIG5vZGVmczogRlM7XG4gIGNvbnN0cnVjdG9yKF9GUyA9ICg8YW55PiBzZWxmKVsnRlMnXSwgX1BBVEggPSAoPGFueT4gc2VsZilbJ1BBVEgnXSwgX0VSUk5PX0NPREVTID0gKDxhbnk+IHNlbGYpWydFUlJOT19DT0RFUyddLCBub2RlZnM6IEZTID0gZnMpIHtcbiAgICB0aGlzLm5vZGVmcyA9IG5vZGVmcztcbiAgICB0aGlzLkZTID0gX0ZTO1xuICAgIHRoaXMuUEFUSCA9IF9QQVRIO1xuICAgIHRoaXMuRVJSTk9fQ09ERVMgPSBfRVJSTk9fQ09ERVM7XG4gICAgdGhpcy5ub2RlX29wcyA9IG5ldyBCRlNFbXNjcmlwdGVuTm9kZU9wcyh0aGlzKTtcbiAgICB0aGlzLnN0cmVhbV9vcHMgPSBuZXcgQkZTRW1zY3JpcHRlblN0cmVhbU9wcyh0aGlzKTtcbiAgfVxuXG4gIHB1YmxpYyBtb3VudChtOiB7b3B0czoge3Jvb3Q6IHN0cmluZ319KTogRW1zY3JpcHRlbkZTTm9kZSB7XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlTm9kZShudWxsLCAnLycsIHRoaXMuZ2V0TW9kZShtLm9wdHMucm9vdCksIDApO1xuICB9XG5cbiAgcHVibGljIGNyZWF0ZU5vZGUocGFyZW50OiBFbXNjcmlwdGVuRlNOb2RlIHwgbnVsbCwgbmFtZTogc3RyaW5nLCBtb2RlOiBudW1iZXIsIGRldj86IGFueSk6IEVtc2NyaXB0ZW5GU05vZGUge1xuICAgIGNvbnN0IEZTID0gdGhpcy5GUztcbiAgICBpZiAoIUZTLmlzRGlyKG1vZGUpICYmICFGUy5pc0ZpbGUobW9kZSkgJiYgIUZTLmlzTGluayhtb2RlKSkge1xuICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IodGhpcy5FUlJOT19DT0RFUy5FSU5WQUwpO1xuICAgIH1cbiAgICBjb25zdCBub2RlID0gRlMuY3JlYXRlTm9kZShwYXJlbnQsIG5hbWUsIG1vZGUpO1xuICAgIG5vZGUubm9kZV9vcHMgPSB0aGlzLm5vZGVfb3BzO1xuICAgIG5vZGUuc3RyZWFtX29wcyA9IHRoaXMuc3RyZWFtX29wcztcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRNb2RlKHBhdGg6IHN0cmluZyk6IG51bWJlciB7XG4gICAgbGV0IHN0YXQ6IE5vZGVTdGF0cztcbiAgICB0cnkge1xuICAgICAgc3RhdCA9IHRoaXMubm9kZWZzLmxzdGF0U3luYyhwYXRoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoIWUuY29kZSkge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IHRoaXMuRlMuRXJybm9FcnJvcih0aGlzLkVSUk5PX0NPREVTW2UuY29kZV0pO1xuICAgIH1cbiAgICByZXR1cm4gc3RhdC5tb2RlO1xuICB9XG5cbiAgcHVibGljIHJlYWxQYXRoKG5vZGU6IEVtc2NyaXB0ZW5GU05vZGUpOiBzdHJpbmcge1xuICAgIGNvbnN0IHBhcnRzOiBzdHJpbmdbXSA9IFtdO1xuICAgIHdoaWxlIChub2RlLnBhcmVudCAhPT0gbm9kZSkge1xuICAgICAgcGFydHMucHVzaChub2RlLm5hbWUpO1xuICAgICAgbm9kZSA9IG5vZGUucGFyZW50O1xuICAgIH1cbiAgICBwYXJ0cy5wdXNoKG5vZGUubW91bnQub3B0cy5yb290KTtcbiAgICBwYXJ0cy5yZXZlcnNlKCk7XG4gICAgcmV0dXJuIHRoaXMuUEFUSC5qb2luLmFwcGx5KG51bGwsIHBhcnRzKTtcbiAgfVxuXG4gIHB1YmxpYyBmbGFnc1RvUGVybWlzc2lvblN0cmluZyhmbGFnczogc3RyaW5nIHwgbnVtYmVyKTogc3RyaW5nIHtcbiAgICBsZXQgcGFyc2VkRmxhZ3MgPSAodHlwZW9mIGZsYWdzID09PSBcInN0cmluZ1wiKSA/IHBhcnNlSW50KGZsYWdzLCAxMCkgOiBmbGFncztcbiAgICBwYXJzZWRGbGFncyAmPSAweDFGRkY7XG4gICAgaWYgKHBhcnNlZEZsYWdzIGluIHRoaXMuZmxhZ3NUb1Blcm1pc3Npb25TdHJpbmdNYXApIHtcbiAgICAgIHJldHVybiAoPGFueT4gdGhpcy5mbGFnc1RvUGVybWlzc2lvblN0cmluZ01hcClbcGFyc2VkRmxhZ3NdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gPHN0cmluZz4gZmxhZ3M7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGdldE5vZGVGUygpIHtcbiAgICByZXR1cm4gdGhpcy5ub2RlZnM7XG4gIH1cblxuICBwdWJsaWMgZ2V0RlMoKSB7XG4gICAgcmV0dXJuIHRoaXMuRlM7XG4gIH1cblxuICBwdWJsaWMgZ2V0UEFUSCgpIHtcbiAgICByZXR1cm4gdGhpcy5QQVRIO1xuICB9XG5cbiAgcHVibGljIGdldEVSUk5PX0NPREVTKCkge1xuICAgIHJldHVybiB0aGlzLkVSUk5PX0NPREVTO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vLi4vLi4vLi4vc3JjL2dlbmVyaWMvZW1zY3JpcHRlbl9mcy50cyIsImltcG9ydCB7QXBpRXJyb3IsIEVycm9yQ29kZX0gZnJvbSAnLi9hcGlfZXJyb3InO1xuaW1wb3J0IFN0YXRzIGZyb20gJy4vbm9kZV9mc19zdGF0cyc7XG5pbXBvcnQge0ZpbGV9IGZyb20gJy4vZmlsZSc7XG5pbXBvcnQge0ZpbGVGbGFnLCBBY3Rpb25UeXBlfSBmcm9tICcuL2ZpbGVfZmxhZyc7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IHtmYWlsfSBmcm9tICcuL3V0aWwnO1xuXG5leHBvcnQgdHlwZSBCRlNPbmVBcmdDYWxsYmFjayA9IChlPzogQXBpRXJyb3IgfCBudWxsKSA9PiBhbnk7XG5leHBvcnQgdHlwZSBCRlNDYWxsYmFjazxUPiA9IChlOiBBcGlFcnJvciB8IG51bGwgfCB1bmRlZmluZWQsIHJ2PzogVCkgPT4gYW55O1xuZXhwb3J0IHR5cGUgQkZTVGhyZWVBcmdDYWxsYmFjazxULCBVPiA9XG4gIChlOiBBcGlFcnJvciB8IG51bGwgfCB1bmRlZmluZWQsIGFyZzE/OiBULCBhcmcyPzogVSkgPT4gYW55O1xuXG4vKipcbiAqIEludGVyZmFjZSBmb3IgYSBmaWxlc3lzdGVtLiAqKkFsbCoqIEJyb3dzZXJGUyBGaWxlU3lzdGVtcyBzaG91bGQgaW1wbGVtZW50XG4gKiB0aGlzIGludGVyZmFjZS5cbiAqXG4gKiBCZWxvdywgd2UgZGVub3RlIGVhY2ggQVBJIG1ldGhvZCBhcyAqKkNvcmUqKiwgKipTdXBwbGVtZW50YWwqKiwgb3JcbiAqICoqT3B0aW9uYWwqKi5cbiAqXG4gKiAjIyMgQ29yZSBNZXRob2RzXG4gKlxuICogKipDb3JlKiogQVBJIG1ldGhvZHMgKm5lZWQqIHRvIGJlIGltcGxlbWVudGVkIGZvciBiYXNpYyByZWFkL3dyaXRlXG4gKiBmdW5jdGlvbmFsaXR5LlxuICpcbiAqIE5vdGUgdGhhdCByZWFkLW9ubHkgRmlsZVN5c3RlbXMgY2FuIGNob29zZSB0byBub3QgaW1wbGVtZW50IGNvcmUgbWV0aG9kc1xuICogdGhhdCBtdXRhdGUgZmlsZXMgb3IgbWV0YWRhdGEuIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIHdpbGwgcGFzcyBhXG4gKiBOT1RfU1VQUE9SVEVEIGVycm9yIHRvIHRoZSBjYWxsYmFjay5cbiAqXG4gKiAjIyMgU3VwcGxlbWVudGFsIE1ldGhvZHNcbiAqXG4gKiAqKlN1cHBsZW1lbnRhbCoqIEFQSSBtZXRob2RzIGRvIG5vdCBuZWVkIHRvIGJlIGltcGxlbWVudGVkIGJ5IGEgZmlsZXN5c3RlbS5cbiAqIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIGltcGxlbWVudHMgYWxsIG9mIHRoZSBzdXBwbGVtZW50YWwgQVBJIG1ldGhvZHMgaW5cbiAqIHRlcm1zIG9mIHRoZSAqKmNvcmUqKiBBUEkgbWV0aG9kcy5cbiAqXG4gKiBOb3RlIHRoYXQgYSBmaWxlIHN5c3RlbSBtYXkgY2hvb3NlIHRvIGltcGxlbWVudCBzdXBwbGVtZW50YWwgbWV0aG9kcyBmb3JcbiAqIGVmZmljaWVuY3kgcmVhc29ucy5cbiAqXG4gKiBUaGUgY29kZSBmb3Igc29tZSBzdXBwbGVtZW50YWwgbWV0aG9kcyB3YXMgYWRhcHRlZCBkaXJlY3RseSBmcm9tIE5vZGVKUydzXG4gKiBmcy5qcyBzb3VyY2UgY29kZS5cbiAqXG4gKiAjIyMgT3B0aW9uYWwgTWV0aG9kc1xuICpcbiAqICoqT3B0aW9uYWwqKiBBUEkgbWV0aG9kcyBwcm92aWRlIGZ1bmN0aW9uYWxpdHkgdGhhdCBtYXkgbm90IGJlIGF2YWlsYWJsZSBpblxuICogYWxsIGZpbGVzeXN0ZW1zLiBGb3IgZXhhbXBsZSwgYWxsIHN5bWxpbmsvaGFyZGxpbmstcmVsYXRlZCBBUEkgbWV0aG9kcyBmYWxsXG4gKiB1bmRlciB0aGlzIGNhdGVnb3J5LlxuICpcbiAqIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIHdpbGwgcGFzcyBhIE5PVF9TVVBQT1JURUQgZXJyb3IgdG8gdGhlIGNhbGxiYWNrLlxuICpcbiAqICMjIyBBcmd1bWVudCBBc3N1bXB0aW9uc1xuICpcbiAqIFlvdSBjYW4gYXNzdW1lIHRoZSBmb2xsb3dpbmcgYWJvdXQgYXJndW1lbnRzIHBhc3NlZCB0byBlYWNoIEFQSSBtZXRob2Q6XG4gKlxuICogKiAqKkV2ZXJ5IHBhdGggaXMgYW4gYWJzb2x1dGUgcGF0aC4qKiBNZWFuaW5nLCBgLmAsIGAuLmAsIGFuZCBvdGhlciBpdGVtc1xuICogICBhcmUgcmVzb2x2ZWQgaW50byBhbiBhYnNvbHV0ZSBmb3JtLlxuICogKiAqKkFsbCBhcmd1bWVudHMgYXJlIHByZXNlbnQuKiogQW55IG9wdGlvbmFsIGFyZ3VtZW50cyBhdCB0aGUgTm9kZSBBUEkgbGV2ZWxcbiAqICAgaGF2ZSBiZWVuIHBhc3NlZCBpbiB3aXRoIHRoZWlyIGRlZmF1bHQgdmFsdWVzLlxuICogKiAqKlRoZSBjYWxsYmFjayB3aWxsIHJlc2V0IHRoZSBzdGFjayBkZXB0aC4qKiBXaGVuIHlvdXIgZmlsZXN5c3RlbSBjYWxscyB0aGVcbiAqICAgY2FsbGJhY2sgd2l0aCB0aGUgcmVxdWVzdGVkIGluZm9ybWF0aW9uLCBpdCB3aWxsIHVzZSBgc2V0SW1tZWRpYXRlYCB0b1xuICogICByZXNldCB0aGUgSmF2YVNjcmlwdCBzdGFjayBkZXB0aCBiZWZvcmUgY2FsbGluZyB0aGUgdXNlci1zdXBwbGllZCBjYWxsYmFjay5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBGaWxlU3lzdGVtIHtcbiAgLyoqXG4gICAqICoqT3B0aW9uYWwqKjogUmV0dXJucyB0aGUgbmFtZSBvZiB0aGUgZmlsZSBzeXN0ZW0uXG4gICAqL1xuICBnZXROYW1lKCk6IHN0cmluZztcbiAgLyoqXG4gICAqICoqT3B0aW9uYWwqKjogUGFzc2VzIHRoZSBmb2xsb3dpbmcgaW5mb3JtYXRpb24gdG8gdGhlIGNhbGxiYWNrOlxuICAgKlxuICAgKiAqIFRvdGFsIG51bWJlciBvZiBieXRlcyBhdmFpbGFibGUgb24gdGhpcyBmaWxlIHN5c3RlbS5cbiAgICogKiBudW1iZXIgb2YgZnJlZSBieXRlcyBhdmFpbGFibGUgb24gdGhpcyBmaWxlIHN5c3RlbS5cbiAgICpcbiAgICogQHRvZG8gVGhpcyBpbmZvIGlzIG5vdCBhdmFpbGFibGUgdGhyb3VnaCB0aGUgTm9kZSBBUEkuIFBlcmhhcHMgd2UgY291bGQgZG8gYVxuICAgKiAgIHBvbHlmaWxsIG9mIGRpc2tzcGFjZS5qcywgb3IgYWRkIGEgbmV3IE5vZGUgQVBJIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0gcGF0aCBUaGUgcGF0aCB0byB0aGUgbG9jYXRpb24gdGhhdCBpcyBiZWluZyBxdWVyaWVkLiBPbmx5XG4gICAqICAgdXNlZnVsIGZvciBmaWxlc3lzdGVtcyB0aGF0IHN1cHBvcnQgbW91bnQgcG9pbnRzLlxuICAgKi9cbiAgZGlza1NwYWNlKHA6IHN0cmluZywgY2I6ICh0b3RhbDogbnVtYmVyLCBmcmVlOiBudW1iZXIpID0+IGFueSk6IHZvaWQ7XG4gIC8qKlxuICAgKiAqKkNvcmUqKjogSXMgdGhpcyBmaWxlc3lzdGVtIHJlYWQtb25seT9cbiAgICogQHJldHVybiBUcnVlIGlmIHRoaXMgRmlsZVN5c3RlbSBpcyBpbmhlcmVudGx5IHJlYWQtb25seS5cbiAgICovXG4gIGlzUmVhZE9ubHkoKTogYm9vbGVhbjtcbiAgLyoqXG4gICAqICoqQ29yZSoqOiBEb2VzIHRoZSBmaWxlc3lzdGVtIHN1cHBvcnQgb3B0aW9uYWwgc3ltbGluay9oYXJkbGluay1yZWxhdGVkXG4gICAqICAgY29tbWFuZHM/XG4gICAqIEByZXR1cm4gVHJ1ZSBpZiB0aGUgRmlsZVN5c3RlbSBzdXBwb3J0cyB0aGUgb3B0aW9uYWxcbiAgICogICBzeW1saW5rL2hhcmRsaW5rLXJlbGF0ZWQgY29tbWFuZHMuXG4gICAqL1xuICBzdXBwb3J0c0xpbmtzKCk6IGJvb2xlYW47XG4gIC8qKlxuICAgKiAqKkNvcmUqKjogRG9lcyB0aGUgZmlsZXN5c3RlbSBzdXBwb3J0IG9wdGlvbmFsIHByb3BlcnR5LXJlbGF0ZWQgY29tbWFuZHM/XG4gICAqIEByZXR1cm4gVHJ1ZSBpZiB0aGUgRmlsZVN5c3RlbSBzdXBwb3J0cyB0aGUgb3B0aW9uYWxcbiAgICogICBwcm9wZXJ0eS1yZWxhdGVkIGNvbW1hbmRzIChwZXJtaXNzaW9ucywgdXRpbWVzLCBldGMpLlxuICAgKi9cbiAgc3VwcG9ydHNQcm9wcygpOiBib29sZWFuO1xuICAvKipcbiAgICogKipDb3JlKio6IERvZXMgdGhlIGZpbGVzeXN0ZW0gc3VwcG9ydCB0aGUgb3B0aW9uYWwgc3luY2hyb25vdXMgaW50ZXJmYWNlP1xuICAgKiBAcmV0dXJuIFRydWUgaWYgdGhlIEZpbGVTeXN0ZW0gc3VwcG9ydHMgc3luY2hyb25vdXMgb3BlcmF0aW9ucy5cbiAgICovXG4gIHN1cHBvcnRzU3luY2goKTogYm9vbGVhbjtcbiAgLy8gKipDT1JFIEFQSSBNRVRIT0RTKipcbiAgLy8gRmlsZSBvciBkaXJlY3Rvcnkgb3BlcmF0aW9uc1xuICAvKipcbiAgICogKipDb3JlKio6IEFzeW5jaHJvbm91cyByZW5hbWUuIE5vIGFyZ3VtZW50cyBvdGhlciB0aGFuIGEgcG9zc2libGUgZXhjZXB0aW9uXG4gICAqIGFyZSBnaXZlbiB0byB0aGUgY29tcGxldGlvbiBjYWxsYmFjay5cbiAgICovXG4gIHJlbmFtZShvbGRQYXRoOiBzdHJpbmcsIG5ld1BhdGg6IHN0cmluZywgY2I6IEJGU09uZUFyZ0NhbGxiYWNrKTogdm9pZDtcbiAgLyoqXG4gICAqICoqQ29yZSoqOiBTeW5jaHJvbm91cyByZW5hbWUuXG4gICAqL1xuICByZW5hbWVTeW5jKG9sZFBhdGg6IHN0cmluZywgbmV3UGF0aDogc3RyaW5nKTogdm9pZDtcbiAgLyoqXG4gICAqICoqQ29yZSoqOiBBc3luY2hyb25vdXMgYHN0YXRgIG9yIGBsc3RhdGAuXG4gICAqIEBwYXJhbSBpc0xzdGF0IFRydWUgaWYgdGhpcyBpcyBgbHN0YXRgLCBmYWxzZSBpZiB0aGlzIGlzIHJlZ3VsYXJcbiAgICogICBgc3RhdGAuXG4gICAqL1xuICBzdGF0KHA6IHN0cmluZywgaXNMc3RhdDogYm9vbGVhbiB8IG51bGwsIGNiOiBCRlNDYWxsYmFjazxTdGF0cz4pOiB2b2lkO1xuICAvKipcbiAgICogKipDb3JlKio6IFN5bmNocm9ub3VzIGBzdGF0YCBvciBgbHN0YXRgLlxuICAgKiBAcGFyYW0gaXNMc3RhdCBUcnVlIGlmIHRoaXMgaXMgYGxzdGF0YCwgZmFsc2UgaWYgdGhpcyBpcyByZWd1bGFyXG4gICAqICAgYHN0YXRgLlxuICAgKi9cbiAgc3RhdFN5bmMocDogc3RyaW5nLCBpc0xzdGF0OiBib29sZWFuIHwgbnVsbCk6IFN0YXRzO1xuICAvLyBGaWxlIG9wZXJhdGlvbnNcbiAgLyoqXG4gICAqICoqQ29yZSoqOiBBc3luY2hyb25vdXMgZmlsZSBvcGVuLlxuICAgKiBAc2VlIGh0dHA6Ly93d3cubWFucGFnZXouY29tL21hbi8yL29wZW4vXG4gICAqIEBwYXJhbSBmbGFncyBIYW5kbGVzIHRoZSBjb21wbGV4aXR5IG9mIHRoZSB2YXJpb3VzIGZpbGVcbiAgICogICBtb2Rlcy4gU2VlIGl0cyBBUEkgZm9yIG1vcmUgZGV0YWlscy5cbiAgICogQHBhcmFtIG1vZGUgTW9kZSB0byB1c2UgdG8gb3BlbiB0aGUgZmlsZS4gQ2FuIGJlIGlnbm9yZWQgaWYgdGhlXG4gICAqICAgZmlsZXN5c3RlbSBkb2Vzbid0IHN1cHBvcnQgcGVybWlzc2lvbnMuXG4gICAqL1xuICBvcGVuKHA6IHN0cmluZywgZmxhZzogRmlsZUZsYWcsIG1vZGU6IG51bWJlciwgY2I6IEJGU0NhbGxiYWNrPEZpbGU+KTogdm9pZDtcbiAgLyoqXG4gICAqICoqQ29yZSoqOiBTeW5jaHJvbm91cyBmaWxlIG9wZW4uXG4gICAqIEBzZWUgaHR0cDovL3d3dy5tYW5wYWdlei5jb20vbWFuLzIvb3Blbi9cbiAgICogQHBhcmFtIGZsYWdzIEhhbmRsZXMgdGhlIGNvbXBsZXhpdHkgb2YgdGhlIHZhcmlvdXMgZmlsZVxuICAgKiAgIG1vZGVzLiBTZWUgaXRzIEFQSSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgKiBAcGFyYW0gbW9kZSBNb2RlIHRvIHVzZSB0byBvcGVuIHRoZSBmaWxlLiBDYW4gYmUgaWdub3JlZCBpZiB0aGVcbiAgICogICBmaWxlc3lzdGVtIGRvZXNuJ3Qgc3VwcG9ydCBwZXJtaXNzaW9ucy5cbiAgICovXG4gIG9wZW5TeW5jKHA6IHN0cmluZywgZmxhZzogRmlsZUZsYWcsIG1vZGU6IG51bWJlcik6IEZpbGU7XG4gIC8qKlxuICAgKiAqKkNvcmUqKjogQXN5bmNocm9ub3VzIGB1bmxpbmtgLlxuICAgKi9cbiAgdW5saW5rKHA6IHN0cmluZywgY2I6IEJGU09uZUFyZ0NhbGxiYWNrKTogdm9pZDtcbiAgLyoqXG4gICAqICoqQ29yZSoqOiBTeW5jaHJvbm91cyBgdW5saW5rYC5cbiAgICovXG4gIHVubGlua1N5bmMocDogc3RyaW5nKTogdm9pZDtcbiAgLy8gRGlyZWN0b3J5IG9wZXJhdGlvbnNcbiAgLyoqXG4gICAqICoqQ29yZSoqOiBBc3luY2hyb25vdXMgYHJtZGlyYC5cbiAgICovXG4gIHJtZGlyKHA6IHN0cmluZywgY2I6IEJGU09uZUFyZ0NhbGxiYWNrKTogdm9pZDtcbiAgLyoqXG4gICAqICoqQ29yZSoqOiBTeW5jaHJvbm91cyBgcm1kaXJgLlxuICAgKi9cbiAgcm1kaXJTeW5jKHA6IHN0cmluZyk6IHZvaWQ7XG4gIC8qKlxuICAgKiAqKkNvcmUqKjogQXN5bmNocm9ub3VzIGBta2RpcmAuXG4gICAqIEBwYXJhbSBtb2RlIE1vZGUgdG8gbWFrZSB0aGUgZGlyZWN0b3J5IHVzaW5nLiBDYW4gYmUgaWdub3JlZCBpZlxuICAgKiAgIHRoZSBmaWxlc3lzdGVtIGRvZXNuJ3Qgc3VwcG9ydCBwZXJtaXNzaW9ucy5cbiAgICovXG4gIG1rZGlyKHA6IHN0cmluZywgbW9kZTogbnVtYmVyLCBjYjogQkZTT25lQXJnQ2FsbGJhY2spOiB2b2lkO1xuICAvKipcbiAgICogKipDb3JlKio6IFN5bmNocm9ub3VzIGBta2RpcmAuXG4gICAqIEBwYXJhbSBtb2RlIE1vZGUgdG8gbWFrZSB0aGUgZGlyZWN0b3J5IHVzaW5nLiBDYW4gYmUgaWdub3JlZCBpZlxuICAgKiAgIHRoZSBmaWxlc3lzdGVtIGRvZXNuJ3Qgc3VwcG9ydCBwZXJtaXNzaW9ucy5cbiAgICovXG4gIG1rZGlyU3luYyhwOiBzdHJpbmcsIG1vZGU6IG51bWJlcik6IHZvaWQ7XG4gIC8qKlxuICAgKiAqKkNvcmUqKjogQXN5bmNocm9ub3VzIGByZWFkZGlyYC4gUmVhZHMgdGhlIGNvbnRlbnRzIG9mIGEgZGlyZWN0b3J5LlxuICAgKlxuICAgKiBUaGUgY2FsbGJhY2sgZ2V0cyB0d28gYXJndW1lbnRzIGAoZXJyLCBmaWxlcylgIHdoZXJlIGBmaWxlc2AgaXMgYW4gYXJyYXkgb2ZcbiAgICogdGhlIG5hbWVzIG9mIHRoZSBmaWxlcyBpbiB0aGUgZGlyZWN0b3J5IGV4Y2x1ZGluZyBgJy4nYCBhbmQgYCcuLidgLlxuICAgKi9cbiAgcmVhZGRpcihwOiBzdHJpbmcsIGNiOiBCRlNDYWxsYmFjazxzdHJpbmdbXT4pOiB2b2lkO1xuICAvKipcbiAgICogKipDb3JlKio6IFN5bmNocm9ub3VzIGByZWFkZGlyYC4gUmVhZHMgdGhlIGNvbnRlbnRzIG9mIGEgZGlyZWN0b3J5LlxuICAgKi9cbiAgcmVhZGRpclN5bmMocDogc3RyaW5nKTogc3RyaW5nW107XG4gIC8vICoqU1VQUExFTUVOVEFMIElOVEVSRkFDRSBNRVRIT0RTKipcbiAgLy8gRmlsZSBvciBkaXJlY3Rvcnkgb3BlcmF0aW9uc1xuICAvKipcbiAgICogKipTdXBwbGVtZW50YWwqKjogVGVzdCB3aGV0aGVyIG9yIG5vdCB0aGUgZ2l2ZW4gcGF0aCBleGlzdHMgYnkgY2hlY2tpbmcgd2l0aFxuICAgKiB0aGUgZmlsZSBzeXN0ZW0uIFRoZW4gY2FsbCB0aGUgY2FsbGJhY2sgYXJndW1lbnQgd2l0aCBlaXRoZXIgdHJ1ZSBvciBmYWxzZS5cbiAgICovXG4gIGV4aXN0cyhwOiBzdHJpbmcsIGNiOiAoZXhpc3RzOiBib29sZWFuKSA9PiB2b2lkKTogdm9pZDtcbiAgLyoqXG4gICAqICoqU3VwcGxlbWVudGFsKio6IFRlc3Qgd2hldGhlciBvciBub3QgdGhlIGdpdmVuIHBhdGggZXhpc3RzIGJ5IGNoZWNraW5nIHdpdGhcbiAgICogdGhlIGZpbGUgc3lzdGVtLlxuICAgKi9cbiAgZXhpc3RzU3luYyhwOiBzdHJpbmcpOiBib29sZWFuO1xuICAvKipcbiAgICogKipTdXBwbGVtZW50YWwqKjogQXN5bmNocm9ub3VzIGByZWFscGF0aGAuIFRoZSBjYWxsYmFjayBnZXRzIHR3byBhcmd1bWVudHNcbiAgICogYChlcnIsIHJlc29sdmVkUGF0aClgLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgdGhlIE5vZGUgQVBJIHdpbGwgcmVzb2x2ZSBgcGF0aGAgdG8gYW4gYWJzb2x1dGUgcGF0aC5cbiAgICogQHBhcmFtIGNhY2hlIEFuIG9iamVjdCBsaXRlcmFsIG9mIG1hcHBlZCBwYXRocyB0aGF0IGNhbiBiZSB1c2VkIHRvXG4gICAqICAgZm9yY2UgYSBzcGVjaWZpYyBwYXRoIHJlc29sdXRpb24gb3IgYXZvaWQgYWRkaXRpb25hbCBgZnMuc3RhdGAgY2FsbHMgZm9yXG4gICAqICAga25vd24gcmVhbCBwYXRocy4gSWYgbm90IHN1cHBsaWVkIGJ5IHRoZSB1c2VyLCBpdCdsbCBiZSBhbiBlbXB0eSBvYmplY3QuXG4gICAqL1xuICByZWFscGF0aChwOiBzdHJpbmcsIGNhY2hlOiB7W3BhdGg6IHN0cmluZ106IHN0cmluZ30sIGNiOiBCRlNDYWxsYmFjazxzdHJpbmc+KTogdm9pZDtcbiAgLyoqXG4gICAqICoqU3VwcGxlbWVudGFsKio6IFN5bmNocm9ub3VzIGByZWFscGF0aGAuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGUgTm9kZSBBUEkgd2lsbCByZXNvbHZlIGBwYXRoYCB0byBhbiBhYnNvbHV0ZSBwYXRoLlxuICAgKiBAcGFyYW0gY2FjaGUgQW4gb2JqZWN0IGxpdGVyYWwgb2YgbWFwcGVkIHBhdGhzIHRoYXQgY2FuIGJlIHVzZWQgdG9cbiAgICogICBmb3JjZSBhIHNwZWNpZmljIHBhdGggcmVzb2x1dGlvbiBvciBhdm9pZCBhZGRpdGlvbmFsIGBmcy5zdGF0YCBjYWxscyBmb3JcbiAgICogICBrbm93biByZWFsIHBhdGhzLiBJZiBub3Qgc3VwcGxpZWQgYnkgdGhlIHVzZXIsIGl0J2xsIGJlIGFuIGVtcHR5IG9iamVjdC5cbiAgICovXG4gIHJlYWxwYXRoU3luYyhwOiBzdHJpbmcsIGNhY2hlOiB7W3BhdGg6IHN0cmluZ106IHN0cmluZ30pOiBzdHJpbmc7XG4gIC8vIEZpbGUgb3BlcmF0aW9uc1xuICAvKipcbiAgICogKipTdXBwbGVtZW50YWwqKjogQXN5bmNocm9ub3VzIGB0cnVuY2F0ZWAuXG4gICAqL1xuICB0cnVuY2F0ZShwOiBzdHJpbmcsIGxlbjogbnVtYmVyLCBjYjogQkZTT25lQXJnQ2FsbGJhY2spOiB2b2lkO1xuICAvKipcbiAgICogKipTdXBwbGVtZW50YWwqKjogU3luY2hyb25vdXMgYHRydW5jYXRlYC5cbiAgICovXG4gIHRydW5jYXRlU3luYyhwOiBzdHJpbmcsIGxlbjogbnVtYmVyKTogdm9pZDtcbiAgLyoqXG4gICAqICoqU3VwcGxlbWVudGFsKio6IEFzeW5jaHJvbm91c2x5IHJlYWRzIHRoZSBlbnRpcmUgY29udGVudHMgb2YgYSBmaWxlLlxuICAgKiBAcGFyYW0gZW5jb2RpbmcgSWYgbm9uLW51bGwsIHRoZSBmaWxlJ3MgY29udGVudHMgc2hvdWxkIGJlIGRlY29kZWRcbiAgICogICBpbnRvIGEgc3RyaW5nIHVzaW5nIHRoYXQgZW5jb2RpbmcuIE90aGVyd2lzZSwgaWYgZW5jb2RpbmcgaXMgbnVsbCwgZmV0Y2hcbiAgICogICB0aGUgZmlsZSdzIGNvbnRlbnRzIGFzIGEgQnVmZmVyLlxuICAgKiBAcGFyYW0gY2IgSWYgbm8gZW5jb2RpbmcgaXMgc3BlY2lmaWVkLCB0aGVuIHRoZSByYXcgYnVmZmVyIGlzIHJldHVybmVkLlxuICAgKi9cbiAgcmVhZEZpbGUoZm5hbWU6IHN0cmluZywgZW5jb2Rpbmc6IHN0cmluZyB8IG51bGwsIGZsYWc6IEZpbGVGbGFnLCBjYjogQkZTQ2FsbGJhY2s8c3RyaW5nIHwgQnVmZmVyPik6IHZvaWQ7XG4gIC8qKlxuICAgKiAqKlN1cHBsZW1lbnRhbCoqOiBTeW5jaHJvbm91c2x5IHJlYWRzIHRoZSBlbnRpcmUgY29udGVudHMgb2YgYSBmaWxlLlxuICAgKiBAcGFyYW0gZW5jb2RpbmcgSWYgbm9uLW51bGwsIHRoZSBmaWxlJ3MgY29udGVudHMgc2hvdWxkIGJlIGRlY29kZWRcbiAgICogICBpbnRvIGEgc3RyaW5nIHVzaW5nIHRoYXQgZW5jb2RpbmcuIE90aGVyd2lzZSwgaWYgZW5jb2RpbmcgaXMgbnVsbCwgZmV0Y2hcbiAgICogICB0aGUgZmlsZSdzIGNvbnRlbnRzIGFzIGEgQnVmZmVyLlxuICAgKi9cbiAgcmVhZEZpbGVTeW5jKGZuYW1lOiBzdHJpbmcsIGVuY29kaW5nOiBzdHJpbmcgfCBudWxsLCBmbGFnOiBGaWxlRmxhZyk6IGFueTtcbiAgLyoqXG4gICAqICoqU3VwcGxlbWVudGFsKio6IEFzeW5jaHJvbm91c2x5IHdyaXRlcyBkYXRhIHRvIGEgZmlsZSwgcmVwbGFjaW5nIHRoZSBmaWxlXG4gICAqIGlmIGl0IGFscmVhZHkgZXhpc3RzLlxuICAgKlxuICAgKiBUaGUgZW5jb2Rpbmcgb3B0aW9uIGlzIGlnbm9yZWQgaWYgZGF0YSBpcyBhIGJ1ZmZlci5cbiAgICovXG4gIHdyaXRlRmlsZShmbmFtZTogc3RyaW5nLCBkYXRhOiBhbnksIGVuY29kaW5nOiBzdHJpbmcgfCBudWxsLCBmbGFnOiBGaWxlRmxhZywgbW9kZTogbnVtYmVyLCBjYjogQkZTT25lQXJnQ2FsbGJhY2spOiB2b2lkO1xuICAvKipcbiAgICogKipTdXBwbGVtZW50YWwqKjogU3luY2hyb25vdXNseSB3cml0ZXMgZGF0YSB0byBhIGZpbGUsIHJlcGxhY2luZyB0aGUgZmlsZVxuICAgKiBpZiBpdCBhbHJlYWR5IGV4aXN0cy5cbiAgICpcbiAgICogVGhlIGVuY29kaW5nIG9wdGlvbiBpcyBpZ25vcmVkIGlmIGRhdGEgaXMgYSBidWZmZXIuXG4gICAqL1xuICB3cml0ZUZpbGVTeW5jKGZuYW1lOiBzdHJpbmcsIGRhdGE6IHN0cmluZyB8IEJ1ZmZlciwgZW5jb2Rpbmc6IHN0cmluZyB8IG51bGwsIGZsYWc6IEZpbGVGbGFnLCBtb2RlOiBudW1iZXIpOiB2b2lkO1xuICAvKipcbiAgICogKipTdXBwbGVtZW50YWwqKjogQXN5bmNocm9ub3VzbHkgYXBwZW5kIGRhdGEgdG8gYSBmaWxlLCBjcmVhdGluZyB0aGUgZmlsZSBpZlxuICAgKiBpdCBub3QgeWV0IGV4aXN0cy5cbiAgICovXG4gIGFwcGVuZEZpbGUoZm5hbWU6IHN0cmluZywgZGF0YTogc3RyaW5nIHwgQnVmZmVyLCBlbmNvZGluZzogc3RyaW5nIHwgbnVsbCwgZmxhZzogRmlsZUZsYWcsIG1vZGU6IG51bWJlciwgY2I6IEJGU09uZUFyZ0NhbGxiYWNrKTogdm9pZDtcbiAgLyoqXG4gICAqICoqU3VwcGxlbWVudGFsKio6IFN5bmNocm9ub3VzbHkgYXBwZW5kIGRhdGEgdG8gYSBmaWxlLCBjcmVhdGluZyB0aGUgZmlsZSBpZlxuICAgKiBpdCBub3QgeWV0IGV4aXN0cy5cbiAgICovXG4gIGFwcGVuZEZpbGVTeW5jKGZuYW1lOiBzdHJpbmcsIGRhdGE6IHN0cmluZyB8IEJ1ZmZlciwgZW5jb2Rpbmc6IHN0cmluZyB8IG51bGwsIGZsYWc6IEZpbGVGbGFnLCBtb2RlOiBudW1iZXIpOiB2b2lkO1xuICAvLyAqKk9QVElPTkFMIElOVEVSRkFDRSBNRVRIT0RTKipcbiAgLy8gUHJvcGVydHkgb3BlcmF0aW9uc1xuICAvLyBUaGlzIGlzbid0IGFsd2F5cyBwb3NzaWJsZSBvbiBzb21lIGZpbGVzeXN0ZW0gdHlwZXMgKGUuZy4gRHJvcGJveCkuXG4gIC8qKlxuICAgKiAqKk9wdGlvbmFsKio6IEFzeW5jaHJvbm91cyBgY2htb2RgIG9yIGBsY2htb2RgLlxuICAgKiBAcGFyYW0gaXNMY2htb2QgYFRydWVgIGlmIGBsY2htb2RgLCBmYWxzZSBpZiBgY2htb2RgLiBIYXMgbm9cbiAgICogICBiZWFyaW5nIG9uIHJlc3VsdCBpZiBsaW5rcyBhcmVuJ3Qgc3VwcG9ydGVkLlxuICAgKi9cbiAgY2htb2QocDogc3RyaW5nLCBpc0xjaG1vZDogYm9vbGVhbiwgbW9kZTogbnVtYmVyLCBjYjogQkZTT25lQXJnQ2FsbGJhY2spOiB2b2lkO1xuICAvKipcbiAgICogKipPcHRpb25hbCoqOiBTeW5jaHJvbm91cyBgY2htb2RgIG9yIGBsY2htb2RgLlxuICAgKiBAcGFyYW0gaXNMY2htb2QgYFRydWVgIGlmIGBsY2htb2RgLCBmYWxzZSBpZiBgY2htb2RgLiBIYXMgbm9cbiAgICogICBiZWFyaW5nIG9uIHJlc3VsdCBpZiBsaW5rcyBhcmVuJ3Qgc3VwcG9ydGVkLlxuICAgKi9cbiAgY2htb2RTeW5jKHA6IHN0cmluZywgaXNMY2htb2Q6IGJvb2xlYW4sIG1vZGU6IG51bWJlcik6IHZvaWQ7XG4gIC8qKlxuICAgKiAqKk9wdGlvbmFsKio6IEFzeW5jaHJvbm91cyBgY2hvd25gIG9yIGBsY2hvd25gLlxuICAgKiBAcGFyYW0gaXNMY2hvd24gYFRydWVgIGlmIGBsY2hvd25gLCBmYWxzZSBpZiBgY2hvd25gLiBIYXMgbm9cbiAgICogICBiZWFyaW5nIG9uIHJlc3VsdCBpZiBsaW5rcyBhcmVuJ3Qgc3VwcG9ydGVkLlxuICAgKi9cbiAgY2hvd24ocDogc3RyaW5nLCBpc0xjaG93bjogYm9vbGVhbiwgdWlkOiBudW1iZXIsIGdpZDogbnVtYmVyLCBjYjogQkZTT25lQXJnQ2FsbGJhY2spOiB2b2lkO1xuICAvKipcbiAgICogKipPcHRpb25hbCoqOiBTeW5jaHJvbm91cyBgY2hvd25gIG9yIGBsY2hvd25gLlxuICAgKiBAcGFyYW0gaXNMY2hvd24gYFRydWVgIGlmIGBsY2hvd25gLCBmYWxzZSBpZiBgY2hvd25gLiBIYXMgbm9cbiAgICogICBiZWFyaW5nIG9uIHJlc3VsdCBpZiBsaW5rcyBhcmVuJ3Qgc3VwcG9ydGVkLlxuICAgKi9cbiAgY2hvd25TeW5jKHA6IHN0cmluZywgaXNMY2hvd246IGJvb2xlYW4sIHVpZDogbnVtYmVyLCBnaWQ6IG51bWJlcik6IHZvaWQ7XG4gIC8qKlxuICAgKiAqKk9wdGlvbmFsKio6IENoYW5nZSBmaWxlIHRpbWVzdGFtcHMgb2YgdGhlIGZpbGUgcmVmZXJlbmNlZCBieSB0aGUgc3VwcGxpZWRcbiAgICogcGF0aC5cbiAgICovXG4gIHV0aW1lcyhwOiBzdHJpbmcsIGF0aW1lOiBEYXRlLCBtdGltZTogRGF0ZSwgY2I6IEJGU09uZUFyZ0NhbGxiYWNrKTogdm9pZDtcbiAgLyoqXG4gICAqICoqT3B0aW9uYWwqKjogQ2hhbmdlIGZpbGUgdGltZXN0YW1wcyBvZiB0aGUgZmlsZSByZWZlcmVuY2VkIGJ5IHRoZSBzdXBwbGllZFxuICAgKiBwYXRoLlxuICAgKi9cbiAgdXRpbWVzU3luYyhwOiBzdHJpbmcsIGF0aW1lOiBEYXRlLCBtdGltZTogRGF0ZSk6IHZvaWQ7XG4gIC8vIFN5bWxpbmsgb3BlcmF0aW9uc1xuICAvLyBTeW1saW5rcyBhcmVuJ3QgYWx3YXlzIHN1cHBvcnRlZC5cbiAgLyoqXG4gICAqICoqT3B0aW9uYWwqKjogQXN5bmNocm9ub3VzIGBsaW5rYC5cbiAgICovXG4gIGxpbmsoc3JjcGF0aDogc3RyaW5nLCBkc3RwYXRoOiBzdHJpbmcsIGNiOiBCRlNPbmVBcmdDYWxsYmFjayk6IHZvaWQ7XG4gIC8qKlxuICAgKiAqKk9wdGlvbmFsKio6IFN5bmNocm9ub3VzIGBsaW5rYC5cbiAgICovXG4gIGxpbmtTeW5jKHNyY3BhdGg6IHN0cmluZywgZHN0cGF0aDogc3RyaW5nKTogdm9pZDtcbiAgLyoqXG4gICAqICoqT3B0aW9uYWwqKjogQXN5bmNocm9ub3VzIGBzeW1saW5rYC5cbiAgICogQHBhcmFtIHR5cGUgY2FuIGJlIGVpdGhlciBgJ2RpcidgIG9yIGAnZmlsZSdgXG4gICAqL1xuICBzeW1saW5rKHNyY3BhdGg6IHN0cmluZywgZHN0cGF0aDogc3RyaW5nLCB0eXBlOiBzdHJpbmcsIGNiOiBCRlNPbmVBcmdDYWxsYmFjayk6IHZvaWQ7XG4gIC8qKlxuICAgKiAqKk9wdGlvbmFsKio6IFN5bmNocm9ub3VzIGBzeW1saW5rYC5cbiAgICogQHBhcmFtIHR5cGUgY2FuIGJlIGVpdGhlciBgJ2RpcidgIG9yIGAnZmlsZSdgXG4gICAqL1xuICBzeW1saW5rU3luYyhzcmNwYXRoOiBzdHJpbmcsIGRzdHBhdGg6IHN0cmluZywgdHlwZTogc3RyaW5nKTogdm9pZDtcbiAgLyoqXG4gICAqICoqT3B0aW9uYWwqKjogQXN5bmNocm9ub3VzIHJlYWRsaW5rLlxuICAgKi9cbiAgcmVhZGxpbmsocDogc3RyaW5nLCBjYjogQkZTQ2FsbGJhY2s8c3RyaW5nPik6IHZvaWQ7XG4gIC8qKlxuICAgKiAqKk9wdGlvbmFsKio6IFN5bmNocm9ub3VzIHJlYWRsaW5rLlxuICAgKi9cbiAgcmVhZGxpbmtTeW5jKHA6IHN0cmluZyk6IHN0cmluZztcbn1cblxuLyoqXG4gKiBEZXNjcmliZXMgYSBmaWxlIHN5c3RlbSBvcHRpb24uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRmlsZVN5c3RlbU9wdGlvbjxUPiB7XG4gIC8vIFRoZSBiYXNpYyBKYXZhU2NyaXB0IHR5cGUocykgZm9yIHRoaXMgb3B0aW9uLlxuICB0eXBlOiBzdHJpbmcgfCBzdHJpbmdbXTtcbiAgLy8gV2hldGhlciBvciBub3QgdGhlIG9wdGlvbiBpcyBvcHRpb25hbCAoZS5nLiwgY2FuIGJlIHNldCB0byBudWxsIG9yIHVuZGVmaW5lZCkuXG4gIC8vIERlZmF1bHRzIHRvIGBmYWxzZWAuXG4gIG9wdGlvbmFsPzogYm9vbGVhbjtcbiAgLy8gRGVzY3JpcHRpb24gb2YgdGhlIG9wdGlvbi4gVXNlZCBpbiBlcnJvciBtZXNzYWdlcyBhbmQgZG9jdW1lbnRhdGlvbi5cbiAgZGVzY3JpcHRpb246IHN0cmluZztcbiAgLy8gQSBjdXN0b20gdmFsaWRhdGlvbiBmdW5jdGlvbiB0byBjaGVjayBpZiB0aGUgb3B0aW9uIGlzIHZhbGlkLlxuICAvLyBDYWxscyB0aGUgY2FsbGJhY2sgd2l0aCBhbiBlcnJvciBvYmplY3Qgb24gYW4gZXJyb3IuXG4gIC8vIChDYW4gY2FsbCBjYWxsYmFjayBzeW5jaHJvbm91c2x5LilcbiAgLy8gRGVmYXVsdHMgdG8gYChvcHQsIGNiKSA9PiBjYigpYC5cbiAgdmFsaWRhdG9yPyhvcHQ6IFQsIGNiOiBCRlNPbmVBcmdDYWxsYmFjayk6IHZvaWQ7XG59XG5cbi8qKlxuICogRGVzY3JpYmVzIGFsbCBvZiB0aGUgb3B0aW9ucyBhdmFpbGFibGUgaW4gYSBmaWxlIHN5c3RlbS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBGaWxlU3lzdGVtT3B0aW9ucyB7XG4gIFtuYW1lOiBzdHJpbmddOiBGaWxlU3lzdGVtT3B0aW9uPGFueT47XG59XG5cbi8qKlxuICogQ29udGFpbnMgdHlwaW5ncyBmb3Igc3RhdGljIGZ1bmN0aW9ucyBvbiB0aGUgZmlsZSBzeXN0ZW0gY29uc3RydWN0b3IuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRmlsZVN5c3RlbUNvbnN0cnVjdG9yIHtcbiAgLyoqXG4gICAqICoqQ29yZSoqOiBOYW1lIHRvIGlkZW50aWZ5IHRoaXMgcGFydGljdWxhciBmaWxlIHN5c3RlbS5cbiAgICovXG4gIE5hbWU6IHN0cmluZztcbiAgLyoqXG4gICAqICoqQ29yZSoqOiBEZXNjcmliZXMgYWxsIG9mIHRoZSBvcHRpb25zIGF2YWlsYWJsZSBmb3IgdGhpcyBmaWxlIHN5c3RlbS5cbiAgICovXG4gIE9wdGlvbnM6IEZpbGVTeXN0ZW1PcHRpb25zO1xuICAvKipcbiAgICogKipDb3JlKio6IENyZWF0ZXMgYSBmaWxlIHN5c3RlbSBvZiB0aGlzIGdpdmVuIHR5cGUgd2l0aCB0aGUgZ2l2ZW5cbiAgICogb3B0aW9ucy5cbiAgICovXG4gIENyZWF0ZShvcHRpb25zOiBvYmplY3QsIGNiOiBCRlNDYWxsYmFjazxGaWxlU3lzdGVtPik6IHZvaWQ7XG4gIC8qKlxuICAgKiAqKkNvcmUqKjogUmV0dXJucyAndHJ1ZScgaWYgdGhpcyBmaWxlc3lzdGVtIGlzIGF2YWlsYWJsZSBpbiB0aGUgY3VycmVudFxuICAgKiBlbnZpcm9ubWVudC4gRm9yIGV4YW1wbGUsIGEgYGxvY2FsU3RvcmFnZWAtYmFja2VkIGZpbGVzeXN0ZW0gd2lsbCByZXR1cm5cbiAgICogJ2ZhbHNlJyBpZiB0aGUgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IHRoYXQgQVBJLlxuICAgKlxuICAgKiBEZWZhdWx0cyB0byAnZmFsc2UnLCBhcyB0aGUgRmlsZVN5c3RlbSBiYXNlIGNsYXNzIGlzbid0IHVzYWJsZSBhbG9uZS5cbiAgICovXG4gIGlzQXZhaWxhYmxlKCk6IGJvb2xlYW47XG59XG5cbi8qKlxuICogQmFzaWMgZmlsZXN5c3RlbSBjbGFzcy4gTW9zdCBmaWxlc3lzdGVtcyBzaG91bGQgZXh0ZW5kIHRoaXMgY2xhc3MsIGFzIGl0XG4gKiBwcm92aWRlcyBkZWZhdWx0IGltcGxlbWVudGF0aW9ucyBmb3IgYSBoYW5kZnVsIG9mIG1ldGhvZHMuXG4gKi9cbmV4cG9ydCBjbGFzcyBCYXNlRmlsZVN5c3RlbSB7XG4gIHB1YmxpYyBzdXBwb3J0c0xpbmtzKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBwdWJsaWMgZGlza1NwYWNlKHA6IHN0cmluZywgY2I6ICh0b3RhbDogbnVtYmVyLCBmcmVlOiBudW1iZXIpID0+IGFueSk6IHZvaWQge1xuICAgIGNiKDAsIDApO1xuICB9XG4gIC8qKlxuICAgKiBPcGVucyB0aGUgZmlsZSBhdCBwYXRoIHAgd2l0aCB0aGUgZ2l2ZW4gZmxhZy4gVGhlIGZpbGUgbXVzdCBleGlzdC5cbiAgICogQHBhcmFtIHAgVGhlIHBhdGggdG8gb3Blbi5cbiAgICogQHBhcmFtIGZsYWcgVGhlIGZsYWcgdG8gdXNlIHdoZW4gb3BlbmluZyB0aGUgZmlsZS5cbiAgICovXG4gIHB1YmxpYyBvcGVuRmlsZShwOiBzdHJpbmcsIGZsYWc6IEZpbGVGbGFnLCBjYjogQkZTQ2FsbGJhY2s8RmlsZT4pOiB2b2lkIHtcbiAgICB0aHJvdyBuZXcgQXBpRXJyb3IoRXJyb3JDb2RlLkVOT1RTVVApO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIGZpbGUgYXQgcGF0aCBwIHdpdGggdGhlIGdpdmVuIG1vZGUuIFRoZW4sIG9wZW4gaXQgd2l0aCB0aGUgZ2l2ZW5cbiAgICogZmxhZy5cbiAgICovXG4gIHB1YmxpYyBjcmVhdGVGaWxlKHA6IHN0cmluZywgZmxhZzogRmlsZUZsYWcsIG1vZGU6IG51bWJlciwgY2I6IEJGU0NhbGxiYWNrPEZpbGU+KTogdm9pZCB7XG4gICAgdGhyb3cgbmV3IEFwaUVycm9yKEVycm9yQ29kZS5FTk9UU1VQKTtcbiAgfVxuICBwdWJsaWMgb3BlbihwOiBzdHJpbmcsIGZsYWc6IEZpbGVGbGFnLCBtb2RlOiBudW1iZXIsIGNiOiBCRlNDYWxsYmFjazxGaWxlPik6IHZvaWQge1xuICAgIGNvbnN0IG11c3RCZUZpbGUgPSAoZTogQXBpRXJyb3IsIHN0YXRzPzogU3RhdHMpOiB2b2lkID0+IHtcbiAgICAgIGlmIChlKSB7XG4gICAgICAgIC8vIEZpbGUgZG9lcyBub3QgZXhpc3QuXG4gICAgICAgIHN3aXRjaCAoZmxhZy5wYXRoTm90RXhpc3RzQWN0aW9uKCkpIHtcbiAgICAgICAgICBjYXNlIEFjdGlvblR5cGUuQ1JFQVRFX0ZJTEU6XG4gICAgICAgICAgICAvLyBFbnN1cmUgcGFyZW50IGV4aXN0cy5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXQocGF0aC5kaXJuYW1lKHApLCBmYWxzZSwgKGU6IEFwaUVycm9yLCBwYXJlbnRTdGF0cz86IFN0YXRzKSA9PiB7XG4gICAgICAgICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICAgICAgY2IoZSk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAocGFyZW50U3RhdHMgJiYgIXBhcmVudFN0YXRzLmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgICAgICAgICAgICBjYihBcGlFcnJvci5FTk9URElSKHBhdGguZGlybmFtZShwKSkpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlRmlsZShwLCBmbGFnLCBtb2RlLCBjYik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIGNhc2UgQWN0aW9uVHlwZS5USFJPV19FWENFUFRJT046XG4gICAgICAgICAgICByZXR1cm4gY2IoQXBpRXJyb3IuRU5PRU5UKHApKTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGNiKG5ldyBBcGlFcnJvcihFcnJvckNvZGUuRUlOVkFMLCAnSW52YWxpZCBGaWxlRmxhZyBvYmplY3QuJykpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGaWxlIGV4aXN0cy5cbiAgICAgICAgaWYgKHN0YXRzICYmIHN0YXRzLmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgICAgICByZXR1cm4gY2IoQXBpRXJyb3IuRUlTRElSKHApKTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGZsYWcucGF0aEV4aXN0c0FjdGlvbigpKSB7XG4gICAgICAgICAgY2FzZSBBY3Rpb25UeXBlLlRIUk9XX0VYQ0VQVElPTjpcbiAgICAgICAgICAgIHJldHVybiBjYihBcGlFcnJvci5FRVhJU1QocCkpO1xuICAgICAgICAgIGNhc2UgQWN0aW9uVHlwZS5UUlVOQ0FURV9GSUxFOlxuICAgICAgICAgICAgLy8gTk9URTogSW4gYSBwcmV2aW91cyBpbXBsZW1lbnRhdGlvbiwgd2UgZGVsZXRlZCB0aGUgZmlsZSBhbmRcbiAgICAgICAgICAgIC8vIHJlLWNyZWF0ZWQgaXQuIEhvd2V2ZXIsIHRoaXMgY3JlYXRlZCBhIHJhY2UgY29uZGl0aW9uIGlmIGFub3RoZXJcbiAgICAgICAgICAgIC8vIGFzeW5jaHJvbm91cyByZXF1ZXN0IHdhcyB0cnlpbmcgdG8gcmVhZCB0aGUgZmlsZSwgYXMgdGhlIGZpbGVcbiAgICAgICAgICAgIC8vIHdvdWxkIG5vdCBleGlzdCBmb3IgYSBzbWFsbCBwZXJpb2Qgb2YgdGltZS5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9wZW5GaWxlKHAsIGZsYWcsIChlOiBBcGlFcnJvciwgZmQ/OiBGaWxlKTogdm9pZCA9PiB7XG4gICAgICAgICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICAgICAgY2IoZSk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoZmQpIHtcbiAgICAgICAgICAgICAgICBmZC50cnVuY2F0ZSgwLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICBmZC5zeW5jKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY2IobnVsbCwgZmQpO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZmFpbCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICBjYXNlIEFjdGlvblR5cGUuTk9QOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3BlbkZpbGUocCwgZmxhZywgY2IpO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gY2IobmV3IEFwaUVycm9yKEVycm9yQ29kZS5FSU5WQUwsICdJbnZhbGlkIEZpbGVGbGFnIG9iamVjdC4nKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuc3RhdChwLCBmYWxzZSwgbXVzdEJlRmlsZSk7XG4gIH1cbiAgcHVibGljIHJlbmFtZShvbGRQYXRoOiBzdHJpbmcsIG5ld1BhdGg6IHN0cmluZywgY2I6IEJGU09uZUFyZ0NhbGxiYWNrKTogdm9pZCB7XG4gICAgY2IobmV3IEFwaUVycm9yKEVycm9yQ29kZS5FTk9UU1VQKSk7XG4gIH1cbiAgcHVibGljIHJlbmFtZVN5bmMob2xkUGF0aDogc3RyaW5nLCBuZXdQYXRoOiBzdHJpbmcpOiB2b2lkIHtcbiAgICB0aHJvdyBuZXcgQXBpRXJyb3IoRXJyb3JDb2RlLkVOT1RTVVApO1xuICB9XG4gIHB1YmxpYyBzdGF0KHA6IHN0cmluZywgaXNMc3RhdDogYm9vbGVhbiB8IG51bGwsIGNiOiBCRlNDYWxsYmFjazxTdGF0cz4pOiB2b2lkIHtcbiAgICBjYihuZXcgQXBpRXJyb3IoRXJyb3JDb2RlLkVOT1RTVVApKTtcbiAgfVxuICBwdWJsaWMgc3RhdFN5bmMocDogc3RyaW5nLCBpc0xzdGF0OiBib29sZWFuIHwgbnVsbCk6IFN0YXRzIHtcbiAgICB0aHJvdyBuZXcgQXBpRXJyb3IoRXJyb3JDb2RlLkVOT1RTVVApO1xuICB9XG4gIC8qKlxuICAgKiBPcGVucyB0aGUgZmlsZSBhdCBwYXRoIHAgd2l0aCB0aGUgZ2l2ZW4gZmxhZy4gVGhlIGZpbGUgbXVzdCBleGlzdC5cbiAgICogQHBhcmFtIHAgVGhlIHBhdGggdG8gb3Blbi5cbiAgICogQHBhcmFtIGZsYWcgVGhlIGZsYWcgdG8gdXNlIHdoZW4gb3BlbmluZyB0aGUgZmlsZS5cbiAgICogQHJldHVybiBBIEZpbGUgb2JqZWN0IGNvcnJlc3BvbmRpbmcgdG8gdGhlIG9wZW5lZCBmaWxlLlxuICAgKi9cbiAgcHVibGljIG9wZW5GaWxlU3luYyhwOiBzdHJpbmcsIGZsYWc6IEZpbGVGbGFnLCBtb2RlOiBudW1iZXIpOiBGaWxlIHtcbiAgICB0aHJvdyBuZXcgQXBpRXJyb3IoRXJyb3JDb2RlLkVOT1RTVVApO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIGZpbGUgYXQgcGF0aCBwIHdpdGggdGhlIGdpdmVuIG1vZGUuIFRoZW4sIG9wZW4gaXQgd2l0aCB0aGUgZ2l2ZW5cbiAgICogZmxhZy5cbiAgICovXG4gIHB1YmxpYyBjcmVhdGVGaWxlU3luYyhwOiBzdHJpbmcsIGZsYWc6IEZpbGVGbGFnLCBtb2RlOiBudW1iZXIpOiBGaWxlIHtcbiAgICB0aHJvdyBuZXcgQXBpRXJyb3IoRXJyb3JDb2RlLkVOT1RTVVApO1xuICB9XG4gIHB1YmxpYyBvcGVuU3luYyhwOiBzdHJpbmcsIGZsYWc6IEZpbGVGbGFnLCBtb2RlOiBudW1iZXIpOiBGaWxlIHtcbiAgICAvLyBDaGVjayBpZiB0aGUgcGF0aCBleGlzdHMsIGFuZCBpcyBhIGZpbGUuXG4gICAgbGV0IHN0YXRzOiBTdGF0cztcbiAgICB0cnkge1xuICAgICAgc3RhdHMgPSB0aGlzLnN0YXRTeW5jKHAsIGZhbHNlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBGaWxlIGRvZXMgbm90IGV4aXN0LlxuICAgICAgc3dpdGNoIChmbGFnLnBhdGhOb3RFeGlzdHNBY3Rpb24oKSkge1xuICAgICAgICBjYXNlIEFjdGlvblR5cGUuQ1JFQVRFX0ZJTEU6XG4gICAgICAgICAgLy8gRW5zdXJlIHBhcmVudCBleGlzdHMuXG4gICAgICAgICAgY29uc3QgcGFyZW50U3RhdHMgPSB0aGlzLnN0YXRTeW5jKHBhdGguZGlybmFtZShwKSwgZmFsc2UpO1xuICAgICAgICAgIGlmICghcGFyZW50U3RhdHMuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgICAgICAgdGhyb3cgQXBpRXJyb3IuRU5PVERJUihwYXRoLmRpcm5hbWUocCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVGaWxlU3luYyhwLCBmbGFnLCBtb2RlKTtcbiAgICAgICAgY2FzZSBBY3Rpb25UeXBlLlRIUk9XX0VYQ0VQVElPTjpcbiAgICAgICAgICB0aHJvdyBBcGlFcnJvci5FTk9FTlQocCk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEFwaUVycm9yKEVycm9yQ29kZS5FSU5WQUwsICdJbnZhbGlkIEZpbGVGbGFnIG9iamVjdC4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBGaWxlIGV4aXN0cy5cbiAgICBpZiAoc3RhdHMuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgdGhyb3cgQXBpRXJyb3IuRUlTRElSKHApO1xuICAgIH1cbiAgICBzd2l0Y2ggKGZsYWcucGF0aEV4aXN0c0FjdGlvbigpKSB7XG4gICAgICBjYXNlIEFjdGlvblR5cGUuVEhST1dfRVhDRVBUSU9OOlxuICAgICAgICB0aHJvdyBBcGlFcnJvci5FRVhJU1QocCk7XG4gICAgICBjYXNlIEFjdGlvblR5cGUuVFJVTkNBVEVfRklMRTpcbiAgICAgICAgLy8gRGVsZXRlIGZpbGUuXG4gICAgICAgIHRoaXMudW5saW5rU3luYyhwKTtcbiAgICAgICAgLy8gQ3JlYXRlIGZpbGUuIFVzZSB0aGUgc2FtZSBtb2RlIGFzIHRoZSBvbGQgZmlsZS5cbiAgICAgICAgLy8gTm9kZSBpdHNlbGYgbW9kaWZpZXMgdGhlIGN0aW1lIHdoZW4gdGhpcyBvY2N1cnMsIHNvIHRoaXMgYWN0aW9uXG4gICAgICAgIC8vIHdpbGwgcHJlc2VydmUgdGhhdCBiZWhhdmlvciBpZiB0aGUgdW5kZXJseWluZyBmaWxlIHN5c3RlbVxuICAgICAgICAvLyBzdXBwb3J0cyB0aG9zZSBwcm9wZXJ0aWVzLlxuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVGaWxlU3luYyhwLCBmbGFnLCBzdGF0cy5tb2RlKTtcbiAgICAgIGNhc2UgQWN0aW9uVHlwZS5OT1A6XG4gICAgICAgIHJldHVybiB0aGlzLm9wZW5GaWxlU3luYyhwLCBmbGFnLCBtb2RlKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBBcGlFcnJvcihFcnJvckNvZGUuRUlOVkFMLCAnSW52YWxpZCBGaWxlRmxhZyBvYmplY3QuJyk7XG4gICAgfVxuICB9XG4gIHB1YmxpYyB1bmxpbmsocDogc3RyaW5nLCBjYjogQkZTT25lQXJnQ2FsbGJhY2spOiB2b2lkIHtcbiAgICBjYihuZXcgQXBpRXJyb3IoRXJyb3JDb2RlLkVOT1RTVVApKTtcbiAgfVxuICBwdWJsaWMgdW5saW5rU3luYyhwOiBzdHJpbmcpOiB2b2lkIHtcbiAgICB0aHJvdyBuZXcgQXBpRXJyb3IoRXJyb3JDb2RlLkVOT1RTVVApO1xuICB9XG4gIHB1YmxpYyBybWRpcihwOiBzdHJpbmcsIGNiOiBCRlNPbmVBcmdDYWxsYmFjayk6IHZvaWQge1xuICAgIGNiKG5ldyBBcGlFcnJvcihFcnJvckNvZGUuRU5PVFNVUCkpO1xuICB9XG4gIHB1YmxpYyBybWRpclN5bmMocDogc3RyaW5nKTogdm9pZCB7XG4gICAgdGhyb3cgbmV3IEFwaUVycm9yKEVycm9yQ29kZS5FTk9UU1VQKTtcbiAgfVxuICBwdWJsaWMgbWtkaXIocDogc3RyaW5nLCBtb2RlOiBudW1iZXIsIGNiOiBCRlNPbmVBcmdDYWxsYmFjayk6IHZvaWQge1xuICAgIGNiKG5ldyBBcGlFcnJvcihFcnJvckNvZGUuRU5PVFNVUCkpO1xuICB9XG4gIHB1YmxpYyBta2RpclN5bmMocDogc3RyaW5nLCBtb2RlOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aHJvdyBuZXcgQXBpRXJyb3IoRXJyb3JDb2RlLkVOT1RTVVApO1xuICB9XG4gIHB1YmxpYyByZWFkZGlyKHA6IHN0cmluZywgY2I6IEJGU0NhbGxiYWNrPHN0cmluZ1tdPik6IHZvaWQge1xuICAgIGNiKG5ldyBBcGlFcnJvcihFcnJvckNvZGUuRU5PVFNVUCkpO1xuICB9XG4gIHB1YmxpYyByZWFkZGlyU3luYyhwOiBzdHJpbmcpOiBzdHJpbmdbXSB7XG4gICAgdGhyb3cgbmV3IEFwaUVycm9yKEVycm9yQ29kZS5FTk9UU1VQKTtcbiAgfVxuICBwdWJsaWMgZXhpc3RzKHA6IHN0cmluZywgY2I6IChleGlzdHM6IGJvb2xlYW4pID0+IHZvaWQpOiB2b2lkIHtcbiAgICB0aGlzLnN0YXQocCwgbnVsbCwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICBjYighZXJyKTtcbiAgICB9KTtcbiAgfVxuICBwdWJsaWMgZXhpc3RzU3luYyhwOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy5zdGF0U3luYyhwLCB0cnVlKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcHVibGljIHJlYWxwYXRoKHA6IHN0cmluZywgY2FjaGU6IHtbcGF0aDogc3RyaW5nXTogc3RyaW5nfSwgY2I6IEJGU0NhbGxiYWNrPHN0cmluZz4pOiB2b2lkIHtcbiAgICBpZiAodGhpcy5zdXBwb3J0c0xpbmtzKCkpIHtcbiAgICAgIC8vIFRoZSBwYXRoIGNvdWxkIGNvbnRhaW4gc3ltbGlua3MuIFNwbGl0IHVwIHRoZSBwYXRoLFxuICAgICAgLy8gcmVzb2x2ZSBhbnkgc3ltbGlua3MsIHJldHVybiB0aGUgcmVzb2x2ZWQgc3RyaW5nLlxuICAgICAgY29uc3Qgc3BsaXRQYXRoID0gcC5zcGxpdChwYXRoLnNlcCk7XG4gICAgICAvLyBUT0RPOiBTaW1wbGVyIHRvIGp1c3QgcGFzcyB0aHJvdWdoIGZpbGUsIGZpbmQgc2VwIGFuZCBzdWNoLlxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzcGxpdFBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYWRkUGF0aHMgPSBzcGxpdFBhdGguc2xpY2UoMCwgaSArIDEpO1xuICAgICAgICBzcGxpdFBhdGhbaV0gPSBwYXRoLmpvaW4uYXBwbHkobnVsbCwgYWRkUGF0aHMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBObyBzeW1saW5rcy4gV2UganVzdCBuZWVkIHRvIHZlcmlmeSB0aGF0IGl0IGV4aXN0cy5cbiAgICAgIHRoaXMuZXhpc3RzKHAsIGZ1bmN0aW9uKGRvZXNFeGlzdCkge1xuICAgICAgICBpZiAoZG9lc0V4aXN0KSB7XG4gICAgICAgICAgY2IobnVsbCwgcCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2IoQXBpRXJyb3IuRU5PRU5UKHApKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHB1YmxpYyByZWFscGF0aFN5bmMocDogc3RyaW5nLCBjYWNoZToge1twYXRoOiBzdHJpbmddOiBzdHJpbmd9KTogc3RyaW5nIHtcbiAgICBpZiAodGhpcy5zdXBwb3J0c0xpbmtzKCkpIHtcbiAgICAgIC8vIFRoZSBwYXRoIGNvdWxkIGNvbnRhaW4gc3ltbGlua3MuIFNwbGl0IHVwIHRoZSBwYXRoLFxuICAgICAgLy8gcmVzb2x2ZSBhbnkgc3ltbGlua3MsIHJldHVybiB0aGUgcmVzb2x2ZWQgc3RyaW5nLlxuICAgICAgY29uc3Qgc3BsaXRQYXRoID0gcC5zcGxpdChwYXRoLnNlcCk7XG4gICAgICAvLyBUT0RPOiBTaW1wbGVyIHRvIGp1c3QgcGFzcyB0aHJvdWdoIGZpbGUsIGZpbmQgc2VwIGFuZCBzdWNoLlxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzcGxpdFBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYWRkUGF0aHMgPSBzcGxpdFBhdGguc2xpY2UoMCwgaSArIDEpO1xuICAgICAgICBzcGxpdFBhdGhbaV0gPSBwYXRoLmpvaW4uYXBwbHkocGF0aCwgYWRkUGF0aHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNwbGl0UGF0aC5qb2luKHBhdGguc2VwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTm8gc3ltbGlua3MuIFdlIGp1c3QgbmVlZCB0byB2ZXJpZnkgdGhhdCBpdCBleGlzdHMuXG4gICAgICBpZiAodGhpcy5leGlzdHNTeW5jKHApKSB7XG4gICAgICAgIHJldHVybiBwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgQXBpRXJyb3IuRU5PRU5UKHApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBwdWJsaWMgdHJ1bmNhdGUocDogc3RyaW5nLCBsZW46IG51bWJlciwgY2I6IEJGU09uZUFyZ0NhbGxiYWNrKTogdm9pZCB7XG4gICAgdGhpcy5vcGVuKHAsIEZpbGVGbGFnLmdldEZpbGVGbGFnKCdyKycpLCAweDFhNCwgKGZ1bmN0aW9uKGVyOiBBcGlFcnJvciwgZmQ/OiBGaWxlKSB7XG4gICAgICBpZiAoZXIpIHtcbiAgICAgICAgcmV0dXJuIGNiKGVyKTtcbiAgICAgIH1cbiAgICAgIGZkIS50cnVuY2F0ZShsZW4sIChmdW5jdGlvbihlcjogYW55KSB7XG4gICAgICAgIGZkIS5jbG9zZSgoZnVuY3Rpb24oZXIyOiBhbnkpIHtcbiAgICAgICAgICBjYihlciB8fCBlcjIpO1xuICAgICAgICB9KSk7XG4gICAgICB9KSk7XG4gICAgfSkpO1xuICB9XG4gIHB1YmxpYyB0cnVuY2F0ZVN5bmMocDogc3RyaW5nLCBsZW46IG51bWJlcik6IHZvaWQge1xuICAgIGNvbnN0IGZkID0gdGhpcy5vcGVuU3luYyhwLCBGaWxlRmxhZy5nZXRGaWxlRmxhZygncisnKSwgMHgxYTQpO1xuICAgIC8vIE5lZWQgdG8gc2FmZWx5IGNsb3NlIEZELCByZWdhcmRsZXNzIG9mIHdoZXRoZXIgb3Igbm90IHRydW5jYXRlIHN1Y2NlZWRzLlxuICAgIHRyeSB7XG4gICAgICBmZC50cnVuY2F0ZVN5bmMobGVuKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBlO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBmZC5jbG9zZVN5bmMoKTtcbiAgICB9XG4gIH1cbiAgcHVibGljIHJlYWRGaWxlKGZuYW1lOiBzdHJpbmcsIGVuY29kaW5nOiBzdHJpbmcgfCBudWxsLCBmbGFnOiBGaWxlRmxhZywgY2I6IEJGU0NhbGxiYWNrPHN0cmluZyB8IEJ1ZmZlcj4pOiB2b2lkIHtcbiAgICAvLyBXcmFwIGNiIGluIGZpbGUgY2xvc2luZyBjb2RlLlxuICAgIGNvbnN0IG9sZENiID0gY2I7XG4gICAgLy8gR2V0IGZpbGUuXG4gICAgdGhpcy5vcGVuKGZuYW1lLCBmbGFnLCAweDFhNCwgKGVyciwgZmQpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGNiKGVycik7XG4gICAgICB9XG4gICAgICBjYiA9IGZ1bmN0aW9uKGVycj86IEFwaUVycm9yIHwgbnVsbCwgYXJnPzogc3RyaW5nIHwgQnVmZmVyKSB7XG4gICAgICAgIGZkIS5jbG9zZShmdW5jdGlvbihlcnIyOiBhbnkpIHtcbiAgICAgICAgICBpZiAoIWVycikge1xuICAgICAgICAgICAgZXJyID0gZXJyMjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG9sZENiKGVyciwgYXJnKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgZmQhLnN0YXQoKGVyciwgc3RhdD8pID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJldHVybiBjYihlcnIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFsbG9jYXRlIGJ1ZmZlci5cbiAgICAgICAgY29uc3QgYnVmID0gQnVmZmVyLmFsbG9jKHN0YXQhLnNpemUpO1xuICAgICAgICBmZCEucmVhZChidWYsIDAsIHN0YXQhLnNpemUsIDAsIChlcnI/OiBBcGlFcnJvciB8IG51bGwpID0+IHtcbiAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gY2IoZXJyKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGVuY29kaW5nID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gY2IoZXJyLCBidWYpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY2IobnVsbCwgYnVmLnRvU3RyaW5nKGVuY29kaW5nKSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY2IoZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIHB1YmxpYyByZWFkRmlsZVN5bmMoZm5hbWU6IHN0cmluZywgZW5jb2Rpbmc6IHN0cmluZyB8IG51bGwsIGZsYWc6IEZpbGVGbGFnKTogYW55IHtcbiAgICAvLyBHZXQgZmlsZS5cbiAgICBjb25zdCBmZCA9IHRoaXMub3BlblN5bmMoZm5hbWUsIGZsYWcsIDB4MWE0KTtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3RhdCA9IGZkLnN0YXRTeW5jKCk7XG4gICAgICAvLyBBbGxvY2F0ZSBidWZmZXIuXG4gICAgICBjb25zdCBidWYgPSBCdWZmZXIuYWxsb2Moc3RhdC5zaXplKTtcbiAgICAgIGZkLnJlYWRTeW5jKGJ1ZiwgMCwgc3RhdC5zaXplLCAwKTtcbiAgICAgIGZkLmNsb3NlU3luYygpO1xuICAgICAgaWYgKGVuY29kaW5nID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBidWY7XG4gICAgICB9XG4gICAgICByZXR1cm4gYnVmLnRvU3RyaW5nKGVuY29kaW5nKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgZmQuY2xvc2VTeW5jKCk7XG4gICAgfVxuICB9XG4gIHB1YmxpYyB3cml0ZUZpbGUoZm5hbWU6IHN0cmluZywgZGF0YTogYW55LCBlbmNvZGluZzogc3RyaW5nIHwgbnVsbCwgZmxhZzogRmlsZUZsYWcsIG1vZGU6IG51bWJlciwgY2I6IEJGU09uZUFyZ0NhbGxiYWNrKTogdm9pZCB7XG4gICAgLy8gV3JhcCBjYiBpbiBmaWxlIGNsb3NpbmcgY29kZS5cbiAgICBjb25zdCBvbGRDYiA9IGNiO1xuICAgIC8vIEdldCBmaWxlLlxuICAgIHRoaXMub3BlbihmbmFtZSwgZmxhZywgMHgxYTQsIGZ1bmN0aW9uKGVycjogQXBpRXJyb3IsIGZkPzogRmlsZSkge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gY2IoZXJyKTtcbiAgICAgIH1cbiAgICAgIGNiID0gZnVuY3Rpb24oZXJyOiBBcGlFcnJvcikge1xuICAgICAgICBmZCEuY2xvc2UoZnVuY3Rpb24oZXJyMjogYW55KSB7XG4gICAgICAgICAgb2xkQ2IoZXJyID8gZXJyIDogZXJyMik7XG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGRhdGEgPSBCdWZmZXIuZnJvbShkYXRhLCBlbmNvZGluZyEpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBjYihlKTtcbiAgICAgIH1cbiAgICAgIC8vIFdyaXRlIGludG8gZmlsZS5cbiAgICAgIGZkIS53cml0ZShkYXRhLCAwLCBkYXRhLmxlbmd0aCwgMCwgY2IpO1xuICAgIH0pO1xuICB9XG4gIHB1YmxpYyB3cml0ZUZpbGVTeW5jKGZuYW1lOiBzdHJpbmcsIGRhdGE6IGFueSwgZW5jb2Rpbmc6IHN0cmluZyB8IG51bGwsIGZsYWc6IEZpbGVGbGFnLCBtb2RlOiBudW1iZXIpOiB2b2lkIHtcbiAgICAvLyBHZXQgZmlsZS5cbiAgICBjb25zdCBmZCA9IHRoaXMub3BlblN5bmMoZm5hbWUsIGZsYWcsIG1vZGUpO1xuICAgIHRyeSB7XG4gICAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGRhdGEgPSBCdWZmZXIuZnJvbShkYXRhLCBlbmNvZGluZyEpO1xuICAgICAgfVxuICAgICAgLy8gV3JpdGUgaW50byBmaWxlLlxuICAgICAgZmQud3JpdGVTeW5jKGRhdGEsIDAsIGRhdGEubGVuZ3RoLCAwKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgZmQuY2xvc2VTeW5jKCk7XG4gICAgfVxuICB9XG4gIHB1YmxpYyBhcHBlbmRGaWxlKGZuYW1lOiBzdHJpbmcsIGRhdGE6IGFueSwgZW5jb2Rpbmc6IHN0cmluZyB8IG51bGwsIGZsYWc6IEZpbGVGbGFnLCBtb2RlOiBudW1iZXIsIGNiOiBCRlNPbmVBcmdDYWxsYmFjayk6IHZvaWQge1xuICAgIC8vIFdyYXAgY2IgaW4gZmlsZSBjbG9zaW5nIGNvZGUuXG4gICAgY29uc3Qgb2xkQ2IgPSBjYjtcbiAgICB0aGlzLm9wZW4oZm5hbWUsIGZsYWcsIG1vZGUsIGZ1bmN0aW9uKGVycjogQXBpRXJyb3IsIGZkPzogRmlsZSkge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gY2IoZXJyKTtcbiAgICAgIH1cbiAgICAgIGNiID0gZnVuY3Rpb24oZXJyOiBBcGlFcnJvcikge1xuICAgICAgICBmZCEuY2xvc2UoZnVuY3Rpb24oZXJyMjogYW55KSB7XG4gICAgICAgICAgb2xkQ2IoZXJyID8gZXJyIDogZXJyMik7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZGF0YSA9IEJ1ZmZlci5mcm9tKGRhdGEsIGVuY29kaW5nISk7XG4gICAgICB9XG4gICAgICBmZCEud3JpdGUoZGF0YSwgMCwgZGF0YS5sZW5ndGgsIG51bGwsIGNiKTtcbiAgICB9KTtcbiAgfVxuICBwdWJsaWMgYXBwZW5kRmlsZVN5bmMoZm5hbWU6IHN0cmluZywgZGF0YTogYW55LCBlbmNvZGluZzogc3RyaW5nIHwgbnVsbCwgZmxhZzogRmlsZUZsYWcsIG1vZGU6IG51bWJlcik6IHZvaWQge1xuICAgIGNvbnN0IGZkID0gdGhpcy5vcGVuU3luYyhmbmFtZSwgZmxhZywgbW9kZSk7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZGF0YSA9IEJ1ZmZlci5mcm9tKGRhdGEsIGVuY29kaW5nISk7XG4gICAgICB9XG4gICAgICBmZC53cml0ZVN5bmMoZGF0YSwgMCwgZGF0YS5sZW5ndGgsIG51bGwpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBmZC5jbG9zZVN5bmMoKTtcbiAgICB9XG4gIH1cbiAgcHVibGljIGNobW9kKHA6IHN0cmluZywgaXNMY2htb2Q6IGJvb2xlYW4sIG1vZGU6IG51bWJlciwgY2I6IEJGU09uZUFyZ0NhbGxiYWNrKTogdm9pZCB7XG4gICAgY2IobmV3IEFwaUVycm9yKEVycm9yQ29kZS5FTk9UU1VQKSk7XG4gIH1cbiAgcHVibGljIGNobW9kU3luYyhwOiBzdHJpbmcsIGlzTGNobW9kOiBib29sZWFuLCBtb2RlOiBudW1iZXIpIHtcbiAgICB0aHJvdyBuZXcgQXBpRXJyb3IoRXJyb3JDb2RlLkVOT1RTVVApO1xuICB9XG4gIHB1YmxpYyBjaG93bihwOiBzdHJpbmcsIGlzTGNob3duOiBib29sZWFuLCB1aWQ6IG51bWJlciwgZ2lkOiBudW1iZXIsIGNiOiBCRlNPbmVBcmdDYWxsYmFjayk6IHZvaWQge1xuICAgIGNiKG5ldyBBcGlFcnJvcihFcnJvckNvZGUuRU5PVFNVUCkpO1xuICB9XG4gIHB1YmxpYyBjaG93blN5bmMocDogc3RyaW5nLCBpc0xjaG93bjogYm9vbGVhbiwgdWlkOiBudW1iZXIsIGdpZDogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhyb3cgbmV3IEFwaUVycm9yKEVycm9yQ29kZS5FTk9UU1VQKTtcbiAgfVxuICBwdWJsaWMgdXRpbWVzKHA6IHN0cmluZywgYXRpbWU6IERhdGUsIG10aW1lOiBEYXRlLCBjYjogQkZTT25lQXJnQ2FsbGJhY2spOiB2b2lkIHtcbiAgICBjYihuZXcgQXBpRXJyb3IoRXJyb3JDb2RlLkVOT1RTVVApKTtcbiAgfVxuICBwdWJsaWMgdXRpbWVzU3luYyhwOiBzdHJpbmcsIGF0aW1lOiBEYXRlLCBtdGltZTogRGF0ZSk6IHZvaWQge1xuICAgIHRocm93IG5ldyBBcGlFcnJvcihFcnJvckNvZGUuRU5PVFNVUCk7XG4gIH1cbiAgcHVibGljIGxpbmsoc3JjcGF0aDogc3RyaW5nLCBkc3RwYXRoOiBzdHJpbmcsIGNiOiBCRlNPbmVBcmdDYWxsYmFjayk6IHZvaWQge1xuICAgIGNiKG5ldyBBcGlFcnJvcihFcnJvckNvZGUuRU5PVFNVUCkpO1xuICB9XG4gIHB1YmxpYyBsaW5rU3luYyhzcmNwYXRoOiBzdHJpbmcsIGRzdHBhdGg6IHN0cmluZyk6IHZvaWQge1xuICAgIHRocm93IG5ldyBBcGlFcnJvcihFcnJvckNvZGUuRU5PVFNVUCk7XG4gIH1cbiAgcHVibGljIHN5bWxpbmsoc3JjcGF0aDogc3RyaW5nLCBkc3RwYXRoOiBzdHJpbmcsIHR5cGU6IHN0cmluZywgY2I6IEJGU09uZUFyZ0NhbGxiYWNrKTogdm9pZCB7XG4gICAgY2IobmV3IEFwaUVycm9yKEVycm9yQ29kZS5FTk9UU1VQKSk7XG4gIH1cbiAgcHVibGljIHN5bWxpbmtTeW5jKHNyY3BhdGg6IHN0cmluZywgZHN0cGF0aDogc3RyaW5nLCB0eXBlOiBzdHJpbmcpOiB2b2lkIHtcbiAgICB0aHJvdyBuZXcgQXBpRXJyb3IoRXJyb3JDb2RlLkVOT1RTVVApO1xuICB9XG4gIHB1YmxpYyByZWFkbGluayhwOiBzdHJpbmcsIGNiOiBCRlNPbmVBcmdDYWxsYmFjayk6IHZvaWQge1xuICAgIGNiKG5ldyBBcGlFcnJvcihFcnJvckNvZGUuRU5PVFNVUCkpO1xuICB9XG4gIHB1YmxpYyByZWFkbGlua1N5bmMocDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICB0aHJvdyBuZXcgQXBpRXJyb3IoRXJyb3JDb2RlLkVOT1RTVVApO1xuICB9XG59XG5cbi8qKlxuICogSW1wbGVtZW50cyB0aGUgYXN5bmNocm9ub3VzIEFQSSBpbiB0ZXJtcyBvZiB0aGUgc3luY2hyb25vdXMgQVBJLlxuICogQGNsYXNzIFN5bmNocm9ub3VzRmlsZVN5c3RlbVxuICovXG5leHBvcnQgY2xhc3MgU3luY2hyb25vdXNGaWxlU3lzdGVtIGV4dGVuZHMgQmFzZUZpbGVTeXN0ZW0ge1xuICBwdWJsaWMgc3VwcG9ydHNTeW5jaCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHB1YmxpYyByZW5hbWUob2xkUGF0aDogc3RyaW5nLCBuZXdQYXRoOiBzdHJpbmcsIGNiOiBCRlNPbmVBcmdDYWxsYmFjayk6IHZvaWQge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLnJlbmFtZVN5bmMob2xkUGF0aCwgbmV3UGF0aCk7XG4gICAgICBjYigpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNiKGUpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBzdGF0KHA6IHN0cmluZywgaXNMc3RhdDogYm9vbGVhbiB8IG51bGwsIGNiOiBCRlNDYWxsYmFjazxTdGF0cz4pOiB2b2lkIHtcbiAgICB0cnkge1xuICAgICAgY2IobnVsbCwgdGhpcy5zdGF0U3luYyhwLCBpc0xzdGF0KSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY2IoZSk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIG9wZW4ocDogc3RyaW5nLCBmbGFnczogRmlsZUZsYWcsIG1vZGU6IG51bWJlciwgY2I6IEJGU0NhbGxiYWNrPEZpbGU+KTogdm9pZCB7XG4gICAgdHJ5IHtcbiAgICAgIGNiKG51bGwsIHRoaXMub3BlblN5bmMocCwgZmxhZ3MsIG1vZGUpKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjYihlKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgdW5saW5rKHA6IHN0cmluZywgY2I6IEJGU09uZUFyZ0NhbGxiYWNrKTogdm9pZCB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMudW5saW5rU3luYyhwKTtcbiAgICAgIGNiKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY2IoZSk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHJtZGlyKHA6IHN0cmluZywgY2I6IEJGU09uZUFyZ0NhbGxiYWNrKTogdm9pZCB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMucm1kaXJTeW5jKHApO1xuICAgICAgY2IoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjYihlKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgbWtkaXIocDogc3RyaW5nLCBtb2RlOiBudW1iZXIsIGNiOiBCRlNPbmVBcmdDYWxsYmFjayk6IHZvaWQge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLm1rZGlyU3luYyhwLCBtb2RlKTtcbiAgICAgIGNiKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY2IoZSk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHJlYWRkaXIocDogc3RyaW5nLCBjYjogQkZTQ2FsbGJhY2s8c3RyaW5nW10+KTogdm9pZCB7XG4gICAgdHJ5IHtcbiAgICAgIGNiKG51bGwsIHRoaXMucmVhZGRpclN5bmMocCkpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNiKGUpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBjaG1vZChwOiBzdHJpbmcsIGlzTGNobW9kOiBib29sZWFuLCBtb2RlOiBudW1iZXIsIGNiOiBCRlNPbmVBcmdDYWxsYmFjayk6IHZvaWQge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmNobW9kU3luYyhwLCBpc0xjaG1vZCwgbW9kZSk7XG4gICAgICBjYigpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNiKGUpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBjaG93bihwOiBzdHJpbmcsIGlzTGNob3duOiBib29sZWFuLCB1aWQ6IG51bWJlciwgZ2lkOiBudW1iZXIsIGNiOiBCRlNPbmVBcmdDYWxsYmFjayk6IHZvaWQge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmNob3duU3luYyhwLCBpc0xjaG93biwgdWlkLCBnaWQpO1xuICAgICAgY2IoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjYihlKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgdXRpbWVzKHA6IHN0cmluZywgYXRpbWU6IERhdGUsIG10aW1lOiBEYXRlLCBjYjogQkZTT25lQXJnQ2FsbGJhY2spOiB2b2lkIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy51dGltZXNTeW5jKHAsIGF0aW1lLCBtdGltZSk7XG4gICAgICBjYigpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNiKGUpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBsaW5rKHNyY3BhdGg6IHN0cmluZywgZHN0cGF0aDogc3RyaW5nLCBjYjogQkZTT25lQXJnQ2FsbGJhY2spOiB2b2lkIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy5saW5rU3luYyhzcmNwYXRoLCBkc3RwYXRoKTtcbiAgICAgIGNiKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY2IoZSk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHN5bWxpbmsoc3JjcGF0aDogc3RyaW5nLCBkc3RwYXRoOiBzdHJpbmcsIHR5cGU6IHN0cmluZywgY2I6IEJGU09uZUFyZ0NhbGxiYWNrKTogdm9pZCB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuc3ltbGlua1N5bmMoc3JjcGF0aCwgZHN0cGF0aCwgdHlwZSk7XG4gICAgICBjYigpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNiKGUpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyByZWFkbGluayhwOiBzdHJpbmcsIGNiOiBCRlNDYWxsYmFjazxzdHJpbmc+KTogdm9pZCB7XG4gICAgdHJ5IHtcbiAgICAgIGNiKG51bGwsIHRoaXMucmVhZGxpbmtTeW5jKHApKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjYihlKTtcbiAgICB9XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi8uLi8uLi8uLi9zcmMvY29yZS9maWxlX3N5c3RlbS50cyIsImltcG9ydCB7QXBpRXJyb3IsIEVycm9yQ29kZX0gZnJvbSAnLi9hcGlfZXJyb3InO1xuaW1wb3J0IFN0YXRzIGZyb20gJy4vbm9kZV9mc19zdGF0cyc7XG5pbXBvcnQge0JGU0NhbGxiYWNrLCBCRlNPbmVBcmdDYWxsYmFjaywgQkZTVGhyZWVBcmdDYWxsYmFja30gZnJvbSAnLi9maWxlX3N5c3RlbSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgRmlsZSB7XG4gIC8qKlxuICAgKiAqKkNvcmUqKjogR2V0IHRoZSBjdXJyZW50IGZpbGUgcG9zaXRpb24uXG4gICAqL1xuICBnZXRQb3MoKTogbnVtYmVyIHwgdW5kZWZpbmVkO1xuICAvKipcbiAgICogKipDb3JlKio6IEFzeW5jaHJvbm91cyBgc3RhdGAuXG4gICAqL1xuICBzdGF0KGNiOiBCRlNDYWxsYmFjazxTdGF0cz4pOiB2b2lkO1xuICAvKipcbiAgICogKipDb3JlKio6IFN5bmNocm9ub3VzIGBzdGF0YC5cbiAgICovXG4gIHN0YXRTeW5jKCk6IFN0YXRzO1xuICAvKipcbiAgICogKipDb3JlKio6IEFzeW5jaHJvbm91cyBjbG9zZS5cbiAgICovXG4gIGNsb3NlKGNiOiBCRlNPbmVBcmdDYWxsYmFjayk6IHZvaWQ7XG4gIC8qKlxuICAgKiAqKkNvcmUqKjogU3luY2hyb25vdXMgY2xvc2UuXG4gICAqL1xuICBjbG9zZVN5bmMoKTogdm9pZDtcbiAgLyoqXG4gICAqICoqQ29yZSoqOiBBc3luY2hyb25vdXMgdHJ1bmNhdGUuXG4gICAqL1xuICB0cnVuY2F0ZShsZW46IG51bWJlciwgY2I6IEJGU09uZUFyZ0NhbGxiYWNrKTogdm9pZDtcbiAgLyoqXG4gICAqICoqQ29yZSoqOiBTeW5jaHJvbm91cyB0cnVuY2F0ZS5cbiAgICovXG4gIHRydW5jYXRlU3luYyhsZW46IG51bWJlcik6IHZvaWQ7XG4gIC8qKlxuICAgKiAqKkNvcmUqKjogQXN5bmNocm9ub3VzIHN5bmMuXG4gICAqL1xuICBzeW5jKGNiOiBCRlNPbmVBcmdDYWxsYmFjayk6IHZvaWQ7XG4gIC8qKlxuICAgKiAqKkNvcmUqKjogU3luY2hyb25vdXMgc3luYy5cbiAgICovXG4gIHN5bmNTeW5jKCk6IHZvaWQ7XG4gIC8qKlxuICAgKiAqKkNvcmUqKjogV3JpdGUgYnVmZmVyIHRvIHRoZSBmaWxlLlxuICAgKiBOb3RlIHRoYXQgaXQgaXMgdW5zYWZlIHRvIHVzZSBmcy53cml0ZSBtdWx0aXBsZSB0aW1lcyBvbiB0aGUgc2FtZSBmaWxlXG4gICAqIHdpdGhvdXQgd2FpdGluZyBmb3IgdGhlIGNhbGxiYWNrLlxuICAgKiBAcGFyYW0gYnVmZmVyIEJ1ZmZlciBjb250YWluaW5nIHRoZSBkYXRhIHRvIHdyaXRlIHRvXG4gICAqICB0aGUgZmlsZS5cbiAgICogQHBhcmFtIG9mZnNldCBPZmZzZXQgaW4gdGhlIGJ1ZmZlciB0byBzdGFydCByZWFkaW5nIGRhdGEgZnJvbS5cbiAgICogQHBhcmFtIGxlbmd0aCBUaGUgYW1vdW50IG9mIGJ5dGVzIHRvIHdyaXRlIHRvIHRoZSBmaWxlLlxuICAgKiBAcGFyYW0gcG9zaXRpb24gT2Zmc2V0IGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgZmlsZSB3aGVyZSB0aGlzXG4gICAqICAgZGF0YSBzaG91bGQgYmUgd3JpdHRlbi4gSWYgcG9zaXRpb24gaXMgbnVsbCwgdGhlIGRhdGEgd2lsbCBiZSB3cml0dGVuIGF0XG4gICAqICAgdGhlIGN1cnJlbnQgcG9zaXRpb24uXG4gICAqIEBwYXJhbSBjYiBUaGUgbnVtYmVyIHNwZWNpZmllcyB0aGUgbnVtYmVyIG9mIGJ5dGVzIHdyaXR0ZW4gaW50byB0aGUgZmlsZS5cbiAgICovXG4gIHdyaXRlKGJ1ZmZlcjogQnVmZmVyLCBvZmZzZXQ6IG51bWJlciwgbGVuZ3RoOiBudW1iZXIsIHBvc2l0aW9uOiBudW1iZXIgfCBudWxsLCBjYjogQkZTVGhyZWVBcmdDYWxsYmFjazxudW1iZXIsIEJ1ZmZlcj4pOiB2b2lkO1xuICAvKipcbiAgICogKipDb3JlKio6IFdyaXRlIGJ1ZmZlciB0byB0aGUgZmlsZS5cbiAgICogTm90ZSB0aGF0IGl0IGlzIHVuc2FmZSB0byB1c2UgZnMud3JpdGVTeW5jIG11bHRpcGxlIHRpbWVzIG9uIHRoZSBzYW1lIGZpbGVcbiAgICogd2l0aG91dCB3YWl0aW5nIGZvciBpdCB0byByZXR1cm4uXG4gICAqIEBwYXJhbSBidWZmZXIgQnVmZmVyIGNvbnRhaW5pbmcgdGhlIGRhdGEgdG8gd3JpdGUgdG9cbiAgICogIHRoZSBmaWxlLlxuICAgKiBAcGFyYW0gb2Zmc2V0IE9mZnNldCBpbiB0aGUgYnVmZmVyIHRvIHN0YXJ0IHJlYWRpbmcgZGF0YSBmcm9tLlxuICAgKiBAcGFyYW0gbGVuZ3RoIFRoZSBhbW91bnQgb2YgYnl0ZXMgdG8gd3JpdGUgdG8gdGhlIGZpbGUuXG4gICAqIEBwYXJhbSBwb3NpdGlvbiBPZmZzZXQgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBmaWxlIHdoZXJlIHRoaXNcbiAgICogICBkYXRhIHNob3VsZCBiZSB3cml0dGVuLiBJZiBwb3NpdGlvbiBpcyBudWxsLCB0aGUgZGF0YSB3aWxsIGJlIHdyaXR0ZW4gYXRcbiAgICogICB0aGUgY3VycmVudCBwb3NpdGlvbi5cbiAgICovXG4gIHdyaXRlU3luYyhidWZmZXI6IEJ1ZmZlciwgb2Zmc2V0OiBudW1iZXIsIGxlbmd0aDogbnVtYmVyLCBwb3NpdGlvbjogbnVtYmVyIHwgbnVsbCk6IG51bWJlcjtcbiAgLyoqXG4gICAqICoqQ29yZSoqOiBSZWFkIGRhdGEgZnJvbSB0aGUgZmlsZS5cbiAgICogQHBhcmFtIGJ1ZmZlciBUaGUgYnVmZmVyIHRoYXQgdGhlIGRhdGEgd2lsbCBiZVxuICAgKiAgIHdyaXR0ZW4gdG8uXG4gICAqIEBwYXJhbSBvZmZzZXQgVGhlIG9mZnNldCB3aXRoaW4gdGhlIGJ1ZmZlciB3aGVyZSB3cml0aW5nIHdpbGxcbiAgICogICBzdGFydC5cbiAgICogQHBhcmFtIGxlbmd0aCBBbiBpbnRlZ2VyIHNwZWNpZnlpbmcgdGhlIG51bWJlciBvZiBieXRlcyB0byByZWFkLlxuICAgKiBAcGFyYW0gcG9zaXRpb24gQW4gaW50ZWdlciBzcGVjaWZ5aW5nIHdoZXJlIHRvIGJlZ2luIHJlYWRpbmcgZnJvbVxuICAgKiAgIGluIHRoZSBmaWxlLiBJZiBwb3NpdGlvbiBpcyBudWxsLCBkYXRhIHdpbGwgYmUgcmVhZCBmcm9tIHRoZSBjdXJyZW50IGZpbGVcbiAgICogICBwb3NpdGlvbi5cbiAgICogQHBhcmFtIGNiIFRoZSBudW1iZXIgaXMgdGhlIG51bWJlciBvZiBieXRlcyByZWFkXG4gICAqL1xuICByZWFkKGJ1ZmZlcjogQnVmZmVyLCBvZmZzZXQ6IG51bWJlciwgbGVuZ3RoOiBudW1iZXIsIHBvc2l0aW9uOiBudW1iZXIgfCBudWxsLCBjYjogQkZTVGhyZWVBcmdDYWxsYmFjazxudW1iZXIsIEJ1ZmZlcj4pOiB2b2lkO1xuICAvKipcbiAgICogKipDb3JlKio6IFJlYWQgZGF0YSBmcm9tIHRoZSBmaWxlLlxuICAgKiBAcGFyYW0gYnVmZmVyIFRoZSBidWZmZXIgdGhhdCB0aGUgZGF0YSB3aWxsIGJlIHdyaXR0ZW4gdG8uXG4gICAqIEBwYXJhbSBvZmZzZXQgVGhlIG9mZnNldCB3aXRoaW4gdGhlIGJ1ZmZlciB3aGVyZSB3cml0aW5nIHdpbGwgc3RhcnQuXG4gICAqIEBwYXJhbSBsZW5ndGggQW4gaW50ZWdlciBzcGVjaWZ5aW5nIHRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gcmVhZC5cbiAgICogQHBhcmFtIHBvc2l0aW9uIEFuIGludGVnZXIgc3BlY2lmeWluZyB3aGVyZSB0byBiZWdpbiByZWFkaW5nIGZyb21cbiAgICogICBpbiB0aGUgZmlsZS4gSWYgcG9zaXRpb24gaXMgbnVsbCwgZGF0YSB3aWxsIGJlIHJlYWQgZnJvbSB0aGUgY3VycmVudCBmaWxlXG4gICAqICAgcG9zaXRpb24uXG4gICAqL1xuICByZWFkU3luYyhidWZmZXI6IEJ1ZmZlciwgb2Zmc2V0OiBudW1iZXIsIGxlbmd0aDogbnVtYmVyLCBwb3NpdGlvbjogbnVtYmVyKTogbnVtYmVyO1xuICAvKipcbiAgICogKipTdXBwbGVtZW50YXJ5Kio6IEFzeW5jaHJvbm91cyBgZGF0YXN5bmNgLlxuICAgKlxuICAgKiBEZWZhdWx0IGltcGxlbWVudGF0aW9uIG1hcHMgdG8gYHN5bmNgLlxuICAgKi9cbiAgZGF0YXN5bmMoY2I6IEJGU09uZUFyZ0NhbGxiYWNrKTogdm9pZDtcbiAgLyoqXG4gICAqICoqU3VwcGxlbWVudGFyeSoqOiBTeW5jaHJvbm91cyBgZGF0YXN5bmNgLlxuICAgKlxuICAgKiBEZWZhdWx0IGltcGxlbWVudGF0aW9uIG1hcHMgdG8gYHN5bmNTeW5jYC5cbiAgICovXG4gIGRhdGFzeW5jU3luYygpOiB2b2lkO1xuICAvKipcbiAgICogKipPcHRpb25hbCoqOiBBc3luY2hyb25vdXMgYGNob3duYC5cbiAgICovXG4gIGNob3duKHVpZDogbnVtYmVyLCBnaWQ6IG51bWJlciwgY2I6IEJGU09uZUFyZ0NhbGxiYWNrKTogdm9pZDtcbiAgLyoqXG4gICAqICoqT3B0aW9uYWwqKjogU3luY2hyb25vdXMgYGNob3duYC5cbiAgICovXG4gIGNob3duU3luYyh1aWQ6IG51bWJlciwgZ2lkOiBudW1iZXIpOiB2b2lkO1xuICAvKipcbiAgICogKipPcHRpb25hbCoqOiBBc3luY2hyb25vdXMgYGZjaG1vZGAuXG4gICAqL1xuICBjaG1vZChtb2RlOiBudW1iZXIsIGNiOiBCRlNPbmVBcmdDYWxsYmFjayk6IHZvaWQ7XG4gIC8qKlxuICAgKiAqKk9wdGlvbmFsKio6IFN5bmNocm9ub3VzIGBmY2htb2RgLlxuICAgKi9cbiAgY2htb2RTeW5jKG1vZGU6IG51bWJlcik6IHZvaWQ7XG4gIC8qKlxuICAgKiAqKk9wdGlvbmFsKio6IENoYW5nZSB0aGUgZmlsZSB0aW1lc3RhbXBzIG9mIHRoZSBmaWxlLlxuICAgKi9cbiAgdXRpbWVzKGF0aW1lOiBEYXRlLCBtdGltZTogRGF0ZSwgY2I6IEJGU09uZUFyZ0NhbGxiYWNrKTogdm9pZDtcbiAgLyoqXG4gICAqICoqT3B0aW9uYWwqKjogQ2hhbmdlIHRoZSBmaWxlIHRpbWVzdGFtcHMgb2YgdGhlIGZpbGUuXG4gICAqL1xuICB1dGltZXNTeW5jKGF0aW1lOiBEYXRlLCBtdGltZTogRGF0ZSk6IHZvaWQ7XG59XG5cbi8qKlxuICogQmFzZSBjbGFzcyB0aGF0IGNvbnRhaW5zIHNoYXJlZCBpbXBsZW1lbnRhdGlvbnMgb2YgZnVuY3Rpb25zIGZvciB0aGUgZmlsZVxuICogb2JqZWN0LlxuICovXG5leHBvcnQgY2xhc3MgQmFzZUZpbGUge1xuICBwdWJsaWMgc3luYyhjYjogQkZTT25lQXJnQ2FsbGJhY2spOiB2b2lkIHtcbiAgICBjYihuZXcgQXBpRXJyb3IoRXJyb3JDb2RlLkVOT1RTVVApKTtcbiAgfVxuICBwdWJsaWMgc3luY1N5bmMoKTogdm9pZCB7XG4gICAgdGhyb3cgbmV3IEFwaUVycm9yKEVycm9yQ29kZS5FTk9UU1VQKTtcbiAgfVxuICBwdWJsaWMgZGF0YXN5bmMoY2I6IEJGU09uZUFyZ0NhbGxiYWNrKTogdm9pZCB7XG4gICAgdGhpcy5zeW5jKGNiKTtcbiAgfVxuICBwdWJsaWMgZGF0YXN5bmNTeW5jKCk6IHZvaWQge1xuICAgIHJldHVybiB0aGlzLnN5bmNTeW5jKCk7XG4gIH1cbiAgcHVibGljIGNob3duKHVpZDogbnVtYmVyLCBnaWQ6IG51bWJlciwgY2I6IEJGU09uZUFyZ0NhbGxiYWNrKTogdm9pZCB7XG4gICAgY2IobmV3IEFwaUVycm9yKEVycm9yQ29kZS5FTk9UU1VQKSk7XG4gIH1cbiAgcHVibGljIGNob3duU3luYyh1aWQ6IG51bWJlciwgZ2lkOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aHJvdyBuZXcgQXBpRXJyb3IoRXJyb3JDb2RlLkVOT1RTVVApO1xuICB9XG4gIHB1YmxpYyBjaG1vZChtb2RlOiBudW1iZXIsIGNiOiBCRlNPbmVBcmdDYWxsYmFjayk6IHZvaWQge1xuICAgIGNiKG5ldyBBcGlFcnJvcihFcnJvckNvZGUuRU5PVFNVUCkpO1xuICB9XG4gIHB1YmxpYyBjaG1vZFN5bmMobW9kZTogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhyb3cgbmV3IEFwaUVycm9yKEVycm9yQ29kZS5FTk9UU1VQKTtcbiAgfVxuICBwdWJsaWMgdXRpbWVzKGF0aW1lOiBEYXRlLCBtdGltZTogRGF0ZSwgY2I6IEJGU09uZUFyZ0NhbGxiYWNrKTogdm9pZCB7XG4gICAgY2IobmV3IEFwaUVycm9yKEVycm9yQ29kZS5FTk9UU1VQKSk7XG4gIH1cbiAgcHVibGljIHV0aW1lc1N5bmMoYXRpbWU6IERhdGUsIG10aW1lOiBEYXRlKTogdm9pZCB7XG4gICAgdGhyb3cgbmV3IEFwaUVycm9yKEVycm9yQ29kZS5FTk9UU1VQKTtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uLy4uLy4uLy4uL3NyYy9jb3JlL2ZpbGUudHMiLCJpbXBvcnQge0Jhc2VGaWxlLCBGaWxlfSBmcm9tICcuLi9jb3JlL2ZpbGUnO1xuaW1wb3J0IHtGaWxlU3lzdGVtLCBCRlNPbmVBcmdDYWxsYmFjaywgQkZTQ2FsbGJhY2ssIEJGU1RocmVlQXJnQ2FsbGJhY2t9IGZyb20gJy4uL2NvcmUvZmlsZV9zeXN0ZW0nO1xuaW1wb3J0IFN0YXRzIGZyb20gJy4uL2NvcmUvbm9kZV9mc19zdGF0cyc7XG5pbXBvcnQge0ZpbGVGbGFnfSBmcm9tICcuLi9jb3JlL2ZpbGVfZmxhZyc7XG5pbXBvcnQge0FwaUVycm9yLCBFcnJvckNvZGV9IGZyb20gJy4uL2NvcmUvYXBpX2Vycm9yJztcbmltcG9ydCBmcyBmcm9tICcuLi9jb3JlL25vZGVfZnMnO1xuaW1wb3J0IHtlbXB0eUJ1ZmZlcn0gZnJvbSAnLi4vY29yZS91dGlsJztcblxuLyoqXG4gKiBBbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgRmlsZSBpbnRlcmZhY2UgdGhhdCBvcGVyYXRlcyBvbiBhIGZpbGUgdGhhdCBpc1xuICogY29tcGxldGVseSBpbi1tZW1vcnkuIFByZWxvYWRGaWxlcyBhcmUgYmFja2VkIGJ5IGEgQnVmZmVyLlxuICpcbiAqIFRoaXMgaXMgYWxzbyBhbiBhYnN0cmFjdCBjbGFzcywgYXMgaXQgbGFja3MgYW4gaW1wbGVtZW50YXRpb24gb2YgJ3N5bmMnIGFuZFxuICogJ2Nsb3NlJy4gRWFjaCBmaWxlc3lzdGVtIHRoYXQgd2lzaGVzIHRvIHVzZSB0aGlzIGZpbGUgcmVwcmVzZW50YXRpb24gbXVzdFxuICogZXh0ZW5kIHRoaXMgY2xhc3MgYW5kIGltcGxlbWVudCB0aG9zZSB0d28gbWV0aG9kcy5cbiAqIEB0b2RvICdjbG9zZScgbGV2ZXIgdGhhdCBkaXNhYmxlcyBmdW5jdGlvbmFsaXR5IG9uY2UgY2xvc2VkLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQcmVsb2FkRmlsZTxUIGV4dGVuZHMgRmlsZVN5c3RlbT4gZXh0ZW5kcyBCYXNlRmlsZSB7XG4gIHByb3RlY3RlZCBfZnM6IFQ7XG4gIHByaXZhdGUgX3BvczogbnVtYmVyID0gMDtcbiAgcHJpdmF0ZSBfcGF0aDogc3RyaW5nO1xuICBwcml2YXRlIF9zdGF0OiBTdGF0cztcbiAgcHJpdmF0ZSBfZmxhZzogRmlsZUZsYWc7XG4gIHByaXZhdGUgX2J1ZmZlcjogQnVmZmVyO1xuICBwcml2YXRlIF9kaXJ0eTogYm9vbGVhbiA9IGZhbHNlO1xuICAvKipcbiAgICogQ3JlYXRlcyBhIGZpbGUgd2l0aCB0aGUgZ2l2ZW4gcGF0aCBhbmQsIG9wdGlvbmFsbHksIHRoZSBnaXZlbiBjb250ZW50cy4gTm90ZVxuICAgKiB0aGF0LCBpZiBjb250ZW50cyBpcyBzcGVjaWZpZWQsIGl0IHdpbGwgYmUgbXV0YXRlZCBieSB0aGUgZmlsZSFcbiAgICogQHBhcmFtIF9mcyBUaGUgZmlsZSBzeXN0ZW0gdGhhdCBjcmVhdGVkIHRoZSBmaWxlLlxuICAgKiBAcGFyYW0gX3BhdGhcbiAgICogQHBhcmFtIF9tb2RlIFRoZSBtb2RlIHRoYXQgdGhlIGZpbGUgd2FzIG9wZW5lZCB1c2luZy5cbiAgICogICBEaWN0YXRlcyBwZXJtaXNzaW9ucyBhbmQgd2hlcmUgdGhlIGZpbGUgcG9pbnRlciBzdGFydHMuXG4gICAqIEBwYXJhbSBfc3RhdCBUaGUgc3RhdHMgb2JqZWN0IGZvciB0aGUgZ2l2ZW4gZmlsZS5cbiAgICogICBQcmVsb2FkRmlsZSB3aWxsIG11dGF0ZSB0aGlzIG9iamVjdC4gTm90ZSB0aGF0IHRoaXMgb2JqZWN0IG11c3QgY29udGFpblxuICAgKiAgIHRoZSBhcHByb3ByaWF0ZSBtb2RlIHRoYXQgdGhlIGZpbGUgd2FzIG9wZW5lZCBhcy5cbiAgICogQHBhcmFtIGNvbnRlbnRzIEEgYnVmZmVyIGNvbnRhaW5pbmcgdGhlIGVudGlyZVxuICAgKiAgIGNvbnRlbnRzIG9mIHRoZSBmaWxlLiBQcmVsb2FkRmlsZSB3aWxsIG11dGF0ZSB0aGlzIGJ1ZmZlci4gSWYgbm90XG4gICAqICAgc3BlY2lmaWVkLCB3ZSBhc3N1bWUgaXQgaXMgYSBuZXcgZmlsZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKF9mczogVCwgX3BhdGg6IHN0cmluZywgX2ZsYWc6IEZpbGVGbGFnLCBfc3RhdDogU3RhdHMsIGNvbnRlbnRzPzogQnVmZmVyKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9mcyA9IF9mcztcbiAgICB0aGlzLl9wYXRoID0gX3BhdGg7XG4gICAgdGhpcy5fZmxhZyA9IF9mbGFnO1xuICAgIHRoaXMuX3N0YXQgPSBfc3RhdDtcbiAgICBpZiAoY29udGVudHMpIHtcbiAgICAgIHRoaXMuX2J1ZmZlciA9IGNvbnRlbnRzO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBFbXB0eSBidWZmZXIuIEl0J2xsIGV4cGFuZCBvbmNlIHdlIHdyaXRlIHN0dWZmIHRvIGl0LlxuICAgICAgdGhpcy5fYnVmZmVyID0gZW1wdHlCdWZmZXIoKTtcbiAgICB9XG4gICAgLy8gTm90ZTogVGhpcyBpbnZhcmlhbnQgaXMgKm5vdCogbWFpbnRhaW5lZCBvbmNlIHRoZSBmaWxlIHN0YXJ0cyBnZXR0aW5nXG4gICAgLy8gbW9kaWZpZWQuXG4gICAgLy8gTm90ZTogT25seSBhY3R1YWxseSBtYXR0ZXJzIGlmIGZpbGUgaXMgcmVhZGFibGUsIGFzIHdyaXRlYWJsZSBtb2RlcyBtYXlcbiAgICAvLyB0cnVuY2F0ZS9hcHBlbmQgdG8gZmlsZS5cbiAgICBpZiAodGhpcy5fc3RhdC5zaXplICE9PSB0aGlzLl9idWZmZXIubGVuZ3RoICYmIHRoaXMuX2ZsYWcuaXNSZWFkYWJsZSgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgYnVmZmVyOiBCdWZmZXIgaXMgJHt0aGlzLl9idWZmZXIubGVuZ3RofSBsb25nLCB5ZXQgU3RhdHMgb2JqZWN0IHNwZWNpZmllcyB0aGF0IGZpbGUgaXMgJHt0aGlzLl9zdGF0LnNpemV9IGxvbmcuYCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE5PTlNUQU5EQVJEOiBHZXQgdGhlIHVuZGVybHlpbmcgYnVmZmVyIGZvciB0aGlzIGZpbGUuICEhRE8gTk9UIE1VVEFURSEhIFdpbGwgbWVzcyB1cCBkaXJ0eSB0cmFja2luZy5cbiAgICovXG4gIHB1YmxpYyBnZXRCdWZmZXIoKTogQnVmZmVyIHtcbiAgICByZXR1cm4gdGhpcy5fYnVmZmVyO1xuICB9XG5cbiAgLyoqXG4gICAqIE5PTlNUQU5EQVJEOiBHZXQgdW5kZXJseWluZyBzdGF0cyBmb3IgdGhpcyBmaWxlLiAhIURPIE5PVCBNVVRBVEUhIVxuICAgKi9cbiAgcHVibGljIGdldFN0YXRzKCk6IFN0YXRzIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdDtcbiAgfVxuXG4gIHB1YmxpYyBnZXRGbGFnKCk6IEZpbGVGbGFnIHtcbiAgICByZXR1cm4gdGhpcy5fZmxhZztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHBhdGggdG8gdGhpcyBmaWxlLlxuICAgKiBAcmV0dXJuIFtTdHJpbmddIFRoZSBwYXRoIHRvIHRoZSBmaWxlLlxuICAgKi9cbiAgcHVibGljIGdldFBhdGgoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5fcGF0aDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnQgZmlsZSBwb3NpdGlvbi5cbiAgICpcbiAgICogV2UgZW11bGF0ZSB0aGUgZm9sbG93aW5nIGJ1ZyBtZW50aW9uZWQgaW4gdGhlIE5vZGUgZG9jdW1lbnRhdGlvbjpcbiAgICogPiBPbiBMaW51eCwgcG9zaXRpb25hbCB3cml0ZXMgZG9uJ3Qgd29yayB3aGVuIHRoZSBmaWxlIGlzIG9wZW5lZCBpbiBhcHBlbmRcbiAgICogICBtb2RlLiBUaGUga2VybmVsIGlnbm9yZXMgdGhlIHBvc2l0aW9uIGFyZ3VtZW50IGFuZCBhbHdheXMgYXBwZW5kcyB0aGUgZGF0YVxuICAgKiAgIHRvIHRoZSBlbmQgb2YgdGhlIGZpbGUuXG4gICAqIEByZXR1cm4gW051bWJlcl0gVGhlIGN1cnJlbnQgZmlsZSBwb3NpdGlvbi5cbiAgICovXG4gIHB1YmxpYyBnZXRQb3MoKTogbnVtYmVyIHtcbiAgICBpZiAodGhpcy5fZmxhZy5pc0FwcGVuZGFibGUoKSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3N0YXQuc2l6ZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3BvcztcbiAgfVxuXG4gIC8qKlxuICAgKiBBZHZhbmNlIHRoZSBjdXJyZW50IGZpbGUgcG9zaXRpb24gYnkgdGhlIGluZGljYXRlZCBudW1iZXIgb2YgcG9zaXRpb25zLlxuICAgKiBAcGFyYW0gW051bWJlcl0gZGVsdGFcbiAgICovXG4gIHB1YmxpYyBhZHZhbmNlUG9zKGRlbHRhOiBudW1iZXIpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLl9wb3MgKz0gZGVsdGE7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBmaWxlIHBvc2l0aW9uLlxuICAgKiBAcGFyYW0gW051bWJlcl0gbmV3UG9zXG4gICAqL1xuICBwdWJsaWMgc2V0UG9zKG5ld1BvczogbnVtYmVyKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fcG9zID0gbmV3UG9zO1xuICB9XG5cbiAgLyoqXG4gICAqICoqQ29yZSoqOiBBc3luY2hyb25vdXMgc3luYy4gTXVzdCBiZSBpbXBsZW1lbnRlZCBieSBzdWJjbGFzc2VzIG9mIHRoaXNcbiAgICogY2xhc3MuXG4gICAqIEBwYXJhbSBbRnVuY3Rpb24oQnJvd3NlckZTLkFwaUVycm9yKV0gY2JcbiAgICovXG4gIHB1YmxpYyBzeW5jKGNiOiBCRlNPbmVBcmdDYWxsYmFjayk6IHZvaWQge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLnN5bmNTeW5jKCk7XG4gICAgICBjYigpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNiKGUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiAqKkNvcmUqKjogU3luY2hyb25vdXMgc3luYy5cbiAgICovXG4gIHB1YmxpYyBzeW5jU3luYygpOiB2b2lkIHtcbiAgICB0aHJvdyBuZXcgQXBpRXJyb3IoRXJyb3JDb2RlLkVOT1RTVVApO1xuICB9XG5cbiAgLyoqXG4gICAqICoqQ29yZSoqOiBBc3luY2hyb25vdXMgY2xvc2UuIE11c3QgYmUgaW1wbGVtZW50ZWQgYnkgc3ViY2xhc3NlcyBvZiB0aGlzXG4gICAqIGNsYXNzLlxuICAgKiBAcGFyYW0gW0Z1bmN0aW9uKEJyb3dzZXJGUy5BcGlFcnJvcildIGNiXG4gICAqL1xuICBwdWJsaWMgY2xvc2UoY2I6IEJGU09uZUFyZ0NhbGxiYWNrKTogdm9pZCB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuY2xvc2VTeW5jKCk7XG4gICAgICBjYigpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNiKGUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiAqKkNvcmUqKjogU3luY2hyb25vdXMgY2xvc2UuXG4gICAqL1xuICBwdWJsaWMgY2xvc2VTeW5jKCk6IHZvaWQge1xuICAgIHRocm93IG5ldyBBcGlFcnJvcihFcnJvckNvZGUuRU5PVFNVUCk7XG4gIH1cblxuICAvKipcbiAgICogQXN5bmNocm9ub3VzIGBzdGF0YC5cbiAgICogQHBhcmFtIFtGdW5jdGlvbihCcm93c2VyRlMuQXBpRXJyb3IsIEJyb3dzZXJGUy5ub2RlLmZzLlN0YXRzKV0gY2JcbiAgICovXG4gIHB1YmxpYyBzdGF0KGNiOiBCRlNDYWxsYmFjazxTdGF0cz4pOiB2b2lkIHtcbiAgICB0cnkge1xuICAgICAgY2IobnVsbCwgdGhpcy5fc3RhdC5jbG9uZSgpKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjYihlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3luY2hyb25vdXMgYHN0YXRgLlxuICAgKi9cbiAgcHVibGljIHN0YXRTeW5jKCk6IFN0YXRzIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdC5jbG9uZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFzeW5jaHJvbm91cyB0cnVuY2F0ZS5cbiAgICogQHBhcmFtIFtOdW1iZXJdIGxlblxuICAgKiBAcGFyYW0gW0Z1bmN0aW9uKEJyb3dzZXJGUy5BcGlFcnJvcildIGNiXG4gICAqL1xuICBwdWJsaWMgdHJ1bmNhdGUobGVuOiBudW1iZXIsIGNiOiBCRlNPbmVBcmdDYWxsYmFjayk6IHZvaWQge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLnRydW5jYXRlU3luYyhsZW4pO1xuICAgICAgaWYgKHRoaXMuX2ZsYWcuaXNTeW5jaHJvbm91cygpICYmICFmcy5nZXRSb290RlMoKSEuc3VwcG9ydHNTeW5jaCgpKSB7XG4gICAgICAgIHRoaXMuc3luYyhjYik7XG4gICAgICB9XG4gICAgICBjYigpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBjYihlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3luY2hyb25vdXMgdHJ1bmNhdGUuXG4gICAqIEBwYXJhbSBbTnVtYmVyXSBsZW5cbiAgICovXG4gIHB1YmxpYyB0cnVuY2F0ZVN5bmMobGVuOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XG4gICAgaWYgKCF0aGlzLl9mbGFnLmlzV3JpdGVhYmxlKCkpIHtcbiAgICAgIHRocm93IG5ldyBBcGlFcnJvcihFcnJvckNvZGUuRVBFUk0sICdGaWxlIG5vdCBvcGVuZWQgd2l0aCBhIHdyaXRlYWJsZSBtb2RlLicpO1xuICAgIH1cbiAgICB0aGlzLl9zdGF0Lm10aW1lID0gbmV3IERhdGUoKTtcbiAgICBpZiAobGVuID4gdGhpcy5fYnVmZmVyLmxlbmd0aCkge1xuICAgICAgY29uc3QgYnVmID0gQnVmZmVyLmFsbG9jKGxlbiAtIHRoaXMuX2J1ZmZlci5sZW5ndGgsIDApO1xuICAgICAgLy8gV3JpdGUgd2lsbCBzZXQgQF9zdGF0LnNpemUgZm9yIHVzLlxuICAgICAgdGhpcy53cml0ZVN5bmMoYnVmLCAwLCBidWYubGVuZ3RoLCB0aGlzLl9idWZmZXIubGVuZ3RoKTtcbiAgICAgIGlmICh0aGlzLl9mbGFnLmlzU3luY2hyb25vdXMoKSAmJiBmcy5nZXRSb290RlMoKSEuc3VwcG9ydHNTeW5jaCgpKSB7XG4gICAgICAgIHRoaXMuc3luY1N5bmMoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fc3RhdC5zaXplID0gbGVuO1xuICAgIC8vIFRydW5jYXRlIGJ1ZmZlciB0byAnbGVuJy5cbiAgICBjb25zdCBuZXdCdWZmID0gQnVmZmVyLmFsbG9jKGxlbik7XG4gICAgdGhpcy5fYnVmZmVyLmNvcHkobmV3QnVmZiwgMCwgMCwgbGVuKTtcbiAgICB0aGlzLl9idWZmZXIgPSBuZXdCdWZmO1xuICAgIGlmICh0aGlzLl9mbGFnLmlzU3luY2hyb25vdXMoKSAmJiBmcy5nZXRSb290RlMoKSEuc3VwcG9ydHNTeW5jaCgpKSB7XG4gICAgICB0aGlzLnN5bmNTeW5jKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFdyaXRlIGJ1ZmZlciB0byB0aGUgZmlsZS5cbiAgICogTm90ZSB0aGF0IGl0IGlzIHVuc2FmZSB0byB1c2UgZnMud3JpdGUgbXVsdGlwbGUgdGltZXMgb24gdGhlIHNhbWUgZmlsZVxuICAgKiB3aXRob3V0IHdhaXRpbmcgZm9yIHRoZSBjYWxsYmFjay5cbiAgICogQHBhcmFtIFtCcm93c2VyRlMubm9kZS5CdWZmZXJdIGJ1ZmZlciBCdWZmZXIgY29udGFpbmluZyB0aGUgZGF0YSB0byB3cml0ZSB0b1xuICAgKiAgdGhlIGZpbGUuXG4gICAqIEBwYXJhbSBbTnVtYmVyXSBvZmZzZXQgT2Zmc2V0IGluIHRoZSBidWZmZXIgdG8gc3RhcnQgcmVhZGluZyBkYXRhIGZyb20uXG4gICAqIEBwYXJhbSBbTnVtYmVyXSBsZW5ndGggVGhlIGFtb3VudCBvZiBieXRlcyB0byB3cml0ZSB0byB0aGUgZmlsZS5cbiAgICogQHBhcmFtIFtOdW1iZXJdIHBvc2l0aW9uIE9mZnNldCBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGZpbGUgd2hlcmUgdGhpc1xuICAgKiAgIGRhdGEgc2hvdWxkIGJlIHdyaXR0ZW4uIElmIHBvc2l0aW9uIGlzIG51bGwsIHRoZSBkYXRhIHdpbGwgYmUgd3JpdHRlbiBhdFxuICAgKiAgIHRoZSBjdXJyZW50IHBvc2l0aW9uLlxuICAgKiBAcGFyYW0gW0Z1bmN0aW9uKEJyb3dzZXJGUy5BcGlFcnJvciwgTnVtYmVyLCBCcm93c2VyRlMubm9kZS5CdWZmZXIpXVxuICAgKiAgIGNiIFRoZSBudW1iZXIgc3BlY2lmaWVzIHRoZSBudW1iZXIgb2YgYnl0ZXMgd3JpdHRlbiBpbnRvIHRoZSBmaWxlLlxuICAgKi9cbiAgcHVibGljIHdyaXRlKGJ1ZmZlcjogQnVmZmVyLCBvZmZzZXQ6IG51bWJlciwgbGVuZ3RoOiBudW1iZXIsIHBvc2l0aW9uOiBudW1iZXIsIGNiOiBCRlNUaHJlZUFyZ0NhbGxiYWNrPG51bWJlciwgQnVmZmVyPik6IHZvaWQge1xuICAgIHRyeSB7XG4gICAgICBjYihudWxsLCB0aGlzLndyaXRlU3luYyhidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbiksIGJ1ZmZlcik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY2IoZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFdyaXRlIGJ1ZmZlciB0byB0aGUgZmlsZS5cbiAgICogTm90ZSB0aGF0IGl0IGlzIHVuc2FmZSB0byB1c2UgZnMud3JpdGVTeW5jIG11bHRpcGxlIHRpbWVzIG9uIHRoZSBzYW1lIGZpbGVcbiAgICogd2l0aG91dCB3YWl0aW5nIGZvciB0aGUgY2FsbGJhY2suXG4gICAqIEBwYXJhbSBbQnJvd3NlckZTLm5vZGUuQnVmZmVyXSBidWZmZXIgQnVmZmVyIGNvbnRhaW5pbmcgdGhlIGRhdGEgdG8gd3JpdGUgdG9cbiAgICogIHRoZSBmaWxlLlxuICAgKiBAcGFyYW0gW051bWJlcl0gb2Zmc2V0IE9mZnNldCBpbiB0aGUgYnVmZmVyIHRvIHN0YXJ0IHJlYWRpbmcgZGF0YSBmcm9tLlxuICAgKiBAcGFyYW0gW051bWJlcl0gbGVuZ3RoIFRoZSBhbW91bnQgb2YgYnl0ZXMgdG8gd3JpdGUgdG8gdGhlIGZpbGUuXG4gICAqIEBwYXJhbSBbTnVtYmVyXSBwb3NpdGlvbiBPZmZzZXQgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBmaWxlIHdoZXJlIHRoaXNcbiAgICogICBkYXRhIHNob3VsZCBiZSB3cml0dGVuLiBJZiBwb3NpdGlvbiBpcyBudWxsLCB0aGUgZGF0YSB3aWxsIGJlIHdyaXR0ZW4gYXRcbiAgICogICB0aGUgY3VycmVudCBwb3NpdGlvbi5cbiAgICogQHJldHVybiBbTnVtYmVyXVxuICAgKi9cbiAgcHVibGljIHdyaXRlU3luYyhidWZmZXI6IEJ1ZmZlciwgb2Zmc2V0OiBudW1iZXIsIGxlbmd0aDogbnVtYmVyLCBwb3NpdGlvbjogbnVtYmVyKTogbnVtYmVyIHtcbiAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XG4gICAgaWYgKHBvc2l0aW9uID09PSB1bmRlZmluZWQgfHwgcG9zaXRpb24gPT09IG51bGwpIHtcbiAgICAgIHBvc2l0aW9uID0gdGhpcy5nZXRQb3MoKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9mbGFnLmlzV3JpdGVhYmxlKCkpIHtcbiAgICAgIHRocm93IG5ldyBBcGlFcnJvcihFcnJvckNvZGUuRVBFUk0sICdGaWxlIG5vdCBvcGVuZWQgd2l0aCBhIHdyaXRlYWJsZSBtb2RlLicpO1xuICAgIH1cbiAgICBjb25zdCBlbmRGcCA9IHBvc2l0aW9uICsgbGVuZ3RoO1xuICAgIGlmIChlbmRGcCA+IHRoaXMuX3N0YXQuc2l6ZSkge1xuICAgICAgdGhpcy5fc3RhdC5zaXplID0gZW5kRnA7XG4gICAgICBpZiAoZW5kRnAgPiB0aGlzLl9idWZmZXIubGVuZ3RoKSB7XG4gICAgICAgIC8vIEV4dGVuZCB0aGUgYnVmZmVyIVxuICAgICAgICBjb25zdCBuZXdCdWZmID0gQnVmZmVyLmFsbG9jKGVuZEZwKTtcbiAgICAgICAgdGhpcy5fYnVmZmVyLmNvcHkobmV3QnVmZik7XG4gICAgICAgIHRoaXMuX2J1ZmZlciA9IG5ld0J1ZmY7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGxlbiA9IGJ1ZmZlci5jb3B5KHRoaXMuX2J1ZmZlciwgcG9zaXRpb24sIG9mZnNldCwgb2Zmc2V0ICsgbGVuZ3RoKTtcbiAgICB0aGlzLl9zdGF0Lm10aW1lID0gbmV3IERhdGUoKTtcbiAgICBpZiAodGhpcy5fZmxhZy5pc1N5bmNocm9ub3VzKCkpIHtcbiAgICAgIHRoaXMuc3luY1N5bmMoKTtcbiAgICAgIHJldHVybiBsZW47XG4gICAgfVxuICAgIHRoaXMuc2V0UG9zKHBvc2l0aW9uICsgbGVuKTtcbiAgICByZXR1cm4gbGVuO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlYWQgZGF0YSBmcm9tIHRoZSBmaWxlLlxuICAgKiBAcGFyYW0gW0Jyb3dzZXJGUy5ub2RlLkJ1ZmZlcl0gYnVmZmVyIFRoZSBidWZmZXIgdGhhdCB0aGUgZGF0YSB3aWxsIGJlXG4gICAqICAgd3JpdHRlbiB0by5cbiAgICogQHBhcmFtIFtOdW1iZXJdIG9mZnNldCBUaGUgb2Zmc2V0IHdpdGhpbiB0aGUgYnVmZmVyIHdoZXJlIHdyaXRpbmcgd2lsbFxuICAgKiAgIHN0YXJ0LlxuICAgKiBAcGFyYW0gW051bWJlcl0gbGVuZ3RoIEFuIGludGVnZXIgc3BlY2lmeWluZyB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRvIHJlYWQuXG4gICAqIEBwYXJhbSBbTnVtYmVyXSBwb3NpdGlvbiBBbiBpbnRlZ2VyIHNwZWNpZnlpbmcgd2hlcmUgdG8gYmVnaW4gcmVhZGluZyBmcm9tXG4gICAqICAgaW4gdGhlIGZpbGUuIElmIHBvc2l0aW9uIGlzIG51bGwsIGRhdGEgd2lsbCBiZSByZWFkIGZyb20gdGhlIGN1cnJlbnQgZmlsZVxuICAgKiAgIHBvc2l0aW9uLlxuICAgKiBAcGFyYW0gW0Z1bmN0aW9uKEJyb3dzZXJGUy5BcGlFcnJvciwgTnVtYmVyLCBCcm93c2VyRlMubm9kZS5CdWZmZXIpXSBjYiBUaGVcbiAgICogICBudW1iZXIgaXMgdGhlIG51bWJlciBvZiBieXRlcyByZWFkXG4gICAqL1xuICBwdWJsaWMgcmVhZChidWZmZXI6IEJ1ZmZlciwgb2Zmc2V0OiBudW1iZXIsIGxlbmd0aDogbnVtYmVyLCBwb3NpdGlvbjogbnVtYmVyLCBjYjogQkZTVGhyZWVBcmdDYWxsYmFjazxudW1iZXIsIEJ1ZmZlcj4pOiB2b2lkIHtcbiAgICB0cnkge1xuICAgICAgY2IobnVsbCwgdGhpcy5yZWFkU3luYyhidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbiksIGJ1ZmZlcik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY2IoZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlYWQgZGF0YSBmcm9tIHRoZSBmaWxlLlxuICAgKiBAcGFyYW0gW0Jyb3dzZXJGUy5ub2RlLkJ1ZmZlcl0gYnVmZmVyIFRoZSBidWZmZXIgdGhhdCB0aGUgZGF0YSB3aWxsIGJlXG4gICAqICAgd3JpdHRlbiB0by5cbiAgICogQHBhcmFtIFtOdW1iZXJdIG9mZnNldCBUaGUgb2Zmc2V0IHdpdGhpbiB0aGUgYnVmZmVyIHdoZXJlIHdyaXRpbmcgd2lsbFxuICAgKiAgIHN0YXJ0LlxuICAgKiBAcGFyYW0gW051bWJlcl0gbGVuZ3RoIEFuIGludGVnZXIgc3BlY2lmeWluZyB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRvIHJlYWQuXG4gICAqIEBwYXJhbSBbTnVtYmVyXSBwb3NpdGlvbiBBbiBpbnRlZ2VyIHNwZWNpZnlpbmcgd2hlcmUgdG8gYmVnaW4gcmVhZGluZyBmcm9tXG4gICAqICAgaW4gdGhlIGZpbGUuIElmIHBvc2l0aW9uIGlzIG51bGwsIGRhdGEgd2lsbCBiZSByZWFkIGZyb20gdGhlIGN1cnJlbnQgZmlsZVxuICAgKiAgIHBvc2l0aW9uLlxuICAgKiBAcmV0dXJuIFtOdW1iZXJdXG4gICAqL1xuICBwdWJsaWMgcmVhZFN5bmMoYnVmZmVyOiBCdWZmZXIsIG9mZnNldDogbnVtYmVyLCBsZW5ndGg6IG51bWJlciwgcG9zaXRpb246IG51bWJlcik6IG51bWJlciB7XG4gICAgaWYgKCF0aGlzLl9mbGFnLmlzUmVhZGFibGUoKSkge1xuICAgICAgdGhyb3cgbmV3IEFwaUVycm9yKEVycm9yQ29kZS5FUEVSTSwgJ0ZpbGUgbm90IG9wZW5lZCB3aXRoIGEgcmVhZGFibGUgbW9kZS4nKTtcbiAgICB9XG4gICAgaWYgKHBvc2l0aW9uID09PSB1bmRlZmluZWQgfHwgcG9zaXRpb24gPT09IG51bGwpIHtcbiAgICAgIHBvc2l0aW9uID0gdGhpcy5nZXRQb3MoKTtcbiAgICB9XG4gICAgY29uc3QgZW5kUmVhZCA9IHBvc2l0aW9uICsgbGVuZ3RoO1xuICAgIGlmIChlbmRSZWFkID4gdGhpcy5fc3RhdC5zaXplKSB7XG4gICAgICBsZW5ndGggPSB0aGlzLl9zdGF0LnNpemUgLSBwb3NpdGlvbjtcbiAgICB9XG4gICAgY29uc3QgcnYgPSB0aGlzLl9idWZmZXIuY29weShidWZmZXIsIG9mZnNldCwgcG9zaXRpb24sIHBvc2l0aW9uICsgbGVuZ3RoKTtcbiAgICB0aGlzLl9zdGF0LmF0aW1lID0gbmV3IERhdGUoKTtcbiAgICB0aGlzLl9wb3MgPSBwb3NpdGlvbiArIGxlbmd0aDtcbiAgICByZXR1cm4gcnY7XG4gIH1cblxuICAvKipcbiAgICogQXN5bmNocm9ub3VzIGBmY2htb2RgLlxuICAgKiBAcGFyYW0gW051bWJlcnxTdHJpbmddIG1vZGVcbiAgICogQHBhcmFtIFtGdW5jdGlvbihCcm93c2VyRlMuQXBpRXJyb3IpXSBjYlxuICAgKi9cbiAgcHVibGljIGNobW9kKG1vZGU6IG51bWJlciwgY2I6IEJGU09uZUFyZ0NhbGxiYWNrKTogdm9pZCB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuY2htb2RTeW5jKG1vZGUpO1xuICAgICAgY2IoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjYihlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQXN5bmNocm9ub3VzIGBmY2htb2RgLlxuICAgKiBAcGFyYW0gW051bWJlcl0gbW9kZVxuICAgKi9cbiAgcHVibGljIGNobW9kU3luYyhtb2RlOiBudW1iZXIpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuX2ZzLnN1cHBvcnRzUHJvcHMoKSkge1xuICAgICAgdGhyb3cgbmV3IEFwaUVycm9yKEVycm9yQ29kZS5FTk9UU1VQKTtcbiAgICB9XG4gICAgdGhpcy5fZGlydHkgPSB0cnVlO1xuICAgIHRoaXMuX3N0YXQuY2htb2QobW9kZSk7XG4gICAgdGhpcy5zeW5jU3luYygpO1xuICB9XG5cbiAgcHJvdGVjdGVkIGlzRGlydHkoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX2RpcnR5O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc2V0cyB0aGUgZGlydHkgYml0LiBTaG91bGQgb25seSBiZSBjYWxsZWQgYWZ0ZXIgYSBzeW5jIGhhcyBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5LlxuICAgKi9cbiAgcHJvdGVjdGVkIHJlc2V0RGlydHkoKSB7XG4gICAgdGhpcy5fZGlydHkgPSBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIEZpbGUgY2xhc3MgZm9yIHRoZSBJbk1lbW9yeSBhbmQgWEhSIGZpbGUgc3lzdGVtcy5cbiAqIERvZXNuJ3Qgc3luYyB0byBhbnl0aGluZywgc28gaXQgd29ya3MgbmljZWx5IGZvciBtZW1vcnktb25seSBmaWxlcy5cbiAqL1xuZXhwb3J0IGNsYXNzIE5vU3luY0ZpbGU8VCBleHRlbmRzIEZpbGVTeXN0ZW0+IGV4dGVuZHMgUHJlbG9hZEZpbGU8VD4gaW1wbGVtZW50cyBGaWxlIHtcbiAgY29uc3RydWN0b3IoX2ZzOiBULCBfcGF0aDogc3RyaW5nLCBfZmxhZzogRmlsZUZsYWcsIF9zdGF0OiBTdGF0cywgY29udGVudHM/OiBCdWZmZXIpIHtcbiAgICBzdXBlcihfZnMsIF9wYXRoLCBfZmxhZywgX3N0YXQsIGNvbnRlbnRzKTtcbiAgfVxuICAvKipcbiAgICogQXN5bmNocm9ub3VzIHN5bmMuIERvZXNuJ3QgZG8gYW55dGhpbmcsIHNpbXBseSBjYWxscyB0aGUgY2IuXG4gICAqIEBwYXJhbSBbRnVuY3Rpb24oQnJvd3NlckZTLkFwaUVycm9yKV0gY2JcbiAgICovXG4gIHB1YmxpYyBzeW5jKGNiOiBCRlNPbmVBcmdDYWxsYmFjayk6IHZvaWQge1xuICAgIGNiKCk7XG4gIH1cbiAgLyoqXG4gICAqIFN5bmNocm9ub3VzIHN5bmMuIERvZXNuJ3QgZG8gYW55dGhpbmcuXG4gICAqL1xuICBwdWJsaWMgc3luY1N5bmMoKTogdm9pZCB7XG4gICAgLy8gTk9QLlxuICB9XG4gIC8qKlxuICAgKiBBc3luY2hyb25vdXMgY2xvc2UuIERvZXNuJ3QgZG8gYW55dGhpbmcsIHNpbXBseSBjYWxscyB0aGUgY2IuXG4gICAqIEBwYXJhbSBbRnVuY3Rpb24oQnJvd3NlckZTLkFwaUVycm9yKV0gY2JcbiAgICovXG4gIHB1YmxpYyBjbG9zZShjYjogQkZTT25lQXJnQ2FsbGJhY2spOiB2b2lkIHtcbiAgICBjYigpO1xuICB9XG4gIC8qKlxuICAgKiBTeW5jaHJvbm91cyBjbG9zZS4gRG9lc24ndCBkbyBhbnl0aGluZy5cbiAgICovXG4gIHB1YmxpYyBjbG9zZVN5bmMoKTogdm9pZCB7XG4gICAgLy8gTk9QLlxuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vLi4vLi4vLi4vc3JjL2dlbmVyaWMvcHJlbG9hZF9maWxlLnRzIiwiaW1wb3J0IHtGaWxlU3lzdGVtLCBTeW5jaHJvbm91c0ZpbGVTeXN0ZW0sIEJGU09uZUFyZ0NhbGxiYWNrLCBCRlNDYWxsYmFjaywgRmlsZVN5c3RlbU9wdGlvbnN9IGZyb20gJy4uL2NvcmUvZmlsZV9zeXN0ZW0nO1xuaW1wb3J0IHtBcGlFcnJvciwgRXJyb3JDb2RlfSBmcm9tICcuLi9jb3JlL2FwaV9lcnJvcic7XG5pbXBvcnQge0ZpbGVGbGFnfSBmcm9tICcuLi9jb3JlL2ZpbGVfZmxhZyc7XG5pbXBvcnQge0ZpbGV9IGZyb20gJy4uL2NvcmUvZmlsZSc7XG5pbXBvcnQgU3RhdHMgZnJvbSAnLi4vY29yZS9ub2RlX2ZzX3N0YXRzJztcbmltcG9ydCBQcmVsb2FkRmlsZSBmcm9tICcuLi9nZW5lcmljL3ByZWxvYWRfZmlsZSc7XG5pbXBvcnQge2RlcHJlY2F0aW9uTWVzc2FnZX0gZnJvbSAnLi4vY29yZS91dGlsJztcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5pbnRlcmZhY2UgSUFzeW5jT3BlcmF0aW9uIHtcbiAgYXBpTWV0aG9kOiBzdHJpbmc7XG4gIGFyZ3VtZW50czogYW55W107XG59XG5cbi8qKlxuICogV2UgZGVmaW5lIG91ciBvd24gZmlsZSB0byBpbnRlcnBvc2Ugb24gc3luY1N5bmMoKSBmb3IgbWlycm9yaW5nIHB1cnBvc2VzLlxuICovXG5jbGFzcyBNaXJyb3JGaWxlIGV4dGVuZHMgUHJlbG9hZEZpbGU8QXN5bmNNaXJyb3I+IGltcGxlbWVudHMgRmlsZSB7XG4gIGNvbnN0cnVjdG9yKGZzOiBBc3luY01pcnJvciwgcGF0aDogc3RyaW5nLCBmbGFnOiBGaWxlRmxhZywgc3RhdDogU3RhdHMsIGRhdGE6IEJ1ZmZlcikge1xuICAgIHN1cGVyKGZzLCBwYXRoLCBmbGFnLCBzdGF0LCBkYXRhKTtcbiAgfVxuXG4gIHB1YmxpYyBzeW5jU3luYygpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5pc0RpcnR5KCkpIHtcbiAgICAgIHRoaXMuX2ZzLl9zeW5jU3luYyh0aGlzKTtcbiAgICAgIHRoaXMucmVzZXREaXJ0eSgpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBjbG9zZVN5bmMoKTogdm9pZCB7XG4gICAgdGhpcy5zeW5jU3luYygpO1xuICB9XG59XG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGUgQXN5bmNNaXJyb3IgZmlsZSBzeXN0ZW0uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQXN5bmNNaXJyb3JPcHRpb25zIHtcbiAgLy8gVGhlIHN5bmNocm9ub3VzIGZpbGUgc3lzdGVtIHRvIG1pcnJvciB0aGUgYXN5bmNocm9ub3VzIGZpbGUgc3lzdGVtIHRvLlxuICBzeW5jOiBGaWxlU3lzdGVtO1xuICAvLyBUaGUgYXN5bmNocm9ub3VzIGZpbGUgc3lzdGVtIHRvIG1pcnJvci5cbiAgYXN5bmM6IEZpbGVTeXN0ZW07XG59XG5cbi8qKlxuICogQXN5bmNNaXJyb3JGUyBtaXJyb3JzIGEgc3luY2hyb25vdXMgZmlsZXN5c3RlbSBpbnRvIGFuIGFzeW5jaHJvbm91cyBmaWxlc3lzdGVtXG4gKiBieTpcbiAqXG4gKiAqIFBlcmZvcm1pbmcgb3BlcmF0aW9ucyBvdmVyIHRoZSBpbi1tZW1vcnkgY29weSwgd2hpbGUgYXN5bmNocm9ub3VzbHkgcGlwZWxpbmluZyB0aGVtXG4gKiAgIHRvIHRoZSBiYWNraW5nIHN0b3JlLlxuICogKiBEdXJpbmcgYXBwbGljYXRpb24gbG9hZGluZywgdGhlIGNvbnRlbnRzIG9mIHRoZSBhc3luYyBmaWxlIHN5c3RlbSBjYW4gYmUgcmVsb2FkZWQgaW50b1xuICogICB0aGUgc3luY2hyb25vdXMgc3RvcmUsIGlmIGRlc2lyZWQuXG4gKlxuICogVGhlIHR3byBzdG9yZXMgd2lsbCBiZSBrZXB0IGluIHN5bmMuIFRoZSBtb3N0IGNvbW1vbiB1c2UtY2FzZSBpcyB0byBwYWlyIGEgc3luY2hyb25vdXNcbiAqIGluLW1lbW9yeSBmaWxlc3lzdGVtIHdpdGggYW4gYXN5bmNocm9ub3VzIGJhY2tpbmcgc3RvcmUuXG4gKlxuICogRXhhbXBsZTogTWlycm9yaW5nIGFuIEluZGV4ZWREQiBmaWxlIHN5c3RlbSB0byBhbiBpbiBtZW1vcnkgZmlsZSBzeXN0ZW0uIE5vdywgeW91IGNhbiB1c2VcbiAqIEluZGV4ZWREQiBzeW5jaHJvbm91c2x5LlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIEJyb3dzZXJGUy5jb25maWd1cmUoe1xuICogICBmczogXCJBc3luY01pcnJvclwiLFxuICogICBvcHRpb25zOiB7XG4gKiAgICAgc3luYzogeyBmczogXCJJbk1lbW9yeVwiIH0sXG4gKiAgICAgYXN5bmM6IHsgZnM6IFwiSW5kZXhlZERCXCIgfVxuICogICB9XG4gKiB9LCBmdW5jdGlvbihlKSB7XG4gKiAgIC8vIEJyb3dzZXJGUyBpcyBpbml0aWFsaXplZCBhbmQgcmVhZHktdG8tdXNlIVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBPciwgYWx0ZXJuYXRpdmVseTpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBCcm93c2VyRlMuRmlsZVN5c3RlbS5JbmRleGVkREIuQ3JlYXRlKGZ1bmN0aW9uKGUsIGlkYmZzKSB7XG4gKiAgIEJyb3dzZXJGUy5GaWxlU3lzdGVtLkluTWVtb3J5LkNyZWF0ZShmdW5jdGlvbihlLCBpbk1lbW9yeSkge1xuICogICAgIEJyb3dzZXJGUy5GaWxlU3lzdGVtLkFzeW5jTWlycm9yKHtcbiAqICAgICAgIHN5bmM6IGluTWVtb3J5LCBhc3luYzogaWRiZnNcbiAqICAgICB9LCBmdW5jdGlvbihlLCBtaXJyb3JlZCkge1xuICogICAgICAgQnJvd3NlckZTLmluaXRpYWxpemUobWlycm9yZWQpO1xuICogICAgIH0pO1xuICogICB9KTtcbiAqIH0pO1xuICogYGBgXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFzeW5jTWlycm9yIGV4dGVuZHMgU3luY2hyb25vdXNGaWxlU3lzdGVtIGltcGxlbWVudHMgRmlsZVN5c3RlbSB7XG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgTmFtZSA9IFwiQXN5bmNNaXJyb3JcIjtcblxuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IE9wdGlvbnM6IEZpbGVTeXN0ZW1PcHRpb25zID0ge1xuICAgIHN5bmM6IHtcbiAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICBkZXNjcmlwdGlvbjogXCJUaGUgc3luY2hyb25vdXMgZmlsZSBzeXN0ZW0gdG8gbWlycm9yIHRoZSBhc3luY2hyb25vdXMgZmlsZSBzeXN0ZW0gdG8uXCJcbiAgICB9LFxuICAgIGFzeW5jOiB7XG4gICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgZGVzY3JpcHRpb246IFwiVGhlIGFzeW5jaHJvbm91cyBmaWxlIHN5c3RlbSB0byBtaXJyb3IuXCJcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYW5kIGluaXRpYWxpemVzIGFuIEFzeW5jTWlycm9yIGZpbGUgc3lzdGVtIHdpdGggdGhlIGdpdmVuIG9wdGlvbnMuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIENyZWF0ZShvcHRzOiBBc3luY01pcnJvck9wdGlvbnMsIGNiOiBCRlNDYWxsYmFjazxBc3luY01pcnJvcj4pOiB2b2lkIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZnMgPSBuZXcgQXN5bmNNaXJyb3Iob3B0cy5zeW5jLCBvcHRzLmFzeW5jLCBmYWxzZSk7XG4gICAgICBmcy5pbml0aWFsaXplKChlPykgPT4ge1xuICAgICAgICBpZiAoZSkge1xuICAgICAgICAgIGNiKGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNiKG51bGwsIGZzKTtcbiAgICAgICAgfVxuICAgICAgfSwgZmFsc2UpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNiKGUpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgaXNBdmFpbGFibGUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogUXVldWUgb2YgcGVuZGluZyBhc3luY2hyb25vdXMgb3BlcmF0aW9ucy5cbiAgICovXG4gIHByaXZhdGUgX3F1ZXVlOiBJQXN5bmNPcGVyYXRpb25bXSA9IFtdO1xuICBwcml2YXRlIF9xdWV1ZVJ1bm5pbmc6IGJvb2xlYW4gPSBmYWxzZTtcbiAgcHJpdmF0ZSBfc3luYzogRmlsZVN5c3RlbTtcbiAgcHJpdmF0ZSBfYXN5bmM6IEZpbGVTeXN0ZW07XG4gIHByaXZhdGUgX2lzSW5pdGlhbGl6ZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgcHJpdmF0ZSBfaW5pdGlhbGl6ZUNhbGxiYWNrczogKChlPzogQXBpRXJyb3IpID0+IHZvaWQpW10gPSBbXTtcblxuICAvKipcbiAgICogKipEZXByZWNhdGVkOyB1c2UgQXN5bmNNaXJyb3IuQ3JlYXRlKCkgbWV0aG9kIGluc3RlYWQuKipcbiAgICpcbiAgICogTWlycm9ycyB0aGUgc3luY2hyb25vdXMgZmlsZSBzeXN0ZW0gaW50byB0aGUgYXN5bmNocm9ub3VzIGZpbGUgc3lzdGVtLlxuICAgKlxuICAgKiAqKklNUE9SVEFOVCoqOiBZb3UgbXVzdCBjYWxsIGBpbml0aWFsaXplYCBvbiB0aGUgZmlsZSBzeXN0ZW0gYmVmb3JlIGl0IGNhbiBiZSB1c2VkLlxuICAgKiBAcGFyYW0gc3luYyBUaGUgc3luY2hyb25vdXMgZmlsZSBzeXN0ZW0gdG8gbWlycm9yIHRoZSBhc3luY2hyb25vdXMgZmlsZSBzeXN0ZW0gdG8uXG4gICAqIEBwYXJhbSBhc3luYyBUaGUgYXN5bmNocm9ub3VzIGZpbGUgc3lzdGVtIHRvIG1pcnJvci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHN5bmM6IEZpbGVTeXN0ZW0sIGFzeW5jOiBGaWxlU3lzdGVtLCBkZXByZWNhdGVNc2cgPSB0cnVlKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9zeW5jID0gc3luYztcbiAgICB0aGlzLl9hc3luYyA9IGFzeW5jO1xuICAgIGlmICghc3luYy5zdXBwb3J0c1N5bmNoKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBmaXJzdCBhcmd1bWVudCB0byBBc3luY01pcnJvciBuZWVkcyB0byBiZSBhIHN5bmNocm9ub3VzIGZpbGUgc3lzdGVtLlwiKTtcbiAgICB9XG4gICAgZGVwcmVjYXRpb25NZXNzYWdlKGRlcHJlY2F0ZU1zZywgQXN5bmNNaXJyb3IuTmFtZSwgeyBzeW5jOiBcInN5bmMgZmlsZSBzeXN0ZW0gaW5zdGFuY2VcIiwgYXN5bmM6IFwiYXN5bmMgZmlsZSBzeXN0ZW0gaW5zdGFuY2VcIn0pO1xuICB9XG5cbiAgcHVibGljIGdldE5hbWUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gQXN5bmNNaXJyb3IuTmFtZTtcbiAgfVxuXG4gIHB1YmxpYyBfc3luY1N5bmMoZmQ6IFByZWxvYWRGaWxlPGFueT4pIHtcbiAgICB0aGlzLl9zeW5jLndyaXRlRmlsZVN5bmMoZmQuZ2V0UGF0aCgpLCBmZC5nZXRCdWZmZXIoKSwgbnVsbCwgRmlsZUZsYWcuZ2V0RmlsZUZsYWcoJ3cnKSwgZmQuZ2V0U3RhdHMoKS5tb2RlKTtcbiAgICB0aGlzLmVucXVldWVPcCh7XG4gICAgICBhcGlNZXRob2Q6ICd3cml0ZUZpbGUnLFxuICAgICAgYXJndW1lbnRzOiBbZmQuZ2V0UGF0aCgpLCBmZC5nZXRCdWZmZXIoKSwgbnVsbCwgZmQuZ2V0RmxhZygpLCBmZC5nZXRTdGF0cygpLm1vZGVdXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsbGVkIG9uY2UgdG8gbG9hZCB1cCBmaWxlcyBmcm9tIGFzeW5jIHN0b3JhZ2UgaW50byBzeW5jIHN0b3JhZ2UuXG4gICAqL1xuICBwdWJsaWMgaW5pdGlhbGl6ZSh1c2VyQ2I6IEJGU09uZUFyZ0NhbGxiYWNrLCBkZXByZWNhdGVNc2cgPSB0cnVlKTogdm9pZCB7XG4gICAgaWYgKGRlcHJlY2F0ZU1zZykge1xuICAgICAgY29uc29sZS53YXJuKGBbQXN5bmNNaXJyb3JdIEFzeW5jTWlycm9yLmluaXRpYWxpemUoKSBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbi4gUGxlYXNlIHVzZSAnQXN5bmNNaXJyb3IuQ3JlYXRlKHsgc3luYzogKHN5bmMgZmlsZSBzeXN0ZW0gaW5zdGFuY2UpLCBhc3luYzogKGFzeW5jIGZpbGUgc3lzdGVtIGluc3RhbmNlKX0sIGNiKScgdG8gY3JlYXRlIGFuZCBpbml0aWFsaXplIEFzeW5jTWlycm9yIGluc3RhbmNlcy5gKTtcbiAgICB9XG4gICAgY29uc3QgY2FsbGJhY2tzID0gdGhpcy5faW5pdGlhbGl6ZUNhbGxiYWNrcztcblxuICAgIGNvbnN0IGVuZCA9IChlPzogQXBpRXJyb3IpOiB2b2lkID0+IHtcbiAgICAgIHRoaXMuX2lzSW5pdGlhbGl6ZWQgPSAhZTtcbiAgICAgIHRoaXMuX2luaXRpYWxpemVDYWxsYmFja3MgPSBbXTtcbiAgICAgIGNhbGxiYWNrcy5mb3JFYWNoKChjYikgPT4gY2IoZSkpO1xuICAgIH07XG5cbiAgICBpZiAoIXRoaXMuX2lzSW5pdGlhbGl6ZWQpIHtcbiAgICAgIC8vIEZpcnN0IGNhbGwgdHJpZ2dlcnMgaW5pdGlhbGl6YXRpb24sIHRoZSByZXN0IHdhaXQuXG4gICAgICBpZiAoY2FsbGJhY2tzLnB1c2godXNlckNiKSA9PT0gMSkge1xuICAgICAgICBjb25zdCBjb3B5RGlyZWN0b3J5ID0gKHA6IHN0cmluZywgbW9kZTogbnVtYmVyLCBjYjogQkZTT25lQXJnQ2FsbGJhY2spID0+IHtcbiAgICAgICAgICBpZiAocCAhPT0gJy8nKSB7XG4gICAgICAgICAgICB0aGlzLl9zeW5jLm1rZGlyU3luYyhwLCBtb2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fYXN5bmMucmVhZGRpcihwLCAoZXJyLCBmaWxlcykgPT4ge1xuICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgLy8gTk9URTogVGhpcyBmdW5jdGlvbiBtdXN0IG5vdCBiZSBpbiBhIGxleGljYWxseSBuZXN0ZWQgc3RhdGVtZW50LFxuICAgICAgICAgICAgLy8gc3VjaCBhcyBhbiBpZiBvciB3aGlsZSBzdGF0ZW1lbnQuIFNhZmFyaSByZWZ1c2VzIHRvIHJ1biB0aGVcbiAgICAgICAgICAgIC8vIHNjcmlwdCBzaW5jZSBpdCBpcyB1bmRlZmluZWQgYmVoYXZpb3IuXG4gICAgICAgICAgICBmdW5jdGlvbiBjb3B5TmV4dEZpbGUoZXJyPzogQXBpRXJyb3IpIHtcbiAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIGNiKGVycik7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoaSA8IGZpbGVzIS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb3B5SXRlbShwYXRoLmpvaW4ocCwgZmlsZXMhW2ldKSwgY29weU5leHRGaWxlKTtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2IoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICBjYihlcnIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29weU5leHRGaWxlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sIGNvcHlGaWxlID0gKHA6IHN0cmluZywgbW9kZTogbnVtYmVyLCBjYjogQkZTT25lQXJnQ2FsbGJhY2spID0+IHtcbiAgICAgICAgICB0aGlzLl9hc3luYy5yZWFkRmlsZShwLCBudWxsLCBGaWxlRmxhZy5nZXRGaWxlRmxhZygncicpLCAoZXJyLCBkYXRhKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgIGNiKGVycik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N5bmMud3JpdGVGaWxlU3luYyhwLCBkYXRhISwgbnVsbCwgRmlsZUZsYWcuZ2V0RmlsZUZsYWcoJ3cnKSwgbW9kZSk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBlcnIgPSBlO1xuICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIGNiKGVycik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgY29weUl0ZW0gPSAocDogc3RyaW5nLCBjYjogQkZTT25lQXJnQ2FsbGJhY2spID0+IHtcbiAgICAgICAgICB0aGlzLl9hc3luYy5zdGF0KHAsIGZhbHNlLCAoZXJyLCBzdGF0cykgPT4ge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICBjYihlcnIpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzdGF0cyEuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgICAgICAgICBjb3B5RGlyZWN0b3J5KHAsIHN0YXRzIS5tb2RlLCBjYik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb3B5RmlsZShwLCBzdGF0cyEubW9kZSwgY2IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBjb3B5RGlyZWN0b3J5KCcvJywgMCwgZW5kKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdXNlckNiKCk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGlzUmVhZE9ubHkoKTogYm9vbGVhbiB7IHJldHVybiBmYWxzZTsgfVxuICBwdWJsaWMgc3VwcG9ydHNTeW5jaCgpOiBib29sZWFuIHsgcmV0dXJuIHRydWU7IH1cbiAgcHVibGljIHN1cHBvcnRzTGlua3MoKTogYm9vbGVhbiB7IHJldHVybiBmYWxzZTsgfVxuICBwdWJsaWMgc3VwcG9ydHNQcm9wcygpOiBib29sZWFuIHsgcmV0dXJuIHRoaXMuX3N5bmMuc3VwcG9ydHNQcm9wcygpICYmIHRoaXMuX2FzeW5jLnN1cHBvcnRzUHJvcHMoKTsgfVxuXG4gIHB1YmxpYyByZW5hbWVTeW5jKG9sZFBhdGg6IHN0cmluZywgbmV3UGF0aDogc3RyaW5nKTogdm9pZCB7XG4gICAgdGhpcy5jaGVja0luaXRpYWxpemVkKCk7XG4gICAgdGhpcy5fc3luYy5yZW5hbWVTeW5jKG9sZFBhdGgsIG5ld1BhdGgpO1xuICAgIHRoaXMuZW5xdWV1ZU9wKHtcbiAgICAgIGFwaU1ldGhvZDogJ3JlbmFtZScsXG4gICAgICBhcmd1bWVudHM6IFtvbGRQYXRoLCBuZXdQYXRoXVxuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIHN0YXRTeW5jKHA6IHN0cmluZywgaXNMc3RhdDogYm9vbGVhbik6IFN0YXRzIHtcbiAgICB0aGlzLmNoZWNrSW5pdGlhbGl6ZWQoKTtcbiAgICByZXR1cm4gdGhpcy5fc3luYy5zdGF0U3luYyhwLCBpc0xzdGF0KTtcbiAgfVxuXG4gIHB1YmxpYyBvcGVuU3luYyhwOiBzdHJpbmcsIGZsYWc6IEZpbGVGbGFnLCBtb2RlOiBudW1iZXIpOiBGaWxlIHtcbiAgICB0aGlzLmNoZWNrSW5pdGlhbGl6ZWQoKTtcbiAgICAvLyBTYW5pdHkgY2hlY2s6IElzIHRoaXMgb3Blbi9jbG9zZSBwZXJtaXR0ZWQ/XG4gICAgY29uc3QgZmQgPSB0aGlzLl9zeW5jLm9wZW5TeW5jKHAsIGZsYWcsIG1vZGUpO1xuICAgIGZkLmNsb3NlU3luYygpO1xuICAgIHJldHVybiBuZXcgTWlycm9yRmlsZSh0aGlzLCBwLCBmbGFnLCB0aGlzLl9zeW5jLnN0YXRTeW5jKHAsIGZhbHNlKSwgdGhpcy5fc3luYy5yZWFkRmlsZVN5bmMocCwgbnVsbCwgRmlsZUZsYWcuZ2V0RmlsZUZsYWcoJ3InKSkpO1xuICB9XG5cbiAgcHVibGljIHVubGlua1N5bmMocDogc3RyaW5nKTogdm9pZCB7XG4gICAgdGhpcy5jaGVja0luaXRpYWxpemVkKCk7XG4gICAgdGhpcy5fc3luYy51bmxpbmtTeW5jKHApO1xuICAgIHRoaXMuZW5xdWV1ZU9wKHtcbiAgICAgIGFwaU1ldGhvZDogJ3VubGluaycsXG4gICAgICBhcmd1bWVudHM6IFtwXVxuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIHJtZGlyU3luYyhwOiBzdHJpbmcpOiB2b2lkIHtcbiAgICB0aGlzLmNoZWNrSW5pdGlhbGl6ZWQoKTtcbiAgICB0aGlzLl9zeW5jLnJtZGlyU3luYyhwKTtcbiAgICB0aGlzLmVucXVldWVPcCh7XG4gICAgICBhcGlNZXRob2Q6ICdybWRpcicsXG4gICAgICBhcmd1bWVudHM6IFtwXVxuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIG1rZGlyU3luYyhwOiBzdHJpbmcsIG1vZGU6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMuY2hlY2tJbml0aWFsaXplZCgpO1xuICAgIHRoaXMuX3N5bmMubWtkaXJTeW5jKHAsIG1vZGUpO1xuICAgIHRoaXMuZW5xdWV1ZU9wKHtcbiAgICAgIGFwaU1ldGhvZDogJ21rZGlyJyxcbiAgICAgIGFyZ3VtZW50czogW3AsIG1vZGVdXG4gICAgfSk7XG4gIH1cblxuICBwdWJsaWMgcmVhZGRpclN5bmMocDogc3RyaW5nKTogc3RyaW5nW10ge1xuICAgIHRoaXMuY2hlY2tJbml0aWFsaXplZCgpO1xuICAgIHJldHVybiB0aGlzLl9zeW5jLnJlYWRkaXJTeW5jKHApO1xuICB9XG5cbiAgcHVibGljIGV4aXN0c1N5bmMocDogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgdGhpcy5jaGVja0luaXRpYWxpemVkKCk7XG4gICAgcmV0dXJuIHRoaXMuX3N5bmMuZXhpc3RzU3luYyhwKTtcbiAgfVxuXG4gIHB1YmxpYyBjaG1vZFN5bmMocDogc3RyaW5nLCBpc0xjaG1vZDogYm9vbGVhbiwgbW9kZTogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5jaGVja0luaXRpYWxpemVkKCk7XG4gICAgdGhpcy5fc3luYy5jaG1vZFN5bmMocCwgaXNMY2htb2QsIG1vZGUpO1xuICAgIHRoaXMuZW5xdWV1ZU9wKHtcbiAgICAgIGFwaU1ldGhvZDogJ2NobW9kJyxcbiAgICAgIGFyZ3VtZW50czogW3AsIGlzTGNobW9kLCBtb2RlXVxuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIGNob3duU3luYyhwOiBzdHJpbmcsIGlzTGNob3duOiBib29sZWFuLCB1aWQ6IG51bWJlciwgZ2lkOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLmNoZWNrSW5pdGlhbGl6ZWQoKTtcbiAgICB0aGlzLl9zeW5jLmNob3duU3luYyhwLCBpc0xjaG93biwgdWlkLCBnaWQpO1xuICAgIHRoaXMuZW5xdWV1ZU9wKHtcbiAgICAgIGFwaU1ldGhvZDogJ2Nob3duJyxcbiAgICAgIGFyZ3VtZW50czogW3AsIGlzTGNob3duLCB1aWQsIGdpZF1cbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyB1dGltZXNTeW5jKHA6IHN0cmluZywgYXRpbWU6IERhdGUsIG10aW1lOiBEYXRlKTogdm9pZCB7XG4gICAgdGhpcy5jaGVja0luaXRpYWxpemVkKCk7XG4gICAgdGhpcy5fc3luYy51dGltZXNTeW5jKHAsIGF0aW1lLCBtdGltZSk7XG4gICAgdGhpcy5lbnF1ZXVlT3Aoe1xuICAgICAgYXBpTWV0aG9kOiAndXRpbWVzJyxcbiAgICAgIGFyZ3VtZW50czogW3AsIGF0aW1lLCBtdGltZV1cbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgY2hlY2tJbml0aWFsaXplZCgpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuX2lzSW5pdGlhbGl6ZWQpIHtcbiAgICAgIHRocm93IG5ldyBBcGlFcnJvcihFcnJvckNvZGUuRVBFUk0sIFwiQXN5bmNNaXJyb3JGUyBpcyBub3QgaW5pdGlhbGl6ZWQuIFBsZWFzZSBpbml0aWFsaXplIEFzeW5jTWlycm9yRlMgdXNpbmcgaXRzIGluaXRpYWxpemUoKSBtZXRob2QgYmVmb3JlIHVzaW5nIGl0LlwiKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGVucXVldWVPcChvcDogSUFzeW5jT3BlcmF0aW9uKSB7XG4gICAgdGhpcy5fcXVldWUucHVzaChvcCk7XG4gICAgaWYgKCF0aGlzLl9xdWV1ZVJ1bm5pbmcpIHtcbiAgICAgIHRoaXMuX3F1ZXVlUnVubmluZyA9IHRydWU7XG4gICAgICBjb25zdCBkb05leHRPcCA9IChlcnI/OiBBcGlFcnJvcikgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihgV0FSTklORzogRmlsZSBzeXN0ZW0gaGFzIGRlc3luY2hyb25pemVkLiBSZWNlaXZlZCBmb2xsb3dpbmcgZXJyb3I6ICR7ZXJyfVxcbiRgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnN0IG9wID0gdGhpcy5fcXVldWUuc2hpZnQoKSEsXG4gICAgICAgICAgICBhcmdzID0gb3AuYXJndW1lbnRzO1xuICAgICAgICAgIGFyZ3MucHVzaChkb05leHRPcCk7XG4gICAgICAgICAgKDxGdW5jdGlvbj4gKDxhbnk+IHRoaXMuX2FzeW5jKVtvcC5hcGlNZXRob2RdKS5hcHBseSh0aGlzLl9hc3luYywgYXJncyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fcXVldWVSdW5uaW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBkb05leHRPcCgpO1xuICAgIH1cbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uLy4uLy4uLy4uL3NyYy9iYWNrZW5kL0FzeW5jTWlycm9yLnRzIiwiLyoqXG4gKiBBIGZhc3RlciBhbHRlcm5hdGl2ZSB0byBgRnVuY3Rpb24jYXBwbHlgLCB0aGlzIGZ1bmN0aW9uIGludm9rZXMgYGZ1bmNgXG4gKiB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiBgdGhpc0FyZ2AgYW5kIHRoZSBhcmd1bWVudHMgb2YgYGFyZ3NgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnZva2UuXG4gKiBAcGFyYW0geyp9IHRoaXNBcmcgVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgYGZ1bmNgIHdpdGguXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGBmdW5jYC5cbiAqL1xuZnVuY3Rpb24gYXBwbHkoZnVuYywgdGhpc0FyZywgYXJncykge1xuICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgY2FzZSAwOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcpO1xuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdKTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICB9XG4gIHJldHVybiBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBhcHBseTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi8uLi8uLi8uLi9+L2xvZGFzaC1lcy9fYXBwbHkuanMiLCJpbXBvcnQgYXBwbHkgZnJvbSAnLi9fYXBwbHkuanMnO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTWF4ID0gTWF0aC5tYXg7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUmVzdGAgd2hpY2ggdHJhbnNmb3JtcyB0aGUgcmVzdCBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgcmVzdCBhcnJheSB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlclJlc3QoZnVuYywgc3RhcnQsIHRyYW5zZm9ybSkge1xuICBzdGFydCA9IG5hdGl2ZU1heChzdGFydCA9PT0gdW5kZWZpbmVkID8gKGZ1bmMubGVuZ3RoIC0gMSkgOiBzdGFydCwgMCk7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWF4KGFyZ3MubGVuZ3RoIC0gc3RhcnQsIDApLFxuICAgICAgICBhcnJheSA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgYXJyYXlbaW5kZXhdID0gYXJnc1tzdGFydCArIGluZGV4XTtcbiAgICB9XG4gICAgaW5kZXggPSAtMTtcbiAgICB2YXIgb3RoZXJBcmdzID0gQXJyYXkoc3RhcnQgKyAxKTtcbiAgICB3aGlsZSAoKytpbmRleCA8IHN0YXJ0KSB7XG4gICAgICBvdGhlckFyZ3NbaW5kZXhdID0gYXJnc1tpbmRleF07XG4gICAgfVxuICAgIG90aGVyQXJnc1tzdGFydF0gPSB0cmFuc2Zvcm0oYXJyYXkpO1xuICAgIHJldHVybiBhcHBseShmdW5jLCB0aGlzLCBvdGhlckFyZ3MpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBvdmVyUmVzdDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi8uLi8uLi8uLi9+L2xvZGFzaC1lcy9fb3ZlclJlc3QuanMiLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGZpcnN0IGFyZ3VtZW50IGl0IHJlY2VpdmVzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlIEFueSB2YWx1ZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGB2YWx1ZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICpcbiAqIGNvbnNvbGUubG9nKF8uaWRlbnRpdHkob2JqZWN0KSA9PT0gb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaWRlbnRpdHkodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpZGVudGl0eTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi8uLi8uLi8uLi9+L2xvZGFzaC1lcy9pZGVudGl0eS5qcyIsImltcG9ydCBfb3ZlclJlc3QgZnJvbSAnbG9kYXNoLWVzL19vdmVyUmVzdCc7XG5pbXBvcnQgaWRlbnRpdHkgZnJvbSAnbG9kYXNoLWVzL2lkZW50aXR5JztcblxuLy8gTG9kYXNoIHJlc3QgZnVuY3Rpb24gd2l0aG91dCBmdW5jdGlvbi50b1N0cmluZygpXG4vLyByZW1hcHBpbmdzXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiByZXN0KGZ1bmMsIHN0YXJ0KSB7XG4gICAgcmV0dXJuIF9vdmVyUmVzdChmdW5jLCBzdGFydCwgaWRlbnRpdHkpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uLy4uLy4uLy4uL34vYXN5bmMtZXMvaW50ZXJuYWwvcmVzdC5qcyIsImltcG9ydCByZXN0IGZyb20gJy4vcmVzdCc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIChmbikge1xuICAgIHJldHVybiByZXN0KGZ1bmN0aW9uIChhcmdzLyouLi4sIGNhbGxiYWNrKi8pIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gYXJncy5wb3AoKTtcbiAgICAgICAgZm4uY2FsbCh0aGlzLCBhcmdzLCBjYWxsYmFjayk7XG4gICAgfSk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vLi4vLi4vLi4vfi9hc3luYy1lcy9pbnRlcm5hbC9pbml0aWFsUGFyYW1zLmpzIiwiaW1wb3J0IHJlc3QgZnJvbSAnLi9yZXN0JztcbmltcG9ydCBpbml0aWFsUGFyYW1zIGZyb20gJy4vaW5pdGlhbFBhcmFtcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGFwcGx5RWFjaChlYWNoZm4pIHtcbiAgICByZXR1cm4gcmVzdChmdW5jdGlvbihmbnMsIGFyZ3MpIHtcbiAgICAgICAgdmFyIGdvID0gaW5pdGlhbFBhcmFtcyhmdW5jdGlvbihhcmdzLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIGVhY2hmbihmbnMsIGZ1bmN0aW9uIChmbiwgY2IpIHtcbiAgICAgICAgICAgICAgICBmbi5hcHBseSh0aGF0LCBhcmdzLmNvbmNhdChjYikpO1xuICAgICAgICAgICAgfSwgY2FsbGJhY2spO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZ28uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZ287XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi8uLi8uLi8uLi9+L2FzeW5jLWVzL2ludGVybmFsL2FwcGx5RWFjaC5qcyIsIi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbmV4cG9ydCBkZWZhdWx0IGZyZWVHbG9iYWw7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vLi4vLi4vLi4vfi9sb2Rhc2gtZXMvX2ZyZWVHbG9iYWwuanMiLCJpbXBvcnQgZnJlZUdsb2JhbCBmcm9tICcuL19mcmVlR2xvYmFsLmpzJztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG5leHBvcnQgZGVmYXVsdCByb290O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uLy4uLy4uLy4uL34vbG9kYXNoLWVzL19yb290LmpzIiwiaW1wb3J0IHJvb3QgZnJvbSAnLi9fcm9vdC5qcyc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFN5bWJvbCA9IHJvb3QuU3ltYm9sO1xuXG5leHBvcnQgZGVmYXVsdCBTeW1ib2w7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vLi4vLi4vLi4vfi9sb2Rhc2gtZXMvX1N5bWJvbC5qcyIsImltcG9ydCBTeW1ib2wgZnJvbSAnLi9fU3ltYm9sLmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUdldFRhZ2Agd2hpY2ggaWdub3JlcyBgU3ltYm9sLnRvU3RyaW5nVGFnYCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmF3IGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGdldFJhd1RhZyh2YWx1ZSkge1xuICB2YXIgaXNPd24gPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBzeW1Ub1N0cmluZ1RhZyksXG4gICAgICB0YWcgPSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG5cbiAgdHJ5IHtcbiAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB1bmRlZmluZWQ7XG4gICAgdmFyIHVubWFza2VkID0gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge31cblxuICB2YXIgcmVzdWx0ID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIGlmICh1bm1hc2tlZCkge1xuICAgIGlmIChpc093bikge1xuICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdGFnO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBnZXRSYXdUYWc7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vLi4vLi4vLi4vfi9sb2Rhc2gtZXMvX2dldFJhd1RhZy5qcyIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcgdXNpbmcgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBvYmplY3RUb1N0cmluZztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi8uLi8uLi8uLi9+L2xvZGFzaC1lcy9fb2JqZWN0VG9TdHJpbmcuanMiLCJpbXBvcnQgU3ltYm9sIGZyb20gJy4vX1N5bWJvbC5qcyc7XG5pbXBvcnQgZ2V0UmF3VGFnIGZyb20gJy4vX2dldFJhd1RhZy5qcyc7XG5pbXBvcnQgb2JqZWN0VG9TdHJpbmcgZnJvbSAnLi9fb2JqZWN0VG9TdHJpbmcuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJyxcbiAgICB1bmRlZmluZWRUYWcgPSAnW29iamVjdCBVbmRlZmluZWRdJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldFRhZ2Agd2l0aG91dCBmYWxsYmFja3MgZm9yIGJ1Z2d5IGVudmlyb25tZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0VGFnKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWRUYWcgOiBudWxsVGFnO1xuICB9XG4gIHJldHVybiAoc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gT2JqZWN0KHZhbHVlKSlcbiAgICA/IGdldFJhd1RhZyh2YWx1ZSlcbiAgICA6IG9iamVjdFRvU3RyaW5nKHZhbHVlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUdldFRhZztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi8uLi8uLi8uLi9+L2xvZGFzaC1lcy9fYmFzZUdldFRhZy5qcyIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc09iamVjdDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi8uLi8uLi8uLi9+L2xvZGFzaC1lcy9pc09iamVjdC5qcyIsImltcG9ydCBiYXNlR2V0VGFnIGZyb20gJy4vX2Jhc2VHZXRUYWcuanMnO1xuaW1wb3J0IGlzT2JqZWN0IGZyb20gJy4vaXNPYmplY3QuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXN5bmNUYWcgPSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICBwcm94eVRhZyA9ICdbb2JqZWN0IFByb3h5XSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheXMgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZyB8fCB0YWcgPT0gYXN5bmNUYWcgfHwgdGFnID09IHByb3h5VGFnO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc0Z1bmN0aW9uO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uLy4uLy4uLy4uL34vbG9kYXNoLWVzL2lzRnVuY3Rpb24uanMiLCIvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNMZW5ndGgoMyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aChJbmZpbml0eSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoJzMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiZcbiAgICB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzTGVuZ3RoO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uLy4uLy4uLy4uL34vbG9kYXNoLWVzL2lzTGVuZ3RoLmpzIiwiaW1wb3J0IGlzRnVuY3Rpb24gZnJvbSAnLi9pc0Z1bmN0aW9uLmpzJztcbmltcG9ydCBpc0xlbmd0aCBmcm9tICcuL2lzTGVuZ3RoLmpzJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgYXJyYXktbGlrZSBpZiBpdCdzXG4gKiBub3QgYSBmdW5jdGlvbiBhbmQgaGFzIGEgYHZhbHVlLmxlbmd0aGAgdGhhdCdzIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yXG4gKiBlcXVhbCB0byBgMGAgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZSgnYWJjJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbih2YWx1ZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzQXJyYXlMaWtlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uLy4uLy4uLy4uL34vbG9kYXNoLWVzL2lzQXJyYXlMaWtlLmpzIiwiLy8gQSB0ZW1wb3JhcnkgdmFsdWUgdXNlZCB0byBpZGVudGlmeSBpZiB0aGUgbG9vcCBzaG91bGQgYmUgYnJva2VuLlxuLy8gU2VlICMxMDY0LCAjMTI5M1xuZXhwb3J0IGRlZmF1bHQge307XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uLy4uLy4uLy4uL34vYXN5bmMtZXMvaW50ZXJuYWwvYnJlYWtMb29wLmpzIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGB1bmRlZmluZWRgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi4zLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udGltZXMoMiwgXy5ub29wKTtcbiAqIC8vID0+IFt1bmRlZmluZWQsIHVuZGVmaW5lZF1cbiAqL1xuZnVuY3Rpb24gbm9vcCgpIHtcbiAgLy8gTm8gb3BlcmF0aW9uIHBlcmZvcm1lZC5cbn1cblxuZXhwb3J0IGRlZmF1bHQgbm9vcDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi8uLi8uLi8uLi9+L2xvZGFzaC1lcy9ub29wLmpzIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gb25jZShmbikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChmbiA9PT0gbnVsbCkgcmV0dXJuO1xuICAgICAgICB2YXIgY2FsbEZuID0gZm47XG4gICAgICAgIGZuID0gbnVsbDtcbiAgICAgICAgY2FsbEZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi8uLi8uLi8uLi9+L2FzeW5jLWVzL2ludGVybmFsL29uY2UuanMiLCJ2YXIgaXRlcmF0b3JTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKGNvbGwpIHtcbiAgICByZXR1cm4gaXRlcmF0b3JTeW1ib2wgJiYgY29sbFtpdGVyYXRvclN5bWJvbF0gJiYgY29sbFtpdGVyYXRvclN5bWJvbF0oKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi8uLi8uLi8uLi9+L2FzeW5jLWVzL2ludGVybmFsL2dldEl0ZXJhdG9yLmpzIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50aW1lc2Agd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzXG4gKiBvciBtYXggYXJyYXkgbGVuZ3RoIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0byBpbnZva2UgYGl0ZXJhdGVlYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUaW1lcyhuLCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KG4pO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbikge1xuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShpbmRleCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZVRpbWVzO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uLy4uLy4uLy4uL34vbG9kYXNoLWVzL19iYXNlVGltZXMuanMiLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNPYmplY3RMaWtlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uLy4uLy4uLy4uL34vbG9kYXNoLWVzL2lzT2JqZWN0TGlrZS5qcyIsImltcG9ydCBiYXNlR2V0VGFnIGZyb20gJy4vX2Jhc2VHZXRUYWcuanMnO1xuaW1wb3J0IGlzT2JqZWN0TGlrZSBmcm9tICcuL2lzT2JqZWN0TGlrZS5qcyc7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNBcmd1bWVudHNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqL1xuZnVuY3Rpb24gYmFzZUlzQXJndW1lbnRzKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGFyZ3NUYWc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VJc0FyZ3VtZW50cztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi8uLi8uLi8uLi9+L2xvZGFzaC1lcy9fYmFzZUlzQXJndW1lbnRzLmpzIiwiaW1wb3J0IGJhc2VJc0FyZ3VtZW50cyBmcm9tICcuL19iYXNlSXNBcmd1bWVudHMuanMnO1xuaW1wb3J0IGlzT2JqZWN0TGlrZSBmcm9tICcuL2lzT2JqZWN0TGlrZS5qcyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGFuIGBhcmd1bWVudHNgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FyZ3VtZW50cyA9IGJhc2VJc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA/IGJhc2VJc0FyZ3VtZW50cyA6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdjYWxsZWUnKSAmJlxuICAgICFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCAnY2FsbGVlJyk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBpc0FyZ3VtZW50cztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi8uLi8uLi8uLi9+L2xvZGFzaC1lcy9pc0FyZ3VtZW50cy5qcyIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXkoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheSgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG5leHBvcnQgZGVmYXVsdCBpc0FycmF5O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uLy4uLy4uLy4uL34vbG9kYXNoLWVzL2lzQXJyYXkuanMiLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYGZhbHNlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udGltZXMoMiwgXy5zdHViRmFsc2UpO1xuICogLy8gPT4gW2ZhbHNlLCBmYWxzZV1cbiAqL1xuZnVuY3Rpb24gc3R1YkZhbHNlKCkge1xuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHN0dWJGYWxzZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi8uLi8uLi8uLi9+L2xvZGFzaC1lcy9zdHViRmFsc2UuanMiLCJpbXBvcnQgcm9vdCBmcm9tICcuL19yb290LmpzJztcbmltcG9ydCBzdHViRmFsc2UgZnJvbSAnLi9zdHViRmFsc2UuanMnO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZDtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUlzQnVmZmVyID0gQnVmZmVyID8gQnVmZmVyLmlzQnVmZmVyIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4zLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IEJ1ZmZlcigyKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgVWludDhBcnJheSgyKSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNCdWZmZXIgPSBuYXRpdmVJc0J1ZmZlciB8fCBzdHViRmFsc2U7XG5cbmV4cG9ydCBkZWZhdWx0IGlzQnVmZmVyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uLy4uLy4uLy4uL34vbG9kYXNoLWVzL2lzQnVmZmVyLmpzIiwiLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy4gKi9cbnZhciByZUlzVWludCA9IC9eKD86MHxbMS05XVxcZCopJC87XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGluZGV4LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgaW5kZXgsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG4gIGxlbmd0aCA9IGxlbmd0aCA9PSBudWxsID8gTUFYX1NBRkVfSU5URUdFUiA6IGxlbmd0aDtcbiAgcmV0dXJuICEhbGVuZ3RoICYmXG4gICAgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyB8fCByZUlzVWludC50ZXN0KHZhbHVlKSkgJiZcbiAgICAodmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzSW5kZXg7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vLi4vLi4vLi4vfi9sb2Rhc2gtZXMvX2lzSW5kZXguanMiLCJpbXBvcnQgYmFzZUdldFRhZyBmcm9tICcuL19iYXNlR2V0VGFnLmpzJztcbmltcG9ydCBpc0xlbmd0aCBmcm9tICcuL2lzTGVuZ3RoLmpzJztcbmltcG9ydCBpc09iamVjdExpa2UgZnJvbSAnLi9pc09iamVjdExpa2UuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBvZiB0eXBlZCBhcnJheXMuICovXG52YXIgdHlwZWRBcnJheVRhZ3MgPSB7fTtcbnR5cGVkQXJyYXlUYWdzW2Zsb2F0MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbZmxvYXQ2NFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50OFRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDhUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xudHlwZWRBcnJheVRhZ3NbYXJnc1RhZ10gPSB0eXBlZEFycmF5VGFnc1thcnJheVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gdHlwZWRBcnJheVRhZ3NbYm9vbFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZGF0YVZpZXdUYWddID0gdHlwZWRBcnJheVRhZ3NbZGF0ZVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZXJyb3JUYWddID0gdHlwZWRBcnJheVRhZ3NbZnVuY1RhZ10gPVxudHlwZWRBcnJheVRhZ3NbbWFwVGFnXSA9IHR5cGVkQXJyYXlUYWdzW251bWJlclRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbb2JqZWN0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3JlZ2V4cFRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbc2V0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3N0cmluZ1RhZ10gPVxudHlwZWRBcnJheVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1R5cGVkQXJyYXlgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzVHlwZWRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJlxuICAgIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgISF0eXBlZEFycmF5VGFnc1tiYXNlR2V0VGFnKHZhbHVlKV07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VJc1R5cGVkQXJyYXk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vLi4vLi4vLi4vfi9sb2Rhc2gtZXMvX2Jhc2VJc1R5cGVkQXJyYXkuanMiLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuYXJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIHN0b3JpbmcgbWV0YWRhdGEuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNhcCBhcmd1bWVudHMgZm9yLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FwcGVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlVW5hcnkoZnVuYykge1xuICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZnVuYyh2YWx1ZSk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VVbmFyeTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi8uLi8uLi8uLi9+L2xvZGFzaC1lcy9fYmFzZVVuYXJ5LmpzIiwiaW1wb3J0IGZyZWVHbG9iYWwgZnJvbSAnLi9fZnJlZUdsb2JhbC5qcyc7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBwcm9jZXNzYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZVByb2Nlc3MgPSBtb2R1bGVFeHBvcnRzICYmIGZyZWVHbG9iYWwucHJvY2VzcztcblxuLyoqIFVzZWQgdG8gYWNjZXNzIGZhc3RlciBOb2RlLmpzIGhlbHBlcnMuICovXG52YXIgbm9kZVV0aWwgPSAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGZyZWVQcm9jZXNzICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcgJiYgZnJlZVByb2Nlc3MuYmluZGluZygndXRpbCcpO1xuICB9IGNhdGNoIChlKSB7fVxufSgpKTtcblxuZXhwb3J0IGRlZmF1bHQgbm9kZVV0aWw7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vLi4vLi4vLi4vfi9sb2Rhc2gtZXMvX25vZGVVdGlsLmpzIiwiaW1wb3J0IGJhc2VJc1R5cGVkQXJyYXkgZnJvbSAnLi9fYmFzZUlzVHlwZWRBcnJheS5qcyc7XG5pbXBvcnQgYmFzZVVuYXJ5IGZyb20gJy4vX2Jhc2VVbmFyeS5qcyc7XG5pbXBvcnQgbm9kZVV0aWwgZnJvbSAnLi9fbm9kZVV0aWwuanMnO1xuXG4vKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xudmFyIG5vZGVJc1R5cGVkQXJyYXkgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1R5cGVkQXJyYXk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIHR5cGVkIGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkobmV3IFVpbnQ4QXJyYXkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KFtdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc1R5cGVkQXJyYXkgPSBub2RlSXNUeXBlZEFycmF5ID8gYmFzZVVuYXJ5KG5vZGVJc1R5cGVkQXJyYXkpIDogYmFzZUlzVHlwZWRBcnJheTtcblxuZXhwb3J0IGRlZmF1bHQgaXNUeXBlZEFycmF5O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uLy4uLy4uLy4uL34vbG9kYXNoLWVzL2lzVHlwZWRBcnJheS5qcyIsImltcG9ydCBiYXNlVGltZXMgZnJvbSAnLi9fYmFzZVRpbWVzLmpzJztcbmltcG9ydCBpc0FyZ3VtZW50cyBmcm9tICcuL2lzQXJndW1lbnRzLmpzJztcbmltcG9ydCBpc0FycmF5IGZyb20gJy4vaXNBcnJheS5qcyc7XG5pbXBvcnQgaXNCdWZmZXIgZnJvbSAnLi9pc0J1ZmZlci5qcyc7XG5pbXBvcnQgaXNJbmRleCBmcm9tICcuL19pc0luZGV4LmpzJztcbmltcG9ydCBpc1R5cGVkQXJyYXkgZnJvbSAnLi9pc1R5cGVkQXJyYXkuanMnO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgdGhlIGFycmF5LWxpa2UgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluaGVyaXRlZCBTcGVjaWZ5IHJldHVybmluZyBpbmhlcml0ZWQgcHJvcGVydHkgbmFtZXMuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBhcnJheUxpa2VLZXlzKHZhbHVlLCBpbmhlcml0ZWQpIHtcbiAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSksXG4gICAgICBpc0FyZyA9ICFpc0FyciAmJiBpc0FyZ3VtZW50cyh2YWx1ZSksXG4gICAgICBpc0J1ZmYgPSAhaXNBcnIgJiYgIWlzQXJnICYmIGlzQnVmZmVyKHZhbHVlKSxcbiAgICAgIGlzVHlwZSA9ICFpc0FyciAmJiAhaXNBcmcgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXkodmFsdWUpLFxuICAgICAgc2tpcEluZGV4ZXMgPSBpc0FyciB8fCBpc0FyZyB8fCBpc0J1ZmYgfHwgaXNUeXBlLFxuICAgICAgcmVzdWx0ID0gc2tpcEluZGV4ZXMgPyBiYXNlVGltZXModmFsdWUubGVuZ3RoLCBTdHJpbmcpIDogW10sXG4gICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgIGlmICgoaW5oZXJpdGVkIHx8IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpICYmXG4gICAgICAgICEoc2tpcEluZGV4ZXMgJiYgKFxuICAgICAgICAgICAvLyBTYWZhcmkgOSBoYXMgZW51bWVyYWJsZSBgYXJndW1lbnRzLmxlbmd0aGAgaW4gc3RyaWN0IG1vZGUuXG4gICAgICAgICAgIGtleSA9PSAnbGVuZ3RoJyB8fFxuICAgICAgICAgICAvLyBOb2RlLmpzIDAuMTAgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gYnVmZmVycy5cbiAgICAgICAgICAgKGlzQnVmZiAmJiAoa2V5ID09ICdvZmZzZXQnIHx8IGtleSA9PSAncGFyZW50JykpIHx8XG4gICAgICAgICAgIC8vIFBoYW50b21KUyAyIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIHR5cGVkIGFycmF5cy5cbiAgICAgICAgICAgKGlzVHlwZSAmJiAoa2V5ID09ICdidWZmZXInIHx8IGtleSA9PSAnYnl0ZUxlbmd0aCcgfHwga2V5ID09ICdieXRlT2Zmc2V0JykpIHx8XG4gICAgICAgICAgIC8vIFNraXAgaW5kZXggcHJvcGVydGllcy5cbiAgICAgICAgICAgaXNJbmRleChrZXksIGxlbmd0aClcbiAgICAgICAgKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFycmF5TGlrZUtleXM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vLi4vLi4vLi4vfi9sb2Rhc2gtZXMvX2FycmF5TGlrZUtleXMuanMiLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhIHByb3RvdHlwZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm90b3R5cGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNQcm90b3R5cGUodmFsdWUpIHtcbiAgdmFyIEN0b3IgPSB2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvcixcbiAgICAgIHByb3RvID0gKHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUpIHx8IG9iamVjdFByb3RvO1xuXG4gIHJldHVybiB2YWx1ZSA9PT0gcHJvdG87XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzUHJvdG90eXBlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uLy4uLy4uLy4uL34vbG9kYXNoLWVzL19pc1Byb3RvdHlwZS5qcyIsIi8qKlxuICogQ3JlYXRlcyBhIHVuYXJ5IGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBpdHMgYXJndW1lbnQgdHJhbnNmb3JtZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIGFyZ3VtZW50IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyQXJnKGZ1bmMsIHRyYW5zZm9ybSkge1xuICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGZ1bmModHJhbnNmb3JtKGFyZykpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBvdmVyQXJnO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uLy4uLy4uLy4uL34vbG9kYXNoLWVzL19vdmVyQXJnLmpzIiwiaW1wb3J0IG92ZXJBcmcgZnJvbSAnLi9fb3ZlckFyZy5qcyc7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVLZXlzID0gb3ZlckFyZyhPYmplY3Qua2V5cywgT2JqZWN0KTtcblxuZXhwb3J0IGRlZmF1bHQgbmF0aXZlS2V5cztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi8uLi8uLi8uLi9+L2xvZGFzaC1lcy9fbmF0aXZlS2V5cy5qcyIsImltcG9ydCBpc1Byb3RvdHlwZSBmcm9tICcuL19pc1Byb3RvdHlwZS5qcyc7XG5pbXBvcnQgbmF0aXZlS2V5cyBmcm9tICcuL19uYXRpdmVLZXlzLmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzKG9iamVjdCkge1xuICBpZiAoIWlzUHJvdG90eXBlKG9iamVjdCkpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5cyhvYmplY3QpO1xuICB9XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGtleSAhPSAnY29uc3RydWN0b3InKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlS2V5cztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi8uLi8uLi8uLi9+L2xvZGFzaC1lcy9fYmFzZUtleXMuanMiLCJpbXBvcnQgYXJyYXlMaWtlS2V5cyBmcm9tICcuL19hcnJheUxpa2VLZXlzLmpzJztcbmltcG9ydCBiYXNlS2V5cyBmcm9tICcuL19iYXNlS2V5cy5qcyc7XG5pbXBvcnQgaXNBcnJheUxpa2UgZnJvbSAnLi9pc0FycmF5TGlrZS5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuIFNlZSB0aGVcbiAqIFtFUyBzcGVjXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIF8ua2V5cygnaGknKTtcbiAqIC8vID0+IFsnMCcsICcxJ11cbiAqL1xuZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCkgOiBiYXNlS2V5cyhvYmplY3QpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBrZXlzO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uLy4uLy4uLy4uL34vbG9kYXNoLWVzL2tleXMuanMiLCJpbXBvcnQgaXNBcnJheUxpa2UgZnJvbSAnbG9kYXNoLWVzL2lzQXJyYXlMaWtlJztcbmltcG9ydCBnZXRJdGVyYXRvciBmcm9tICcuL2dldEl0ZXJhdG9yJztcbmltcG9ydCBrZXlzIGZyb20gJ2xvZGFzaC1lcy9rZXlzJztcblxuZnVuY3Rpb24gY3JlYXRlQXJyYXlJdGVyYXRvcihjb2xsKSB7XG4gICAgdmFyIGkgPSAtMTtcbiAgICB2YXIgbGVuID0gY29sbC5sZW5ndGg7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgIHJldHVybiArK2kgPCBsZW4gPyB7dmFsdWU6IGNvbGxbaV0sIGtleTogaX0gOiBudWxsO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRVMyMDE1SXRlcmF0b3IoaXRlcmF0b3IpIHtcbiAgICB2YXIgaSA9IC0xO1xuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICB2YXIgaXRlbSA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgaWYgKGl0ZW0uZG9uZSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBpKys7XG4gICAgICAgIHJldHVybiB7dmFsdWU6IGl0ZW0udmFsdWUsIGtleTogaX07XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVPYmplY3RJdGVyYXRvcihvYmopIHtcbiAgICB2YXIgb2tleXMgPSBrZXlzKG9iaik7XG4gICAgdmFyIGkgPSAtMTtcbiAgICB2YXIgbGVuID0gb2tleXMubGVuZ3RoO1xuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICB2YXIga2V5ID0gb2tleXNbKytpXTtcbiAgICAgICAgcmV0dXJuIGkgPCBsZW4gPyB7dmFsdWU6IG9ialtrZXldLCBrZXk6IGtleX0gOiBudWxsO1xuICAgIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGl0ZXJhdG9yKGNvbGwpIHtcbiAgICBpZiAoaXNBcnJheUxpa2UoY29sbCkpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUFycmF5SXRlcmF0b3IoY29sbCk7XG4gICAgfVxuXG4gICAgdmFyIGl0ZXJhdG9yID0gZ2V0SXRlcmF0b3IoY29sbCk7XG4gICAgcmV0dXJuIGl0ZXJhdG9yID8gY3JlYXRlRVMyMDE1SXRlcmF0b3IoaXRlcmF0b3IpIDogY3JlYXRlT2JqZWN0SXRlcmF0b3IoY29sbCk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vLi4vLi4vLi4vfi9hc3luYy1lcy9pbnRlcm5hbC9pdGVyYXRvci5qcyIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG9ubHlPbmNlKGZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoZm4gPT09IG51bGwpIHRocm93IG5ldyBFcnJvcihcIkNhbGxiYWNrIHdhcyBhbHJlYWR5IGNhbGxlZC5cIik7XG4gICAgICAgIHZhciBjYWxsRm4gPSBmbjtcbiAgICAgICAgZm4gPSBudWxsO1xuICAgICAgICBjYWxsRm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uLy4uLy4uLy4uL34vYXN5bmMtZXMvaW50ZXJuYWwvb25seU9uY2UuanMiLCJpbXBvcnQgbm9vcCBmcm9tICdsb2Rhc2gtZXMvbm9vcCc7XG5pbXBvcnQgb25jZSBmcm9tICcuL29uY2UnO1xuXG5pbXBvcnQgaXRlcmF0b3IgZnJvbSAnLi9pdGVyYXRvcic7XG5pbXBvcnQgb25seU9uY2UgZnJvbSAnLi9vbmx5T25jZSc7XG5cbmltcG9ydCBicmVha0xvb3AgZnJvbSAnLi9icmVha0xvb3AnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfZWFjaE9mTGltaXQobGltaXQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG9iaiwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrID0gb25jZShjYWxsYmFjayB8fCBub29wKTtcbiAgICAgICAgaWYgKGxpbWl0IDw9IDAgfHwgIW9iaikge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuZXh0RWxlbSA9IGl0ZXJhdG9yKG9iaik7XG4gICAgICAgIHZhciBkb25lID0gZmFsc2U7XG4gICAgICAgIHZhciBydW5uaW5nID0gMDtcblxuICAgICAgICBmdW5jdGlvbiBpdGVyYXRlZUNhbGxiYWNrKGVyciwgdmFsdWUpIHtcbiAgICAgICAgICAgIHJ1bm5pbmcgLT0gMTtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgPT09IGJyZWFrTG9vcCB8fCAoZG9uZSAmJiBydW5uaW5nIDw9IDApKSB7XG4gICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVwbGVuaXNoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiByZXBsZW5pc2ggKCkge1xuICAgICAgICAgICAgd2hpbGUgKHJ1bm5pbmcgPCBsaW1pdCAmJiAhZG9uZSkge1xuICAgICAgICAgICAgICAgIHZhciBlbGVtID0gbmV4dEVsZW0oKTtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJ1bm5pbmcgPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBydW5uaW5nICs9IDE7XG4gICAgICAgICAgICAgICAgaXRlcmF0ZWUoZWxlbS52YWx1ZSwgZWxlbS5rZXksIG9ubHlPbmNlKGl0ZXJhdGVlQ2FsbGJhY2spKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJlcGxlbmlzaCgpO1xuICAgIH07XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vLi4vLi4vLi4vfi9hc3luYy1lcy9pbnRlcm5hbC9lYWNoT2ZMaW1pdC5qcyIsImltcG9ydCBfZWFjaE9mTGltaXQgZnJvbSAnLi9pbnRlcm5hbC9lYWNoT2ZMaW1pdCc7XG5cbi8qKlxuICogVGhlIHNhbWUgYXMgW2BlYWNoT2ZgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZWFjaE9mfSBidXQgcnVucyBhIG1heGltdW0gb2YgYGxpbWl0YCBhc3luYyBvcGVyYXRpb25zIGF0IGFcbiAqIHRpbWUuXG4gKlxuICogQG5hbWUgZWFjaE9mTGltaXRcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLmVhY2hPZl17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmVhY2hPZn1cbiAqIEBhbGlhcyBmb3JFYWNoT2ZMaW1pdFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBsaW1pdCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBhc3luYyBvcGVyYXRpb25zIGF0IGEgdGltZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIC0gQSBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoXG4gKiBpdGVtIGluIGBjb2xsYC4gVGhlIGBrZXlgIGlzIHRoZSBpdGVtJ3Mga2V5LCBvciBpbmRleCBpbiB0aGUgY2FzZSBvZiBhblxuICogYXJyYXkuIFRoZSBpdGVyYXRlZSBpcyBwYXNzZWQgYSBgY2FsbGJhY2soZXJyKWAgd2hpY2ggbXVzdCBiZSBjYWxsZWQgb25jZSBpdFxuICogaGFzIGNvbXBsZXRlZC4gSWYgbm8gZXJyb3IgaGFzIG9jY3VycmVkLCB0aGUgY2FsbGJhY2sgc2hvdWxkIGJlIHJ1biB3aXRob3V0XG4gKiBhcmd1bWVudHMgb3Igd2l0aCBhbiBleHBsaWNpdCBgbnVsbGAgYXJndW1lbnQuIEludm9rZWQgd2l0aFxuICogKGl0ZW0sIGtleSwgY2FsbGJhY2spLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIHdoZW4gYWxsXG4gKiBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLCBvciBhbiBlcnJvciBvY2N1cnMuIEludm9rZWQgd2l0aCAoZXJyKS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZWFjaE9mTGltaXQoY29sbCwgbGltaXQsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgIF9lYWNoT2ZMaW1pdChsaW1pdCkoY29sbCwgaXRlcmF0ZWUsIGNhbGxiYWNrKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi8uLi8uLi8uLi9+L2FzeW5jLWVzL2VhY2hPZkxpbWl0LmpzIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZG9MaW1pdChmbiwgbGltaXQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGl0ZXJhYmxlLCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIGZuKGl0ZXJhYmxlLCBsaW1pdCwgaXRlcmF0ZWUsIGNhbGxiYWNrKTtcbiAgICB9O1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uLy4uLy4uLy4uL34vYXN5bmMtZXMvaW50ZXJuYWwvZG9MaW1pdC5qcyIsImltcG9ydCBpc0FycmF5TGlrZSBmcm9tICdsb2Rhc2gtZXMvaXNBcnJheUxpa2UnO1xuXG5pbXBvcnQgYnJlYWtMb29wIGZyb20gJy4vaW50ZXJuYWwvYnJlYWtMb29wJztcbmltcG9ydCBlYWNoT2ZMaW1pdCBmcm9tICcuL2VhY2hPZkxpbWl0JztcbmltcG9ydCBkb0xpbWl0IGZyb20gJy4vaW50ZXJuYWwvZG9MaW1pdCc7XG5pbXBvcnQgbm9vcCBmcm9tICdsb2Rhc2gtZXMvbm9vcCc7XG5pbXBvcnQgb25jZSBmcm9tICcuL2ludGVybmFsL29uY2UnO1xuaW1wb3J0IG9ubHlPbmNlIGZyb20gJy4vaW50ZXJuYWwvb25seU9uY2UnO1xuXG4vLyBlYWNoT2YgaW1wbGVtZW50YXRpb24gb3B0aW1pemVkIGZvciBhcnJheS1saWtlc1xuZnVuY3Rpb24gZWFjaE9mQXJyYXlMaWtlKGNvbGwsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gb25jZShjYWxsYmFjayB8fCBub29wKTtcbiAgICB2YXIgaW5kZXggPSAwLFxuICAgICAgICBjb21wbGV0ZWQgPSAwLFxuICAgICAgICBsZW5ndGggPSBjb2xsLmxlbmd0aDtcbiAgICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGl0ZXJhdG9yQ2FsbGJhY2soZXJyLCB2YWx1ZSkge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICB9IGVsc2UgaWYgKCgrK2NvbXBsZXRlZCA9PT0gbGVuZ3RoKSB8fCB2YWx1ZSA9PT0gYnJlYWtMb29wKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBpdGVyYXRlZShjb2xsW2luZGV4XSwgaW5kZXgsIG9ubHlPbmNlKGl0ZXJhdG9yQ2FsbGJhY2spKTtcbiAgICB9XG59XG5cbi8vIGEgZ2VuZXJpYyB2ZXJzaW9uIG9mIGVhY2hPZiB3aGljaCBjYW4gaGFuZGxlIGFycmF5LCBvYmplY3QsIGFuZCBpdGVyYXRvciBjYXNlcy5cbnZhciBlYWNoT2ZHZW5lcmljID0gZG9MaW1pdChlYWNoT2ZMaW1pdCwgSW5maW5pdHkpO1xuXG4vKipcbiAqIExpa2UgW2BlYWNoYF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmVhY2h9LCBleGNlcHQgdGhhdCBpdCBwYXNzZXMgdGhlIGtleSAob3IgaW5kZXgpIGFzIHRoZSBzZWNvbmQgYXJndW1lbnRcbiAqIHRvIHRoZSBpdGVyYXRlZS5cbiAqXG4gKiBAbmFtZSBlYWNoT2ZcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAqIEBtZXRob2RcbiAqIEBhbGlhcyBmb3JFYWNoT2ZcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAc2VlIFthc3luYy5lYWNoXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZWFjaH1cbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIC0gQSBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoXG4gKiBpdGVtIGluIGBjb2xsYC4gVGhlIGBrZXlgIGlzIHRoZSBpdGVtJ3Mga2V5LCBvciBpbmRleCBpbiB0aGUgY2FzZSBvZiBhblxuICogYXJyYXkuIFRoZSBpdGVyYXRlZSBpcyBwYXNzZWQgYSBgY2FsbGJhY2soZXJyKWAgd2hpY2ggbXVzdCBiZSBjYWxsZWQgb25jZSBpdFxuICogaGFzIGNvbXBsZXRlZC4gSWYgbm8gZXJyb3IgaGFzIG9jY3VycmVkLCB0aGUgY2FsbGJhY2sgc2hvdWxkIGJlIHJ1biB3aXRob3V0XG4gKiBhcmd1bWVudHMgb3Igd2l0aCBhbiBleHBsaWNpdCBgbnVsbGAgYXJndW1lbnQuIEludm9rZWQgd2l0aFxuICogKGl0ZW0sIGtleSwgY2FsbGJhY2spLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIHdoZW4gYWxsXG4gKiBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLCBvciBhbiBlcnJvciBvY2N1cnMuIEludm9rZWQgd2l0aCAoZXJyKS5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iaiA9IHtkZXY6IFwiL2Rldi5qc29uXCIsIHRlc3Q6IFwiL3Rlc3QuanNvblwiLCBwcm9kOiBcIi9wcm9kLmpzb25cIn07XG4gKiB2YXIgY29uZmlncyA9IHt9O1xuICpcbiAqIGFzeW5jLmZvckVhY2hPZihvYmosIGZ1bmN0aW9uICh2YWx1ZSwga2V5LCBjYWxsYmFjaykge1xuICogICAgIGZzLnJlYWRGaWxlKF9fZGlybmFtZSArIHZhbHVlLCBcInV0ZjhcIiwgZnVuY3Rpb24gKGVyciwgZGF0YSkge1xuICogICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAqICAgICAgICAgdHJ5IHtcbiAqICAgICAgICAgICAgIGNvbmZpZ3Nba2V5XSA9IEpTT04ucGFyc2UoZGF0YSk7XG4gKiAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAqICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlKTtcbiAqICAgICAgICAgfVxuICogICAgICAgICBjYWxsYmFjaygpO1xuICogICAgIH0pO1xuICogfSwgZnVuY3Rpb24gKGVycikge1xuICogICAgIGlmIChlcnIpIGNvbnNvbGUuZXJyb3IoZXJyLm1lc3NhZ2UpO1xuICogICAgIC8vIGNvbmZpZ3MgaXMgbm93IGEgbWFwIG9mIEpTT04gZGF0YVxuICogICAgIGRvU29tZXRoaW5nV2l0aChjb25maWdzKTtcbiAqIH0pO1xuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihjb2xsLCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgZWFjaE9mSW1wbGVtZW50YXRpb24gPSBpc0FycmF5TGlrZShjb2xsKSA/IGVhY2hPZkFycmF5TGlrZSA6IGVhY2hPZkdlbmVyaWM7XG4gICAgZWFjaE9mSW1wbGVtZW50YXRpb24oY29sbCwgaXRlcmF0ZWUsIGNhbGxiYWNrKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi8uLi8uLi8uLi9+L2FzeW5jLWVzL2VhY2hPZi5qcyIsImltcG9ydCBlYWNoT2YgZnJvbSAnLi4vZWFjaE9mJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZG9QYXJhbGxlbChmbikge1xuICAgIHJldHVybiBmdW5jdGlvbiAob2JqLCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIGZuKGVhY2hPZiwgb2JqLCBpdGVyYXRlZSwgY2FsbGJhY2spO1xuICAgIH07XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vLi4vLi4vLi4vfi9hc3luYy1lcy9pbnRlcm5hbC9kb1BhcmFsbGVsLmpzIiwiaW1wb3J0IG5vb3AgZnJvbSAnbG9kYXNoLWVzL25vb3AnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfYXN5bmNNYXAoZWFjaGZuLCBhcnIsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgbm9vcDtcbiAgICBhcnIgPSBhcnIgfHwgW107XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICB2YXIgY291bnRlciA9IDA7XG5cbiAgICBlYWNoZm4oYXJyLCBmdW5jdGlvbiAodmFsdWUsIF8sIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGNvdW50ZXIrKztcbiAgICAgICAgaXRlcmF0ZWUodmFsdWUsIGZ1bmN0aW9uIChlcnIsIHYpIHtcbiAgICAgICAgICAgIHJlc3VsdHNbaW5kZXhdID0gdjtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgIH0pO1xuICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgY2FsbGJhY2soZXJyLCByZXN1bHRzKTtcbiAgICB9KTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi8uLi8uLi8uLi9+L2FzeW5jLWVzL2ludGVybmFsL21hcC5qcyIsImltcG9ydCBkb1BhcmFsbGVsIGZyb20gJy4vaW50ZXJuYWwvZG9QYXJhbGxlbCc7XG5pbXBvcnQgbWFwIGZyb20gJy4vaW50ZXJuYWwvbWFwJztcblxuLyoqXG4gKiBQcm9kdWNlcyBhIG5ldyBjb2xsZWN0aW9uIG9mIHZhbHVlcyBieSBtYXBwaW5nIGVhY2ggdmFsdWUgaW4gYGNvbGxgIHRocm91Z2hcbiAqIHRoZSBgaXRlcmF0ZWVgIGZ1bmN0aW9uLiBUaGUgYGl0ZXJhdGVlYCBpcyBjYWxsZWQgd2l0aCBhbiBpdGVtIGZyb20gYGNvbGxgXG4gKiBhbmQgYSBjYWxsYmFjayBmb3Igd2hlbiBpdCBoYXMgZmluaXNoZWQgcHJvY2Vzc2luZy4gRWFjaCBvZiB0aGVzZSBjYWxsYmFja1xuICogdGFrZXMgMiBhcmd1bWVudHM6IGFuIGBlcnJvcmAsIGFuZCB0aGUgdHJhbnNmb3JtZWQgaXRlbSBmcm9tIGBjb2xsYC4gSWZcbiAqIGBpdGVyYXRlZWAgcGFzc2VzIGFuIGVycm9yIHRvIGl0cyBjYWxsYmFjaywgdGhlIG1haW4gYGNhbGxiYWNrYCAoZm9yIHRoZVxuICogYG1hcGAgZnVuY3Rpb24pIGlzIGltbWVkaWF0ZWx5IGNhbGxlZCB3aXRoIHRoZSBlcnJvci5cbiAqXG4gKiBOb3RlLCB0aGF0IHNpbmNlIHRoaXMgZnVuY3Rpb24gYXBwbGllcyB0aGUgYGl0ZXJhdGVlYCB0byBlYWNoIGl0ZW0gaW5cbiAqIHBhcmFsbGVsLCB0aGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCB0aGUgYGl0ZXJhdGVlYCBmdW5jdGlvbnMgd2lsbCBjb21wbGV0ZVxuICogaW4gb3JkZXIuIEhvd2V2ZXIsIHRoZSByZXN1bHRzIGFycmF5IHdpbGwgYmUgaW4gdGhlIHNhbWUgb3JkZXIgYXMgdGhlXG4gKiBvcmlnaW5hbCBgY29sbGAuXG4gKlxuICogSWYgYG1hcGAgaXMgcGFzc2VkIGFuIE9iamVjdCwgdGhlIHJlc3VsdHMgd2lsbCBiZSBhbiBBcnJheS4gIFRoZSByZXN1bHRzXG4gKiB3aWxsIHJvdWdobHkgYmUgaW4gdGhlIG9yZGVyIG9mIHRoZSBvcmlnaW5hbCBPYmplY3RzJyBrZXlzIChidXQgdGhpcyBjYW5cbiAqIHZhcnkgYWNyb3NzIEphdmFTY3JpcHQgZW5naW5lcylcbiAqXG4gKiBAbmFtZSBtYXBcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAqIEBtZXRob2RcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEEgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluIGBjb2xsYC5cbiAqIFRoZSBpdGVyYXRlZSBpcyBwYXNzZWQgYSBgY2FsbGJhY2soZXJyLCB0cmFuc2Zvcm1lZClgIHdoaWNoIG11c3QgYmUgY2FsbGVkXG4gKiBvbmNlIGl0IGhhcyBjb21wbGV0ZWQgd2l0aCBhbiBlcnJvciAod2hpY2ggY2FuIGJlIGBudWxsYCkgYW5kIGFcbiAqIHRyYW5zZm9ybWVkIGl0ZW0uIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIHdoZW4gYWxsIGBpdGVyYXRlZWBcbiAqIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLCBvciBhbiBlcnJvciBvY2N1cnMuIFJlc3VsdHMgaXMgYW4gQXJyYXkgb2YgdGhlXG4gKiB0cmFuc2Zvcm1lZCBpdGVtcyBmcm9tIHRoZSBgY29sbGAuIEludm9rZWQgd2l0aCAoZXJyLCByZXN1bHRzKS5cbiAqIEBleGFtcGxlXG4gKlxuICogYXN5bmMubWFwKFsnZmlsZTEnLCdmaWxlMicsJ2ZpbGUzJ10sIGZzLnN0YXQsIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICogICAgIC8vIHJlc3VsdHMgaXMgbm93IGFuIGFycmF5IG9mIHN0YXRzIGZvciBlYWNoIGZpbGVcbiAqIH0pO1xuICovXG5leHBvcnQgZGVmYXVsdCBkb1BhcmFsbGVsKG1hcCk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vLi4vLi4vLi4vfi9hc3luYy1lcy9tYXAuanMiLCJpbXBvcnQgYXBwbHlFYWNoIGZyb20gJy4vaW50ZXJuYWwvYXBwbHlFYWNoJztcbmltcG9ydCBtYXAgZnJvbSAnLi9tYXAnO1xuXG4vKipcbiAqIEFwcGxpZXMgdGhlIHByb3ZpZGVkIGFyZ3VtZW50cyB0byBlYWNoIGZ1bmN0aW9uIGluIHRoZSBhcnJheSwgY2FsbGluZ1xuICogYGNhbGxiYWNrYCBhZnRlciBhbGwgZnVuY3Rpb25zIGhhdmUgY29tcGxldGVkLiBJZiB5b3Ugb25seSBwcm92aWRlIHRoZSBmaXJzdFxuICogYXJndW1lbnQsIGBmbnNgLCB0aGVuIGl0IHdpbGwgcmV0dXJuIGEgZnVuY3Rpb24gd2hpY2ggbGV0cyB5b3UgcGFzcyBpbiB0aGVcbiAqIGFyZ3VtZW50cyBhcyBpZiBpdCB3ZXJlIGEgc2luZ2xlIGZ1bmN0aW9uIGNhbGwuIElmIG1vcmUgYXJndW1lbnRzIGFyZVxuICogcHJvdmlkZWQsIGBjYWxsYmFja2AgaXMgcmVxdWlyZWQgd2hpbGUgYGFyZ3NgIGlzIHN0aWxsIG9wdGlvbmFsLlxuICpcbiAqIEBuYW1lIGFwcGx5RWFjaFxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvd1xuICogQG1ldGhvZFxuICogQGNhdGVnb3J5IENvbnRyb2wgRmxvd1xuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGZucyAtIEEgY29sbGVjdGlvbiBvZiBhc3luY2hyb25vdXMgZnVuY3Rpb25zXG4gKiB0byBhbGwgY2FsbCB3aXRoIHRoZSBzYW1lIGFyZ3VtZW50c1xuICogQHBhcmFtIHsuLi4qfSBbYXJnc10gLSBhbnkgbnVtYmVyIG9mIHNlcGFyYXRlIGFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZVxuICogZnVuY3Rpb24uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gdGhlIGZpbmFsIGFyZ3VtZW50IHNob3VsZCBiZSB0aGUgY2FsbGJhY2ssXG4gKiBjYWxsZWQgd2hlbiBhbGwgZnVuY3Rpb25zIGhhdmUgY29tcGxldGVkIHByb2Nlc3NpbmcuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IC0gSWYgb25seSB0aGUgZmlyc3QgYXJndW1lbnQsIGBmbnNgLCBpcyBwcm92aWRlZCwgaXQgd2lsbFxuICogcmV0dXJuIGEgZnVuY3Rpb24gd2hpY2ggbGV0cyB5b3UgcGFzcyBpbiB0aGUgYXJndW1lbnRzIGFzIGlmIGl0IHdlcmUgYSBzaW5nbGVcbiAqIGZ1bmN0aW9uIGNhbGwuIFRoZSBzaWduYXR1cmUgaXMgYCguLmFyZ3MsIGNhbGxiYWNrKWAuIElmIGludm9rZWQgd2l0aCBhbnlcbiAqIGFyZ3VtZW50cywgYGNhbGxiYWNrYCBpcyByZXF1aXJlZC5cbiAqIEBleGFtcGxlXG4gKlxuICogYXN5bmMuYXBwbHlFYWNoKFtlbmFibGVTZWFyY2gsIHVwZGF0ZVNjaGVtYV0sICdidWNrZXQnLCBjYWxsYmFjayk7XG4gKlxuICogLy8gcGFydGlhbCBhcHBsaWNhdGlvbiBleGFtcGxlOlxuICogYXN5bmMuZWFjaChcbiAqICAgICBidWNrZXRzLFxuICogICAgIGFzeW5jLmFwcGx5RWFjaChbZW5hYmxlU2VhcmNoLCB1cGRhdGVTY2hlbWFdKSxcbiAqICAgICBjYWxsYmFja1xuICogKTtcbiAqL1xuZXhwb3J0IGRlZmF1bHQgYXBwbHlFYWNoKG1hcCk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vLi4vLi4vLi4vfi9hc3luYy1lcy9hcHBseUVhY2guanMiLCJpbXBvcnQgZWFjaE9mTGltaXQgZnJvbSAnLi9lYWNoT2ZMaW1pdCc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGRvUGFyYWxsZWxMaW1pdChmbikge1xuICAgIHJldHVybiBmdW5jdGlvbiAob2JqLCBsaW1pdCwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBmbihlYWNoT2ZMaW1pdChsaW1pdCksIG9iaiwgaXRlcmF0ZWUsIGNhbGxiYWNrKTtcbiAgICB9O1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uLy4uLy4uLy4uL34vYXN5bmMtZXMvaW50ZXJuYWwvZG9QYXJhbGxlbExpbWl0LmpzIiwiaW1wb3J0IGRvUGFyYWxsZWxMaW1pdCBmcm9tICcuL2ludGVybmFsL2RvUGFyYWxsZWxMaW1pdCc7XG5pbXBvcnQgbWFwIGZyb20gJy4vaW50ZXJuYWwvbWFwJztcblxuLyoqXG4gKiBUaGUgc2FtZSBhcyBbYG1hcGBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5tYXB9IGJ1dCBydW5zIGEgbWF4aW11bSBvZiBgbGltaXRgIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLlxuICpcbiAqIEBuYW1lIG1hcExpbWl0XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5tYXBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5tYXB9XG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2ggaXRlbSBpbiBgY29sbGAuXG4gKiBUaGUgaXRlcmF0ZWUgaXMgcGFzc2VkIGEgYGNhbGxiYWNrKGVyciwgdHJhbnNmb3JtZWQpYCB3aGljaCBtdXN0IGJlIGNhbGxlZFxuICogb25jZSBpdCBoYXMgY29tcGxldGVkIHdpdGggYW4gZXJyb3IgKHdoaWNoIGNhbiBiZSBgbnVsbGApIGFuZCBhIHRyYW5zZm9ybWVkXG4gKiBpdGVtLiBJbnZva2VkIHdpdGggKGl0ZW0sIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIGFsbCBgaXRlcmF0ZWVgXG4gKiBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZCwgb3IgYW4gZXJyb3Igb2NjdXJzLiBSZXN1bHRzIGlzIGFuIGFycmF5IG9mIHRoZVxuICogdHJhbnNmb3JtZWQgaXRlbXMgZnJvbSB0aGUgYGNvbGxgLiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0cykuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGRvUGFyYWxsZWxMaW1pdChtYXApO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uLy4uLy4uLy4uL34vYXN5bmMtZXMvbWFwTGltaXQuanMiLCJpbXBvcnQgbWFwTGltaXQgZnJvbSAnLi9tYXBMaW1pdCc7XG5pbXBvcnQgZG9MaW1pdCBmcm9tICcuL2ludGVybmFsL2RvTGltaXQnO1xuXG4vKipcbiAqIFRoZSBzYW1lIGFzIFtgbWFwYF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLm1hcH0gYnV0IHJ1bnMgb25seSBhIHNpbmdsZSBhc3luYyBvcGVyYXRpb24gYXQgYSB0aW1lLlxuICpcbiAqIEBuYW1lIG1hcFNlcmllc1xuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICogQG1ldGhvZFxuICogQHNlZSBbYXN5bmMubWFwXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMubWFwfVxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIC0gQSBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoIGl0ZW0gaW4gYGNvbGxgLlxuICogVGhlIGl0ZXJhdGVlIGlzIHBhc3NlZCBhIGBjYWxsYmFjayhlcnIsIHRyYW5zZm9ybWVkKWAgd2hpY2ggbXVzdCBiZSBjYWxsZWRcbiAqIG9uY2UgaXQgaGFzIGNvbXBsZXRlZCB3aXRoIGFuIGVycm9yICh3aGljaCBjYW4gYmUgYG51bGxgKSBhbmQgYVxuICogdHJhbnNmb3JtZWQgaXRlbS4gSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiBhbGwgYGl0ZXJhdGVlYFxuICogZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQsIG9yIGFuIGVycm9yIG9jY3Vycy4gUmVzdWx0cyBpcyBhbiBhcnJheSBvZiB0aGVcbiAqIHRyYW5zZm9ybWVkIGl0ZW1zIGZyb20gdGhlIGBjb2xsYC4gSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdHMpLlxuICovXG5leHBvcnQgZGVmYXVsdCBkb0xpbWl0KG1hcExpbWl0LCAxKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi8uLi8uLi8uLi9+L2FzeW5jLWVzL21hcFNlcmllcy5qcyIsImltcG9ydCBhcHBseUVhY2ggZnJvbSAnLi9pbnRlcm5hbC9hcHBseUVhY2gnO1xuaW1wb3J0IG1hcFNlcmllcyBmcm9tICcuL21hcFNlcmllcyc7XG5cbi8qKlxuICogVGhlIHNhbWUgYXMgW2BhcHBseUVhY2hgXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cuYXBwbHlFYWNofSBidXQgcnVucyBvbmx5IGEgc2luZ2xlIGFzeW5jIG9wZXJhdGlvbiBhdCBhIHRpbWUuXG4gKlxuICogQG5hbWUgYXBwbHlFYWNoU2VyaWVzXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93XG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5hcHBseUVhY2hde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy5hcHBseUVhY2h9XG4gKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93XG4gKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gZm5zIC0gQSBjb2xsZWN0aW9uIG9mIGFzeW5jaHJvbm91cyBmdW5jdGlvbnMgdG8gYWxsXG4gKiBjYWxsIHdpdGggdGhlIHNhbWUgYXJndW1lbnRzXG4gKiBAcGFyYW0gey4uLip9IFthcmdzXSAtIGFueSBudW1iZXIgb2Ygc2VwYXJhdGUgYXJndW1lbnRzIHRvIHBhc3MgdG8gdGhlXG4gKiBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSB0aGUgZmluYWwgYXJndW1lbnQgc2hvdWxkIGJlIHRoZSBjYWxsYmFjayxcbiAqIGNhbGxlZCB3aGVuIGFsbCBmdW5jdGlvbnMgaGF2ZSBjb21wbGV0ZWQgcHJvY2Vzc2luZy5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gLSBJZiBvbmx5IHRoZSBmaXJzdCBhcmd1bWVudCBpcyBwcm92aWRlZCwgaXQgd2lsbCByZXR1cm5cbiAqIGEgZnVuY3Rpb24gd2hpY2ggbGV0cyB5b3UgcGFzcyBpbiB0aGUgYXJndW1lbnRzIGFzIGlmIGl0IHdlcmUgYSBzaW5nbGVcbiAqIGZ1bmN0aW9uIGNhbGwuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGFwcGx5RWFjaChtYXBTZXJpZXMpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uLy4uLy4uLy4uL34vYXN5bmMtZXMvYXBwbHlFYWNoU2VyaWVzLmpzIiwiaW1wb3J0IHJlc3QgZnJvbSAnLi9pbnRlcm5hbC9yZXN0JztcblxuLyoqXG4gKiBDcmVhdGVzIGEgY29udGludWF0aW9uIGZ1bmN0aW9uIHdpdGggc29tZSBhcmd1bWVudHMgYWxyZWFkeSBhcHBsaWVkLlxuICpcbiAqIFVzZWZ1bCBhcyBhIHNob3J0aGFuZCB3aGVuIGNvbWJpbmVkIHdpdGggb3RoZXIgY29udHJvbCBmbG93IGZ1bmN0aW9ucy4gQW55XG4gKiBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSByZXR1cm5lZCBmdW5jdGlvbiBhcmUgYWRkZWQgdG8gdGhlIGFyZ3VtZW50c1xuICogb3JpZ2luYWxseSBwYXNzZWQgdG8gYXBwbHkuXG4gKlxuICogQG5hbWUgYXBwbHlcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6VXRpbHNcbiAqIEBtZXRob2RcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jdGlvbiAtIFRoZSBmdW5jdGlvbiB5b3Ugd2FudCB0byBldmVudHVhbGx5IGFwcGx5IGFsbFxuICogYXJndW1lbnRzIHRvLiBJbnZva2VzIHdpdGggKGFyZ3VtZW50cy4uLikuXG4gKiBAcGFyYW0gey4uLip9IGFyZ3VtZW50cy4uLiAtIEFueSBudW1iZXIgb2YgYXJndW1lbnRzIHRvIGF1dG9tYXRpY2FsbHkgYXBwbHlcbiAqIHdoZW4gdGhlIGNvbnRpbnVhdGlvbiBpcyBjYWxsZWQuXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIHVzaW5nIGFwcGx5XG4gKiBhc3luYy5wYXJhbGxlbChbXG4gKiAgICAgYXN5bmMuYXBwbHkoZnMud3JpdGVGaWxlLCAndGVzdGZpbGUxJywgJ3Rlc3QxJyksXG4gKiAgICAgYXN5bmMuYXBwbHkoZnMud3JpdGVGaWxlLCAndGVzdGZpbGUyJywgJ3Rlc3QyJylcbiAqIF0pO1xuICpcbiAqXG4gKiAvLyB0aGUgc2FtZSBwcm9jZXNzIHdpdGhvdXQgdXNpbmcgYXBwbHlcbiAqIGFzeW5jLnBhcmFsbGVsKFtcbiAqICAgICBmdW5jdGlvbihjYWxsYmFjaykge1xuICogICAgICAgICBmcy53cml0ZUZpbGUoJ3Rlc3RmaWxlMScsICd0ZXN0MScsIGNhbGxiYWNrKTtcbiAqICAgICB9LFxuICogICAgIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIGZzLndyaXRlRmlsZSgndGVzdGZpbGUyJywgJ3Rlc3QyJywgY2FsbGJhY2spO1xuICogICAgIH1cbiAqIF0pO1xuICpcbiAqIC8vIEl0J3MgcG9zc2libGUgdG8gcGFzcyBhbnkgbnVtYmVyIG9mIGFkZGl0aW9uYWwgYXJndW1lbnRzIHdoZW4gY2FsbGluZyB0aGVcbiAqIC8vIGNvbnRpbnVhdGlvbjpcbiAqXG4gKiBub2RlPiB2YXIgZm4gPSBhc3luYy5hcHBseShzeXMucHV0cywgJ29uZScpO1xuICogbm9kZT4gZm4oJ3R3bycsICd0aHJlZScpO1xuICogb25lXG4gKiB0d29cbiAqIHRocmVlXG4gKi9cbmV4cG9ydCBkZWZhdWx0IHJlc3QoZnVuY3Rpb24oZm4sIGFyZ3MpIHtcbiAgICByZXR1cm4gcmVzdChmdW5jdGlvbihjYWxsQXJncykge1xuICAgICAgICByZXR1cm4gZm4uYXBwbHkobnVsbCwgYXJncy5jb25jYXQoY2FsbEFyZ3MpKTtcbiAgICB9KTtcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uLy4uLy4uLy4uL34vYXN5bmMtZXMvYXBwbHkuanMiLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5mb3JFYWNoYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlFYWNoKGFycmF5LCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSA9PT0gZmFsc2UpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFycmF5RWFjaDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi8uLi8uLi8uLi9+L2xvZGFzaC1lcy9fYXJyYXlFYWNoLmpzIiwiLyoqXG4gKiBDcmVhdGVzIGEgYmFzZSBmdW5jdGlvbiBmb3IgbWV0aG9kcyBsaWtlIGBfLmZvckluYCBhbmQgYF8uZm9yT3duYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBiYXNlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVCYXNlRm9yKGZyb21SaWdodCkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0LCBpdGVyYXRlZSwga2V5c0Z1bmMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgaXRlcmFibGUgPSBPYmplY3Qob2JqZWN0KSxcbiAgICAgICAgcHJvcHMgPSBrZXlzRnVuYyhvYmplY3QpLFxuICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIHZhciBrZXkgPSBwcm9wc1tmcm9tUmlnaHQgPyBsZW5ndGggOiArK2luZGV4XTtcbiAgICAgIGlmIChpdGVyYXRlZShpdGVyYWJsZVtrZXldLCBrZXksIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZUJhc2VGb3I7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vLi4vLi4vLi4vfi9sb2Rhc2gtZXMvX2NyZWF0ZUJhc2VGb3IuanMiLCJpbXBvcnQgY3JlYXRlQmFzZUZvciBmcm9tICcuL19jcmVhdGVCYXNlRm9yLmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYmFzZUZvck93bmAgd2hpY2ggaXRlcmF0ZXMgb3ZlciBgb2JqZWN0YFxuICogcHJvcGVydGllcyByZXR1cm5lZCBieSBga2V5c0Z1bmNgIGFuZCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGVhY2ggcHJvcGVydHkuXG4gKiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbnZhciBiYXNlRm9yID0gY3JlYXRlQmFzZUZvcigpO1xuXG5leHBvcnQgZGVmYXVsdCBiYXNlRm9yO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uLy4uLy4uLy4uL34vbG9kYXNoLWVzL19iYXNlRm9yLmpzIiwiaW1wb3J0IGJhc2VGb3IgZnJvbSAnLi9fYmFzZUZvci5qcyc7XG5pbXBvcnQga2V5cyBmcm9tICcuL2tleXMuanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvck93bmAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VGb3JPd24ob2JqZWN0LCBpdGVyYXRlZSkge1xuICByZXR1cm4gb2JqZWN0ICYmIGJhc2VGb3Iob2JqZWN0LCBpdGVyYXRlZSwga2V5cyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VGb3JPd247XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vLi4vLi4vLi4vfi9sb2Rhc2gtZXMvX2Jhc2VGb3JPd24uanMiLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZpbmRJbmRleGAgYW5kIGBfLmZpbmRMYXN0SW5kZXhgIHdpdGhvdXRcbiAqIHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUZpbmRJbmRleChhcnJheSwgcHJlZGljYXRlLCBmcm9tSW5kZXgsIGZyb21SaWdodCkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgaW5kZXggPSBmcm9tSW5kZXggKyAoZnJvbVJpZ2h0ID8gMSA6IC0xKTtcblxuICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSkge1xuICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUZpbmRJbmRleDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi8uLi8uLi8uLi9+L2xvZGFzaC1lcy9fYmFzZUZpbmRJbmRleC5qcyIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYU5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgbnVtYmVyIG9iamVjdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYE5hTmAsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTmFOKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VJc05hTjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi8uLi8uLi8uLi9+L2xvZGFzaC1lcy9fYmFzZUlzTmFOLmpzIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uaW5kZXhPZmAgd2hpY2ggcGVyZm9ybXMgc3RyaWN0IGVxdWFsaXR5XG4gKiBjb21wYXJpc29ucyBvZiB2YWx1ZXMsIGkuZS4gYD09PWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gc3RyaWN0SW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICB2YXIgaW5kZXggPSBmcm9tSW5kZXggLSAxLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKGFycmF5W2luZGV4XSA9PT0gdmFsdWUpIHtcbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG5leHBvcnQgZGVmYXVsdCBzdHJpY3RJbmRleE9mO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uLy4uLy4uLy4uL34vbG9kYXNoLWVzL19zdHJpY3RJbmRleE9mLmpzIiwiaW1wb3J0IGJhc2VGaW5kSW5kZXggZnJvbSAnLi9fYmFzZUZpbmRJbmRleC5qcyc7XG5pbXBvcnQgYmFzZUlzTmFOIGZyb20gJy4vX2Jhc2VJc05hTi5qcyc7XG5pbXBvcnQgc3RyaWN0SW5kZXhPZiBmcm9tICcuL19zdHJpY3RJbmRleE9mLmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pbmRleE9mYCB3aXRob3V0IGBmcm9tSW5kZXhgIGJvdW5kcyBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZVxuICAgID8gc3RyaWN0SW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleClcbiAgICA6IGJhc2VGaW5kSW5kZXgoYXJyYXksIGJhc2VJc05hTiwgZnJvbUluZGV4KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUluZGV4T2Y7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vLi4vLi4vLi4vfi9sb2Rhc2gtZXMvX2Jhc2VJbmRleE9mLmpzIiwiaW1wb3J0IGFycmF5RWFjaCBmcm9tICdsb2Rhc2gtZXMvX2FycmF5RWFjaCc7XG5pbXBvcnQgZm9yT3duIGZyb20gJ2xvZGFzaC1lcy9fYmFzZUZvck93bic7XG5pbXBvcnQgaW5kZXhPZiBmcm9tICdsb2Rhc2gtZXMvX2Jhc2VJbmRleE9mJztcbmltcG9ydCBpc0FycmF5IGZyb20gJ2xvZGFzaC1lcy9pc0FycmF5JztcbmltcG9ydCBva2V5cyBmcm9tICdsb2Rhc2gtZXMva2V5cyc7XG5pbXBvcnQgbm9vcCBmcm9tICdsb2Rhc2gtZXMvbm9vcCc7XG5pbXBvcnQgcmVzdCBmcm9tICcuL2ludGVybmFsL3Jlc3QnO1xuXG5pbXBvcnQgb25jZSBmcm9tICcuL2ludGVybmFsL29uY2UnO1xuaW1wb3J0IG9ubHlPbmNlIGZyb20gJy4vaW50ZXJuYWwvb25seU9uY2UnO1xuXG4vKipcbiAqIERldGVybWluZXMgdGhlIGJlc3Qgb3JkZXIgZm9yIHJ1bm5pbmcgdGhlIGZ1bmN0aW9ucyBpbiBgdGFza3NgLCBiYXNlZCBvblxuICogdGhlaXIgcmVxdWlyZW1lbnRzLiBFYWNoIGZ1bmN0aW9uIGNhbiBvcHRpb25hbGx5IGRlcGVuZCBvbiBvdGhlciBmdW5jdGlvbnNcbiAqIGJlaW5nIGNvbXBsZXRlZCBmaXJzdCwgYW5kIGVhY2ggZnVuY3Rpb24gaXMgcnVuIGFzIHNvb24gYXMgaXRzIHJlcXVpcmVtZW50c1xuICogYXJlIHNhdGlzZmllZC5cbiAqXG4gKiBJZiBhbnkgb2YgdGhlIGZ1bmN0aW9ucyBwYXNzIGFuIGVycm9yIHRvIHRoZWlyIGNhbGxiYWNrLCB0aGUgYGF1dG9gIHNlcXVlbmNlXG4gKiB3aWxsIHN0b3AuIEZ1cnRoZXIgdGFza3Mgd2lsbCBub3QgZXhlY3V0ZSAoc28gYW55IG90aGVyIGZ1bmN0aW9ucyBkZXBlbmRpbmdcbiAqIG9uIGl0IHdpbGwgbm90IHJ1biksIGFuZCB0aGUgbWFpbiBgY2FsbGJhY2tgIGlzIGltbWVkaWF0ZWx5IGNhbGxlZCB3aXRoIHRoZVxuICogZXJyb3IuXG4gKlxuICogRnVuY3Rpb25zIGFsc28gcmVjZWl2ZSBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgcmVzdWx0cyBvZiBmdW5jdGlvbnMgd2hpY2hcbiAqIGhhdmUgY29tcGxldGVkIHNvIGZhciBhcyB0aGUgZmlyc3QgYXJndW1lbnQsIGlmIHRoZXkgaGF2ZSBkZXBlbmRlbmNpZXMuIElmIGFcbiAqIHRhc2sgZnVuY3Rpb24gaGFzIG5vIGRlcGVuZGVuY2llcywgaXQgd2lsbCBvbmx5IGJlIHBhc3NlZCBhIGNhbGxiYWNrLlxuICpcbiAqIEBuYW1lIGF1dG9cbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3dcbiAqIEBtZXRob2RcbiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3dcbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXNrcyAtIEFuIG9iamVjdC4gRWFjaCBvZiBpdHMgcHJvcGVydGllcyBpcyBlaXRoZXIgYVxuICogZnVuY3Rpb24gb3IgYW4gYXJyYXkgb2YgcmVxdWlyZW1lbnRzLCB3aXRoIHRoZSBmdW5jdGlvbiBpdHNlbGYgdGhlIGxhc3QgaXRlbVxuICogaW4gdGhlIGFycmF5LiBUaGUgb2JqZWN0J3Mga2V5IG9mIGEgcHJvcGVydHkgc2VydmVzIGFzIHRoZSBuYW1lIG9mIHRoZSB0YXNrXG4gKiBkZWZpbmVkIGJ5IHRoYXQgcHJvcGVydHksIGkuZS4gY2FuIGJlIHVzZWQgd2hlbiBzcGVjaWZ5aW5nIHJlcXVpcmVtZW50cyBmb3JcbiAqIG90aGVyIHRhc2tzLiBUaGUgZnVuY3Rpb24gcmVjZWl2ZXMgb25lIG9yIHR3byBhcmd1bWVudHM6XG4gKiAqIGEgYHJlc3VsdHNgIG9iamVjdCwgY29udGFpbmluZyB0aGUgcmVzdWx0cyBvZiB0aGUgcHJldmlvdXNseSBleGVjdXRlZFxuICogICBmdW5jdGlvbnMsIG9ubHkgcGFzc2VkIGlmIHRoZSB0YXNrIGhhcyBhbnkgZGVwZW5kZW5jaWVzLFxuICogKiBhIGBjYWxsYmFjayhlcnIsIHJlc3VsdClgIGZ1bmN0aW9uLCB3aGljaCBtdXN0IGJlIGNhbGxlZCB3aGVuIGZpbmlzaGVkLFxuICogICBwYXNzaW5nIGFuIGBlcnJvcmAgKHdoaWNoIGNhbiBiZSBgbnVsbGApIGFuZCB0aGUgcmVzdWx0IG9mIHRoZSBmdW5jdGlvbidzXG4gKiAgIGV4ZWN1dGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbY29uY3VycmVuY3k9SW5maW5pdHldIC0gQW4gb3B0aW9uYWwgYGludGVnZXJgIGZvclxuICogZGV0ZXJtaW5pbmcgdGhlIG1heGltdW0gbnVtYmVyIG9mIHRhc2tzIHRoYXQgY2FuIGJlIHJ1biBpbiBwYXJhbGxlbC4gQnlcbiAqIGRlZmF1bHQsIGFzIG1hbnkgYXMgcG9zc2libGUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQW4gb3B0aW9uYWwgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIHdoZW4gYWxsXG4gKiB0aGUgdGFza3MgaGF2ZSBiZWVuIGNvbXBsZXRlZC4gSXQgcmVjZWl2ZXMgdGhlIGBlcnJgIGFyZ3VtZW50IGlmIGFueSBgdGFza3NgXG4gKiBwYXNzIGFuIGVycm9yIHRvIHRoZWlyIGNhbGxiYWNrLiBSZXN1bHRzIGFyZSBhbHdheXMgcmV0dXJuZWQ7IGhvd2V2ZXIsIGlmIGFuXG4gKiBlcnJvciBvY2N1cnMsIG5vIGZ1cnRoZXIgYHRhc2tzYCB3aWxsIGJlIHBlcmZvcm1lZCwgYW5kIHRoZSByZXN1bHRzIG9iamVjdFxuICogd2lsbCBvbmx5IGNvbnRhaW4gcGFydGlhbCByZXN1bHRzLiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0cykuXG4gKiBAcmV0dXJucyB1bmRlZmluZWRcbiAqIEBleGFtcGxlXG4gKlxuICogYXN5bmMuYXV0byh7XG4gKiAgICAgLy8gdGhpcyBmdW5jdGlvbiB3aWxsIGp1c3QgYmUgcGFzc2VkIGEgY2FsbGJhY2tcbiAqICAgICByZWFkRGF0YTogYXN5bmMuYXBwbHkoZnMucmVhZEZpbGUsICdkYXRhLnR4dCcsICd1dGYtOCcpLFxuICogICAgIHNob3dEYXRhOiBbJ3JlYWREYXRhJywgZnVuY3Rpb24ocmVzdWx0cywgY2IpIHtcbiAqICAgICAgICAgLy8gcmVzdWx0cy5yZWFkRGF0YSBpcyB0aGUgZmlsZSdzIGNvbnRlbnRzXG4gKiAgICAgICAgIC8vIC4uLlxuICogICAgIH1dXG4gKiB9LCBjYWxsYmFjayk7XG4gKlxuICogYXN5bmMuYXV0byh7XG4gKiAgICAgZ2V0X2RhdGE6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKCdpbiBnZXRfZGF0YScpO1xuICogICAgICAgICAvLyBhc3luYyBjb2RlIHRvIGdldCBzb21lIGRhdGFcbiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ2RhdGEnLCAnY29udmVydGVkIHRvIGFycmF5Jyk7XG4gKiAgICAgfSxcbiAqICAgICBtYWtlX2ZvbGRlcjogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgY29uc29sZS5sb2coJ2luIG1ha2VfZm9sZGVyJyk7XG4gKiAgICAgICAgIC8vIGFzeW5jIGNvZGUgdG8gY3JlYXRlIGEgZGlyZWN0b3J5IHRvIHN0b3JlIGEgZmlsZSBpblxuICogICAgICAgICAvLyB0aGlzIGlzIHJ1biBhdCB0aGUgc2FtZSB0aW1lIGFzIGdldHRpbmcgdGhlIGRhdGFcbiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ2ZvbGRlcicpO1xuICogICAgIH0sXG4gKiAgICAgd3JpdGVfZmlsZTogWydnZXRfZGF0YScsICdtYWtlX2ZvbGRlcicsIGZ1bmN0aW9uKHJlc3VsdHMsIGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKCdpbiB3cml0ZV9maWxlJywgSlNPTi5zdHJpbmdpZnkocmVzdWx0cykpO1xuICogICAgICAgICAvLyBvbmNlIHRoZXJlIGlzIHNvbWUgZGF0YSBhbmQgdGhlIGRpcmVjdG9yeSBleGlzdHMsXG4gKiAgICAgICAgIC8vIHdyaXRlIHRoZSBkYXRhIHRvIGEgZmlsZSBpbiB0aGUgZGlyZWN0b3J5XG4gKiAgICAgICAgIGNhbGxiYWNrKG51bGwsICdmaWxlbmFtZScpO1xuICogICAgIH1dLFxuICogICAgIGVtYWlsX2xpbms6IFsnd3JpdGVfZmlsZScsIGZ1bmN0aW9uKHJlc3VsdHMsIGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKCdpbiBlbWFpbF9saW5rJywgSlNPTi5zdHJpbmdpZnkocmVzdWx0cykpO1xuICogICAgICAgICAvLyBvbmNlIHRoZSBmaWxlIGlzIHdyaXR0ZW4gbGV0J3MgZW1haWwgYSBsaW5rIHRvIGl0Li4uXG4gKiAgICAgICAgIC8vIHJlc3VsdHMud3JpdGVfZmlsZSBjb250YWlucyB0aGUgZmlsZW5hbWUgcmV0dXJuZWQgYnkgd3JpdGVfZmlsZS5cbiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgeydmaWxlJzpyZXN1bHRzLndyaXRlX2ZpbGUsICdlbWFpbCc6J3VzZXJAZXhhbXBsZS5jb20nfSk7XG4gKiAgICAgfV1cbiAqIH0sIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICogICAgIGNvbnNvbGUubG9nKCdlcnIgPSAnLCBlcnIpO1xuICogICAgIGNvbnNvbGUubG9nKCdyZXN1bHRzID0gJywgcmVzdWx0cyk7XG4gKiB9KTtcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKHRhc2tzLCBjb25jdXJyZW5jeSwgY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIGNvbmN1cnJlbmN5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIGNvbmN1cnJlbmN5IGlzIG9wdGlvbmFsLCBzaGlmdCB0aGUgYXJncy5cbiAgICAgICAgY2FsbGJhY2sgPSBjb25jdXJyZW5jeTtcbiAgICAgICAgY29uY3VycmVuY3kgPSBudWxsO1xuICAgIH1cbiAgICBjYWxsYmFjayA9IG9uY2UoY2FsbGJhY2sgfHwgbm9vcCk7XG4gICAgdmFyIGtleXMgPSBva2V5cyh0YXNrcyk7XG4gICAgdmFyIG51bVRhc2tzID0ga2V5cy5sZW5ndGg7XG4gICAgaWYgKCFudW1UYXNrcykge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCk7XG4gICAgfVxuICAgIGlmICghY29uY3VycmVuY3kpIHtcbiAgICAgICAgY29uY3VycmVuY3kgPSBudW1UYXNrcztcbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0cyA9IHt9O1xuICAgIHZhciBydW5uaW5nVGFza3MgPSAwO1xuICAgIHZhciBoYXNFcnJvciA9IGZhbHNlO1xuXG4gICAgdmFyIGxpc3RlbmVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICB2YXIgcmVhZHlUYXNrcyA9IFtdO1xuXG4gICAgLy8gZm9yIGN5Y2xlIGRldGVjdGlvbjpcbiAgICB2YXIgcmVhZHlUb0NoZWNrID0gW107IC8vIHRhc2tzIHRoYXQgaGF2ZSBiZWVuIGlkZW50aWZpZWQgYXMgcmVhY2hhYmxlXG4gICAgLy8gd2l0aG91dCB0aGUgcG9zc2liaWxpdHkgb2YgcmV0dXJuaW5nIHRvIGFuIGFuY2VzdG9yIHRhc2tcbiAgICB2YXIgdW5jaGVja2VkRGVwZW5kZW5jaWVzID0ge307XG5cbiAgICBmb3JPd24odGFza3MsIGZ1bmN0aW9uICh0YXNrLCBrZXkpIHtcbiAgICAgICAgaWYgKCFpc0FycmF5KHRhc2spKSB7XG4gICAgICAgICAgICAvLyBubyBkZXBlbmRlbmNpZXNcbiAgICAgICAgICAgIGVucXVldWVUYXNrKGtleSwgW3Rhc2tdKTtcbiAgICAgICAgICAgIHJlYWR5VG9DaGVjay5wdXNoKGtleSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGVwZW5kZW5jaWVzID0gdGFzay5zbGljZSgwLCB0YXNrLmxlbmd0aCAtIDEpO1xuICAgICAgICB2YXIgcmVtYWluaW5nRGVwZW5kZW5jaWVzID0gZGVwZW5kZW5jaWVzLmxlbmd0aDtcbiAgICAgICAgaWYgKHJlbWFpbmluZ0RlcGVuZGVuY2llcyA9PT0gMCkge1xuICAgICAgICAgICAgZW5xdWV1ZVRhc2soa2V5LCB0YXNrKTtcbiAgICAgICAgICAgIHJlYWR5VG9DaGVjay5wdXNoKGtleSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdW5jaGVja2VkRGVwZW5kZW5jaWVzW2tleV0gPSByZW1haW5pbmdEZXBlbmRlbmNpZXM7XG5cbiAgICAgICAgYXJyYXlFYWNoKGRlcGVuZGVuY2llcywgZnVuY3Rpb24gKGRlcGVuZGVuY3lOYW1lKSB7XG4gICAgICAgICAgICBpZiAoIXRhc2tzW2RlcGVuZGVuY3lOYW1lXSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXN5bmMuYXV0byB0YXNrIGAnICsga2V5ICtcbiAgICAgICAgICAgICAgICAgICAgJ2AgaGFzIGEgbm9uLWV4aXN0ZW50IGRlcGVuZGVuY3kgYCcgK1xuICAgICAgICAgICAgICAgICAgICBkZXBlbmRlbmN5TmFtZSArICdgIGluICcgK1xuICAgICAgICAgICAgICAgICAgICBkZXBlbmRlbmNpZXMuam9pbignLCAnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhZGRMaXN0ZW5lcihkZXBlbmRlbmN5TmFtZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJlbWFpbmluZ0RlcGVuZGVuY2llcy0tO1xuICAgICAgICAgICAgICAgIGlmIChyZW1haW5pbmdEZXBlbmRlbmNpZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZW5xdWV1ZVRhc2soa2V5LCB0YXNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBjaGVja0ZvckRlYWRsb2NrcygpO1xuICAgIHByb2Nlc3NRdWV1ZSgpO1xuXG4gICAgZnVuY3Rpb24gZW5xdWV1ZVRhc2soa2V5LCB0YXNrKSB7XG4gICAgICAgIHJlYWR5VGFza3MucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBydW5UYXNrKGtleSwgdGFzayk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByb2Nlc3NRdWV1ZSgpIHtcbiAgICAgICAgaWYgKHJlYWR5VGFza3MubGVuZ3RoID09PSAwICYmIHJ1bm5pbmdUYXNrcyA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHJlc3VsdHMpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlKHJlYWR5VGFza3MubGVuZ3RoICYmIHJ1bm5pbmdUYXNrcyA8IGNvbmN1cnJlbmN5KSB7XG4gICAgICAgICAgICB2YXIgcnVuID0gcmVhZHlUYXNrcy5zaGlmdCgpO1xuICAgICAgICAgICAgcnVuKCk7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZExpc3RlbmVyKHRhc2tOYW1lLCBmbikge1xuICAgICAgICB2YXIgdGFza0xpc3RlbmVycyA9IGxpc3RlbmVyc1t0YXNrTmFtZV07XG4gICAgICAgIGlmICghdGFza0xpc3RlbmVycykge1xuICAgICAgICAgICAgdGFza0xpc3RlbmVycyA9IGxpc3RlbmVyc1t0YXNrTmFtZV0gPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRhc2tMaXN0ZW5lcnMucHVzaChmbik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdGFza0NvbXBsZXRlKHRhc2tOYW1lKSB7XG4gICAgICAgIHZhciB0YXNrTGlzdGVuZXJzID0gbGlzdGVuZXJzW3Rhc2tOYW1lXSB8fCBbXTtcbiAgICAgICAgYXJyYXlFYWNoKHRhc2tMaXN0ZW5lcnMsIGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHByb2Nlc3NRdWV1ZSgpO1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gcnVuVGFzayhrZXksIHRhc2spIHtcbiAgICAgICAgaWYgKGhhc0Vycm9yKSByZXR1cm47XG5cbiAgICAgICAgdmFyIHRhc2tDYWxsYmFjayA9IG9ubHlPbmNlKHJlc3QoZnVuY3Rpb24oZXJyLCBhcmdzKSB7XG4gICAgICAgICAgICBydW5uaW5nVGFza3MtLTtcbiAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgICAgICAgICAgYXJncyA9IGFyZ3NbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNhZmVSZXN1bHRzID0ge307XG4gICAgICAgICAgICAgICAgZm9yT3duKHJlc3VsdHMsIGZ1bmN0aW9uKHZhbCwgcmtleSkge1xuICAgICAgICAgICAgICAgICAgICBzYWZlUmVzdWx0c1tya2V5XSA9IHZhbDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzYWZlUmVzdWx0c1trZXldID0gYXJncztcbiAgICAgICAgICAgICAgICBoYXNFcnJvciA9IHRydWU7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgc2FmZVJlc3VsdHMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzW2tleV0gPSBhcmdzO1xuICAgICAgICAgICAgICAgIHRhc2tDb21wbGV0ZShrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSk7XG5cbiAgICAgICAgcnVubmluZ1Rhc2tzKys7XG4gICAgICAgIHZhciB0YXNrRm4gPSB0YXNrW3Rhc2subGVuZ3RoIC0gMV07XG4gICAgICAgIGlmICh0YXNrLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHRhc2tGbihyZXN1bHRzLCB0YXNrQ2FsbGJhY2spO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGFza0ZuKHRhc2tDYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaGVja0ZvckRlYWRsb2NrcygpIHtcbiAgICAgICAgLy8gS2FobidzIGFsZ29yaXRobVxuICAgICAgICAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Ub3BvbG9naWNhbF9zb3J0aW5nI0thaG4uMjdzX2FsZ29yaXRobVxuICAgICAgICAvLyBodHRwOi8vY29ubmFsbGUuYmxvZ3Nwb3QuY29tLzIwMTMvMTAvdG9wb2xvZ2ljYWwtc29ydGluZ2thaG4tYWxnb3JpdGhtLmh0bWxcbiAgICAgICAgdmFyIGN1cnJlbnRUYXNrO1xuICAgICAgICB2YXIgY291bnRlciA9IDA7XG4gICAgICAgIHdoaWxlIChyZWFkeVRvQ2hlY2subGVuZ3RoKSB7XG4gICAgICAgICAgICBjdXJyZW50VGFzayA9IHJlYWR5VG9DaGVjay5wb3AoKTtcbiAgICAgICAgICAgIGNvdW50ZXIrKztcbiAgICAgICAgICAgIGFycmF5RWFjaChnZXREZXBlbmRlbnRzKGN1cnJlbnRUYXNrKSwgZnVuY3Rpb24gKGRlcGVuZGVudCkge1xuICAgICAgICAgICAgICAgIGlmICgtLXVuY2hlY2tlZERlcGVuZGVuY2llc1tkZXBlbmRlbnRdID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlYWR5VG9DaGVjay5wdXNoKGRlcGVuZGVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY291bnRlciAhPT0gbnVtVGFza3MpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAnYXN5bmMuYXV0byBjYW5ub3QgZXhlY3V0ZSB0YXNrcyBkdWUgdG8gYSByZWN1cnNpdmUgZGVwZW5kZW5jeSdcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXREZXBlbmRlbnRzKHRhc2tOYW1lKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yT3duKHRhc2tzLCBmdW5jdGlvbiAodGFzaywga2V5KSB7XG4gICAgICAgICAgICBpZiAoaXNBcnJheSh0YXNrKSAmJiBpbmRleE9mKHRhc2ssIHRhc2tOYW1lLCAwKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uLy4uLy4uLy4uL34vYXN5bmMtZXMvYXV0by5qcyIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1hcGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gKiBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheU1hcChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFycmF5TWFwO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uLy4uLy4uLy4uL34vbG9kYXNoLWVzL19hcnJheU1hcC5qcyIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2xpY2VgIHdpdGhvdXQgYW4gaXRlcmF0ZWUgY2FsbCBndWFyZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNsaWNlLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgcG9zaXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gW2VuZD1hcnJheS5sZW5ndGhdIFRoZSBlbmQgcG9zaXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VTbGljZShhcnJheSwgc3RhcnQsIGVuZCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAtc3RhcnQgPiBsZW5ndGggPyAwIDogKGxlbmd0aCArIHN0YXJ0KTtcbiAgfVxuICBlbmQgPSBlbmQgPiBsZW5ndGggPyBsZW5ndGggOiBlbmQ7XG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlbmd0aDtcbiAgfVxuICBsZW5ndGggPSBzdGFydCA+IGVuZCA/IDAgOiAoKGVuZCAtIHN0YXJ0KSA+Pj4gMCk7XG4gIHN0YXJ0ID4+Pj0gMDtcblxuICB2YXIgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICByZXN1bHRbaW5kZXhdID0gYXJyYXlbaW5kZXggKyBzdGFydF07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZVNsaWNlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uLy4uLy4uLy4uL34vbG9kYXNoLWVzL19iYXNlU2xpY2UuanMiLCIvKipcbiAqIENvbnZlcnRzIGFuIEFTQ0lJIGBzdHJpbmdgIHRvIGFuIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY29udmVydGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhc2NpaVRvQXJyYXkoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcuc3BsaXQoJycpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBhc2NpaVRvQXJyYXk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vLi4vLi4vLi4vfi9sb2Rhc2gtZXMvX2FzY2lpVG9BcnJheS5qcyIsIi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjaGFyYWN0ZXIgY2xhc3Nlcy4gKi9cbnZhciByc0FzdHJhbFJhbmdlID0gJ1xcXFx1ZDgwMC1cXFxcdWRmZmYnLFxuICAgIHJzQ29tYm9NYXJrc1JhbmdlID0gJ1xcXFx1MDMwMC1cXFxcdTAzNmYnLFxuICAgIHJlQ29tYm9IYWxmTWFya3NSYW5nZSA9ICdcXFxcdWZlMjAtXFxcXHVmZTJmJyxcbiAgICByc0NvbWJvU3ltYm9sc1JhbmdlID0gJ1xcXFx1MjBkMC1cXFxcdTIwZmYnLFxuICAgIHJzQ29tYm9SYW5nZSA9IHJzQ29tYm9NYXJrc1JhbmdlICsgcmVDb21ib0hhbGZNYXJrc1JhbmdlICsgcnNDb21ib1N5bWJvbHNSYW5nZSxcbiAgICByc1ZhclJhbmdlID0gJ1xcXFx1ZmUwZVxcXFx1ZmUwZic7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjYXB0dXJlIGdyb3Vwcy4gKi9cbnZhciByc1pXSiA9ICdcXFxcdTIwMGQnO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgc3RyaW5ncyB3aXRoIFt6ZXJvLXdpZHRoIGpvaW5lcnMgb3IgY29kZSBwb2ludHMgZnJvbSB0aGUgYXN0cmFsIHBsYW5lc10oaHR0cDovL2Vldi5lZS9ibG9nLzIwMTUvMDkvMTIvZGFyay1jb3JuZXJzLW9mLXVuaWNvZGUvKS4gKi9cbnZhciByZUhhc1VuaWNvZGUgPSBSZWdFeHAoJ1snICsgcnNaV0ogKyByc0FzdHJhbFJhbmdlICArIHJzQ29tYm9SYW5nZSArIHJzVmFyUmFuZ2UgKyAnXScpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgc3RyaW5nYCBjb250YWlucyBVbmljb2RlIHN5bWJvbHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGEgc3ltYm9sIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc1VuaWNvZGUoc3RyaW5nKSB7XG4gIHJldHVybiByZUhhc1VuaWNvZGUudGVzdChzdHJpbmcpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBoYXNVbmljb2RlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uLy4uLy4uLy4uL34vbG9kYXNoLWVzL19oYXNVbmljb2RlLmpzIiwiLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNoYXJhY3RlciBjbGFzc2VzLiAqL1xudmFyIHJzQXN0cmFsUmFuZ2UgPSAnXFxcXHVkODAwLVxcXFx1ZGZmZicsXG4gICAgcnNDb21ib01hcmtzUmFuZ2UgPSAnXFxcXHUwMzAwLVxcXFx1MDM2ZicsXG4gICAgcmVDb21ib0hhbGZNYXJrc1JhbmdlID0gJ1xcXFx1ZmUyMC1cXFxcdWZlMmYnLFxuICAgIHJzQ29tYm9TeW1ib2xzUmFuZ2UgPSAnXFxcXHUyMGQwLVxcXFx1MjBmZicsXG4gICAgcnNDb21ib1JhbmdlID0gcnNDb21ib01hcmtzUmFuZ2UgKyByZUNvbWJvSGFsZk1hcmtzUmFuZ2UgKyByc0NvbWJvU3ltYm9sc1JhbmdlLFxuICAgIHJzVmFyUmFuZ2UgPSAnXFxcXHVmZTBlXFxcXHVmZTBmJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNhcHR1cmUgZ3JvdXBzLiAqL1xudmFyIHJzQXN0cmFsID0gJ1snICsgcnNBc3RyYWxSYW5nZSArICddJyxcbiAgICByc0NvbWJvID0gJ1snICsgcnNDb21ib1JhbmdlICsgJ10nLFxuICAgIHJzRml0eiA9ICdcXFxcdWQ4M2NbXFxcXHVkZmZiLVxcXFx1ZGZmZl0nLFxuICAgIHJzTW9kaWZpZXIgPSAnKD86JyArIHJzQ29tYm8gKyAnfCcgKyByc0ZpdHogKyAnKScsXG4gICAgcnNOb25Bc3RyYWwgPSAnW14nICsgcnNBc3RyYWxSYW5nZSArICddJyxcbiAgICByc1JlZ2lvbmFsID0gJyg/OlxcXFx1ZDgzY1tcXFxcdWRkZTYtXFxcXHVkZGZmXSl7Mn0nLFxuICAgIHJzU3VyclBhaXIgPSAnW1xcXFx1ZDgwMC1cXFxcdWRiZmZdW1xcXFx1ZGMwMC1cXFxcdWRmZmZdJyxcbiAgICByc1pXSiA9ICdcXFxcdTIwMGQnO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgcmVnZXhlcy4gKi9cbnZhciByZU9wdE1vZCA9IHJzTW9kaWZpZXIgKyAnPycsXG4gICAgcnNPcHRWYXIgPSAnWycgKyByc1ZhclJhbmdlICsgJ10/JyxcbiAgICByc09wdEpvaW4gPSAnKD86JyArIHJzWldKICsgJyg/OicgKyBbcnNOb25Bc3RyYWwsIHJzUmVnaW9uYWwsIHJzU3VyclBhaXJdLmpvaW4oJ3wnKSArICcpJyArIHJzT3B0VmFyICsgcmVPcHRNb2QgKyAnKSonLFxuICAgIHJzU2VxID0gcnNPcHRWYXIgKyByZU9wdE1vZCArIHJzT3B0Sm9pbixcbiAgICByc1N5bWJvbCA9ICcoPzonICsgW3JzTm9uQXN0cmFsICsgcnNDb21ibyArICc/JywgcnNDb21ibywgcnNSZWdpb25hbCwgcnNTdXJyUGFpciwgcnNBc3RyYWxdLmpvaW4oJ3wnKSArICcpJztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggW3N0cmluZyBzeW1ib2xzXShodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC11bmljb2RlKS4gKi9cbnZhciByZVVuaWNvZGUgPSBSZWdFeHAocnNGaXR6ICsgJyg/PScgKyByc0ZpdHogKyAnKXwnICsgcnNTeW1ib2wgKyByc1NlcSwgJ2cnKTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIFVuaWNvZGUgYHN0cmluZ2AgdG8gYW4gYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHVuaWNvZGVUb0FycmF5KHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLm1hdGNoKHJlVW5pY29kZSkgfHwgW107XG59XG5cbmV4cG9ydCBkZWZhdWx0IHVuaWNvZGVUb0FycmF5O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uLy4uLy4uLy4uL34vbG9kYXNoLWVzL191bmljb2RlVG9BcnJheS5qcyIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHJlc3QgZnJvbSAnLi9yZXN0JztcblxuZXhwb3J0IHZhciBoYXNTZXRJbW1lZGlhdGUgPSB0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSAnZnVuY3Rpb24nICYmIHNldEltbWVkaWF0ZTtcbmV4cG9ydCB2YXIgaGFzTmV4dFRpY2sgPSB0eXBlb2YgcHJvY2VzcyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHByb2Nlc3MubmV4dFRpY2sgPT09ICdmdW5jdGlvbic7XG5cbmV4cG9ydCBmdW5jdGlvbiBmYWxsYmFjayhmbikge1xuICAgIHNldFRpbWVvdXQoZm4sIDApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gd3JhcChkZWZlcikge1xuICAgIHJldHVybiByZXN0KGZ1bmN0aW9uIChmbiwgYXJncykge1xuICAgICAgICBkZWZlcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5cbnZhciBfZGVmZXI7XG5cbmlmIChoYXNTZXRJbW1lZGlhdGUpIHtcbiAgICBfZGVmZXIgPSBzZXRJbW1lZGlhdGU7XG59IGVsc2UgaWYgKGhhc05leHRUaWNrKSB7XG4gICAgX2RlZmVyID0gcHJvY2Vzcy5uZXh0VGljaztcbn0gZWxzZSB7XG4gICAgX2RlZmVyID0gZmFsbGJhY2s7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHdyYXAoX2RlZmVyKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi8uLi8uLi8uLi9+L2FzeW5jLWVzL2ludGVybmFsL3NldEltbWVkaWF0ZS5qcyIsIi8vIFNpbXBsZSBkb3VibHkgbGlua2VkIGxpc3QgKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0RvdWJseV9saW5rZWRfbGlzdCkgaW1wbGVtZW50YXRpb25cbi8vIHVzZWQgZm9yIHF1ZXVlcy4gVGhpcyBpbXBsZW1lbnRhdGlvbiBhc3N1bWVzIHRoYXQgdGhlIG5vZGUgcHJvdmlkZWQgYnkgdGhlIHVzZXIgY2FuIGJlIG1vZGlmaWVkXG4vLyB0byBhZGp1c3QgdGhlIG5leHQgYW5kIGxhc3QgcHJvcGVydGllcy4gV2UgaW1wbGVtZW50IG9ubHkgdGhlIG1pbmltYWwgZnVuY3Rpb25hbGl0eVxuLy8gZm9yIHF1ZXVlIHN1cHBvcnQuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBETEwoKSB7XG4gICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG59XG5cbmZ1bmN0aW9uIHNldEluaXRpYWwoZGxsLCBub2RlKSB7XG4gICAgZGxsLmxlbmd0aCA9IDE7XG4gICAgZGxsLmhlYWQgPSBkbGwudGFpbCA9IG5vZGU7XG59XG5cbkRMTC5wcm90b3R5cGUucmVtb3ZlTGluayA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBpZiAobm9kZS5wcmV2KSBub2RlLnByZXYubmV4dCA9IG5vZGUubmV4dDtcbiAgICBlbHNlIHRoaXMuaGVhZCA9IG5vZGUubmV4dFxuICAgIGlmIChub2RlLm5leHQpIG5vZGUubmV4dC5wcmV2ID0gbm9kZS5wcmV2O1xuICAgIGVsc2UgdGhpcy50YWlsID0gbm9kZS5wcmV2O1xuXG4gICAgbm9kZS5wcmV2ID0gbm9kZS5uZXh0ID0gbnVsbDtcbiAgICB0aGlzLmxlbmd0aCAtPSAxO1xuICAgIHJldHVybiBub2RlO1xufVxuXG5ETEwucHJvdG90eXBlLmVtcHR5ID0gRExMO1xuXG5ETEwucHJvdG90eXBlLmluc2VydEFmdGVyID0gZnVuY3Rpb24obm9kZSwgbmV3Tm9kZSkge1xuICAgIG5ld05vZGUucHJldiA9IG5vZGU7XG4gICAgbmV3Tm9kZS5uZXh0ID0gbm9kZS5uZXh0O1xuICAgIGlmIChub2RlLm5leHQpIG5vZGUubmV4dC5wcmV2ID0gbmV3Tm9kZTtcbiAgICBlbHNlIHRoaXMudGFpbCA9IG5ld05vZGU7XG4gICAgbm9kZS5uZXh0ID0gbmV3Tm9kZTtcbiAgICB0aGlzLmxlbmd0aCArPSAxO1xufVxuXG5ETEwucHJvdG90eXBlLmluc2VydEJlZm9yZSA9IGZ1bmN0aW9uKG5vZGUsIG5ld05vZGUpIHtcbiAgICBuZXdOb2RlLnByZXYgPSBub2RlLnByZXY7XG4gICAgbmV3Tm9kZS5uZXh0ID0gbm9kZTtcbiAgICBpZiAobm9kZS5wcmV2KSBub2RlLnByZXYubmV4dCA9IG5ld05vZGU7XG4gICAgZWxzZSB0aGlzLmhlYWQgPSBuZXdOb2RlO1xuICAgIG5vZGUucHJldiA9IG5ld05vZGU7XG4gICAgdGhpcy5sZW5ndGggKz0gMTtcbn1cblxuRExMLnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24obm9kZSkge1xuICAgIGlmICh0aGlzLmhlYWQpIHRoaXMuaW5zZXJ0QmVmb3JlKHRoaXMuaGVhZCwgbm9kZSk7XG4gICAgZWxzZSBzZXRJbml0aWFsKHRoaXMsIG5vZGUpO1xufTtcblxuRExMLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24obm9kZSkge1xuICAgIGlmICh0aGlzLnRhaWwpIHRoaXMuaW5zZXJ0QWZ0ZXIodGhpcy50YWlsLCBub2RlKTtcbiAgICBlbHNlIHNldEluaXRpYWwodGhpcywgbm9kZSk7XG59O1xuXG5ETEwucHJvdG90eXBlLnNoaWZ0ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuaGVhZCAmJiB0aGlzLnJlbW92ZUxpbmsodGhpcy5oZWFkKTtcbn07XG5cbkRMTC5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudGFpbCAmJiB0aGlzLnJlbW92ZUxpbmsodGhpcy50YWlsKTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vLi4vLi4vLi4vfi9hc3luYy1lcy9pbnRlcm5hbC9Eb3VibHlMaW5rZWRMaXN0LmpzIiwiaW1wb3J0IGVhY2hPZkxpbWl0IGZyb20gJy4vZWFjaE9mTGltaXQnO1xuaW1wb3J0IGRvTGltaXQgZnJvbSAnLi9pbnRlcm5hbC9kb0xpbWl0JztcblxuLyoqXG4gKiBUaGUgc2FtZSBhcyBbYGVhY2hPZmBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5lYWNoT2Z9IGJ1dCBydW5zIG9ubHkgYSBzaW5nbGUgYXN5bmMgb3BlcmF0aW9uIGF0IGEgdGltZS5cbiAqXG4gKiBAbmFtZSBlYWNoT2ZTZXJpZXNcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLmVhY2hPZl17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmVhY2hPZn1cbiAqIEBhbGlhcyBmb3JFYWNoT2ZTZXJpZXNcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEEgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluIGBjb2xsYC4gVGhlXG4gKiBga2V5YCBpcyB0aGUgaXRlbSdzIGtleSwgb3IgaW5kZXggaW4gdGhlIGNhc2Ugb2YgYW4gYXJyYXkuIFRoZSBpdGVyYXRlZSBpc1xuICogcGFzc2VkIGEgYGNhbGxiYWNrKGVycilgIHdoaWNoIG11c3QgYmUgY2FsbGVkIG9uY2UgaXQgaGFzIGNvbXBsZXRlZC4gSWYgbm9cbiAqIGVycm9yIGhhcyBvY2N1cnJlZCwgdGhlIGNhbGxiYWNrIHNob3VsZCBiZSBydW4gd2l0aG91dCBhcmd1bWVudHMgb3Igd2l0aCBhblxuICogZXhwbGljaXQgYG51bGxgIGFyZ3VtZW50LiBJbnZva2VkIHdpdGggKGl0ZW0sIGtleSwgY2FsbGJhY2spLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIHdoZW4gYWxsIGBpdGVyYXRlZWBcbiAqIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLCBvciBhbiBlcnJvciBvY2N1cnMuIEludm9rZWQgd2l0aCAoZXJyKS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZG9MaW1pdChlYWNoT2ZMaW1pdCwgMSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vLi4vLi4vLi4vfi9hc3luYy1lcy9lYWNoT2ZTZXJpZXMuanMiLCJpbXBvcnQgZWFjaE9mU2VyaWVzIGZyb20gJy4vZWFjaE9mU2VyaWVzJztcbmltcG9ydCBub29wIGZyb20gJ2xvZGFzaC1lcy9ub29wJztcbmltcG9ydCBvbmNlIGZyb20gJy4vaW50ZXJuYWwvb25jZSc7XG5cbi8qKlxuICogUmVkdWNlcyBgY29sbGAgaW50byBhIHNpbmdsZSB2YWx1ZSB1c2luZyBhbiBhc3luYyBgaXRlcmF0ZWVgIHRvIHJldHVybiBlYWNoXG4gKiBzdWNjZXNzaXZlIHN0ZXAuIGBtZW1vYCBpcyB0aGUgaW5pdGlhbCBzdGF0ZSBvZiB0aGUgcmVkdWN0aW9uLiBUaGlzIGZ1bmN0aW9uXG4gKiBvbmx5IG9wZXJhdGVzIGluIHNlcmllcy5cbiAqXG4gKiBGb3IgcGVyZm9ybWFuY2UgcmVhc29ucywgaXQgbWF5IG1ha2Ugc2Vuc2UgdG8gc3BsaXQgYSBjYWxsIHRvIHRoaXMgZnVuY3Rpb25cbiAqIGludG8gYSBwYXJhbGxlbCBtYXAsIGFuZCB0aGVuIHVzZSB0aGUgbm9ybWFsIGBBcnJheS5wcm90b3R5cGUucmVkdWNlYCBvbiB0aGVcbiAqIHJlc3VsdHMuIFRoaXMgZnVuY3Rpb24gaXMgZm9yIHNpdHVhdGlvbnMgd2hlcmUgZWFjaCBzdGVwIGluIHRoZSByZWR1Y3Rpb25cbiAqIG5lZWRzIHRvIGJlIGFzeW5jOyBpZiB5b3UgY2FuIGdldCB0aGUgZGF0YSBiZWZvcmUgcmVkdWNpbmcgaXQsIHRoZW4gaXQnc1xuICogcHJvYmFibHkgYSBnb29kIGlkZWEgdG8gZG8gc28uXG4gKlxuICogQG5hbWUgcmVkdWNlXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAYWxpYXMgaW5qZWN0XG4gKiBAYWxpYXMgZm9sZGxcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0geyp9IG1lbW8gLSBUaGUgaW5pdGlhbCBzdGF0ZSBvZiB0aGUgcmVkdWN0aW9uLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBIGZ1bmN0aW9uIGFwcGxpZWQgdG8gZWFjaCBpdGVtIGluIHRoZVxuICogYXJyYXkgdG8gcHJvZHVjZSB0aGUgbmV4dCBzdGVwIGluIHRoZSByZWR1Y3Rpb24uIFRoZSBgaXRlcmF0ZWVgIGlzIHBhc3NlZCBhXG4gKiBgY2FsbGJhY2soZXJyLCByZWR1Y3Rpb24pYCB3aGljaCBhY2NlcHRzIGFuIG9wdGlvbmFsIGVycm9yIGFzIGl0cyBmaXJzdFxuICogYXJndW1lbnQsIGFuZCB0aGUgc3RhdGUgb2YgdGhlIHJlZHVjdGlvbiBhcyB0aGUgc2Vjb25kLiBJZiBhbiBlcnJvciBpc1xuICogcGFzc2VkIHRvIHRoZSBjYWxsYmFjaywgdGhlIHJlZHVjdGlvbiBpcyBzdG9wcGVkIGFuZCB0aGUgbWFpbiBgY2FsbGJhY2tgIGlzXG4gKiBpbW1lZGlhdGVseSBjYWxsZWQgd2l0aCB0aGUgZXJyb3IuIEludm9rZWQgd2l0aCAobWVtbywgaXRlbSwgY2FsbGJhY2spLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFmdGVyIGFsbCB0aGVcbiAqIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQuIFJlc3VsdCBpcyB0aGUgcmVkdWNlZCB2YWx1ZS4gSW52b2tlZCB3aXRoXG4gKiAoZXJyLCByZXN1bHQpLlxuICogQGV4YW1wbGVcbiAqXG4gKiBhc3luYy5yZWR1Y2UoWzEsMiwzXSwgMCwgZnVuY3Rpb24obWVtbywgaXRlbSwgY2FsbGJhY2spIHtcbiAqICAgICAvLyBwb2ludGxlc3MgYXN5bmM6XG4gKiAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgbWVtbyArIGl0ZW0pXG4gKiAgICAgfSk7XG4gKiB9LCBmdW5jdGlvbihlcnIsIHJlc3VsdCkge1xuICogICAgIC8vIHJlc3VsdCBpcyBub3cgZXF1YWwgdG8gdGhlIGxhc3QgdmFsdWUgb2YgbWVtbywgd2hpY2ggaXMgNlxuICogfSk7XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJlZHVjZShjb2xsLCBtZW1vLCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IG9uY2UoY2FsbGJhY2sgfHwgbm9vcCk7XG4gICAgZWFjaE9mU2VyaWVzKGNvbGwsIGZ1bmN0aW9uKHgsIGksIGNhbGxiYWNrKSB7XG4gICAgICAgIGl0ZXJhdGVlKG1lbW8sIHgsIGZ1bmN0aW9uKGVyciwgdikge1xuICAgICAgICAgICAgbWVtbyA9IHY7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICB9KTtcbiAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgY2FsbGJhY2soZXJyLCBtZW1vKTtcbiAgICB9KTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi8uLi8uLi8uLi9+L2FzeW5jLWVzL3JlZHVjZS5qcyIsImltcG9ydCBub29wIGZyb20gJ2xvZGFzaC1lcy9ub29wJztcbmltcG9ydCByZXN0IGZyb20gJy4vaW50ZXJuYWwvcmVzdCc7XG5pbXBvcnQgcmVkdWNlIGZyb20gJy4vcmVkdWNlJztcblxuLyoqXG4gKiBWZXJzaW9uIG9mIHRoZSBjb21wb3NlIGZ1bmN0aW9uIHRoYXQgaXMgbW9yZSBuYXR1cmFsIHRvIHJlYWQuIEVhY2ggZnVuY3Rpb25cbiAqIGNvbnN1bWVzIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIHByZXZpb3VzIGZ1bmN0aW9uLiBJdCBpcyB0aGUgZXF1aXZhbGVudCBvZlxuICogW2NvbXBvc2Vde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy5jb21wb3NlfSB3aXRoIHRoZSBhcmd1bWVudHMgcmV2ZXJzZWQuXG4gKlxuICogRWFjaCBmdW5jdGlvbiBpcyBleGVjdXRlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgY29tcG9zZWQgZnVuY3Rpb24uXG4gKlxuICogQG5hbWUgc2VxXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93XG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5jb21wb3NlXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cuY29tcG9zZX1cbiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3dcbiAqIEBwYXJhbSB7Li4uRnVuY3Rpb259IGZ1bmN0aW9ucyAtIHRoZSBhc3luY2hyb25vdXMgZnVuY3Rpb25zIHRvIGNvbXBvc2VcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gYSBmdW5jdGlvbiB0aGF0IGNvbXBvc2VzIHRoZSBgZnVuY3Rpb25zYCBpbiBvcmRlclxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBSZXF1aXJlcyBsb2Rhc2ggKG9yIHVuZGVyc2NvcmUpLCBleHByZXNzMyBhbmQgZHJlc2VuZGUncyBvcm0yLlxuICogLy8gUGFydCBvZiBhbiBhcHAsIHRoYXQgZmV0Y2hlcyBjYXRzIG9mIHRoZSBsb2dnZWQgdXNlci5cbiAqIC8vIFRoaXMgZXhhbXBsZSB1c2VzIGBzZXFgIGZ1bmN0aW9uIHRvIGF2b2lkIG92ZXJuZXN0aW5nIGFuZCBlcnJvclxuICogLy8gaGFuZGxpbmcgY2x1dHRlci5cbiAqIGFwcC5nZXQoJy9jYXRzJywgZnVuY3Rpb24ocmVxdWVzdCwgcmVzcG9uc2UpIHtcbiAqICAgICB2YXIgVXNlciA9IHJlcXVlc3QubW9kZWxzLlVzZXI7XG4gKiAgICAgYXN5bmMuc2VxKFxuICogICAgICAgICBfLmJpbmQoVXNlci5nZXQsIFVzZXIpLCAgLy8gJ1VzZXIuZ2V0JyBoYXMgc2lnbmF0dXJlIChpZCwgY2FsbGJhY2soZXJyLCBkYXRhKSlcbiAqICAgICAgICAgZnVuY3Rpb24odXNlciwgZm4pIHtcbiAqICAgICAgICAgICAgIHVzZXIuZ2V0Q2F0cyhmbik7ICAgICAgLy8gJ2dldENhdHMnIGhhcyBzaWduYXR1cmUgKGNhbGxiYWNrKGVyciwgZGF0YSkpXG4gKiAgICAgICAgIH1cbiAqICAgICApKHJlcS5zZXNzaW9uLnVzZXJfaWQsIGZ1bmN0aW9uIChlcnIsIGNhdHMpIHtcbiAqICAgICAgICAgaWYgKGVycikge1xuICogICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICogICAgICAgICAgICAgcmVzcG9uc2UuanNvbih7IHN0YXR1czogJ2Vycm9yJywgbWVzc2FnZTogZXJyLm1lc3NhZ2UgfSk7XG4gKiAgICAgICAgIH0gZWxzZSB7XG4gKiAgICAgICAgICAgICByZXNwb25zZS5qc29uKHsgc3RhdHVzOiAnb2snLCBtZXNzYWdlOiAnQ2F0cyBmb3VuZCcsIGRhdGE6IGNhdHMgfSk7XG4gKiAgICAgICAgIH1cbiAqICAgICB9KTtcbiAqIH0pO1xuICovXG5leHBvcnQgZGVmYXVsdCByZXN0KGZ1bmN0aW9uIHNlcShmdW5jdGlvbnMpIHtcbiAgICByZXR1cm4gcmVzdChmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgICAgICB2YXIgY2IgPSBhcmdzW2FyZ3MubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmICh0eXBlb2YgY2IgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgYXJncy5wb3AoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNiID0gbm9vcDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlZHVjZShmdW5jdGlvbnMsIGFyZ3MsIGZ1bmN0aW9uKG5ld2FyZ3MsIGZuLCBjYikge1xuICAgICAgICAgICAgZm4uYXBwbHkodGhhdCwgbmV3YXJncy5jb25jYXQocmVzdChmdW5jdGlvbihlcnIsIG5leHRhcmdzKSB7XG4gICAgICAgICAgICAgICAgY2IoZXJyLCBuZXh0YXJncyk7XG4gICAgICAgICAgICB9KSkpO1xuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHtcbiAgICAgICAgICAgIGNiLmFwcGx5KHRoYXQsIFtlcnJdLmNvbmNhdChyZXN1bHRzKSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufSlcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi8uLi8uLi8uLi9+L2FzeW5jLWVzL3NlcS5qcyIsImltcG9ydCBzZXEgZnJvbSAnLi9zZXEnO1xuaW1wb3J0IHJlc3QgZnJvbSAnLi9pbnRlcm5hbC9yZXN0JztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gd2hpY2ggaXMgYSBjb21wb3NpdGlvbiBvZiB0aGUgcGFzc2VkIGFzeW5jaHJvbm91c1xuICogZnVuY3Rpb25zLiBFYWNoIGZ1bmN0aW9uIGNvbnN1bWVzIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGZ1bmN0aW9uIHRoYXRcbiAqIGZvbGxvd3MuIENvbXBvc2luZyBmdW5jdGlvbnMgYGYoKWAsIGBnKClgLCBhbmQgYGgoKWAgd291bGQgcHJvZHVjZSB0aGUgcmVzdWx0XG4gKiBvZiBgZihnKGgoKSkpYCwgb25seSB0aGlzIHZlcnNpb24gdXNlcyBjYWxsYmFja3MgdG8gb2J0YWluIHRoZSByZXR1cm4gdmFsdWVzLlxuICpcbiAqIEVhY2ggZnVuY3Rpb24gaXMgZXhlY3V0ZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIGNvbXBvc2VkIGZ1bmN0aW9uLlxuICpcbiAqIEBuYW1lIGNvbXBvc2VcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3dcbiAqIEBtZXRob2RcbiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3dcbiAqIEBwYXJhbSB7Li4uRnVuY3Rpb259IGZ1bmN0aW9ucyAtIHRoZSBhc3luY2hyb25vdXMgZnVuY3Rpb25zIHRvIGNvbXBvc2VcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gYW4gYXN5bmNocm9ub3VzIGZ1bmN0aW9uIHRoYXQgaXMgdGhlIGNvbXBvc2VkXG4gKiBhc3luY2hyb25vdXMgYGZ1bmN0aW9uc2BcbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gYWRkMShuLCBjYWxsYmFjaykge1xuICogICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICogICAgICAgICBjYWxsYmFjayhudWxsLCBuICsgMSk7XG4gKiAgICAgfSwgMTApO1xuICogfVxuICpcbiAqIGZ1bmN0aW9uIG11bDMobiwgY2FsbGJhY2spIHtcbiAqICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgbiAqIDMpO1xuICogICAgIH0sIDEwKTtcbiAqIH1cbiAqXG4gKiB2YXIgYWRkMW11bDMgPSBhc3luYy5jb21wb3NlKG11bDMsIGFkZDEpO1xuICogYWRkMW11bDMoNCwgZnVuY3Rpb24gKGVyciwgcmVzdWx0KSB7XG4gKiAgICAgLy8gcmVzdWx0IG5vdyBlcXVhbHMgMTVcbiAqIH0pO1xuICovXG5leHBvcnQgZGVmYXVsdCByZXN0KGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICByZXR1cm4gc2VxLmFwcGx5KG51bGwsIGFyZ3MucmV2ZXJzZSgpKTtcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uLy4uLy4uLy4uL34vYXN5bmMtZXMvY29tcG9zZS5qcyIsImltcG9ydCBjb25jYXQgZnJvbSAnLi9pbnRlcm5hbC9jb25jYXQnO1xuaW1wb3J0IGRvUGFyYWxsZWwgZnJvbSAnLi9pbnRlcm5hbC9kb1BhcmFsbGVsJztcblxuLyoqXG4gKiBBcHBsaWVzIGBpdGVyYXRlZWAgdG8gZWFjaCBpdGVtIGluIGBjb2xsYCwgY29uY2F0ZW5hdGluZyB0aGUgcmVzdWx0cy4gUmV0dXJuc1xuICogdGhlIGNvbmNhdGVuYXRlZCBsaXN0LiBUaGUgYGl0ZXJhdGVlYHMgYXJlIGNhbGxlZCBpbiBwYXJhbGxlbCwgYW5kIHRoZVxuICogcmVzdWx0cyBhcmUgY29uY2F0ZW5hdGVkIGFzIHRoZXkgcmV0dXJuLiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCB0aGVcbiAqIHJlc3VsdHMgYXJyYXkgd2lsbCBiZSByZXR1cm5lZCBpbiB0aGUgb3JpZ2luYWwgb3JkZXIgb2YgYGNvbGxgIHBhc3NlZCB0byB0aGVcbiAqIGBpdGVyYXRlZWAgZnVuY3Rpb24uXG4gKlxuICogQG5hbWUgY29uY2F0XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2ggaXRlbSBpbiBgY29sbGAuXG4gKiBUaGUgaXRlcmF0ZWUgaXMgcGFzc2VkIGEgYGNhbGxiYWNrKGVyciwgcmVzdWx0cylgIHdoaWNoIG11c3QgYmUgY2FsbGVkIG9uY2VcbiAqIGl0IGhhcyBjb21wbGV0ZWQgd2l0aCBhbiBlcnJvciAod2hpY2ggY2FuIGJlIGBudWxsYCkgYW5kIGFuIGFycmF5IG9mIHJlc3VsdHMuXG4gKiBJbnZva2VkIHdpdGggKGl0ZW0sIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFjayhlcnIpXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFmdGVyIGFsbCB0aGVcbiAqIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQsIG9yIGFuIGVycm9yIG9jY3Vycy4gUmVzdWx0cyBpcyBhbiBhcnJheVxuICogY29udGFpbmluZyB0aGUgY29uY2F0ZW5hdGVkIHJlc3VsdHMgb2YgdGhlIGBpdGVyYXRlZWAgZnVuY3Rpb24uIEludm9rZWQgd2l0aFxuICogKGVyciwgcmVzdWx0cykuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGFzeW5jLmNvbmNhdChbJ2RpcjEnLCdkaXIyJywnZGlyMyddLCBmcy5yZWFkZGlyLCBmdW5jdGlvbihlcnIsIGZpbGVzKSB7XG4gKiAgICAgLy8gZmlsZXMgaXMgbm93IGEgbGlzdCBvZiBmaWxlbmFtZXMgdGhhdCBleGlzdCBpbiB0aGUgMyBkaXJlY3Rvcmllc1xuICogfSk7XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGRvUGFyYWxsZWwoY29uY2F0KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi8uLi8uLi8uLi9+L2FzeW5jLWVzL2NvbmNhdC5qcyIsImltcG9ydCBjb25jYXQgZnJvbSAnLi9pbnRlcm5hbC9jb25jYXQnO1xuaW1wb3J0IGRvU2VyaWVzIGZyb20gJy4vaW50ZXJuYWwvZG9TZXJpZXMnO1xuXG4vKipcbiAqIFRoZSBzYW1lIGFzIFtgY29uY2F0YF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmNvbmNhdH0gYnV0IHJ1bnMgb25seSBhIHNpbmdsZSBhc3luYyBvcGVyYXRpb24gYXQgYSB0aW1lLlxuICpcbiAqIEBuYW1lIGNvbmNhdFNlcmllc1xuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICogQG1ldGhvZFxuICogQHNlZSBbYXN5bmMuY29uY2F0XXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuY29uY2F0fVxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIC0gQSBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoIGl0ZW0gaW4gYGNvbGxgLlxuICogVGhlIGl0ZXJhdGVlIGlzIHBhc3NlZCBhIGBjYWxsYmFjayhlcnIsIHJlc3VsdHMpYCB3aGljaCBtdXN0IGJlIGNhbGxlZCBvbmNlXG4gKiBpdCBoYXMgY29tcGxldGVkIHdpdGggYW4gZXJyb3IgKHdoaWNoIGNhbiBiZSBgbnVsbGApIGFuZCBhbiBhcnJheSBvZiByZXN1bHRzLlxuICogSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2soZXJyKV0gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhZnRlciBhbGwgdGhlXG4gKiBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLCBvciBhbiBlcnJvciBvY2N1cnMuIFJlc3VsdHMgaXMgYW4gYXJyYXlcbiAqIGNvbnRhaW5pbmcgdGhlIGNvbmNhdGVuYXRlZCByZXN1bHRzIG9mIHRoZSBgaXRlcmF0ZWVgIGZ1bmN0aW9uLiBJbnZva2VkIHdpdGhcbiAqIChlcnIsIHJlc3VsdHMpLlxuICovXG5leHBvcnQgZGVmYXVsdCBkb1Nlcmllcyhjb25jYXQpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uLy4uLy4uLy4uL34vYXN5bmMtZXMvY29uY2F0U2VyaWVzLmpzIiwiaW1wb3J0IHJlc3QgZnJvbSAnLi9pbnRlcm5hbC9yZXN0JztcbmltcG9ydCBpbml0aWFsUGFyYW1zIGZyb20gJy4vaW50ZXJuYWwvaW5pdGlhbFBhcmFtcyc7XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgd2hlbiBjYWxsZWQsIGNhbGxzLWJhY2sgd2l0aCB0aGUgdmFsdWVzIHByb3ZpZGVkLlxuICogVXNlZnVsIGFzIHRoZSBmaXJzdCBmdW5jdGlvbiBpbiBhIFtgd2F0ZXJmYWxsYF17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LndhdGVyZmFsbH0sIG9yIGZvciBwbHVnZ2luZyB2YWx1ZXMgaW4gdG9cbiAqIFtgYXV0b2Bde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy5hdXRvfS5cbiAqXG4gKiBAbmFtZSBjb25zdGFudFxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpVdGlsc1xuICogQG1ldGhvZFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Li4uKn0gYXJndW1lbnRzLi4uIC0gQW55IG51bWJlciBvZiBhcmd1bWVudHMgdG8gYXV0b21hdGljYWxseSBpbnZva2VcbiAqIGNhbGxiYWNrIHdpdGguXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdoZW4gaW52b2tlZCwgYXV0b21hdGljYWxseVxuICogaW52b2tlcyB0aGUgY2FsbGJhY2sgd2l0aCB0aGUgcHJldmlvdXMgZ2l2ZW4gYXJndW1lbnRzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBhc3luYy53YXRlcmZhbGwoW1xuICogICAgIGFzeW5jLmNvbnN0YW50KDQyKSxcbiAqICAgICBmdW5jdGlvbiAodmFsdWUsIG5leHQpIHtcbiAqICAgICAgICAgLy8gdmFsdWUgPT09IDQyXG4gKiAgICAgfSxcbiAqICAgICAvLy4uLlxuICogXSwgY2FsbGJhY2spO1xuICpcbiAqIGFzeW5jLndhdGVyZmFsbChbXG4gKiAgICAgYXN5bmMuY29uc3RhbnQoZmlsZW5hbWUsIFwidXRmOFwiKSxcbiAqICAgICBmcy5yZWFkRmlsZSxcbiAqICAgICBmdW5jdGlvbiAoZmlsZURhdGEsIG5leHQpIHtcbiAqICAgICAgICAgLy8uLi5cbiAqICAgICB9XG4gKiAgICAgLy8uLi5cbiAqIF0sIGNhbGxiYWNrKTtcbiAqXG4gKiBhc3luYy5hdXRvKHtcbiAqICAgICBob3N0bmFtZTogYXN5bmMuY29uc3RhbnQoXCJodHRwczovL3NlcnZlci5uZXQvXCIpLFxuICogICAgIHBvcnQ6IGZpbmRGcmVlUG9ydCxcbiAqICAgICBsYXVuY2hTZXJ2ZXI6IFtcImhvc3RuYW1lXCIsIFwicG9ydFwiLCBmdW5jdGlvbiAob3B0aW9ucywgY2IpIHtcbiAqICAgICAgICAgc3RhcnRTZXJ2ZXIob3B0aW9ucywgY2IpO1xuICogICAgIH1dLFxuICogICAgIC8vLi4uXG4gKiB9LCBjYWxsYmFjayk7XG4gKi9cbmV4cG9ydCBkZWZhdWx0IHJlc3QoZnVuY3Rpb24odmFsdWVzKSB7XG4gICAgdmFyIGFyZ3MgPSBbbnVsbF0uY29uY2F0KHZhbHVlcyk7XG4gICAgcmV0dXJuIGluaXRpYWxQYXJhbXMoZnVuY3Rpb24gKGlnbm9yZWRBcmdzLCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkodGhpcywgYXJncyk7XG4gICAgfSk7XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi8uLi8uLi8uLi9+L2FzeW5jLWVzL2NvbnN0YW50LmpzIiwiaW1wb3J0IGlkZW50aXR5IGZyb20gJ2xvZGFzaC1lcy9pZGVudGl0eSc7XG5cbmltcG9ydCBjcmVhdGVUZXN0ZXIgZnJvbSAnLi9pbnRlcm5hbC9jcmVhdGVUZXN0ZXInO1xuaW1wb3J0IGRvUGFyYWxsZWwgZnJvbSAnLi9pbnRlcm5hbC9kb1BhcmFsbGVsJztcbmltcG9ydCBmaW5kR2V0UmVzdWx0IGZyb20gJy4vaW50ZXJuYWwvZmluZEdldFJlc3VsdCc7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZmlyc3QgdmFsdWUgaW4gYGNvbGxgIHRoYXQgcGFzc2VzIGFuIGFzeW5jIHRydXRoIHRlc3QuIFRoZVxuICogYGl0ZXJhdGVlYCBpcyBhcHBsaWVkIGluIHBhcmFsbGVsLCBtZWFuaW5nIHRoZSBmaXJzdCBpdGVyYXRlZSB0byByZXR1cm5cbiAqIGB0cnVlYCB3aWxsIGZpcmUgdGhlIGRldGVjdCBgY2FsbGJhY2tgIHdpdGggdGhhdCByZXN1bHQuIFRoYXQgbWVhbnMgdGhlXG4gKiByZXN1bHQgbWlnaHQgbm90IGJlIHRoZSBmaXJzdCBpdGVtIGluIHRoZSBvcmlnaW5hbCBgY29sbGAgKGluIHRlcm1zIG9mIG9yZGVyKVxuICogdGhhdCBwYXNzZXMgdGhlIHRlc3QuXG5cbiAqIElmIG9yZGVyIHdpdGhpbiB0aGUgb3JpZ2luYWwgYGNvbGxgIGlzIGltcG9ydGFudCwgdGhlbiBsb29rIGF0XG4gKiBbYGRldGVjdFNlcmllc2Bde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5kZXRlY3RTZXJpZXN9LlxuICpcbiAqIEBuYW1lIGRldGVjdFxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICogQG1ldGhvZFxuICogQGFsaWFzIGZpbmRcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBIHRydXRoIHRlc3QgdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluIGBjb2xsYC5cbiAqIFRoZSBpdGVyYXRlZSBpcyBwYXNzZWQgYSBgY2FsbGJhY2soZXJyLCB0cnV0aFZhbHVlKWAgd2hpY2ggbXVzdCBiZSBjYWxsZWRcbiAqIHdpdGggYSBib29sZWFuIGFyZ3VtZW50IG9uY2UgaXQgaGFzIGNvbXBsZXRlZC4gSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYXMgc29vbiBhcyBhbnlcbiAqIGl0ZXJhdGVlIHJldHVybnMgYHRydWVgLCBvciBhZnRlciBhbGwgdGhlIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQuXG4gKiBSZXN1bHQgd2lsbCBiZSB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgYXJyYXkgdGhhdCBwYXNzZXMgdGhlIHRydXRoIHRlc3RcbiAqIChpdGVyYXRlZSkgb3IgdGhlIHZhbHVlIGB1bmRlZmluZWRgIGlmIG5vbmUgcGFzc2VkLiBJbnZva2VkIHdpdGhcbiAqIChlcnIsIHJlc3VsdCkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGFzeW5jLmRldGVjdChbJ2ZpbGUxJywnZmlsZTInLCdmaWxlMyddLCBmdW5jdGlvbihmaWxlUGF0aCwgY2FsbGJhY2spIHtcbiAqICAgICBmcy5hY2Nlc3MoZmlsZVBhdGgsIGZ1bmN0aW9uKGVycikge1xuICogICAgICAgICBjYWxsYmFjayhudWxsLCAhZXJyKVxuICogICAgIH0pO1xuICogfSwgZnVuY3Rpb24oZXJyLCByZXN1bHQpIHtcbiAqICAgICAvLyByZXN1bHQgbm93IGVxdWFscyB0aGUgZmlyc3QgZmlsZSBpbiB0aGUgbGlzdCB0aGF0IGV4aXN0c1xuICogfSk7XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGRvUGFyYWxsZWwoY3JlYXRlVGVzdGVyKGlkZW50aXR5LCBmaW5kR2V0UmVzdWx0KSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vLi4vLi4vLi4vfi9hc3luYy1lcy9kZXRlY3QuanMiLCJpbXBvcnQgaWRlbnRpdHkgZnJvbSAnbG9kYXNoLWVzL2lkZW50aXR5JztcblxuaW1wb3J0IGNyZWF0ZVRlc3RlciBmcm9tICcuL2ludGVybmFsL2NyZWF0ZVRlc3Rlcic7XG5pbXBvcnQgZG9QYXJhbGxlbExpbWl0IGZyb20gJy4vaW50ZXJuYWwvZG9QYXJhbGxlbExpbWl0JztcbmltcG9ydCBmaW5kR2V0UmVzdWx0IGZyb20gJy4vaW50ZXJuYWwvZmluZEdldFJlc3VsdCc7XG5cbi8qKlxuICogVGhlIHNhbWUgYXMgW2BkZXRlY3RgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZGV0ZWN0fSBidXQgcnVucyBhIG1heGltdW0gb2YgYGxpbWl0YCBhc3luYyBvcGVyYXRpb25zIGF0IGFcbiAqIHRpbWUuXG4gKlxuICogQG5hbWUgZGV0ZWN0TGltaXRcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLmRldGVjdF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmRldGVjdH1cbiAqIEBhbGlhcyBmaW5kTGltaXRcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBIHRydXRoIHRlc3QgdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluIGBjb2xsYC5cbiAqIFRoZSBpdGVyYXRlZSBpcyBwYXNzZWQgYSBgY2FsbGJhY2soZXJyLCB0cnV0aFZhbHVlKWAgd2hpY2ggbXVzdCBiZSBjYWxsZWRcbiAqIHdpdGggYSBib29sZWFuIGFyZ3VtZW50IG9uY2UgaXQgaGFzIGNvbXBsZXRlZC4gSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYXMgc29vbiBhcyBhbnlcbiAqIGl0ZXJhdGVlIHJldHVybnMgYHRydWVgLCBvciBhZnRlciBhbGwgdGhlIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQuXG4gKiBSZXN1bHQgd2lsbCBiZSB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgYXJyYXkgdGhhdCBwYXNzZXMgdGhlIHRydXRoIHRlc3RcbiAqIChpdGVyYXRlZSkgb3IgdGhlIHZhbHVlIGB1bmRlZmluZWRgIGlmIG5vbmUgcGFzc2VkLiBJbnZva2VkIHdpdGhcbiAqIChlcnIsIHJlc3VsdCkuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGRvUGFyYWxsZWxMaW1pdChjcmVhdGVUZXN0ZXIoaWRlbnRpdHksIGZpbmRHZXRSZXN1bHQpKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi8uLi8uLi8uLi9+L2FzeW5jLWVzL2RldGVjdExpbWl0LmpzIiwiaW1wb3J0IGRldGVjdExpbWl0IGZyb20gJy4vZGV0ZWN0TGltaXQnO1xuaW1wb3J0IGRvTGltaXQgZnJvbSAnLi9pbnRlcm5hbC9kb0xpbWl0JztcblxuLyoqXG4gKiBUaGUgc2FtZSBhcyBbYGRldGVjdGBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5kZXRlY3R9IGJ1dCBydW5zIG9ubHkgYSBzaW5nbGUgYXN5bmMgb3BlcmF0aW9uIGF0IGEgdGltZS5cbiAqXG4gKiBAbmFtZSBkZXRlY3RTZXJpZXNcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLmRldGVjdF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmRldGVjdH1cbiAqIEBhbGlhcyBmaW5kU2VyaWVzXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIC0gQSB0cnV0aCB0ZXN0IHRvIGFwcGx5IHRvIGVhY2ggaXRlbSBpbiBgY29sbGAuXG4gKiBUaGUgaXRlcmF0ZWUgaXMgcGFzc2VkIGEgYGNhbGxiYWNrKGVyciwgdHJ1dGhWYWx1ZSlgIHdoaWNoIG11c3QgYmUgY2FsbGVkXG4gKiB3aXRoIGEgYm9vbGVhbiBhcmd1bWVudCBvbmNlIGl0IGhhcyBjb21wbGV0ZWQuIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFzIHNvb24gYXMgYW55XG4gKiBpdGVyYXRlZSByZXR1cm5zIGB0cnVlYCwgb3IgYWZ0ZXIgYWxsIHRoZSBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLlxuICogUmVzdWx0IHdpbGwgYmUgdGhlIGZpcnN0IGl0ZW0gaW4gdGhlIGFycmF5IHRoYXQgcGFzc2VzIHRoZSB0cnV0aCB0ZXN0XG4gKiAoaXRlcmF0ZWUpIG9yIHRoZSB2YWx1ZSBgdW5kZWZpbmVkYCBpZiBub25lIHBhc3NlZC4gSW52b2tlZCB3aXRoXG4gKiAoZXJyLCByZXN1bHQpLlxuICovXG5leHBvcnQgZGVmYXVsdCBkb0xpbWl0KGRldGVjdExpbWl0LCAxKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi8uLi8uLi8uLi9+L2FzeW5jLWVzL2RldGVjdFNlcmllcy5qcyIsImltcG9ydCBhcnJheUVhY2ggZnJvbSAnbG9kYXNoLWVzL19hcnJheUVhY2gnO1xuaW1wb3J0IHJlc3QgZnJvbSAnLi9yZXN0JztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29uc29sZUZ1bmMobmFtZSkge1xuICAgIHJldHVybiByZXN0KGZ1bmN0aW9uIChmbiwgYXJncykge1xuICAgICAgICBmbi5hcHBseShudWxsLCBhcmdzLmNvbmNhdChyZXN0KGZ1bmN0aW9uIChlcnIsIGFyZ3MpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb25zb2xlLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY29uc29sZVtuYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICBhcnJheUVhY2goYXJncywgZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGVbbmFtZV0oeCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpKTtcbiAgICB9KTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi8uLi8uLi8uLi9+L2FzeW5jLWVzL2ludGVybmFsL2NvbnNvbGVGdW5jLmpzIiwiaW1wb3J0IGNvbnNvbGVGdW5jIGZyb20gJy4vaW50ZXJuYWwvY29uc29sZUZ1bmMnO1xuXG4vKipcbiAqIExvZ3MgdGhlIHJlc3VsdCBvZiBhbiBgYXN5bmNgIGZ1bmN0aW9uIHRvIHRoZSBgY29uc29sZWAgdXNpbmcgYGNvbnNvbGUuZGlyYFxuICogdG8gZGlzcGxheSB0aGUgcHJvcGVydGllcyBvZiB0aGUgcmVzdWx0aW5nIG9iamVjdC4gT25seSB3b3JrcyBpbiBOb2RlLmpzIG9yXG4gKiBpbiBicm93c2VycyB0aGF0IHN1cHBvcnQgYGNvbnNvbGUuZGlyYCBhbmQgYGNvbnNvbGUuZXJyb3JgIChzdWNoIGFzIEZGIGFuZFxuICogQ2hyb21lKS4gSWYgbXVsdGlwbGUgYXJndW1lbnRzIGFyZSByZXR1cm5lZCBmcm9tIHRoZSBhc3luYyBmdW5jdGlvbixcbiAqIGBjb25zb2xlLmRpcmAgaXMgY2FsbGVkIG9uIGVhY2ggYXJndW1lbnQgaW4gb3JkZXIuXG4gKlxuICogQG5hbWUgZGlyXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOlV0aWxzXG4gKiBAbWV0aG9kXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuY3Rpb24gLSBUaGUgZnVuY3Rpb24geW91IHdhbnQgdG8gZXZlbnR1YWxseSBhcHBseSBhbGxcbiAqIGFyZ3VtZW50cyB0by5cbiAqIEBwYXJhbSB7Li4uKn0gYXJndW1lbnRzLi4uIC0gQW55IG51bWJlciBvZiBhcmd1bWVudHMgdG8gYXBwbHkgdG8gdGhlIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBpbiBhIG1vZHVsZVxuICogdmFyIGhlbGxvID0gZnVuY3Rpb24obmFtZSwgY2FsbGJhY2spIHtcbiAqICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICogICAgICAgICBjYWxsYmFjayhudWxsLCB7aGVsbG86IG5hbWV9KTtcbiAqICAgICB9LCAxMDAwKTtcbiAqIH07XG4gKlxuICogLy8gaW4gdGhlIG5vZGUgcmVwbFxuICogbm9kZT4gYXN5bmMuZGlyKGhlbGxvLCAnd29ybGQnKTtcbiAqIHtoZWxsbzogJ3dvcmxkJ31cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY29uc29sZUZ1bmMoJ2RpcicpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uLy4uLy4uLy4uL34vYXN5bmMtZXMvZGlyLmpzIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX3dpdGhvdXRJbmRleChpdGVyYXRlZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUsIGluZGV4LCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gaXRlcmF0ZWUodmFsdWUsIGNhbGxiYWNrKTtcbiAgICB9O1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uLy4uLy4uLy4uL34vYXN5bmMtZXMvaW50ZXJuYWwvd2l0aG91dEluZGV4LmpzIiwiaW1wb3J0IGVhY2hPZiBmcm9tICcuL2VhY2hPZic7XG5pbXBvcnQgd2l0aG91dEluZGV4IGZyb20gJy4vaW50ZXJuYWwvd2l0aG91dEluZGV4JztcblxuLyoqXG4gKiBBcHBsaWVzIHRoZSBmdW5jdGlvbiBgaXRlcmF0ZWVgIHRvIGVhY2ggaXRlbSBpbiBgY29sbGAsIGluIHBhcmFsbGVsLlxuICogVGhlIGBpdGVyYXRlZWAgaXMgY2FsbGVkIHdpdGggYW4gaXRlbSBmcm9tIHRoZSBsaXN0LCBhbmQgYSBjYWxsYmFjayBmb3Igd2hlblxuICogaXQgaGFzIGZpbmlzaGVkLiBJZiB0aGUgYGl0ZXJhdGVlYCBwYXNzZXMgYW4gZXJyb3IgdG8gaXRzIGBjYWxsYmFja2AsIHRoZVxuICogbWFpbiBgY2FsbGJhY2tgIChmb3IgdGhlIGBlYWNoYCBmdW5jdGlvbikgaXMgaW1tZWRpYXRlbHkgY2FsbGVkIHdpdGggdGhlXG4gKiBlcnJvci5cbiAqXG4gKiBOb3RlLCB0aGF0IHNpbmNlIHRoaXMgZnVuY3Rpb24gYXBwbGllcyBgaXRlcmF0ZWVgIHRvIGVhY2ggaXRlbSBpbiBwYXJhbGxlbCxcbiAqIHRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IHRoZSBpdGVyYXRlZSBmdW5jdGlvbnMgd2lsbCBjb21wbGV0ZSBpbiBvcmRlci5cbiAqXG4gKiBAbmFtZSBlYWNoXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAYWxpYXMgZm9yRWFjaFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIC0gQSBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoIGl0ZW1cbiAqIGluIGBjb2xsYC4gVGhlIGl0ZXJhdGVlIGlzIHBhc3NlZCBhIGBjYWxsYmFjayhlcnIpYCB3aGljaCBtdXN0IGJlIGNhbGxlZCBvbmNlXG4gKiBpdCBoYXMgY29tcGxldGVkLiBJZiBubyBlcnJvciBoYXMgb2NjdXJyZWQsIHRoZSBgY2FsbGJhY2tgIHNob3VsZCBiZSBydW5cbiAqIHdpdGhvdXQgYXJndW1lbnRzIG9yIHdpdGggYW4gZXhwbGljaXQgYG51bGxgIGFyZ3VtZW50LiBUaGUgYXJyYXkgaW5kZXggaXMgbm90XG4gKiBwYXNzZWQgdG8gdGhlIGl0ZXJhdGVlLiBJbnZva2VkIHdpdGggKGl0ZW0sIGNhbGxiYWNrKS4gSWYgeW91IG5lZWQgdGhlIGluZGV4LFxuICogdXNlIGBlYWNoT2ZgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIHdoZW4gYWxsXG4gKiBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLCBvciBhbiBlcnJvciBvY2N1cnMuIEludm9rZWQgd2l0aCAoZXJyKS5cbiAqIEBleGFtcGxlXG4gKlxuICogLy8gYXNzdW1pbmcgb3BlbkZpbGVzIGlzIGFuIGFycmF5IG9mIGZpbGUgbmFtZXMgYW5kIHNhdmVGaWxlIGlzIGEgZnVuY3Rpb25cbiAqIC8vIHRvIHNhdmUgdGhlIG1vZGlmaWVkIGNvbnRlbnRzIG9mIHRoYXQgZmlsZTpcbiAqXG4gKiBhc3luYy5lYWNoKG9wZW5GaWxlcywgc2F2ZUZpbGUsIGZ1bmN0aW9uKGVycil7XG4gKiAgIC8vIGlmIGFueSBvZiB0aGUgc2F2ZXMgcHJvZHVjZWQgYW4gZXJyb3IsIGVyciB3b3VsZCBlcXVhbCB0aGF0IGVycm9yXG4gKiB9KTtcbiAqXG4gKiAvLyBhc3N1bWluZyBvcGVuRmlsZXMgaXMgYW4gYXJyYXkgb2YgZmlsZSBuYW1lc1xuICogYXN5bmMuZWFjaChvcGVuRmlsZXMsIGZ1bmN0aW9uKGZpbGUsIGNhbGxiYWNrKSB7XG4gKlxuICogICAgIC8vIFBlcmZvcm0gb3BlcmF0aW9uIG9uIGZpbGUgaGVyZS5cbiAqICAgICBjb25zb2xlLmxvZygnUHJvY2Vzc2luZyBmaWxlICcgKyBmaWxlKTtcbiAqXG4gKiAgICAgaWYoIGZpbGUubGVuZ3RoID4gMzIgKSB7XG4gKiAgICAgICBjb25zb2xlLmxvZygnVGhpcyBmaWxlIG5hbWUgaXMgdG9vIGxvbmcnKTtcbiAqICAgICAgIGNhbGxiYWNrKCdGaWxlIG5hbWUgdG9vIGxvbmcnKTtcbiAqICAgICB9IGVsc2Uge1xuICogICAgICAgLy8gRG8gd29yayB0byBwcm9jZXNzIGZpbGUgaGVyZVxuICogICAgICAgY29uc29sZS5sb2coJ0ZpbGUgcHJvY2Vzc2VkJyk7XG4gKiAgICAgICBjYWxsYmFjaygpO1xuICogICAgIH1cbiAqIH0sIGZ1bmN0aW9uKGVycikge1xuICogICAgIC8vIGlmIGFueSBvZiB0aGUgZmlsZSBwcm9jZXNzaW5nIHByb2R1Y2VkIGFuIGVycm9yLCBlcnIgd291bGQgZXF1YWwgdGhhdCBlcnJvclxuICogICAgIGlmKCBlcnIgKSB7XG4gKiAgICAgICAvLyBPbmUgb2YgdGhlIGl0ZXJhdGlvbnMgcHJvZHVjZWQgYW4gZXJyb3IuXG4gKiAgICAgICAvLyBBbGwgcHJvY2Vzc2luZyB3aWxsIG5vdyBzdG9wLlxuICogICAgICAgY29uc29sZS5sb2coJ0EgZmlsZSBmYWlsZWQgdG8gcHJvY2VzcycpO1xuICogICAgIH0gZWxzZSB7XG4gKiAgICAgICBjb25zb2xlLmxvZygnQWxsIGZpbGVzIGhhdmUgYmVlbiBwcm9jZXNzZWQgc3VjY2Vzc2Z1bGx5Jyk7XG4gKiAgICAgfVxuICogfSk7XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGVhY2hMaW1pdChjb2xsLCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICBlYWNoT2YoY29sbCwgd2l0aG91dEluZGV4KGl0ZXJhdGVlKSwgY2FsbGJhY2spO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uLy4uLy4uLy4uL34vYXN5bmMtZXMvZWFjaC5qcyIsImltcG9ydCBlYWNoTGltaXQgZnJvbSAnLi9lYWNoTGltaXQnO1xuaW1wb3J0IGRvTGltaXQgZnJvbSAnLi9pbnRlcm5hbC9kb0xpbWl0JztcblxuLyoqXG4gKiBUaGUgc2FtZSBhcyBbYGVhY2hgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZWFjaH0gYnV0IHJ1bnMgb25seSBhIHNpbmdsZSBhc3luYyBvcGVyYXRpb24gYXQgYSB0aW1lLlxuICpcbiAqIEBuYW1lIGVhY2hTZXJpZXNcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLmVhY2hde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5lYWNofVxuICogQGFsaWFzIGZvckVhY2hTZXJpZXNcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEEgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaFxuICogaXRlbSBpbiBgY29sbGAuIFRoZSBpdGVyYXRlZSBpcyBwYXNzZWQgYSBgY2FsbGJhY2soZXJyKWAgd2hpY2ggbXVzdCBiZSBjYWxsZWRcbiAqIG9uY2UgaXQgaGFzIGNvbXBsZXRlZC4gSWYgbm8gZXJyb3IgaGFzIG9jY3VycmVkLCB0aGUgYGNhbGxiYWNrYCBzaG91bGQgYmUgcnVuXG4gKiB3aXRob3V0IGFyZ3VtZW50cyBvciB3aXRoIGFuIGV4cGxpY2l0IGBudWxsYCBhcmd1bWVudC4gVGhlIGFycmF5IGluZGV4IGlzXG4gKiBub3QgcGFzc2VkIHRvIHRoZSBpdGVyYXRlZS4gSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuIElmIHlvdSBuZWVkIHRoZVxuICogaW5kZXgsIHVzZSBgZWFjaE9mU2VyaWVzYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIGFsbFxuICogYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZCwgb3IgYW4gZXJyb3Igb2NjdXJzLiBJbnZva2VkIHdpdGggKGVycikuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGRvTGltaXQoZWFjaExpbWl0LCAxKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi8uLi8uLi8uLi9+L2FzeW5jLWVzL2VhY2hTZXJpZXMuanMiLCJpbXBvcnQgY3JlYXRlVGVzdGVyIGZyb20gJy4vaW50ZXJuYWwvY3JlYXRlVGVzdGVyJztcbmltcG9ydCBkb1BhcmFsbGVsIGZyb20gJy4vaW50ZXJuYWwvZG9QYXJhbGxlbCc7XG5pbXBvcnQgbm90SWQgZnJvbSAnLi9pbnRlcm5hbC9ub3RJZCc7XG5cbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgZXZlcnkgZWxlbWVudCBpbiBgY29sbGAgc2F0aXNmaWVzIGFuIGFzeW5jIHRlc3QuIElmIGFueVxuICogaXRlcmF0ZWUgY2FsbCByZXR1cm5zIGBmYWxzZWAsIHRoZSBtYWluIGBjYWxsYmFja2AgaXMgaW1tZWRpYXRlbHkgY2FsbGVkLlxuICpcbiAqIEBuYW1lIGV2ZXJ5XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAYWxpYXMgYWxsXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBIHRydXRoIHRlc3QgdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluIHRoZVxuICogY29sbGVjdGlvbiBpbiBwYXJhbGxlbC4gVGhlIGl0ZXJhdGVlIGlzIHBhc3NlZCBhIGBjYWxsYmFjayhlcnIsIHRydXRoVmFsdWUpYFxuICogd2hpY2ggbXVzdCBiZSBjYWxsZWQgd2l0aCBhICBib29sZWFuIGFyZ3VtZW50IG9uY2UgaXQgaGFzIGNvbXBsZXRlZC4gSW52b2tlZFxuICogd2l0aCAoaXRlbSwgY2FsbGJhY2spLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFmdGVyIGFsbCB0aGVcbiAqIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQuIFJlc3VsdCB3aWxsIGJlIGVpdGhlciBgdHJ1ZWAgb3IgYGZhbHNlYFxuICogZGVwZW5kaW5nIG9uIHRoZSB2YWx1ZXMgb2YgdGhlIGFzeW5jIHRlc3RzLiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0KS5cbiAqIEBleGFtcGxlXG4gKlxuICogYXN5bmMuZXZlcnkoWydmaWxlMScsJ2ZpbGUyJywnZmlsZTMnXSwgZnVuY3Rpb24oZmlsZVBhdGgsIGNhbGxiYWNrKSB7XG4gKiAgICAgZnMuYWNjZXNzKGZpbGVQYXRoLCBmdW5jdGlvbihlcnIpIHtcbiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgIWVycilcbiAqICAgICB9KTtcbiAqIH0sIGZ1bmN0aW9uKGVyciwgcmVzdWx0KSB7XG4gKiAgICAgLy8gaWYgcmVzdWx0IGlzIHRydWUgdGhlbiBldmVyeSBmaWxlIGV4aXN0c1xuICogfSk7XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGRvUGFyYWxsZWwoY3JlYXRlVGVzdGVyKG5vdElkLCBub3RJZCkpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uLy4uLy4uLy4uL34vYXN5bmMtZXMvZXZlcnkuanMiLCJpbXBvcnQgY3JlYXRlVGVzdGVyIGZyb20gJy4vaW50ZXJuYWwvY3JlYXRlVGVzdGVyJztcbmltcG9ydCBkb1BhcmFsbGVsTGltaXQgZnJvbSAnLi9pbnRlcm5hbC9kb1BhcmFsbGVsTGltaXQnO1xuaW1wb3J0IG5vdElkIGZyb20gJy4vaW50ZXJuYWwvbm90SWQnO1xuXG4vKipcbiAqIFRoZSBzYW1lIGFzIFtgZXZlcnlgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZXZlcnl9IGJ1dCBydW5zIGEgbWF4aW11bSBvZiBgbGltaXRgIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLlxuICpcbiAqIEBuYW1lIGV2ZXJ5TGltaXRcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLmV2ZXJ5XXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZXZlcnl9XG4gKiBAYWxpYXMgYWxsTGltaXRcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge251bWJlcn0gbGltaXQgLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgYXN5bmMgb3BlcmF0aW9ucyBhdCBhIHRpbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEEgdHJ1dGggdGVzdCB0byBhcHBseSB0byBlYWNoIGl0ZW0gaW4gdGhlXG4gKiBjb2xsZWN0aW9uIGluIHBhcmFsbGVsLiBUaGUgaXRlcmF0ZWUgaXMgcGFzc2VkIGEgYGNhbGxiYWNrKGVyciwgdHJ1dGhWYWx1ZSlgXG4gKiB3aGljaCBtdXN0IGJlIGNhbGxlZCB3aXRoIGEgIGJvb2xlYW4gYXJndW1lbnQgb25jZSBpdCBoYXMgY29tcGxldGVkLiBJbnZva2VkXG4gKiB3aXRoIChpdGVtLCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgYWxsIHRoZVxuICogYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZC4gUmVzdWx0IHdpbGwgYmUgZWl0aGVyIGB0cnVlYCBvciBgZmFsc2VgXG4gKiBkZXBlbmRpbmcgb24gdGhlIHZhbHVlcyBvZiB0aGUgYXN5bmMgdGVzdHMuIEludm9rZWQgd2l0aCAoZXJyLCByZXN1bHQpLlxuICovXG5leHBvcnQgZGVmYXVsdCBkb1BhcmFsbGVsTGltaXQoY3JlYXRlVGVzdGVyKG5vdElkLCBub3RJZCkpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uLy4uLy4uLy4uL34vYXN5bmMtZXMvZXZlcnlMaW1pdC5qcyIsImltcG9ydCBldmVyeUxpbWl0IGZyb20gJy4vZXZlcnlMaW1pdCc7XG5pbXBvcnQgZG9MaW1pdCBmcm9tICcuL2ludGVybmFsL2RvTGltaXQnO1xuXG4vKipcbiAqIFRoZSBzYW1lIGFzIFtgZXZlcnlgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZXZlcnl9IGJ1dCBydW5zIG9ubHkgYSBzaW5nbGUgYXN5bmMgb3BlcmF0aW9uIGF0IGEgdGltZS5cbiAqXG4gKiBAbmFtZSBldmVyeVNlcmllc1xuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICogQG1ldGhvZFxuICogQHNlZSBbYXN5bmMuZXZlcnlde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5ldmVyeX1cbiAqIEBhbGlhcyBhbGxTZXJpZXNcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEEgdHJ1dGggdGVzdCB0byBhcHBseSB0byBlYWNoIGl0ZW0gaW4gdGhlXG4gKiBjb2xsZWN0aW9uIGluIHBhcmFsbGVsLiBUaGUgaXRlcmF0ZWUgaXMgcGFzc2VkIGEgYGNhbGxiYWNrKGVyciwgdHJ1dGhWYWx1ZSlgXG4gKiB3aGljaCBtdXN0IGJlIGNhbGxlZCB3aXRoIGEgIGJvb2xlYW4gYXJndW1lbnQgb25jZSBpdCBoYXMgY29tcGxldGVkLiBJbnZva2VkXG4gKiB3aXRoIChpdGVtLCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgYWxsIHRoZVxuICogYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZC4gUmVzdWx0IHdpbGwgYmUgZWl0aGVyIGB0cnVlYCBvciBgZmFsc2VgXG4gKiBkZXBlbmRpbmcgb24gdGhlIHZhbHVlcyBvZiB0aGUgYXN5bmMgdGVzdHMuIEludm9rZWQgd2l0aCAoZXJyLCByZXN1bHQpLlxuICovXG5leHBvcnQgZGVmYXVsdCBkb0xpbWl0KGV2ZXJ5TGltaXQsIDEpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uLy4uLy4uLy4uL34vYXN5bmMtZXMvZXZlcnlTZXJpZXMuanMiLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnByb3BlcnR5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VQcm9wZXJ0eShrZXkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlUHJvcGVydHk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vLi4vLi4vLi4vfi9sb2Rhc2gtZXMvX2Jhc2VQcm9wZXJ0eS5qcyIsImltcG9ydCBmaWx0ZXIgZnJvbSAnLi9pbnRlcm5hbC9maWx0ZXInO1xuaW1wb3J0IGRvUGFyYWxsZWwgZnJvbSAnLi9pbnRlcm5hbC9kb1BhcmFsbGVsJztcblxuLyoqXG4gKiBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIGFsbCB0aGUgdmFsdWVzIGluIGBjb2xsYCB3aGljaCBwYXNzIGFuIGFzeW5jIHRydXRoXG4gKiB0ZXN0LiBUaGlzIG9wZXJhdGlvbiBpcyBwZXJmb3JtZWQgaW4gcGFyYWxsZWwsIGJ1dCB0aGUgcmVzdWx0cyBhcnJheSB3aWxsIGJlXG4gKiBpbiB0aGUgc2FtZSBvcmRlciBhcyB0aGUgb3JpZ2luYWwuXG4gKlxuICogQG5hbWUgZmlsdGVyXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAYWxpYXMgc2VsZWN0XG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBIHRydXRoIHRlc3QgdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluIGBjb2xsYC5cbiAqIFRoZSBgaXRlcmF0ZWVgIGlzIHBhc3NlZCBhIGBjYWxsYmFjayhlcnIsIHRydXRoVmFsdWUpYCwgd2hpY2ggbXVzdCBiZSBjYWxsZWRcbiAqIHdpdGggYSBib29sZWFuIGFyZ3VtZW50IG9uY2UgaXQgaGFzIGNvbXBsZXRlZC4gSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgYWxsIHRoZVxuICogYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZC4gSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdHMpLlxuICogQGV4YW1wbGVcbiAqXG4gKiBhc3luYy5maWx0ZXIoWydmaWxlMScsJ2ZpbGUyJywnZmlsZTMnXSwgZnVuY3Rpb24oZmlsZVBhdGgsIGNhbGxiYWNrKSB7XG4gKiAgICAgZnMuYWNjZXNzKGZpbGVQYXRoLCBmdW5jdGlvbihlcnIpIHtcbiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgIWVycilcbiAqICAgICB9KTtcbiAqIH0sIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICogICAgIC8vIHJlc3VsdHMgbm93IGVxdWFscyBhbiBhcnJheSBvZiB0aGUgZXhpc3RpbmcgZmlsZXNcbiAqIH0pO1xuICovXG5leHBvcnQgZGVmYXVsdCBkb1BhcmFsbGVsKGZpbHRlcik7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vLi4vLi4vLi4vfi9hc3luYy1lcy9maWx0ZXIuanMiLCJpbXBvcnQgZmlsdGVyIGZyb20gJy4vaW50ZXJuYWwvZmlsdGVyJztcbmltcG9ydCBkb1BhcmFsbGVsTGltaXQgZnJvbSAnLi9pbnRlcm5hbC9kb1BhcmFsbGVsTGltaXQnO1xuXG4vKipcbiAqIFRoZSBzYW1lIGFzIFtgZmlsdGVyYF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmZpbHRlcn0gYnV0IHJ1bnMgYSBtYXhpbXVtIG9mIGBsaW1pdGAgYXN5bmMgb3BlcmF0aW9ucyBhdCBhXG4gKiB0aW1lLlxuICpcbiAqIEBuYW1lIGZpbHRlckxpbWl0XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5maWx0ZXJde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5maWx0ZXJ9XG4gKiBAYWxpYXMgc2VsZWN0TGltaXRcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge251bWJlcn0gbGltaXQgLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgYXN5bmMgb3BlcmF0aW9ucyBhdCBhIHRpbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEEgdHJ1dGggdGVzdCB0byBhcHBseSB0byBlYWNoIGl0ZW0gaW4gYGNvbGxgLlxuICogVGhlIGBpdGVyYXRlZWAgaXMgcGFzc2VkIGEgYGNhbGxiYWNrKGVyciwgdHJ1dGhWYWx1ZSlgLCB3aGljaCBtdXN0IGJlIGNhbGxlZFxuICogd2l0aCBhIGJvb2xlYW4gYXJndW1lbnQgb25jZSBpdCBoYXMgY29tcGxldGVkLiBJbnZva2VkIHdpdGggKGl0ZW0sIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhZnRlciBhbGwgdGhlXG4gKiBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0cykuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGRvUGFyYWxsZWxMaW1pdChmaWx0ZXIpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uLy4uLy4uLy4uL34vYXN5bmMtZXMvZmlsdGVyTGltaXQuanMiLCJpbXBvcnQgZmlsdGVyTGltaXQgZnJvbSAnLi9maWx0ZXJMaW1pdCc7XG5pbXBvcnQgZG9MaW1pdCBmcm9tICcuL2ludGVybmFsL2RvTGltaXQnO1xuXG4vKipcbiAqIFRoZSBzYW1lIGFzIFtgZmlsdGVyYF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmZpbHRlcn0gYnV0IHJ1bnMgb25seSBhIHNpbmdsZSBhc3luYyBvcGVyYXRpb24gYXQgYSB0aW1lLlxuICpcbiAqIEBuYW1lIGZpbHRlclNlcmllc1xuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICogQG1ldGhvZFxuICogQHNlZSBbYXN5bmMuZmlsdGVyXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZmlsdGVyfVxuICogQGFsaWFzIHNlbGVjdFNlcmllc1xuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIC0gQSB0cnV0aCB0ZXN0IHRvIGFwcGx5IHRvIGVhY2ggaXRlbSBpbiBgY29sbGAuXG4gKiBUaGUgYGl0ZXJhdGVlYCBpcyBwYXNzZWQgYSBgY2FsbGJhY2soZXJyLCB0cnV0aFZhbHVlKWAsIHdoaWNoIG11c3QgYmUgY2FsbGVkXG4gKiB3aXRoIGEgYm9vbGVhbiBhcmd1bWVudCBvbmNlIGl0IGhhcyBjb21wbGV0ZWQuIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFmdGVyIGFsbCB0aGVcbiAqIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQuIEludm9rZWQgd2l0aCAoZXJyLCByZXN1bHRzKVxuICovXG5leHBvcnQgZGVmYXVsdCBkb0xpbWl0KGZpbHRlckxpbWl0LCAxKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi8uLi8uLi8uLi9+L2FzeW5jLWVzL2ZpbHRlclNlcmllcy5qcyIsImltcG9ydCBjb25zb2xlRnVuYyBmcm9tICcuL2ludGVybmFsL2NvbnNvbGVGdW5jJztcblxuLyoqXG4gKiBMb2dzIHRoZSByZXN1bHQgb2YgYW4gYGFzeW5jYCBmdW5jdGlvbiB0byB0aGUgYGNvbnNvbGVgLiBPbmx5IHdvcmtzIGluXG4gKiBOb2RlLmpzIG9yIGluIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBgY29uc29sZS5sb2dgIGFuZCBgY29uc29sZS5lcnJvcmAgKHN1Y2hcbiAqIGFzIEZGIGFuZCBDaHJvbWUpLiBJZiBtdWx0aXBsZSBhcmd1bWVudHMgYXJlIHJldHVybmVkIGZyb20gdGhlIGFzeW5jXG4gKiBmdW5jdGlvbiwgYGNvbnNvbGUubG9nYCBpcyBjYWxsZWQgb24gZWFjaCBhcmd1bWVudCBpbiBvcmRlci5cbiAqXG4gKiBAbmFtZSBsb2dcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6VXRpbHNcbiAqIEBtZXRob2RcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jdGlvbiAtIFRoZSBmdW5jdGlvbiB5b3Ugd2FudCB0byBldmVudHVhbGx5IGFwcGx5IGFsbFxuICogYXJndW1lbnRzIHRvLlxuICogQHBhcmFtIHsuLi4qfSBhcmd1bWVudHMuLi4gLSBBbnkgbnVtYmVyIG9mIGFyZ3VtZW50cyB0byBhcHBseSB0byB0aGUgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIGluIGEgbW9kdWxlXG4gKiB2YXIgaGVsbG8gPSBmdW5jdGlvbihuYW1lLCBjYWxsYmFjaykge1xuICogICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgIGNhbGxiYWNrKG51bGwsICdoZWxsbyAnICsgbmFtZSk7XG4gKiAgICAgfSwgMTAwMCk7XG4gKiB9O1xuICpcbiAqIC8vIGluIHRoZSBub2RlIHJlcGxcbiAqIG5vZGU+IGFzeW5jLmxvZyhoZWxsbywgJ3dvcmxkJyk7XG4gKiAnaGVsbG8gd29ybGQnXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNvbnNvbGVGdW5jKCdsb2cnKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi8uLi8uLi8uLi9+L2FzeW5jLWVzL2xvZy5qcyIsImltcG9ydCBtYXBWYWx1ZXNMaW1pdCBmcm9tICcuL21hcFZhbHVlc0xpbWl0JztcbmltcG9ydCBkb0xpbWl0IGZyb20gJy4vaW50ZXJuYWwvZG9MaW1pdCc7XG5cblxuLyoqXG4gKiBBIHJlbGF0aXZlIG9mIFtgbWFwYF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLm1hcH0sIGRlc2lnbmVkIGZvciB1c2Ugd2l0aCBvYmplY3RzLlxuICpcbiAqIFByb2R1Y2VzIGEgbmV3IE9iamVjdCBieSBtYXBwaW5nIGVhY2ggdmFsdWUgb2YgYG9iamAgdGhyb3VnaCB0aGUgYGl0ZXJhdGVlYFxuICogZnVuY3Rpb24uIFRoZSBgaXRlcmF0ZWVgIGlzIGNhbGxlZCBlYWNoIGB2YWx1ZWAgYW5kIGBrZXlgIGZyb20gYG9iamAgYW5kIGFcbiAqIGNhbGxiYWNrIGZvciB3aGVuIGl0IGhhcyBmaW5pc2hlZCBwcm9jZXNzaW5nLiBFYWNoIG9mIHRoZXNlIGNhbGxiYWNrcyB0YWtlc1xuICogdHdvIGFyZ3VtZW50czogYW4gYGVycm9yYCwgYW5kIHRoZSB0cmFuc2Zvcm1lZCBpdGVtIGZyb20gYG9iamAuIElmIGBpdGVyYXRlZWBcbiAqIHBhc3NlcyBhbiBlcnJvciB0byBpdHMgY2FsbGJhY2ssIHRoZSBtYWluIGBjYWxsYmFja2AgKGZvciB0aGUgYG1hcFZhbHVlc2BcbiAqIGZ1bmN0aW9uKSBpcyBpbW1lZGlhdGVseSBjYWxsZWQgd2l0aCB0aGUgZXJyb3IuXG4gKlxuICogTm90ZSwgdGhlIG9yZGVyIG9mIHRoZSBrZXlzIGluIHRoZSByZXN1bHQgaXMgbm90IGd1YXJhbnRlZWQuICBUaGUga2V5cyB3aWxsXG4gKiBiZSByb3VnaGx5IGluIHRoZSBvcmRlciB0aGV5IGNvbXBsZXRlLCAoYnV0IHRoaXMgaXMgdmVyeSBlbmdpbmUtc3BlY2lmaWMpXG4gKlxuICogQG5hbWUgbWFwVmFsdWVzXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEEgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCB2YWx1ZSBhbmQga2V5IGluXG4gKiBgY29sbGAuIFRoZSBpdGVyYXRlZSBpcyBwYXNzZWQgYSBgY2FsbGJhY2soZXJyLCB0cmFuc2Zvcm1lZClgIHdoaWNoIG11c3QgYmVcbiAqIGNhbGxlZCBvbmNlIGl0IGhhcyBjb21wbGV0ZWQgd2l0aCBhbiBlcnJvciAod2hpY2ggY2FuIGJlIGBudWxsYCkgYW5kIGFcbiAqIHRyYW5zZm9ybWVkIHZhbHVlLiBJbnZva2VkIHdpdGggKHZhbHVlLCBrZXksIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIGFsbCBgaXRlcmF0ZWVgXG4gKiBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZCwgb3IgYW4gZXJyb3Igb2NjdXJzLiBgcmVzdWx0YCBpcyBhIG5ldyBvYmplY3QgY29uc2lzdGluZ1xuICogb2YgZWFjaCBrZXkgZnJvbSBgb2JqYCwgd2l0aCBlYWNoIHRyYW5zZm9ybWVkIHZhbHVlIG9uIHRoZSByaWdodC1oYW5kIHNpZGUuXG4gKiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0KS5cbiAqIEBleGFtcGxlXG4gKlxuICogYXN5bmMubWFwVmFsdWVzKHtcbiAqICAgICBmMTogJ2ZpbGUxJyxcbiAqICAgICBmMjogJ2ZpbGUyJyxcbiAqICAgICBmMzogJ2ZpbGUzJ1xuICogfSwgZnVuY3Rpb24gKGZpbGUsIGtleSwgY2FsbGJhY2spIHtcbiAqICAgZnMuc3RhdChmaWxlLCBjYWxsYmFjayk7XG4gKiB9LCBmdW5jdGlvbihlcnIsIHJlc3VsdCkge1xuICogICAgIC8vIHJlc3VsdCBpcyBub3cgYSBtYXAgb2Ygc3RhdHMgZm9yIGVhY2ggZmlsZSwgZS5nLlxuICogICAgIC8vIHtcbiAqICAgICAvLyAgICAgZjE6IFtzdGF0cyBmb3IgZmlsZTFdLFxuICogICAgIC8vICAgICBmMjogW3N0YXRzIGZvciBmaWxlMl0sXG4gKiAgICAgLy8gICAgIGYzOiBbc3RhdHMgZm9yIGZpbGUzXVxuICogICAgIC8vIH1cbiAqIH0pO1xuICovXG5cbmV4cG9ydCBkZWZhdWx0IGRvTGltaXQobWFwVmFsdWVzTGltaXQsIEluZmluaXR5KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi8uLi8uLi8uLi9+L2FzeW5jLWVzL21hcFZhbHVlcy5qcyIsImltcG9ydCBtYXBWYWx1ZXNMaW1pdCBmcm9tICcuL21hcFZhbHVlc0xpbWl0JztcbmltcG9ydCBkb0xpbWl0IGZyb20gJy4vaW50ZXJuYWwvZG9MaW1pdCc7XG5cbi8qKlxuICogVGhlIHNhbWUgYXMgW2BtYXBWYWx1ZXNgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMubWFwVmFsdWVzfSBidXQgcnVucyBvbmx5IGEgc2luZ2xlIGFzeW5jIG9wZXJhdGlvbiBhdCBhIHRpbWUuXG4gKlxuICogQG5hbWUgbWFwVmFsdWVzU2VyaWVzXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5tYXBWYWx1ZXNde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5tYXBWYWx1ZXN9XG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEEgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCB2YWx1ZSBpbiBgb2JqYC5cbiAqIFRoZSBpdGVyYXRlZSBpcyBwYXNzZWQgYSBgY2FsbGJhY2soZXJyLCB0cmFuc2Zvcm1lZClgIHdoaWNoIG11c3QgYmUgY2FsbGVkXG4gKiBvbmNlIGl0IGhhcyBjb21wbGV0ZWQgd2l0aCBhbiBlcnJvciAod2hpY2ggY2FuIGJlIGBudWxsYCkgYW5kIGFcbiAqIHRyYW5zZm9ybWVkIHZhbHVlLiBJbnZva2VkIHdpdGggKHZhbHVlLCBrZXksIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIGFsbCBgaXRlcmF0ZWVgXG4gKiBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZCwgb3IgYW4gZXJyb3Igb2NjdXJzLiBgcmVzdWx0YCBpcyBhIG5ldyBvYmplY3QgY29uc2lzdGluZ1xuICogb2YgZWFjaCBrZXkgZnJvbSBgb2JqYCwgd2l0aCBlYWNoIHRyYW5zZm9ybWVkIHZhbHVlIG9uIHRoZSByaWdodC1oYW5kIHNpZGUuXG4gKiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0KS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZG9MaW1pdChtYXBWYWx1ZXNMaW1pdCwgMSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vLi4vLi4vLi4vfi9hc3luYy1lcy9tYXBWYWx1ZXNTZXJpZXMuanMiLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB7IGhhc05leHRUaWNrLCBoYXNTZXRJbW1lZGlhdGUsIGZhbGxiYWNrLCB3cmFwIH0gIGZyb20gJy4vaW50ZXJuYWwvc2V0SW1tZWRpYXRlJztcblxuLyoqXG4gKiBDYWxscyBgY2FsbGJhY2tgIG9uIGEgbGF0ZXIgbG9vcCBhcm91bmQgdGhlIGV2ZW50IGxvb3AuIEluIE5vZGUuanMgdGhpcyBqdXN0XG4gKiBjYWxscyBgc2V0SW1tZWRpYXRlYC4gIEluIHRoZSBicm93c2VyIGl0IHdpbGwgdXNlIGBzZXRJbW1lZGlhdGVgIGlmXG4gKiBhdmFpbGFibGUsIG90aGVyd2lzZSBgc2V0VGltZW91dChjYWxsYmFjaywgMClgLCB3aGljaCBtZWFucyBvdGhlciBoaWdoZXJcbiAqIHByaW9yaXR5IGV2ZW50cyBtYXkgcHJlY2VkZSB0aGUgZXhlY3V0aW9uIG9mIGBjYWxsYmFja2AuXG4gKlxuICogVGhpcyBpcyB1c2VkIGludGVybmFsbHkgZm9yIGJyb3dzZXItY29tcGF0aWJpbGl0eSBwdXJwb3Nlcy5cbiAqXG4gKiBAbmFtZSBuZXh0VGlja1xuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpVdGlsc1xuICogQG1ldGhvZFxuICogQGFsaWFzIHNldEltbWVkaWF0ZVxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gVGhlIGZ1bmN0aW9uIHRvIGNhbGwgb24gYSBsYXRlciBsb29wIGFyb3VuZFxuICogdGhlIGV2ZW50IGxvb3AuIEludm9rZWQgd2l0aCAoYXJncy4uLikuXG4gKiBAcGFyYW0gey4uLip9IGFyZ3MuLi4gLSBhbnkgbnVtYmVyIG9mIGFkZGl0aW9uYWwgYXJndW1lbnRzIHRvIHBhc3MgdG8gdGhlXG4gKiBjYWxsYmFjayBvbiB0aGUgbmV4dCB0aWNrLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgY2FsbF9vcmRlciA9IFtdO1xuICogYXN5bmMubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gKiAgICAgY2FsbF9vcmRlci5wdXNoKCd0d28nKTtcbiAqICAgICAvLyBjYWxsX29yZGVyIG5vdyBlcXVhbHMgWydvbmUnLCd0d28nXVxuICogfSk7XG4gKiBjYWxsX29yZGVyLnB1c2goJ29uZScpO1xuICpcbiAqIGFzeW5jLnNldEltbWVkaWF0ZShmdW5jdGlvbiAoYSwgYiwgYykge1xuICogICAgIC8vIGEsIGIsIGFuZCBjIGVxdWFsIDEsIDIsIGFuZCAzXG4gKiB9LCAxLCAyLCAzKTtcbiAqL1xudmFyIF9kZWZlcjtcblxuaWYgKGhhc05leHRUaWNrKSB7XG4gICAgX2RlZmVyID0gcHJvY2Vzcy5uZXh0VGljaztcbn0gZWxzZSBpZiAoaGFzU2V0SW1tZWRpYXRlKSB7XG4gICAgX2RlZmVyID0gc2V0SW1tZWRpYXRlO1xufSBlbHNlIHtcbiAgICBfZGVmZXIgPSBmYWxsYmFjaztcbn1cblxuZXhwb3J0IGRlZmF1bHQgd3JhcChfZGVmZXIpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uLy4uLy4uLy4uL34vYXN5bmMtZXMvbmV4dFRpY2suanMiLCJpbXBvcnQgc2V0SW1tZWRpYXRlIGZyb20gJy4vaW50ZXJuYWwvc2V0SW1tZWRpYXRlJztcblxuLyoqXG4gKiBDYWxscyBgY2FsbGJhY2tgIG9uIGEgbGF0ZXIgbG9vcCBhcm91bmQgdGhlIGV2ZW50IGxvb3AuIEluIE5vZGUuanMgdGhpcyBqdXN0XG4gKiBjYWxscyBgc2V0SW1tZWRpYXRlYC4gIEluIHRoZSBicm93c2VyIGl0IHdpbGwgdXNlIGBzZXRJbW1lZGlhdGVgIGlmXG4gKiBhdmFpbGFibGUsIG90aGVyd2lzZSBgc2V0VGltZW91dChjYWxsYmFjaywgMClgLCB3aGljaCBtZWFucyBvdGhlciBoaWdoZXJcbiAqIHByaW9yaXR5IGV2ZW50cyBtYXkgcHJlY2VkZSB0aGUgZXhlY3V0aW9uIG9mIGBjYWxsYmFja2AuXG4gKlxuICogVGhpcyBpcyB1c2VkIGludGVybmFsbHkgZm9yIGJyb3dzZXItY29tcGF0aWJpbGl0eSBwdXJwb3Nlcy5cbiAqXG4gKiBAbmFtZSBzZXRJbW1lZGlhdGVcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6VXRpbHNcbiAqIEBtZXRob2RcbiAqIEBhbGlhcyBuZXh0VGlja1xuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gVGhlIGZ1bmN0aW9uIHRvIGNhbGwgb24gYSBsYXRlciBsb29wIGFyb3VuZFxuICogdGhlIGV2ZW50IGxvb3AuIEludm9rZWQgd2l0aCAoYXJncy4uLikuXG4gKiBAcGFyYW0gey4uLip9IGFyZ3MuLi4gLSBhbnkgbnVtYmVyIG9mIGFkZGl0aW9uYWwgYXJndW1lbnRzIHRvIHBhc3MgdG8gdGhlXG4gKiBjYWxsYmFjayBvbiB0aGUgbmV4dCB0aWNrLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgY2FsbF9vcmRlciA9IFtdO1xuICogYXN5bmMubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gKiAgICAgY2FsbF9vcmRlci5wdXNoKCd0d28nKTtcbiAqICAgICAvLyBjYWxsX29yZGVyIG5vdyBlcXVhbHMgWydvbmUnLCd0d28nXVxuICogfSk7XG4gKiBjYWxsX29yZGVyLnB1c2goJ29uZScpO1xuICpcbiAqIGFzeW5jLnNldEltbWVkaWF0ZShmdW5jdGlvbiAoYSwgYiwgYykge1xuICogICAgIC8vIGEsIGIsIGFuZCBjIGVxdWFsIDEsIDIsIGFuZCAzXG4gKiB9LCAxLCAyLCAzKTtcbiAqL1xuZXhwb3J0IGRlZmF1bHQgc2V0SW1tZWRpYXRlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uLy4uLy4uLy4uL34vYXN5bmMtZXMvc2V0SW1tZWRpYXRlLmpzIiwiaW1wb3J0IHF1ZXVlIGZyb20gJy4vaW50ZXJuYWwvcXVldWUnO1xuXG4vKipcbiAqIEEgcXVldWUgb2YgdGFza3MgZm9yIHRoZSB3b3JrZXIgZnVuY3Rpb24gdG8gY29tcGxldGUuXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBRdWV1ZU9iamVjdFxuICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvd1xuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gbGVuZ3RoIC0gYSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIG51bWJlciBvZiBpdGVtc1xuICogd2FpdGluZyB0byBiZSBwcm9jZXNzZWQuIEludm9rZSB3aXRoIGBxdWV1ZS5sZW5ndGgoKWAuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHN0YXJ0ZWQgLSBhIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIG9yIG5vdCBhbnlcbiAqIGl0ZW1zIGhhdmUgYmVlbiBwdXNoZWQgYW5kIHByb2Nlc3NlZCBieSB0aGUgcXVldWUuXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBydW5uaW5nIC0gYSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIG51bWJlciBvZiBpdGVtc1xuICogY3VycmVudGx5IGJlaW5nIHByb2Nlc3NlZC4gSW52b2tlIHdpdGggYHF1ZXVlLnJ1bm5pbmcoKWAuXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSB3b3JrZXJzTGlzdCAtIGEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBhcnJheSBvZiBpdGVtc1xuICogY3VycmVudGx5IGJlaW5nIHByb2Nlc3NlZC4gSW52b2tlIHdpdGggYHF1ZXVlLndvcmtlcnNMaXN0KClgLlxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gaWRsZSAtIGEgZnVuY3Rpb24gcmV0dXJuaW5nIGZhbHNlIGlmIHRoZXJlIGFyZSBpdGVtc1xuICogd2FpdGluZyBvciBiZWluZyBwcm9jZXNzZWQsIG9yIHRydWUgaWYgbm90LiBJbnZva2Ugd2l0aCBgcXVldWUuaWRsZSgpYC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjb25jdXJyZW5jeSAtIGFuIGludGVnZXIgZm9yIGRldGVybWluaW5nIGhvdyBtYW55IGB3b3JrZXJgXG4gKiBmdW5jdGlvbnMgc2hvdWxkIGJlIHJ1biBpbiBwYXJhbGxlbC4gVGhpcyBwcm9wZXJ0eSBjYW4gYmUgY2hhbmdlZCBhZnRlciBhXG4gKiBgcXVldWVgIGlzIGNyZWF0ZWQgdG8gYWx0ZXIgdGhlIGNvbmN1cnJlbmN5IG9uLXRoZS1mbHkuXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBwdXNoIC0gYWRkIGEgbmV3IHRhc2sgdG8gdGhlIGBxdWV1ZWAuIENhbGxzIGBjYWxsYmFja2BcbiAqIG9uY2UgdGhlIGB3b3JrZXJgIGhhcyBmaW5pc2hlZCBwcm9jZXNzaW5nIHRoZSB0YXNrLiBJbnN0ZWFkIG9mIGEgc2luZ2xlIHRhc2ssXG4gKiBhIGB0YXNrc2AgYXJyYXkgY2FuIGJlIHN1Ym1pdHRlZC4gVGhlIHJlc3BlY3RpdmUgY2FsbGJhY2sgaXMgdXNlZCBmb3IgZXZlcnlcbiAqIHRhc2sgaW4gdGhlIGxpc3QuIEludm9rZSB3aXRoIGBxdWV1ZS5wdXNoKHRhc2ssIFtjYWxsYmFja10pYCxcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IHVuc2hpZnQgLSBhZGQgYSBuZXcgdGFzayB0byB0aGUgZnJvbnQgb2YgdGhlIGBxdWV1ZWAuXG4gKiBJbnZva2Ugd2l0aCBgcXVldWUudW5zaGlmdCh0YXNrLCBbY2FsbGJhY2tdKWAuXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBzYXR1cmF0ZWQgLSBhIGNhbGxiYWNrIHRoYXQgaXMgY2FsbGVkIHdoZW4gdGhlIG51bWJlciBvZlxuICogcnVubmluZyB3b3JrZXJzIGhpdHMgdGhlIGBjb25jdXJyZW5jeWAgbGltaXQsIGFuZCBmdXJ0aGVyIHRhc2tzIHdpbGwgYmVcbiAqIHF1ZXVlZC5cbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IHVuc2F0dXJhdGVkIC0gYSBjYWxsYmFjayB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoZSBudW1iZXJcbiAqIG9mIHJ1bm5pbmcgd29ya2VycyBpcyBsZXNzIHRoYW4gdGhlIGBjb25jdXJyZW5jeWAgJiBgYnVmZmVyYCBsaW1pdHMsIGFuZFxuICogZnVydGhlciB0YXNrcyB3aWxsIG5vdCBiZSBxdWV1ZWQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gYnVmZmVyIC0gQSBtaW5pbXVtIHRocmVzaG9sZCBidWZmZXIgaW4gb3JkZXIgdG8gc2F5IHRoYXRcbiAqIHRoZSBgcXVldWVgIGlzIGB1bnNhdHVyYXRlZGAuXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBlbXB0eSAtIGEgY2FsbGJhY2sgdGhhdCBpcyBjYWxsZWQgd2hlbiB0aGUgbGFzdCBpdGVtXG4gKiBmcm9tIHRoZSBgcXVldWVgIGlzIGdpdmVuIHRvIGEgYHdvcmtlcmAuXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBkcmFpbiAtIGEgY2FsbGJhY2sgdGhhdCBpcyBjYWxsZWQgd2hlbiB0aGUgbGFzdCBpdGVtXG4gKiBmcm9tIHRoZSBgcXVldWVgIGhhcyByZXR1cm5lZCBmcm9tIHRoZSBgd29ya2VyYC5cbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGVycm9yIC0gYSBjYWxsYmFjayB0aGF0IGlzIGNhbGxlZCB3aGVuIGEgdGFzayBlcnJvcnMuXG4gKiBIYXMgdGhlIHNpZ25hdHVyZSBgZnVuY3Rpb24oZXJyb3IsIHRhc2spYC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gcGF1c2VkIC0gYSBib29sZWFuIGZvciBkZXRlcm1pbmluZyB3aGV0aGVyIHRoZSBxdWV1ZSBpc1xuICogaW4gYSBwYXVzZWQgc3RhdGUuXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBwYXVzZSAtIGEgZnVuY3Rpb24gdGhhdCBwYXVzZXMgdGhlIHByb2Nlc3Npbmcgb2YgdGFza3NcbiAqIHVudGlsIGByZXN1bWUoKWAgaXMgY2FsbGVkLiBJbnZva2Ugd2l0aCBgcXVldWUucGF1c2UoKWAuXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSByZXN1bWUgLSBhIGZ1bmN0aW9uIHRoYXQgcmVzdW1lcyB0aGUgcHJvY2Vzc2luZyBvZlxuICogcXVldWVkIHRhc2tzIHdoZW4gdGhlIHF1ZXVlIGlzIHBhdXNlZC4gSW52b2tlIHdpdGggYHF1ZXVlLnJlc3VtZSgpYC5cbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGtpbGwgLSBhIGZ1bmN0aW9uIHRoYXQgcmVtb3ZlcyB0aGUgYGRyYWluYCBjYWxsYmFjayBhbmRcbiAqIGVtcHRpZXMgcmVtYWluaW5nIHRhc2tzIGZyb20gdGhlIHF1ZXVlIGZvcmNpbmcgaXQgdG8gZ28gaWRsZS4gSW52b2tlIHdpdGggYHF1ZXVlLmtpbGwoKWAuXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIGEgYHF1ZXVlYCBvYmplY3Qgd2l0aCB0aGUgc3BlY2lmaWVkIGBjb25jdXJyZW5jeWAuIFRhc2tzIGFkZGVkIHRvIHRoZVxuICogYHF1ZXVlYCBhcmUgcHJvY2Vzc2VkIGluIHBhcmFsbGVsICh1cCB0byB0aGUgYGNvbmN1cnJlbmN5YCBsaW1pdCkuIElmIGFsbFxuICogYHdvcmtlcmBzIGFyZSBpbiBwcm9ncmVzcywgdGhlIHRhc2sgaXMgcXVldWVkIHVudGlsIG9uZSBiZWNvbWVzIGF2YWlsYWJsZS5cbiAqIE9uY2UgYSBgd29ya2VyYCBjb21wbGV0ZXMgYSBgdGFza2AsIHRoYXQgYHRhc2tgJ3MgY2FsbGJhY2sgaXMgY2FsbGVkLlxuICpcbiAqIEBuYW1lIHF1ZXVlXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93XG4gKiBAbWV0aG9kXG4gKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB3b3JrZXIgLSBBbiBhc3luY2hyb25vdXMgZnVuY3Rpb24gZm9yIHByb2Nlc3NpbmcgYSBxdWV1ZWRcbiAqIHRhc2ssIHdoaWNoIG11c3QgY2FsbCBpdHMgYGNhbGxiYWNrKGVycilgIGFyZ3VtZW50IHdoZW4gZmluaXNoZWQsIHdpdGggYW5cbiAqIG9wdGlvbmFsIGBlcnJvcmAgYXMgYW4gYXJndW1lbnQuICBJZiB5b3Ugd2FudCB0byBoYW5kbGUgZXJyb3JzIGZyb20gYW5cbiAqIGluZGl2aWR1YWwgdGFzaywgcGFzcyBhIGNhbGxiYWNrIHRvIGBxLnB1c2goKWAuIEludm9rZWQgd2l0aFxuICogKHRhc2ssIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbY29uY3VycmVuY3k9MV0gLSBBbiBgaW50ZWdlcmAgZm9yIGRldGVybWluaW5nIGhvdyBtYW55XG4gKiBgd29ya2VyYCBmdW5jdGlvbnMgc2hvdWxkIGJlIHJ1biBpbiBwYXJhbGxlbC4gIElmIG9taXR0ZWQsIHRoZSBjb25jdXJyZW5jeVxuICogZGVmYXVsdHMgdG8gYDFgLiAgSWYgdGhlIGNvbmN1cnJlbmN5IGlzIGAwYCwgYW4gZXJyb3IgaXMgdGhyb3duLlxuICogQHJldHVybnMge21vZHVsZTpDb250cm9sRmxvdy5RdWV1ZU9iamVjdH0gQSBxdWV1ZSBvYmplY3QgdG8gbWFuYWdlIHRoZSB0YXNrcy4gQ2FsbGJhY2tzIGNhblxuICogYXR0YWNoZWQgYXMgY2VydGFpbiBwcm9wZXJ0aWVzIHRvIGxpc3RlbiBmb3Igc3BlY2lmaWMgZXZlbnRzIGR1cmluZyB0aGVcbiAqIGxpZmVjeWNsZSBvZiB0aGUgcXVldWUuXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIGNyZWF0ZSBhIHF1ZXVlIG9iamVjdCB3aXRoIGNvbmN1cnJlbmN5IDJcbiAqIHZhciBxID0gYXN5bmMucXVldWUoZnVuY3Rpb24odGFzaywgY2FsbGJhY2spIHtcbiAqICAgICBjb25zb2xlLmxvZygnaGVsbG8gJyArIHRhc2submFtZSk7XG4gKiAgICAgY2FsbGJhY2soKTtcbiAqIH0sIDIpO1xuICpcbiAqIC8vIGFzc2lnbiBhIGNhbGxiYWNrXG4gKiBxLmRyYWluID0gZnVuY3Rpb24oKSB7XG4gKiAgICAgY29uc29sZS5sb2coJ2FsbCBpdGVtcyBoYXZlIGJlZW4gcHJvY2Vzc2VkJyk7XG4gKiB9O1xuICpcbiAqIC8vIGFkZCBzb21lIGl0ZW1zIHRvIHRoZSBxdWV1ZVxuICogcS5wdXNoKHtuYW1lOiAnZm9vJ30sIGZ1bmN0aW9uKGVycikge1xuICogICAgIGNvbnNvbGUubG9nKCdmaW5pc2hlZCBwcm9jZXNzaW5nIGZvbycpO1xuICogfSk7XG4gKiBxLnB1c2goe25hbWU6ICdiYXInfSwgZnVuY3Rpb24gKGVycikge1xuICogICAgIGNvbnNvbGUubG9nKCdmaW5pc2hlZCBwcm9jZXNzaW5nIGJhcicpO1xuICogfSk7XG4gKlxuICogLy8gYWRkIHNvbWUgaXRlbXMgdG8gdGhlIHF1ZXVlIChiYXRjaC13aXNlKVxuICogcS5wdXNoKFt7bmFtZTogJ2Jheid9LHtuYW1lOiAnYmF5J30se25hbWU6ICdiYXgnfV0sIGZ1bmN0aW9uKGVycikge1xuICogICAgIGNvbnNvbGUubG9nKCdmaW5pc2hlZCBwcm9jZXNzaW5nIGl0ZW0nKTtcbiAqIH0pO1xuICpcbiAqIC8vIGFkZCBzb21lIGl0ZW1zIHRvIHRoZSBmcm9udCBvZiB0aGUgcXVldWVcbiAqIHEudW5zaGlmdCh7bmFtZTogJ2Jhcid9LCBmdW5jdGlvbiAoZXJyKSB7XG4gKiAgICAgY29uc29sZS5sb2coJ2ZpbmlzaGVkIHByb2Nlc3NpbmcgYmFyJyk7XG4gKiB9KTtcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKHdvcmtlciwgY29uY3VycmVuY3kpIHtcbiAgICByZXR1cm4gcXVldWUoZnVuY3Rpb24gKGl0ZW1zLCBjYikge1xuICAgICAgICB3b3JrZXIoaXRlbXNbMF0sIGNiKTtcbiAgICB9LCBjb25jdXJyZW5jeSwgMSk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vLi4vLi4vLi4vfi9hc3luYy1lcy9xdWV1ZS5qcyIsImltcG9ydCBpc0FycmF5IGZyb20gJ2xvZGFzaC1lcy9pc0FycmF5JztcbmltcG9ydCBub29wIGZyb20gJ2xvZGFzaC1lcy9ub29wJztcblxuaW1wb3J0IHNldEltbWVkaWF0ZSBmcm9tICcuL3NldEltbWVkaWF0ZSc7XG5cbmltcG9ydCBxdWV1ZSBmcm9tICcuL3F1ZXVlJztcblxuLyoqXG4gKiBUaGUgc2FtZSBhcyBbYXN5bmMucXVldWVde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy5xdWV1ZX0gb25seSB0YXNrcyBhcmUgYXNzaWduZWQgYSBwcmlvcml0eSBhbmRcbiAqIGNvbXBsZXRlZCBpbiBhc2NlbmRpbmcgcHJpb3JpdHkgb3JkZXIuXG4gKlxuICogQG5hbWUgcHJpb3JpdHlRdWV1ZVxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvd1xuICogQG1ldGhvZFxuICogQHNlZSBbYXN5bmMucXVldWVde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy5xdWV1ZX1cbiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3dcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHdvcmtlciAtIEFuIGFzeW5jaHJvbm91cyBmdW5jdGlvbiBmb3IgcHJvY2Vzc2luZyBhIHF1ZXVlZFxuICogdGFzaywgd2hpY2ggbXVzdCBjYWxsIGl0cyBgY2FsbGJhY2soZXJyKWAgYXJndW1lbnQgd2hlbiBmaW5pc2hlZCwgd2l0aCBhblxuICogb3B0aW9uYWwgYGVycm9yYCBhcyBhbiBhcmd1bWVudC4gIElmIHlvdSB3YW50IHRvIGhhbmRsZSBlcnJvcnMgZnJvbSBhblxuICogaW5kaXZpZHVhbCB0YXNrLCBwYXNzIGEgY2FsbGJhY2sgdG8gYHEucHVzaCgpYC4gSW52b2tlZCB3aXRoXG4gKiAodGFzaywgY2FsbGJhY2spLlxuICogQHBhcmFtIHtudW1iZXJ9IGNvbmN1cnJlbmN5IC0gQW4gYGludGVnZXJgIGZvciBkZXRlcm1pbmluZyBob3cgbWFueSBgd29ya2VyYFxuICogZnVuY3Rpb25zIHNob3VsZCBiZSBydW4gaW4gcGFyYWxsZWwuICBJZiBvbWl0dGVkLCB0aGUgY29uY3VycmVuY3kgZGVmYXVsdHMgdG9cbiAqIGAxYC4gIElmIHRoZSBjb25jdXJyZW5jeSBpcyBgMGAsIGFuIGVycm9yIGlzIHRocm93bi5cbiAqIEByZXR1cm5zIHttb2R1bGU6Q29udHJvbEZsb3cuUXVldWVPYmplY3R9IEEgcHJpb3JpdHlRdWV1ZSBvYmplY3QgdG8gbWFuYWdlIHRoZSB0YXNrcy4gVGhlcmUgYXJlIHR3b1xuICogZGlmZmVyZW5jZXMgYmV0d2VlbiBgcXVldWVgIGFuZCBgcHJpb3JpdHlRdWV1ZWAgb2JqZWN0czpcbiAqICogYHB1c2godGFzaywgcHJpb3JpdHksIFtjYWxsYmFja10pYCAtIGBwcmlvcml0eWAgc2hvdWxkIGJlIGEgbnVtYmVyLiBJZiBhblxuICogICBhcnJheSBvZiBgdGFza3NgIGlzIGdpdmVuLCBhbGwgdGFza3Mgd2lsbCBiZSBhc3NpZ25lZCB0aGUgc2FtZSBwcmlvcml0eS5cbiAqICogVGhlIGB1bnNoaWZ0YCBtZXRob2Qgd2FzIHJlbW92ZWQuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHdvcmtlciwgY29uY3VycmVuY3kpIHtcbiAgICAvLyBTdGFydCB3aXRoIGEgbm9ybWFsIHF1ZXVlXG4gICAgdmFyIHEgPSBxdWV1ZSh3b3JrZXIsIGNvbmN1cnJlbmN5KTtcblxuICAgIC8vIE92ZXJyaWRlIHB1c2ggdG8gYWNjZXB0IHNlY29uZCBwYXJhbWV0ZXIgcmVwcmVzZW50aW5nIHByaW9yaXR5XG4gICAgcS5wdXNoID0gZnVuY3Rpb24oZGF0YSwgcHJpb3JpdHksIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChjYWxsYmFjayA9PSBudWxsKSBjYWxsYmFjayA9IG5vb3A7XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndGFzayBjYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuICAgICAgICBxLnN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICBpZiAoIWlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgICAgIGRhdGEgPSBbZGF0YV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAvLyBjYWxsIGRyYWluIGltbWVkaWF0ZWx5IGlmIHRoZXJlIGFyZSBubyB0YXNrc1xuICAgICAgICAgICAgcmV0dXJuIHNldEltbWVkaWF0ZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBxLmRyYWluKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByaW9yaXR5ID0gcHJpb3JpdHkgfHwgMDtcbiAgICAgICAgdmFyIG5leHROb2RlID0gcS5fdGFza3MuaGVhZDtcbiAgICAgICAgd2hpbGUgKG5leHROb2RlICYmIHByaW9yaXR5ID49IG5leHROb2RlLnByaW9yaXR5KSB7XG4gICAgICAgICAgICBuZXh0Tm9kZSA9IG5leHROb2RlLm5leHQ7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGRhdGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IHtcbiAgICAgICAgICAgICAgICBkYXRhOiBkYXRhW2ldLFxuICAgICAgICAgICAgICAgIHByaW9yaXR5OiBwcmlvcml0eSxcbiAgICAgICAgICAgICAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmIChuZXh0Tm9kZSkge1xuICAgICAgICAgICAgICAgIHEuX3Rhc2tzLmluc2VydEJlZm9yZShuZXh0Tm9kZSwgaXRlbSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHEuX3Rhc2tzLnB1c2goaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2V0SW1tZWRpYXRlKHEucHJvY2Vzcyk7XG4gICAgfTtcblxuICAgIC8vIFJlbW92ZSB1bnNoaWZ0IGZ1bmN0aW9uXG4gICAgZGVsZXRlIHEudW5zaGlmdDtcblxuICAgIHJldHVybiBxO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uLy4uLy4uLy4uL34vYXN5bmMtZXMvcHJpb3JpdHlRdWV1ZS5qcyIsImltcG9ydCByZWplY3QgZnJvbSAnLi9pbnRlcm5hbC9yZWplY3QnO1xuaW1wb3J0IGRvUGFyYWxsZWwgZnJvbSAnLi9pbnRlcm5hbC9kb1BhcmFsbGVsJztcblxuLyoqXG4gKiBUaGUgb3Bwb3NpdGUgb2YgW2BmaWx0ZXJgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZmlsdGVyfS4gUmVtb3ZlcyB2YWx1ZXMgdGhhdCBwYXNzIGFuIGBhc3luY2AgdHJ1dGggdGVzdC5cbiAqXG4gKiBAbmFtZSByZWplY3RcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLmZpbHRlcl17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmZpbHRlcn1cbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEEgdHJ1dGggdGVzdCB0byBhcHBseSB0byBlYWNoIGl0ZW0gaW4gYGNvbGxgLlxuICogVGhlIGBpdGVyYXRlZWAgaXMgcGFzc2VkIGEgYGNhbGxiYWNrKGVyciwgdHJ1dGhWYWx1ZSlgLCB3aGljaCBtdXN0IGJlIGNhbGxlZFxuICogd2l0aCBhIGJvb2xlYW4gYXJndW1lbnQgb25jZSBpdCBoYXMgY29tcGxldGVkLiBJbnZva2VkIHdpdGggKGl0ZW0sIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhZnRlciBhbGwgdGhlXG4gKiBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0cykuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGFzeW5jLnJlamVjdChbJ2ZpbGUxJywnZmlsZTInLCdmaWxlMyddLCBmdW5jdGlvbihmaWxlUGF0aCwgY2FsbGJhY2spIHtcbiAqICAgICBmcy5hY2Nlc3MoZmlsZVBhdGgsIGZ1bmN0aW9uKGVycikge1xuICogICAgICAgICBjYWxsYmFjayhudWxsLCAhZXJyKVxuICogICAgIH0pO1xuICogfSwgZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7XG4gKiAgICAgLy8gcmVzdWx0cyBub3cgZXF1YWxzIGFuIGFycmF5IG9mIG1pc3NpbmcgZmlsZXNcbiAqICAgICBjcmVhdGVGaWxlcyhyZXN1bHRzKTtcbiAqIH0pO1xuICovXG5leHBvcnQgZGVmYXVsdCBkb1BhcmFsbGVsKHJlamVjdCk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vLi4vLi4vLi4vfi9hc3luYy1lcy9yZWplY3QuanMiLCJpbXBvcnQgcmVqZWN0IGZyb20gJy4vaW50ZXJuYWwvcmVqZWN0JztcbmltcG9ydCBkb1BhcmFsbGVsTGltaXQgZnJvbSAnLi9pbnRlcm5hbC9kb1BhcmFsbGVsTGltaXQnO1xuXG4vKipcbiAqIFRoZSBzYW1lIGFzIFtgcmVqZWN0YF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLnJlamVjdH0gYnV0IHJ1bnMgYSBtYXhpbXVtIG9mIGBsaW1pdGAgYXN5bmMgb3BlcmF0aW9ucyBhdCBhXG4gKiB0aW1lLlxuICpcbiAqIEBuYW1lIHJlamVjdExpbWl0XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5yZWplY3Rde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5yZWplY3R9XG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBIHRydXRoIHRlc3QgdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluIGBjb2xsYC5cbiAqIFRoZSBgaXRlcmF0ZWVgIGlzIHBhc3NlZCBhIGBjYWxsYmFjayhlcnIsIHRydXRoVmFsdWUpYCwgd2hpY2ggbXVzdCBiZSBjYWxsZWRcbiAqIHdpdGggYSBib29sZWFuIGFyZ3VtZW50IG9uY2UgaXQgaGFzIGNvbXBsZXRlZC4gSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgYWxsIHRoZVxuICogYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZC4gSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdHMpLlxuICovXG5leHBvcnQgZGVmYXVsdCBkb1BhcmFsbGVsTGltaXQocmVqZWN0KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi8uLi8uLi8uLi9+L2FzeW5jLWVzL3JlamVjdExpbWl0LmpzIiwiaW1wb3J0IHJlamVjdExpbWl0IGZyb20gJy4vcmVqZWN0TGltaXQnO1xuaW1wb3J0IGRvTGltaXQgZnJvbSAnLi9pbnRlcm5hbC9kb0xpbWl0JztcblxuLyoqXG4gKiBUaGUgc2FtZSBhcyBbYHJlamVjdGBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5yZWplY3R9IGJ1dCBydW5zIG9ubHkgYSBzaW5nbGUgYXN5bmMgb3BlcmF0aW9uIGF0IGEgdGltZS5cbiAqXG4gKiBAbmFtZSByZWplY3RTZXJpZXNcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLnJlamVjdF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLnJlamVjdH1cbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEEgdHJ1dGggdGVzdCB0byBhcHBseSB0byBlYWNoIGl0ZW0gaW4gYGNvbGxgLlxuICogVGhlIGBpdGVyYXRlZWAgaXMgcGFzc2VkIGEgYGNhbGxiYWNrKGVyciwgdHJ1dGhWYWx1ZSlgLCB3aGljaCBtdXN0IGJlIGNhbGxlZFxuICogd2l0aCBhIGJvb2xlYW4gYXJndW1lbnQgb25jZSBpdCBoYXMgY29tcGxldGVkLiBJbnZva2VkIHdpdGggKGl0ZW0sIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhZnRlciBhbGwgdGhlXG4gKiBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0cykuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGRvTGltaXQocmVqZWN0TGltaXQsIDEpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uLy4uLy4uLy4uL34vYXN5bmMtZXMvcmVqZWN0U2VyaWVzLmpzIiwiLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGB2YWx1ZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJldHVybiBmcm9tIHRoZSBuZXcgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb25zdGFudCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBfLnRpbWVzKDIsIF8uY29uc3RhbnQoeyAnYSc6IDEgfSkpO1xuICpcbiAqIGNvbnNvbGUubG9nKG9iamVjdHMpO1xuICogLy8gPT4gW3sgJ2EnOiAxIH0sIHsgJ2EnOiAxIH1dXG4gKlxuICogY29uc29sZS5sb2cob2JqZWN0c1swXSA9PT0gb2JqZWN0c1sxXSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGNvbnN0YW50KHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNvbnN0YW50O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uLy4uLy4uLy4uL34vbG9kYXNoLWVzL2NvbnN0YW50LmpzIiwiaW1wb3J0IHJldHJ5IGZyb20gJy4vcmV0cnknO1xuaW1wb3J0IGluaXRpYWxQYXJhbXMgZnJvbSAnLi9pbnRlcm5hbC9pbml0aWFsUGFyYW1zJztcblxuLyoqXG4gKiBBIGNsb3NlIHJlbGF0aXZlIG9mIFtgcmV0cnlgXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cucmV0cnl9LiAgVGhpcyBtZXRob2Qgd3JhcHMgYSB0YXNrIGFuZCBtYWtlcyBpdFxuICogcmV0cnlhYmxlLCByYXRoZXIgdGhhbiBpbW1lZGlhdGVseSBjYWxsaW5nIGl0IHdpdGggcmV0cmllcy5cbiAqXG4gKiBAbmFtZSByZXRyeWFibGVcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3dcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLnJldHJ5XXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cucmV0cnl9XG4gKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93XG4gKiBAcGFyYW0ge09iamVjdHxudW1iZXJ9IFtvcHRzID0ge3RpbWVzOiA1LCBpbnRlcnZhbDogMH18IDVdIC0gb3B0aW9uYWxcbiAqIG9wdGlvbnMsIGV4YWN0bHkgdGhlIHNhbWUgYXMgZnJvbSBgcmV0cnlgXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0YXNrIC0gdGhlIGFzeW5jaHJvbm91cyBmdW5jdGlvbiB0byB3cmFwXG4gKiBAcmV0dXJucyB7RnVuY3Rpb25zfSBUaGUgd3JhcHBlZCBmdW5jdGlvbiwgd2hpY2ggd2hlbiBpbnZva2VkLCB3aWxsIHJldHJ5IG9uXG4gKiBhbiBlcnJvciwgYmFzZWQgb24gdGhlIHBhcmFtZXRlcnMgc3BlY2lmaWVkIGluIGBvcHRzYC5cbiAqIEBleGFtcGxlXG4gKlxuICogYXN5bmMuYXV0byh7XG4gKiAgICAgZGVwMTogYXN5bmMucmV0cnlhYmxlKDMsIGdldEZyb21GbGFreVNlcnZpY2UpLFxuICogICAgIHByb2Nlc3M6IFtcImRlcDFcIiwgYXN5bmMucmV0cnlhYmxlKDMsIGZ1bmN0aW9uIChyZXN1bHRzLCBjYikge1xuICogICAgICAgICBtYXliZVByb2Nlc3NEYXRhKHJlc3VsdHMuZGVwMSwgY2IpO1xuICogICAgIH0pXVxuICogfSwgY2FsbGJhY2spO1xuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAob3B0cywgdGFzaykge1xuICAgIGlmICghdGFzaykge1xuICAgICAgICB0YXNrID0gb3B0cztcbiAgICAgICAgb3B0cyA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBpbml0aWFsUGFyYW1zKGZ1bmN0aW9uIChhcmdzLCBjYWxsYmFjaykge1xuICAgICAgICBmdW5jdGlvbiB0YXNrRm4oY2IpIHtcbiAgICAgICAgICAgIHRhc2suYXBwbHkobnVsbCwgYXJncy5jb25jYXQoY2IpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRzKSByZXRyeShvcHRzLCB0YXNrRm4sIGNhbGxiYWNrKTtcbiAgICAgICAgZWxzZSByZXRyeSh0YXNrRm4sIGNhbGxiYWNrKTtcblxuICAgIH0pO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uLy4uLy4uLy4uL34vYXN5bmMtZXMvcmV0cnlhYmxlLmpzIiwiaW1wb3J0IGNyZWF0ZVRlc3RlciBmcm9tICcuL2ludGVybmFsL2NyZWF0ZVRlc3Rlcic7XG5pbXBvcnQgZG9QYXJhbGxlbCBmcm9tICcuL2ludGVybmFsL2RvUGFyYWxsZWwnO1xuaW1wb3J0IGlkZW50aXR5IGZyb20gJ2xvZGFzaC1lcy9pZGVudGl0eSc7XG5cbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgYXQgbGVhc3Qgb25lIGVsZW1lbnQgaW4gdGhlIGBjb2xsYCBzYXRpc2ZpZXMgYW4gYXN5bmMgdGVzdC5cbiAqIElmIGFueSBpdGVyYXRlZSBjYWxsIHJldHVybnMgYHRydWVgLCB0aGUgbWFpbiBgY2FsbGJhY2tgIGlzIGltbWVkaWF0ZWx5XG4gKiBjYWxsZWQuXG4gKlxuICogQG5hbWUgc29tZVxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICogQG1ldGhvZFxuICogQGFsaWFzIGFueVxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIC0gQSB0cnV0aCB0ZXN0IHRvIGFwcGx5IHRvIGVhY2ggaXRlbSBpbiB0aGUgYXJyYXlcbiAqIGluIHBhcmFsbGVsLiBUaGUgaXRlcmF0ZWUgaXMgcGFzc2VkIGEgYGNhbGxiYWNrKGVyciwgdHJ1dGhWYWx1ZSlgIHdoaWNoIG11c3RcbiAqIGJlIGNhbGxlZCB3aXRoIGEgYm9vbGVhbiBhcmd1bWVudCBvbmNlIGl0IGhhcyBjb21wbGV0ZWQuIEludm9rZWQgd2l0aFxuICogKGl0ZW0sIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhcyBzb29uIGFzIGFueVxuICogaXRlcmF0ZWUgcmV0dXJucyBgdHJ1ZWAsIG9yIGFmdGVyIGFsbCB0aGUgaXRlcmF0ZWUgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQuXG4gKiBSZXN1bHQgd2lsbCBiZSBlaXRoZXIgYHRydWVgIG9yIGBmYWxzZWAgZGVwZW5kaW5nIG9uIHRoZSB2YWx1ZXMgb2YgdGhlIGFzeW5jXG4gKiB0ZXN0cy4gSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdCkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGFzeW5jLnNvbWUoWydmaWxlMScsJ2ZpbGUyJywnZmlsZTMnXSwgZnVuY3Rpb24oZmlsZVBhdGgsIGNhbGxiYWNrKSB7XG4gKiAgICAgZnMuYWNjZXNzKGZpbGVQYXRoLCBmdW5jdGlvbihlcnIpIHtcbiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgIWVycilcbiAqICAgICB9KTtcbiAqIH0sIGZ1bmN0aW9uKGVyciwgcmVzdWx0KSB7XG4gKiAgICAgLy8gaWYgcmVzdWx0IGlzIHRydWUgdGhlbiBhdCBsZWFzdCBvbmUgb2YgdGhlIGZpbGVzIGV4aXN0c1xuICogfSk7XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGRvUGFyYWxsZWwoY3JlYXRlVGVzdGVyKEJvb2xlYW4sIGlkZW50aXR5KSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vLi4vLi4vLi4vfi9hc3luYy1lcy9zb21lLmpzIiwiaW1wb3J0IGNyZWF0ZVRlc3RlciBmcm9tICcuL2ludGVybmFsL2NyZWF0ZVRlc3Rlcic7XG5pbXBvcnQgZG9QYXJhbGxlbExpbWl0IGZyb20gJy4vaW50ZXJuYWwvZG9QYXJhbGxlbExpbWl0JztcbmltcG9ydCBpZGVudGl0eSBmcm9tICdsb2Rhc2gtZXMvaWRlbnRpdHknO1xuXG4vKipcbiAqIFRoZSBzYW1lIGFzIFtgc29tZWBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5zb21lfSBidXQgcnVucyBhIG1heGltdW0gb2YgYGxpbWl0YCBhc3luYyBvcGVyYXRpb25zIGF0IGEgdGltZS5cbiAqXG4gKiBAbmFtZSBzb21lTGltaXRcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLnNvbWVde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5zb21lfVxuICogQGFsaWFzIGFueUxpbWl0XG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBIHRydXRoIHRlc3QgdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluIHRoZSBhcnJheVxuICogaW4gcGFyYWxsZWwuIFRoZSBpdGVyYXRlZSBpcyBwYXNzZWQgYSBgY2FsbGJhY2soZXJyLCB0cnV0aFZhbHVlKWAgd2hpY2ggbXVzdFxuICogYmUgY2FsbGVkIHdpdGggYSBib29sZWFuIGFyZ3VtZW50IG9uY2UgaXQgaGFzIGNvbXBsZXRlZC4gSW52b2tlZCB3aXRoXG4gKiAoaXRlbSwgY2FsbGJhY2spLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFzIHNvb24gYXMgYW55XG4gKiBpdGVyYXRlZSByZXR1cm5zIGB0cnVlYCwgb3IgYWZ0ZXIgYWxsIHRoZSBpdGVyYXRlZSBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZC5cbiAqIFJlc3VsdCB3aWxsIGJlIGVpdGhlciBgdHJ1ZWAgb3IgYGZhbHNlYCBkZXBlbmRpbmcgb24gdGhlIHZhbHVlcyBvZiB0aGUgYXN5bmNcbiAqIHRlc3RzLiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0KS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZG9QYXJhbGxlbExpbWl0KGNyZWF0ZVRlc3RlcihCb29sZWFuLCBpZGVudGl0eSkpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uLy4uLy4uLy4uL34vYXN5bmMtZXMvc29tZUxpbWl0LmpzIiwiaW1wb3J0IHNvbWVMaW1pdCBmcm9tICcuL3NvbWVMaW1pdCc7XG5pbXBvcnQgZG9MaW1pdCBmcm9tICcuL2ludGVybmFsL2RvTGltaXQnO1xuXG4vKipcbiAqIFRoZSBzYW1lIGFzIFtgc29tZWBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5zb21lfSBidXQgcnVucyBvbmx5IGEgc2luZ2xlIGFzeW5jIG9wZXJhdGlvbiBhdCBhIHRpbWUuXG4gKlxuICogQG5hbWUgc29tZVNlcmllc1xuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICogQG1ldGhvZFxuICogQHNlZSBbYXN5bmMuc29tZV17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLnNvbWV9XG4gKiBAYWxpYXMgYW55U2VyaWVzXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBIHRydXRoIHRlc3QgdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluIHRoZSBhcnJheVxuICogaW4gcGFyYWxsZWwuIFRoZSBpdGVyYXRlZSBpcyBwYXNzZWQgYSBgY2FsbGJhY2soZXJyLCB0cnV0aFZhbHVlKWAgd2hpY2ggbXVzdFxuICogYmUgY2FsbGVkIHdpdGggYSBib29sZWFuIGFyZ3VtZW50IG9uY2UgaXQgaGFzIGNvbXBsZXRlZC4gSW52b2tlZCB3aXRoXG4gKiAoaXRlbSwgY2FsbGJhY2spLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFzIHNvb24gYXMgYW55XG4gKiBpdGVyYXRlZSByZXR1cm5zIGB0cnVlYCwgb3IgYWZ0ZXIgYWxsIHRoZSBpdGVyYXRlZSBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZC5cbiAqIFJlc3VsdCB3aWxsIGJlIGVpdGhlciBgdHJ1ZWAgb3IgYGZhbHNlYCBkZXBlbmRpbmcgb24gdGhlIHZhbHVlcyBvZiB0aGUgYXN5bmNcbiAqIHRlc3RzLiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0KS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZG9MaW1pdChzb21lTGltaXQsIDEpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uLy4uLy4uLy4uL34vYXN5bmMtZXMvc29tZVNlcmllcy5qcyIsIi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVDZWlsID0gTWF0aC5jZWlsLFxuICAgIG5hdGl2ZU1heCA9IE1hdGgubWF4O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJhbmdlYCBhbmQgYF8ucmFuZ2VSaWdodGAgd2hpY2ggZG9lc24ndFxuICogY29lcmNlIGFyZ3VtZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFRoZSBzdGFydCBvZiB0aGUgcmFuZ2UuXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSBlbmQgb2YgdGhlIHJhbmdlLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0ZXAgVGhlIHZhbHVlIHRvIGluY3JlbWVudCBvciBkZWNyZW1lbnQgYnkuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcmFuZ2Ugb2YgbnVtYmVycy5cbiAqL1xuZnVuY3Rpb24gYmFzZVJhbmdlKHN0YXJ0LCBlbmQsIHN0ZXAsIGZyb21SaWdodCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IG5hdGl2ZU1heChuYXRpdmVDZWlsKChlbmQgLSBzdGFydCkgLyAoc3RlcCB8fCAxKSksIDApLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICByZXN1bHRbZnJvbVJpZ2h0ID8gbGVuZ3RoIDogKytpbmRleF0gPSBzdGFydDtcbiAgICBzdGFydCArPSBzdGVwO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VSYW5nZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi8uLi8uLi8uLi9+L2xvZGFzaC1lcy9fYmFzZVJhbmdlLmpzIiwiaW1wb3J0IHRpbWVzTGltaXQgZnJvbSAnLi90aW1lc0xpbWl0JztcbmltcG9ydCBkb0xpbWl0IGZyb20gJy4vaW50ZXJuYWwvZG9MaW1pdCc7XG5cbi8qKlxuICogQ2FsbHMgdGhlIGBpdGVyYXRlZWAgZnVuY3Rpb24gYG5gIHRpbWVzLCBhbmQgYWNjdW11bGF0ZXMgcmVzdWx0cyBpbiB0aGUgc2FtZVxuICogbWFubmVyIHlvdSB3b3VsZCB1c2Ugd2l0aCBbbWFwXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMubWFwfS5cbiAqXG4gKiBAbmFtZSB0aW1lc1xuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvd1xuICogQG1ldGhvZFxuICogQHNlZSBbYXN5bmMubWFwXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMubWFwfVxuICogQGNhdGVnb3J5IENvbnRyb2wgRmxvd1xuICogQHBhcmFtIHtudW1iZXJ9IG4gLSBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIHJ1biB0aGUgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSAtIFRoZSBmdW5jdGlvbiB0byBjYWxsIGBuYCB0aW1lcy4gSW52b2tlZCB3aXRoIHRoZVxuICogaXRlcmF0aW9uIGluZGV4IGFuZCBhIGNhbGxiYWNrIChuLCBuZXh0KS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gc2VlIHtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMubWFwfS5cbiAqIEBleGFtcGxlXG4gKlxuICogLy8gUHJldGVuZCB0aGlzIGlzIHNvbWUgY29tcGxpY2F0ZWQgYXN5bmMgZmFjdG9yeVxuICogdmFyIGNyZWF0ZVVzZXIgPSBmdW5jdGlvbihpZCwgY2FsbGJhY2spIHtcbiAqICAgICBjYWxsYmFjayhudWxsLCB7XG4gKiAgICAgICAgIGlkOiAndXNlcicgKyBpZFxuICogICAgIH0pO1xuICogfTtcbiAqXG4gKiAvLyBnZW5lcmF0ZSA1IHVzZXJzXG4gKiBhc3luYy50aW1lcyg1LCBmdW5jdGlvbihuLCBuZXh0KSB7XG4gKiAgICAgY3JlYXRlVXNlcihuLCBmdW5jdGlvbihlcnIsIHVzZXIpIHtcbiAqICAgICAgICAgbmV4dChlcnIsIHVzZXIpO1xuICogICAgIH0pO1xuICogfSwgZnVuY3Rpb24oZXJyLCB1c2Vycykge1xuICogICAgIC8vIHdlIHNob3VsZCBub3cgaGF2ZSA1IHVzZXJzXG4gKiB9KTtcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZG9MaW1pdCh0aW1lc0xpbWl0LCBJbmZpbml0eSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vLi4vLi4vLi4vfi9hc3luYy1lcy90aW1lcy5qcyIsImltcG9ydCB0aW1lc0xpbWl0IGZyb20gJy4vdGltZXNMaW1pdCc7XG5pbXBvcnQgZG9MaW1pdCBmcm9tICcuL2ludGVybmFsL2RvTGltaXQnO1xuXG4vKipcbiAqIFRoZSBzYW1lIGFzIFt0aW1lc117QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LnRpbWVzfSBidXQgcnVucyBvbmx5IGEgc2luZ2xlIGFzeW5jIG9wZXJhdGlvbiBhdCBhIHRpbWUuXG4gKlxuICogQG5hbWUgdGltZXNTZXJpZXNcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3dcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLnRpbWVzXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cudGltZXN9XG4gKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93XG4gKiBAcGFyYW0ge251bWJlcn0gbiAtIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gcnVuIHRoZSBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIC0gVGhlIGZ1bmN0aW9uIHRvIGNhbGwgYG5gIHRpbWVzLiBJbnZva2VkIHdpdGggdGhlXG4gKiBpdGVyYXRpb24gaW5kZXggYW5kIGEgY2FsbGJhY2sgKG4sIG5leHQpLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBzZWUge0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5tYXB9LlxuICovXG5leHBvcnQgZGVmYXVsdCBkb0xpbWl0KHRpbWVzTGltaXQsIDEpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uLy4uLy4uLy4uL34vYXN5bmMtZXMvdGltZXNTZXJpZXMuanMiLCIvKipcbiAqIFVuZG9lcyBhIFttZW1vaXplXXtAbGluayBtb2R1bGU6VXRpbHMubWVtb2l6ZX1kIGZ1bmN0aW9uLCByZXZlcnRpbmcgaXQgdG8gdGhlIG9yaWdpbmFsLFxuICogdW5tZW1vaXplZCBmb3JtLiBIYW5keSBmb3IgdGVzdGluZy5cbiAqXG4gKiBAbmFtZSB1bm1lbW9pemVcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6VXRpbHNcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLm1lbW9pemVde0BsaW5rIG1vZHVsZTpVdGlscy5tZW1vaXplfVxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gdGhlIG1lbW9pemVkIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IGEgZnVuY3Rpb24gdGhhdCBjYWxscyB0aGUgb3JpZ2luYWwgdW5tZW1vaXplZCBmdW5jdGlvblxuICovXG5leHBvcnQgZGVmYXVsdCAgZnVuY3Rpb24gdW5tZW1vaXplKGZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChmbi51bm1lbW9pemVkIHx8IGZuKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH07XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vLi4vLi4vLi4vfi9hc3luYy1lcy91bm1lbW9pemUuanMiLCJpbXBvcnQgaXNBcnJheSBmcm9tICdsb2Rhc2gtZXMvaXNBcnJheSc7XG5pbXBvcnQgbm9vcCBmcm9tICdsb2Rhc2gtZXMvbm9vcCc7XG5pbXBvcnQgb25jZSBmcm9tICcuL2ludGVybmFsL29uY2UnO1xuaW1wb3J0IHJlc3QgZnJvbSAnLi9pbnRlcm5hbC9yZXN0JztcblxuaW1wb3J0IG9ubHlPbmNlIGZyb20gJy4vaW50ZXJuYWwvb25seU9uY2UnO1xuXG4vKipcbiAqIFJ1bnMgdGhlIGB0YXNrc2AgYXJyYXkgb2YgZnVuY3Rpb25zIGluIHNlcmllcywgZWFjaCBwYXNzaW5nIHRoZWlyIHJlc3VsdHMgdG9cbiAqIHRoZSBuZXh0IGluIHRoZSBhcnJheS4gSG93ZXZlciwgaWYgYW55IG9mIHRoZSBgdGFza3NgIHBhc3MgYW4gZXJyb3IgdG8gdGhlaXJcbiAqIG93biBjYWxsYmFjaywgdGhlIG5leHQgZnVuY3Rpb24gaXMgbm90IGV4ZWN1dGVkLCBhbmQgdGhlIG1haW4gYGNhbGxiYWNrYCBpc1xuICogaW1tZWRpYXRlbHkgY2FsbGVkIHdpdGggdGhlIGVycm9yLlxuICpcbiAqIEBuYW1lIHdhdGVyZmFsbFxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvd1xuICogQG1ldGhvZFxuICogQGNhdGVnb3J5IENvbnRyb2wgRmxvd1xuICogQHBhcmFtIHtBcnJheX0gdGFza3MgLSBBbiBhcnJheSBvZiBmdW5jdGlvbnMgdG8gcnVuLCBlYWNoIGZ1bmN0aW9uIGlzIHBhc3NlZFxuICogYSBgY2FsbGJhY2soZXJyLCByZXN1bHQxLCByZXN1bHQyLCAuLi4pYCBpdCBtdXN0IGNhbGwgb24gY29tcGxldGlvbi4gVGhlXG4gKiBmaXJzdCBhcmd1bWVudCBpcyBhbiBlcnJvciAod2hpY2ggY2FuIGJlIGBudWxsYCkgYW5kIGFueSBmdXJ0aGVyIGFyZ3VtZW50c1xuICogd2lsbCBiZSBwYXNzZWQgYXMgYXJndW1lbnRzIGluIG9yZGVyIHRvIHRoZSBuZXh0IHRhc2suXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQW4gb3B0aW9uYWwgY2FsbGJhY2sgdG8gcnVuIG9uY2UgYWxsIHRoZVxuICogZnVuY3Rpb25zIGhhdmUgY29tcGxldGVkLiBUaGlzIHdpbGwgYmUgcGFzc2VkIHRoZSByZXN1bHRzIG9mIHRoZSBsYXN0IHRhc2snc1xuICogY2FsbGJhY2suIEludm9rZWQgd2l0aCAoZXJyLCBbcmVzdWx0c10pLlxuICogQHJldHVybnMgdW5kZWZpbmVkXG4gKiBAZXhhbXBsZVxuICpcbiAqIGFzeW5jLndhdGVyZmFsbChbXG4gKiAgICAgZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ29uZScsICd0d28nKTtcbiAqICAgICB9LFxuICogICAgIGZ1bmN0aW9uKGFyZzEsIGFyZzIsIGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIC8vIGFyZzEgbm93IGVxdWFscyAnb25lJyBhbmQgYXJnMiBub3cgZXF1YWxzICd0d28nXG4gKiAgICAgICAgIGNhbGxiYWNrKG51bGwsICd0aHJlZScpO1xuICogICAgIH0sXG4gKiAgICAgZnVuY3Rpb24oYXJnMSwgY2FsbGJhY2spIHtcbiAqICAgICAgICAgLy8gYXJnMSBub3cgZXF1YWxzICd0aHJlZSdcbiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ2RvbmUnKTtcbiAqICAgICB9XG4gKiBdLCBmdW5jdGlvbiAoZXJyLCByZXN1bHQpIHtcbiAqICAgICAvLyByZXN1bHQgbm93IGVxdWFscyAnZG9uZSdcbiAqIH0pO1xuICpcbiAqIC8vIE9yLCB3aXRoIG5hbWVkIGZ1bmN0aW9uczpcbiAqIGFzeW5jLndhdGVyZmFsbChbXG4gKiAgICAgbXlGaXJzdEZ1bmN0aW9uLFxuICogICAgIG15U2Vjb25kRnVuY3Rpb24sXG4gKiAgICAgbXlMYXN0RnVuY3Rpb24sXG4gKiBdLCBmdW5jdGlvbiAoZXJyLCByZXN1bHQpIHtcbiAqICAgICAvLyByZXN1bHQgbm93IGVxdWFscyAnZG9uZSdcbiAqIH0pO1xuICogZnVuY3Rpb24gbXlGaXJzdEZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gKiAgICAgY2FsbGJhY2sobnVsbCwgJ29uZScsICd0d28nKTtcbiAqIH1cbiAqIGZ1bmN0aW9uIG15U2Vjb25kRnVuY3Rpb24oYXJnMSwgYXJnMiwgY2FsbGJhY2spIHtcbiAqICAgICAvLyBhcmcxIG5vdyBlcXVhbHMgJ29uZScgYW5kIGFyZzIgbm93IGVxdWFscyAndHdvJ1xuICogICAgIGNhbGxiYWNrKG51bGwsICd0aHJlZScpO1xuICogfVxuICogZnVuY3Rpb24gbXlMYXN0RnVuY3Rpb24oYXJnMSwgY2FsbGJhY2spIHtcbiAqICAgICAvLyBhcmcxIG5vdyBlcXVhbHMgJ3RocmVlJ1xuICogICAgIGNhbGxiYWNrKG51bGwsICdkb25lJyk7XG4gKiB9XG4gKi9cbmV4cG9ydCBkZWZhdWx0ICBmdW5jdGlvbih0YXNrcywgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IG9uY2UoY2FsbGJhY2sgfHwgbm9vcCk7XG4gICAgaWYgKCFpc0FycmF5KHRhc2tzKSkgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcignRmlyc3QgYXJndW1lbnQgdG8gd2F0ZXJmYWxsIG11c3QgYmUgYW4gYXJyYXkgb2YgZnVuY3Rpb25zJykpO1xuICAgIGlmICghdGFza3MubGVuZ3RoKSByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB2YXIgdGFza0luZGV4ID0gMDtcblxuICAgIGZ1bmN0aW9uIG5leHRUYXNrKGFyZ3MpIHtcbiAgICAgICAgaWYgKHRhc2tJbmRleCA9PT0gdGFza3MubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkobnVsbCwgW251bGxdLmNvbmNhdChhcmdzKSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdGFza0NhbGxiYWNrID0gb25seU9uY2UocmVzdChmdW5jdGlvbihlcnIsIGFyZ3MpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkobnVsbCwgW2Vycl0uY29uY2F0KGFyZ3MpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5leHRUYXNrKGFyZ3MpO1xuICAgICAgICB9KSk7XG5cbiAgICAgICAgYXJncy5wdXNoKHRhc2tDYWxsYmFjayk7XG5cbiAgICAgICAgdmFyIHRhc2sgPSB0YXNrc1t0YXNrSW5kZXgrK107XG4gICAgICAgIHRhc2suYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfVxuXG4gICAgbmV4dFRhc2soW10pO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uLy4uLy4uLy4uL34vYXN5bmMtZXMvd2F0ZXJmYWxsLmpzIiwiLyoqXG4gKiBBc3luYyBpcyBhIHV0aWxpdHkgbW9kdWxlIHdoaWNoIHByb3ZpZGVzIHN0cmFpZ2h0LWZvcndhcmQsIHBvd2VyZnVsIGZ1bmN0aW9uc1xuICogZm9yIHdvcmtpbmcgd2l0aCBhc3luY2hyb25vdXMgSmF2YVNjcmlwdC4gQWx0aG91Z2ggb3JpZ2luYWxseSBkZXNpZ25lZCBmb3JcbiAqIHVzZSB3aXRoIFtOb2RlLmpzXShodHRwOi8vbm9kZWpzLm9yZykgYW5kIGluc3RhbGxhYmxlIHZpYVxuICogYG5wbSBpbnN0YWxsIC0tc2F2ZSBhc3luY2AsIGl0IGNhbiBhbHNvIGJlIHVzZWQgZGlyZWN0bHkgaW4gdGhlIGJyb3dzZXIuXG4gKiBAbW9kdWxlIGFzeW5jXG4gKi9cblxuLyoqXG4gKiBBIGNvbGxlY3Rpb24gb2YgYGFzeW5jYCBmdW5jdGlvbnMgZm9yIG1hbmlwdWxhdGluZyBjb2xsZWN0aW9ucywgc3VjaCBhc1xuICogYXJyYXlzIGFuZCBvYmplY3RzLlxuICogQG1vZHVsZSBDb2xsZWN0aW9uc1xuICovXG5cbi8qKlxuICogQSBjb2xsZWN0aW9uIG9mIGBhc3luY2AgZnVuY3Rpb25zIGZvciBjb250cm9sbGluZyB0aGUgZmxvdyB0aHJvdWdoIGEgc2NyaXB0LlxuICogQG1vZHVsZSBDb250cm9sRmxvd1xuICovXG5cbiAvKipcbiAgKiBBIGNvbGxlY3Rpb24gb2YgYGFzeW5jYCB1dGlsaXR5IGZ1bmN0aW9ucy5cbiAgKiBAbW9kdWxlIFV0aWxzXG4gICovXG5pbXBvcnQgYXBwbHlFYWNoIGZyb20gJy4vYXBwbHlFYWNoJztcbmltcG9ydCBhcHBseUVhY2hTZXJpZXMgZnJvbSAnLi9hcHBseUVhY2hTZXJpZXMnO1xuaW1wb3J0IGFwcGx5IGZyb20gJy4vYXBwbHknO1xuaW1wb3J0IGFzeW5jaWZ5IGZyb20gJy4vYXN5bmNpZnknO1xuaW1wb3J0IGF1dG8gZnJvbSAnLi9hdXRvJztcbmltcG9ydCBhdXRvSW5qZWN0IGZyb20gJy4vYXV0b0luamVjdCc7XG5pbXBvcnQgY2FyZ28gZnJvbSAnLi9jYXJnbyc7XG5pbXBvcnQgY29tcG9zZSBmcm9tICcuL2NvbXBvc2UnO1xuaW1wb3J0IGNvbmNhdCBmcm9tICcuL2NvbmNhdCc7XG5pbXBvcnQgY29uY2F0U2VyaWVzIGZyb20gJy4vY29uY2F0U2VyaWVzJztcbmltcG9ydCBjb25zdGFudCBmcm9tICcuL2NvbnN0YW50JztcbmltcG9ydCBkZXRlY3QgZnJvbSAnLi9kZXRlY3QnO1xuaW1wb3J0IGRldGVjdExpbWl0IGZyb20gJy4vZGV0ZWN0TGltaXQnO1xuaW1wb3J0IGRldGVjdFNlcmllcyBmcm9tICcuL2RldGVjdFNlcmllcyc7XG5pbXBvcnQgZGlyIGZyb20gJy4vZGlyJztcbmltcG9ydCBkb0R1cmluZyBmcm9tICcuL2RvRHVyaW5nJztcbmltcG9ydCBkb1VudGlsIGZyb20gJy4vZG9VbnRpbCc7XG5pbXBvcnQgZG9XaGlsc3QgZnJvbSAnLi9kb1doaWxzdCc7XG5pbXBvcnQgZHVyaW5nIGZyb20gJy4vZHVyaW5nJztcbmltcG9ydCBlYWNoIGZyb20gJy4vZWFjaCc7XG5pbXBvcnQgZWFjaExpbWl0IGZyb20gJy4vZWFjaExpbWl0JztcbmltcG9ydCBlYWNoT2YgZnJvbSAnLi9lYWNoT2YnO1xuaW1wb3J0IGVhY2hPZkxpbWl0IGZyb20gJy4vZWFjaE9mTGltaXQnO1xuaW1wb3J0IGVhY2hPZlNlcmllcyBmcm9tICcuL2VhY2hPZlNlcmllcyc7XG5pbXBvcnQgZWFjaFNlcmllcyBmcm9tICcuL2VhY2hTZXJpZXMnO1xuaW1wb3J0IGVuc3VyZUFzeW5jIGZyb20gJy4vZW5zdXJlQXN5bmMnO1xuaW1wb3J0IGV2ZXJ5IGZyb20gJy4vZXZlcnknO1xuaW1wb3J0IGV2ZXJ5TGltaXQgZnJvbSAnLi9ldmVyeUxpbWl0JztcbmltcG9ydCBldmVyeVNlcmllcyBmcm9tICcuL2V2ZXJ5U2VyaWVzJztcbmltcG9ydCBmaWx0ZXIgZnJvbSAnLi9maWx0ZXInO1xuaW1wb3J0IGZpbHRlckxpbWl0IGZyb20gJy4vZmlsdGVyTGltaXQnO1xuaW1wb3J0IGZpbHRlclNlcmllcyBmcm9tICcuL2ZpbHRlclNlcmllcyc7XG5pbXBvcnQgZm9yZXZlciBmcm9tICcuL2ZvcmV2ZXInO1xuaW1wb3J0IGxvZyBmcm9tICcuL2xvZyc7XG5pbXBvcnQgbWFwIGZyb20gJy4vbWFwJztcbmltcG9ydCBtYXBMaW1pdCBmcm9tICcuL21hcExpbWl0JztcbmltcG9ydCBtYXBTZXJpZXMgZnJvbSAnLi9tYXBTZXJpZXMnO1xuaW1wb3J0IG1hcFZhbHVlcyBmcm9tICcuL21hcFZhbHVlcyc7XG5pbXBvcnQgbWFwVmFsdWVzTGltaXQgZnJvbSAnLi9tYXBWYWx1ZXNMaW1pdCc7XG5pbXBvcnQgbWFwVmFsdWVzU2VyaWVzIGZyb20gJy4vbWFwVmFsdWVzU2VyaWVzJztcbmltcG9ydCBtZW1vaXplIGZyb20gJy4vbWVtb2l6ZSc7XG5pbXBvcnQgbmV4dFRpY2sgZnJvbSAnLi9uZXh0VGljayc7XG5pbXBvcnQgcGFyYWxsZWwgZnJvbSAnLi9wYXJhbGxlbCc7XG5pbXBvcnQgcGFyYWxsZWxMaW1pdCBmcm9tICcuL3BhcmFsbGVsTGltaXQnO1xuaW1wb3J0IHByaW9yaXR5UXVldWUgZnJvbSAnLi9wcmlvcml0eVF1ZXVlJztcbmltcG9ydCBxdWV1ZSBmcm9tICcuL3F1ZXVlJztcbmltcG9ydCByYWNlIGZyb20gJy4vcmFjZSc7XG5pbXBvcnQgcmVkdWNlIGZyb20gJy4vcmVkdWNlJztcbmltcG9ydCByZWR1Y2VSaWdodCBmcm9tICcuL3JlZHVjZVJpZ2h0JztcbmltcG9ydCByZWZsZWN0IGZyb20gJy4vcmVmbGVjdCc7XG5pbXBvcnQgcmVqZWN0IGZyb20gJy4vcmVqZWN0JztcbmltcG9ydCByZWZsZWN0QWxsIGZyb20gJy4vcmVmbGVjdEFsbCc7XG5pbXBvcnQgcmVqZWN0TGltaXQgZnJvbSAnLi9yZWplY3RMaW1pdCc7XG5pbXBvcnQgcmVqZWN0U2VyaWVzIGZyb20gJy4vcmVqZWN0U2VyaWVzJztcbmltcG9ydCByZXRyeSBmcm9tICcuL3JldHJ5JztcbmltcG9ydCByZXRyeWFibGUgZnJvbSAnLi9yZXRyeWFibGUnO1xuaW1wb3J0IHNlcSBmcm9tICcuL3NlcSc7XG5pbXBvcnQgc2VyaWVzIGZyb20gJy4vc2VyaWVzJztcbmltcG9ydCBzZXRJbW1lZGlhdGUgZnJvbSAnLi9zZXRJbW1lZGlhdGUnO1xuaW1wb3J0IHNvbWUgZnJvbSAnLi9zb21lJztcbmltcG9ydCBzb21lTGltaXQgZnJvbSAnLi9zb21lTGltaXQnO1xuaW1wb3J0IHNvbWVTZXJpZXMgZnJvbSAnLi9zb21lU2VyaWVzJztcbmltcG9ydCBzb3J0QnkgZnJvbSAnLi9zb3J0QnknO1xuaW1wb3J0IHRpbWVvdXQgZnJvbSAnLi90aW1lb3V0JztcbmltcG9ydCB0aW1lcyBmcm9tICcuL3RpbWVzJztcbmltcG9ydCB0aW1lc0xpbWl0IGZyb20gJy4vdGltZXNMaW1pdCc7XG5pbXBvcnQgdGltZXNTZXJpZXMgZnJvbSAnLi90aW1lc1Nlcmllcyc7XG5pbXBvcnQgdHJhbnNmb3JtIGZyb20gJy4vdHJhbnNmb3JtJztcbmltcG9ydCB1bm1lbW9pemUgZnJvbSAnLi91bm1lbW9pemUnO1xuaW1wb3J0IHVudGlsIGZyb20gJy4vdW50aWwnO1xuaW1wb3J0IHdhdGVyZmFsbCBmcm9tICcuL3dhdGVyZmFsbCc7XG5pbXBvcnQgd2hpbHN0IGZyb20gJy4vd2hpbHN0JztcblxuZXhwb3J0IGRlZmF1bHQge1xuICAgIGFwcGx5RWFjaDogYXBwbHlFYWNoLFxuICAgIGFwcGx5RWFjaFNlcmllczogYXBwbHlFYWNoU2VyaWVzLFxuICAgIGFwcGx5OiBhcHBseSxcbiAgICBhc3luY2lmeTogYXN5bmNpZnksXG4gICAgYXV0bzogYXV0byxcbiAgICBhdXRvSW5qZWN0OiBhdXRvSW5qZWN0LFxuICAgIGNhcmdvOiBjYXJnbyxcbiAgICBjb21wb3NlOiBjb21wb3NlLFxuICAgIGNvbmNhdDogY29uY2F0LFxuICAgIGNvbmNhdFNlcmllczogY29uY2F0U2VyaWVzLFxuICAgIGNvbnN0YW50OiBjb25zdGFudCxcbiAgICBkZXRlY3Q6IGRldGVjdCxcbiAgICBkZXRlY3RMaW1pdDogZGV0ZWN0TGltaXQsXG4gICAgZGV0ZWN0U2VyaWVzOiBkZXRlY3RTZXJpZXMsXG4gICAgZGlyOiBkaXIsXG4gICAgZG9EdXJpbmc6IGRvRHVyaW5nLFxuICAgIGRvVW50aWw6IGRvVW50aWwsXG4gICAgZG9XaGlsc3Q6IGRvV2hpbHN0LFxuICAgIGR1cmluZzogZHVyaW5nLFxuICAgIGVhY2g6IGVhY2gsXG4gICAgZWFjaExpbWl0OiBlYWNoTGltaXQsXG4gICAgZWFjaE9mOiBlYWNoT2YsXG4gICAgZWFjaE9mTGltaXQ6IGVhY2hPZkxpbWl0LFxuICAgIGVhY2hPZlNlcmllczogZWFjaE9mU2VyaWVzLFxuICAgIGVhY2hTZXJpZXM6IGVhY2hTZXJpZXMsXG4gICAgZW5zdXJlQXN5bmM6IGVuc3VyZUFzeW5jLFxuICAgIGV2ZXJ5OiBldmVyeSxcbiAgICBldmVyeUxpbWl0OiBldmVyeUxpbWl0LFxuICAgIGV2ZXJ5U2VyaWVzOiBldmVyeVNlcmllcyxcbiAgICBmaWx0ZXI6IGZpbHRlcixcbiAgICBmaWx0ZXJMaW1pdDogZmlsdGVyTGltaXQsXG4gICAgZmlsdGVyU2VyaWVzOiBmaWx0ZXJTZXJpZXMsXG4gICAgZm9yZXZlcjogZm9yZXZlcixcbiAgICBsb2c6IGxvZyxcbiAgICBtYXA6IG1hcCxcbiAgICBtYXBMaW1pdDogbWFwTGltaXQsXG4gICAgbWFwU2VyaWVzOiBtYXBTZXJpZXMsXG4gICAgbWFwVmFsdWVzOiBtYXBWYWx1ZXMsXG4gICAgbWFwVmFsdWVzTGltaXQ6IG1hcFZhbHVlc0xpbWl0LFxuICAgIG1hcFZhbHVlc1NlcmllczogbWFwVmFsdWVzU2VyaWVzLFxuICAgIG1lbW9pemU6IG1lbW9pemUsXG4gICAgbmV4dFRpY2s6IG5leHRUaWNrLFxuICAgIHBhcmFsbGVsOiBwYXJhbGxlbCxcbiAgICBwYXJhbGxlbExpbWl0OiBwYXJhbGxlbExpbWl0LFxuICAgIHByaW9yaXR5UXVldWU6IHByaW9yaXR5UXVldWUsXG4gICAgcXVldWU6IHF1ZXVlLFxuICAgIHJhY2U6IHJhY2UsXG4gICAgcmVkdWNlOiByZWR1Y2UsXG4gICAgcmVkdWNlUmlnaHQ6IHJlZHVjZVJpZ2h0LFxuICAgIHJlZmxlY3Q6IHJlZmxlY3QsXG4gICAgcmVmbGVjdEFsbDogcmVmbGVjdEFsbCxcbiAgICByZWplY3Q6IHJlamVjdCxcbiAgICByZWplY3RMaW1pdDogcmVqZWN0TGltaXQsXG4gICAgcmVqZWN0U2VyaWVzOiByZWplY3RTZXJpZXMsXG4gICAgcmV0cnk6IHJldHJ5LFxuICAgIHJldHJ5YWJsZTogcmV0cnlhYmxlLFxuICAgIHNlcTogc2VxLFxuICAgIHNlcmllczogc2VyaWVzLFxuICAgIHNldEltbWVkaWF0ZTogc2V0SW1tZWRpYXRlLFxuICAgIHNvbWU6IHNvbWUsXG4gICAgc29tZUxpbWl0OiBzb21lTGltaXQsXG4gICAgc29tZVNlcmllczogc29tZVNlcmllcyxcbiAgICBzb3J0Qnk6IHNvcnRCeSxcbiAgICB0aW1lb3V0OiB0aW1lb3V0LFxuICAgIHRpbWVzOiB0aW1lcyxcbiAgICB0aW1lc0xpbWl0OiB0aW1lc0xpbWl0LFxuICAgIHRpbWVzU2VyaWVzOiB0aW1lc1NlcmllcyxcbiAgICB0cmFuc2Zvcm06IHRyYW5zZm9ybSxcbiAgICB1bm1lbW9pemU6IHVubWVtb2l6ZSxcbiAgICB1bnRpbDogdW50aWwsXG4gICAgd2F0ZXJmYWxsOiB3YXRlcmZhbGwsXG4gICAgd2hpbHN0OiB3aGlsc3QsXG5cbiAgICAvLyBhbGlhc2VzXG4gICAgYWxsOiBldmVyeSxcbiAgICBhbnk6IHNvbWUsXG4gICAgZm9yRWFjaDogZWFjaCxcbiAgICBmb3JFYWNoU2VyaWVzOiBlYWNoU2VyaWVzLFxuICAgIGZvckVhY2hMaW1pdDogZWFjaExpbWl0LFxuICAgIGZvckVhY2hPZjogZWFjaE9mLFxuICAgIGZvckVhY2hPZlNlcmllczogZWFjaE9mU2VyaWVzLFxuICAgIGZvckVhY2hPZkxpbWl0OiBlYWNoT2ZMaW1pdCxcbiAgICBpbmplY3Q6IHJlZHVjZSxcbiAgICBmb2xkbDogcmVkdWNlLFxuICAgIGZvbGRyOiByZWR1Y2VSaWdodCxcbiAgICBzZWxlY3Q6IGZpbHRlcixcbiAgICBzZWxlY3RMaW1pdDogZmlsdGVyTGltaXQsXG4gICAgc2VsZWN0U2VyaWVzOiBmaWx0ZXJTZXJpZXMsXG4gICAgd3JhcFN5bmM6IGFzeW5jaWZ5XG59O1xuXG5leHBvcnQge1xuICAgIGFwcGx5RWFjaCBhcyBhcHBseUVhY2gsXG4gICAgYXBwbHlFYWNoU2VyaWVzIGFzIGFwcGx5RWFjaFNlcmllcyxcbiAgICBhcHBseSBhcyBhcHBseSxcbiAgICBhc3luY2lmeSBhcyBhc3luY2lmeSxcbiAgICBhdXRvIGFzIGF1dG8sXG4gICAgYXV0b0luamVjdCBhcyBhdXRvSW5qZWN0LFxuICAgIGNhcmdvIGFzIGNhcmdvLFxuICAgIGNvbXBvc2UgYXMgY29tcG9zZSxcbiAgICBjb25jYXQgYXMgY29uY2F0LFxuICAgIGNvbmNhdFNlcmllcyBhcyBjb25jYXRTZXJpZXMsXG4gICAgY29uc3RhbnQgYXMgY29uc3RhbnQsXG4gICAgZGV0ZWN0IGFzIGRldGVjdCxcbiAgICBkZXRlY3RMaW1pdCBhcyBkZXRlY3RMaW1pdCxcbiAgICBkZXRlY3RTZXJpZXMgYXMgZGV0ZWN0U2VyaWVzLFxuICAgIGRpciBhcyBkaXIsXG4gICAgZG9EdXJpbmcgYXMgZG9EdXJpbmcsXG4gICAgZG9VbnRpbCBhcyBkb1VudGlsLFxuICAgIGRvV2hpbHN0IGFzIGRvV2hpbHN0LFxuICAgIGR1cmluZyBhcyBkdXJpbmcsXG4gICAgZWFjaCBhcyBlYWNoLFxuICAgIGVhY2hMaW1pdCBhcyBlYWNoTGltaXQsXG4gICAgZWFjaE9mIGFzIGVhY2hPZixcbiAgICBlYWNoT2ZMaW1pdCBhcyBlYWNoT2ZMaW1pdCxcbiAgICBlYWNoT2ZTZXJpZXMgYXMgZWFjaE9mU2VyaWVzLFxuICAgIGVhY2hTZXJpZXMgYXMgZWFjaFNlcmllcyxcbiAgICBlbnN1cmVBc3luYyBhcyBlbnN1cmVBc3luYyxcbiAgICBldmVyeSBhcyBldmVyeSxcbiAgICBldmVyeUxpbWl0IGFzIGV2ZXJ5TGltaXQsXG4gICAgZXZlcnlTZXJpZXMgYXMgZXZlcnlTZXJpZXMsXG4gICAgZmlsdGVyIGFzIGZpbHRlcixcbiAgICBmaWx0ZXJMaW1pdCBhcyBmaWx0ZXJMaW1pdCxcbiAgICBmaWx0ZXJTZXJpZXMgYXMgZmlsdGVyU2VyaWVzLFxuICAgIGZvcmV2ZXIgYXMgZm9yZXZlcixcbiAgICBsb2cgYXMgbG9nLFxuICAgIG1hcCBhcyBtYXAsXG4gICAgbWFwTGltaXQgYXMgbWFwTGltaXQsXG4gICAgbWFwU2VyaWVzIGFzIG1hcFNlcmllcyxcbiAgICBtYXBWYWx1ZXMgYXMgbWFwVmFsdWVzLFxuICAgIG1hcFZhbHVlc0xpbWl0IGFzIG1hcFZhbHVlc0xpbWl0LFxuICAgIG1hcFZhbHVlc1NlcmllcyBhcyBtYXBWYWx1ZXNTZXJpZXMsXG4gICAgbWVtb2l6ZSBhcyBtZW1vaXplLFxuICAgIG5leHRUaWNrIGFzIG5leHRUaWNrLFxuICAgIHBhcmFsbGVsIGFzIHBhcmFsbGVsLFxuICAgIHBhcmFsbGVsTGltaXQgYXMgcGFyYWxsZWxMaW1pdCxcbiAgICBwcmlvcml0eVF1ZXVlIGFzIHByaW9yaXR5UXVldWUsXG4gICAgcXVldWUgYXMgcXVldWUsXG4gICAgcmFjZSBhcyByYWNlLFxuICAgIHJlZHVjZSBhcyByZWR1Y2UsXG4gICAgcmVkdWNlUmlnaHQgYXMgcmVkdWNlUmlnaHQsXG4gICAgcmVmbGVjdCBhcyByZWZsZWN0LFxuICAgIHJlZmxlY3RBbGwgYXMgcmVmbGVjdEFsbCxcbiAgICByZWplY3QgYXMgcmVqZWN0LFxuICAgIHJlamVjdExpbWl0IGFzIHJlamVjdExpbWl0LFxuICAgIHJlamVjdFNlcmllcyBhcyByZWplY3RTZXJpZXMsXG4gICAgcmV0cnkgYXMgcmV0cnksXG4gICAgcmV0cnlhYmxlIGFzIHJldHJ5YWJsZSxcbiAgICBzZXEgYXMgc2VxLFxuICAgIHNlcmllcyBhcyBzZXJpZXMsXG4gICAgc2V0SW1tZWRpYXRlIGFzIHNldEltbWVkaWF0ZSxcbiAgICBzb21lIGFzIHNvbWUsXG4gICAgc29tZUxpbWl0IGFzIHNvbWVMaW1pdCxcbiAgICBzb21lU2VyaWVzIGFzIHNvbWVTZXJpZXMsXG4gICAgc29ydEJ5IGFzIHNvcnRCeSxcbiAgICB0aW1lb3V0IGFzIHRpbWVvdXQsXG4gICAgdGltZXMgYXMgdGltZXMsXG4gICAgdGltZXNMaW1pdCBhcyB0aW1lc0xpbWl0LFxuICAgIHRpbWVzU2VyaWVzIGFzIHRpbWVzU2VyaWVzLFxuICAgIHRyYW5zZm9ybSBhcyB0cmFuc2Zvcm0sXG4gICAgdW5tZW1vaXplIGFzIHVubWVtb2l6ZSxcbiAgICB1bnRpbCBhcyB1bnRpbCxcbiAgICB3YXRlcmZhbGwgYXMgd2F0ZXJmYWxsLFxuICAgIHdoaWxzdCBhcyB3aGlsc3QsXG5cbiAgICAvLyBBbGlhc2VzXG4gICAgZXZlcnkgYXMgYWxsLFxuICAgIGV2ZXJ5TGltaXQgYXMgYWxsTGltaXQsXG4gICAgZXZlcnlTZXJpZXMgYXMgYWxsU2VyaWVzLFxuICAgIHNvbWUgYXMgYW55LFxuICAgIHNvbWVMaW1pdCBhcyBhbnlMaW1pdCxcbiAgICBzb21lU2VyaWVzIGFzIGFueVNlcmllcyxcbiAgICBkZXRlY3QgYXMgZmluZCxcbiAgICBkZXRlY3RMaW1pdCBhcyBmaW5kTGltaXQsXG4gICAgZGV0ZWN0U2VyaWVzIGFzIGZpbmRTZXJpZXMsXG4gICAgZWFjaCBhcyBmb3JFYWNoLFxuICAgIGVhY2hTZXJpZXMgYXMgZm9yRWFjaFNlcmllcyxcbiAgICBlYWNoTGltaXQgYXMgZm9yRWFjaExpbWl0LFxuICAgIGVhY2hPZiBhcyBmb3JFYWNoT2YsXG4gICAgZWFjaE9mU2VyaWVzIGFzIGZvckVhY2hPZlNlcmllcyxcbiAgICBlYWNoT2ZMaW1pdCBhcyBmb3JFYWNoT2ZMaW1pdCxcbiAgICByZWR1Y2UgYXMgaW5qZWN0LFxuICAgIHJlZHVjZSBhcyBmb2xkbCxcbiAgICByZWR1Y2VSaWdodCBhcyBmb2xkcixcbiAgICBmaWx0ZXIgYXMgc2VsZWN0LFxuICAgIGZpbHRlckxpbWl0IGFzIHNlbGVjdExpbWl0LFxuICAgIGZpbHRlclNlcmllcyBhcyBzZWxlY3RTZXJpZXMsXG4gICAgYXN5bmNpZnkgYXMgd3JhcFN5bmNcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vLi4vLi4vLi4vfi9hc3luYy1lcy9pbmRleC5qcyIsImltcG9ydCBQcmVsb2FkRmlsZSBmcm9tICcuLi9nZW5lcmljL3ByZWxvYWRfZmlsZSc7XG5pbXBvcnQge0Jhc2VGaWxlU3lzdGVtLCBGaWxlU3lzdGVtLCBCRlNPbmVBcmdDYWxsYmFjaywgQkZTQ2FsbGJhY2ssIEZpbGVTeXN0ZW1PcHRpb25zfSBmcm9tICcuLi9jb3JlL2ZpbGVfc3lzdGVtJztcbmltcG9ydCB7RmlsZUZsYWd9IGZyb20gJy4uL2NvcmUvZmlsZV9mbGFnJztcbmltcG9ydCB7ZGVmYXVsdCBhcyBTdGF0cywgRmlsZVR5cGV9IGZyb20gJy4uL2NvcmUvbm9kZV9mc19zdGF0cyc7XG5pbXBvcnQge0FwaUVycm9yLCBFcnJvckNvZGV9IGZyb20gJy4uL2NvcmUvYXBpX2Vycm9yJztcbmltcG9ydCB7RmlsZX0gZnJvbSAnLi4vY29yZS9maWxlJztcbmltcG9ydCB7ZWFjaCBhcyBhc3luY0VhY2h9IGZyb20gJ2FzeW5jJztcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQge2FycmF5QnVmZmVyMkJ1ZmZlciwgYnVmZmVyMkFycmF5QnVmZmVyLCBlbXB0eUJ1ZmZlciwgZGVwcmVjYXRpb25NZXNzYWdlfSBmcm9tICcuLi9jb3JlL3V0aWwnO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xubGV0IGVycm9yQ29kZUxvb2t1cDoge1tkcm9wYm94RXJyb3JDb2RlOiBudW1iZXJdOiBFcnJvckNvZGV9O1xuLyoqXG4gKiBMYXppbHkgY29uc3RydWN0IGVycm9yIGNvZGUgbG9va3VwLCBzaW5jZSBEcm9wYm94SlMgbWlnaHQgYmUgbG9hZGVkICphZnRlciogQnJvd3NlckZTIChvciBub3QgYXQgYWxsISlcbiAqIEBoaWRkZW5cbiAqL1xuZnVuY3Rpb24gY29uc3RydWN0RXJyb3JDb2RlTG9va3VwKCkge1xuICBpZiAoZXJyb3JDb2RlTG9va3VwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGVycm9yQ29kZUxvb2t1cCA9IHt9O1xuICAvLyBUaGlzIGluZGljYXRlcyBhIG5ldHdvcmsgdHJhbnNtaXNzaW9uIGVycm9yIG9uIG1vZGVybiBicm93c2Vycy4gSW50ZXJuZXQgRXhwbG9yZXIgbWlnaHQgY2F1c2UgdGhpcyBjb2RlIHRvIGJlIHJlcG9ydGVkIG9uIHNvbWUgQVBJIHNlcnZlciBlcnJvcnMuXG4gIGVycm9yQ29kZUxvb2t1cFtEcm9wYm94LkFwaUVycm9yLk5FVFdPUktfRVJST1JdID0gRXJyb3JDb2RlLkVJTztcbiAgLy8gVGhpcyBoYXBwZW5zIHdoZW4gdGhlIGNvbnRlbnRIYXNoIHBhcmFtZXRlciBwYXNzZWQgdG8gYSBEcm9wYm94LkNsaWVudCNyZWFkZGlyIG9yIERyb3Bib3guQ2xpZW50I3N0YXQgbWF0Y2hlcyB0aGUgbW9zdCByZWNlbnQgY29udGVudCwgc28gdGhlIEFQSSBjYWxsIHJlc3BvbnNlIGlzIG9taXR0ZWQsIHRvIHNhdmUgYmFuZHdpZHRoLlxuICAvLyBlcnJvckNvZGVMb29rdXBbRHJvcGJveC5BcGlFcnJvci5OT19DT05URU5UXTtcbiAgLy8gVGhlIGVycm9yIHByb3BlcnR5IG9uIHtEcm9wYm94LkFwaUVycm9yI3Jlc3BvbnNlfSBzaG91bGQgaW5kaWNhdGUgd2hpY2ggaW5wdXQgcGFyYW1ldGVyIGlzIGludmFsaWQgYW5kIHdoeS5cbiAgZXJyb3JDb2RlTG9va3VwW0Ryb3Bib3guQXBpRXJyb3IuSU5WQUxJRF9QQVJBTV0gPSBFcnJvckNvZGUuRUlOVkFMO1xuICAvLyBUaGUgT0F1dGggdG9rZW4gdXNlZCBmb3IgdGhlIHJlcXVlc3Qgd2lsbCBuZXZlciBiZWNvbWUgdmFsaWQgYWdhaW4sIHNvIHRoZSB1c2VyIHNob3VsZCBiZSByZS1hdXRoZW50aWNhdGVkLlxuICBlcnJvckNvZGVMb29rdXBbRHJvcGJveC5BcGlFcnJvci5JTlZBTElEX1RPS0VOXSA9IEVycm9yQ29kZS5FUEVSTTtcbiAgLy8gVGhpcyBpbmRpY2F0ZXMgYSBidWcgaW4gZHJvcGJveC5qcyBhbmQgc2hvdWxkIG5ldmVyIG9jY3VyIHVuZGVyIG5vcm1hbCBjaXJjdW1zdGFuY2VzLlxuICAvLyBeIEFjdHVhbGx5LCB0aGF0J3MgZmFsc2UuIFRoaXMgb2NjdXJzIHdoZW4geW91IHRyeSB0byBtb3ZlIGZvbGRlcnMgdG8gdGhlbXNlbHZlcywgb3IgbW92ZSBhIGZpbGUgb3ZlciBhbm90aGVyIGZpbGUuXG4gIGVycm9yQ29kZUxvb2t1cFtEcm9wYm94LkFwaUVycm9yLk9BVVRIX0VSUk9SXSA9IEVycm9yQ29kZS5FUEVSTTtcbiAgLy8gVGhpcyBoYXBwZW5zIHdoZW4gdHJ5aW5nIHRvIHJlYWQgZnJvbSBhIG5vbi1leGlzdGluZyBmaWxlLCByZWFkZGlyIGEgbm9uLWV4aXN0aW5nIGRpcmVjdG9yeSwgd3JpdGUgYSBmaWxlIGludG8gYSBub24tZXhpc3RpbmcgZGlyZWN0b3J5LCBldGMuXG4gIGVycm9yQ29kZUxvb2t1cFtEcm9wYm94LkFwaUVycm9yLk5PVF9GT1VORF0gPSBFcnJvckNvZGUuRU5PRU5UO1xuICAvLyBUaGlzIGluZGljYXRlcyBhIGJ1ZyBpbiBkcm9wYm94LmpzIGFuZCBzaG91bGQgbmV2ZXIgb2NjdXIgdW5kZXIgbm9ybWFsIGNpcmN1bXN0YW5jZXMuXG4gIGVycm9yQ29kZUxvb2t1cFtEcm9wYm94LkFwaUVycm9yLklOVkFMSURfTUVUSE9EXSA9IEVycm9yQ29kZS5FSU5WQUw7XG4gIC8vIFRoaXMgaGFwcGVucyB3aGVuIGEgRHJvcGJveC5DbGllbnQjcmVhZGRpciBvciBEcm9wYm94LkNsaWVudCNzdGF0IGNhbGwgd291bGQgcmV0dXJuIG1vcmUgdGhhbiBhIG1heGltdW0gYW1vdW50IG9mIGRpcmVjdG9yeSBlbnRyaWVzLlxuICBlcnJvckNvZGVMb29rdXBbRHJvcGJveC5BcGlFcnJvci5OT1RfQUNDRVBUQUJMRV0gPSBFcnJvckNvZGUuRUlOVkFMO1xuICAvLyBUaGlzIGlzIHVzZWQgYnkgc29tZSBiYWNrZW5kIG1ldGhvZHMgdG8gaW5kaWNhdGUgdGhhdCB0aGUgY2xpZW50IG5lZWRzIHRvIGRvd25sb2FkIHNlcnZlci1zaWRlIGNoYW5nZXMgYW5kIHBlcmZvcm0gY29uZmxpY3QgcmVzb2x1dGlvbi4gVW5kZXIgbm9ybWFsIHVzYWdlLCBlcnJvcnMgd2l0aCB0aGlzIGNvZGUgc2hvdWxkIG5ldmVyIHN1cmZhY2UgdG8gdGhlIGNvZGUgdXNpbmcgZHJvcGJveC5qcy5cbiAgZXJyb3JDb2RlTG9va3VwW0Ryb3Bib3guQXBpRXJyb3IuQ09ORkxJQ1RdID0gRXJyb3JDb2RlLkVJTlZBTDtcbiAgLy8gU3RhdHVzIHZhbHVlIGluZGljYXRpbmcgdGhhdCB0aGUgYXBwbGljYXRpb24gaXMgbWFraW5nIHRvbyBtYW55IHJlcXVlc3RzLlxuICBlcnJvckNvZGVMb29rdXBbRHJvcGJveC5BcGlFcnJvci5SQVRFX0xJTUlURURdID0gRXJyb3JDb2RlLkVCVVNZO1xuICAvLyBUaGUgcmVxdWVzdCBzaG91bGQgYmUgcmV0cmllZCBhZnRlciBzb21lIHRpbWUuXG4gIGVycm9yQ29kZUxvb2t1cFtEcm9wYm94LkFwaUVycm9yLlNFUlZFUl9FUlJPUl0gPSBFcnJvckNvZGUuRUJVU1k7XG4gIC8vIFN0YXR1cyB2YWx1ZSBpbmRpY2F0aW5nIHRoYXQgdGhlIHVzZXIncyBEcm9wYm94IGlzIG92ZXIgaXRzIHN0b3JhZ2UgcXVvdGEuXG4gIGVycm9yQ29kZUxvb2t1cFtEcm9wYm94LkFwaUVycm9yLk9WRVJfUVVPVEFdID0gRXJyb3JDb2RlLkVOT1NQQztcbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmludGVyZmFjZSBJQ2FjaGVkUGF0aEluZm8ge1xuICBzdGF0OiBEcm9wYm94LkZpbGUuU3RhdDtcbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmludGVyZmFjZSBJQ2FjaGVkRmlsZUluZm8gZXh0ZW5kcyBJQ2FjaGVkUGF0aEluZm8ge1xuICBjb250ZW50czogQXJyYXlCdWZmZXI7XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5mdW5jdGlvbiBpc0ZpbGVJbmZvKGNhY2hlOiBJQ2FjaGVkUGF0aEluZm8pOiBjYWNoZSBpcyBJQ2FjaGVkRmlsZUluZm8ge1xuICByZXR1cm4gY2FjaGUgJiYgY2FjaGUuc3RhdC5pc0ZpbGU7XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5pbnRlcmZhY2UgSUNhY2hlZERpckluZm8gZXh0ZW5kcyBJQ2FjaGVkUGF0aEluZm8ge1xuICBjb250ZW50czogc3RyaW5nW107XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5mdW5jdGlvbiBpc0RpckluZm8oY2FjaGU6IElDYWNoZWRQYXRoSW5mbyk6IGNhY2hlIGlzIElDYWNoZWREaXJJbmZvIHtcbiAgcmV0dXJuIGNhY2hlICYmIGNhY2hlLnN0YXQuaXNGb2xkZXI7XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyKGFiOiBhbnkpOiBhYiBpcyBBcnJheUJ1ZmZlciB7XG4gIC8vIEFjY2VwdCBudWxsIC8gdW5kZWZpbmVkLCB0b28uXG4gIHJldHVybiBhYiA9PT0gbnVsbCB8fCBhYiA9PT0gdW5kZWZpbmVkIHx8ICh0eXBlb2YoYWIpID09PSAnb2JqZWN0JyAmJiB0eXBlb2YoYWJbJ2J5dGVMZW5ndGgnXSkgPT09ICdudW1iZXInKTtcbn1cblxuLyoqXG4gKiBXcmFwcyBhIERyb3Bib3ggY2xpZW50IGFuZCBjYWNoZXMgb3BlcmF0aW9ucy5cbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgQ2FjaGVkRHJvcGJveENsaWVudCB7XG4gIHByaXZhdGUgX2NhY2hlOiB7W3BhdGg6IHN0cmluZ106IElDYWNoZWRQYXRoSW5mb30gPSB7fTtcbiAgcHJpdmF0ZSBfY2xpZW50OiBEcm9wYm94LkNsaWVudDtcblxuICBjb25zdHJ1Y3RvcihjbGllbnQ6IERyb3Bib3guQ2xpZW50KSB7XG4gICAgdGhpcy5fY2xpZW50ID0gY2xpZW50O1xuICB9XG5cbiAgcHVibGljIHJlYWRkaXIocDogc3RyaW5nLCBjYjogKGVycm9yOiBEcm9wYm94LkFwaUVycm9yIHwgbnVsbCwgY29udGVudHM/OiBzdHJpbmdbXSkgPT4gdm9pZCk6IHZvaWQge1xuICAgIGNvbnN0IGNhY2hlSW5mbyA9IHRoaXMuZ2V0Q2FjaGVkRGlySW5mbyhwKTtcblxuICAgIHRoaXMuX3dyYXAoKGludGVyY2VwdENiKSA9PiB7XG4gICAgICBpZiAoY2FjaGVJbmZvICE9PSBudWxsICYmIGNhY2hlSW5mby5jb250ZW50cykge1xuICAgICAgICB0aGlzLl9jbGllbnQucmVhZGRpcihwLCB7XG4gICAgICAgICAgY29udGVudEhhc2g6IGNhY2hlSW5mby5zdGF0LmNvbnRlbnRIYXNoXG4gICAgICAgIH0sIGludGVyY2VwdENiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2NsaWVudC5yZWFkZGlyKHAsIGludGVyY2VwdENiKTtcbiAgICAgIH1cbiAgICB9LCAoZXJyOiBEcm9wYm94LkFwaUVycm9yLCBmaWxlbmFtZXM6IHN0cmluZ1tdLCBzdGF0OiBEcm9wYm94LkZpbGUuU3RhdCwgZm9sZGVyRW50cmllczogRHJvcGJveC5GaWxlLlN0YXRbXSkgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBpZiAoZXJyLnN0YXR1cyA9PT0gRHJvcGJveC5BcGlFcnJvci5OT19DT05URU5UICYmIGNhY2hlSW5mbyAhPT0gbnVsbCkge1xuICAgICAgICAgIGNiKG51bGwsIGNhY2hlSW5mby5jb250ZW50cy5zbGljZSgwKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2IoZXJyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy51cGRhdGVDYWNoZWREaXJJbmZvKHAsIHN0YXQsIGZpbGVuYW1lcy5zbGljZSgwKSk7XG4gICAgICAgIGZvbGRlckVudHJpZXMuZm9yRWFjaCgoZW50cnkpID0+IHtcbiAgICAgICAgICB0aGlzLnVwZGF0ZUNhY2hlZEluZm8ocGF0aC5qb2luKHAsIGVudHJ5Lm5hbWUpLCBlbnRyeSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjYihudWxsLCBmaWxlbmFtZXMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIHJlbW92ZShwOiBzdHJpbmcsIGNiOiAoZXJyb3I/OiBEcm9wYm94LkFwaUVycm9yIHwgbnVsbCkgPT4gdm9pZCk6IHZvaWQge1xuICAgIHRoaXMuX3dyYXAoKGludGVyY2VwdENiKSA9PiB7XG4gICAgICB0aGlzLl9jbGllbnQucmVtb3ZlKHAsIGludGVyY2VwdENiKTtcbiAgICB9LCAoZXJyOiBEcm9wYm94LkFwaUVycm9yLCBzdGF0PzogRHJvcGJveC5GaWxlLlN0YXQpID0+IHtcbiAgICAgIGlmICghZXJyKSB7XG4gICAgICAgIHRoaXMudXBkYXRlQ2FjaGVkSW5mbyhwLCBzdGF0ISk7XG4gICAgICB9XG4gICAgICBjYihlcnIpO1xuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIG1vdmUoc3JjOiBzdHJpbmcsIGRlc3Q6IHN0cmluZywgY2I6IChlcnJvcj86IERyb3Bib3guQXBpRXJyb3IpID0+IHZvaWQpOiB2b2lkIHtcbiAgICB0aGlzLl93cmFwKChpbnRlcmNlcHRDYikgPT4ge1xuICAgICAgdGhpcy5fY2xpZW50Lm1vdmUoc3JjLCBkZXN0LCBpbnRlcmNlcHRDYik7XG4gICAgfSwgKGVycjogRHJvcGJveC5BcGlFcnJvciwgc3RhdDogRHJvcGJveC5GaWxlLlN0YXQpID0+IHtcbiAgICAgIGlmICghZXJyKSB7XG4gICAgICAgIHRoaXMuZGVsZXRlQ2FjaGVkSW5mbyhzcmMpO1xuICAgICAgICB0aGlzLnVwZGF0ZUNhY2hlZEluZm8oZGVzdCwgc3RhdCk7XG4gICAgICB9XG4gICAgICBjYihlcnIpO1xuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIHN0YXQocDogc3RyaW5nLCBjYjogKGVycm9yOiBEcm9wYm94LkFwaUVycm9yLCBzdGF0PzogRHJvcGJveC5GaWxlLlN0YXQpID0+IHZvaWQpOiB2b2lkIHtcbiAgICB0aGlzLl93cmFwKChpbnRlcmNlcHRDYikgPT4ge1xuICAgICAgdGhpcy5fY2xpZW50LnN0YXQocCwgaW50ZXJjZXB0Q2IpO1xuICAgIH0sIChlcnI6IERyb3Bib3guQXBpRXJyb3IsIHN0YXQ6IERyb3Bib3guRmlsZS5TdGF0KSA9PiB7XG4gICAgICBpZiAoIWVycikge1xuICAgICAgICB0aGlzLnVwZGF0ZUNhY2hlZEluZm8ocCwgc3RhdCk7XG4gICAgICB9XG4gICAgICBjYihlcnIsIHN0YXQpO1xuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIHJlYWRGaWxlKHA6IHN0cmluZywgY2I6IChlcnJvcjogRHJvcGJveC5BcGlFcnJvciwgZmlsZT86IEFycmF5QnVmZmVyLCBzdGF0PzogRHJvcGJveC5GaWxlLlN0YXQpID0+IHZvaWQpOiB2b2lkIHtcbiAgICBjb25zdCBjYWNoZUluZm8gPSB0aGlzLmdldENhY2hlZEZpbGVJbmZvKHApO1xuICAgIGlmIChjYWNoZUluZm8gIT09IG51bGwgJiYgY2FjaGVJbmZvLmNvbnRlbnRzICE9PSBudWxsKSB7XG4gICAgICAvLyBUcnkgdG8gdXNlIGNhY2hlZCBpbmZvOyBpc3N1ZSBhIHN0YXQgdG8gc2VlIGlmIGNvbnRlbnRzIGFyZSB1cC10by1kYXRlLlxuICAgICAgdGhpcy5zdGF0KHAsIChlcnJvciwgc3RhdD8pID0+IHtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgY2IoZXJyb3IpO1xuICAgICAgICB9IGVsc2UgaWYgKHN0YXQhLmNvbnRlbnRIYXNoID09PSBjYWNoZUluZm8hLnN0YXQuY29udGVudEhhc2gpIHtcbiAgICAgICAgICAvLyBObyBmaWxlIGNoYW5nZXMuXG4gICAgICAgICAgY2IoZXJyb3IsIGNhY2hlSW5mbyEuY29udGVudHMuc2xpY2UoMCksIGNhY2hlSW5mbyEuc3RhdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gRmlsZSBjaGFuZ2VzOyByZXJ1biB0byB0cmlnZ2VyIGFjdHVhbCByZWFkRmlsZS5cbiAgICAgICAgICB0aGlzLnJlYWRGaWxlKHAsIGNiKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3dyYXAoKGludGVyY2VwdENiKSA9PiB7XG4gICAgICAgIHRoaXMuX2NsaWVudC5yZWFkRmlsZShwLCB7IGFycmF5QnVmZmVyOiB0cnVlIH0sIGludGVyY2VwdENiKTtcbiAgICAgIH0sIChlcnI6IERyb3Bib3guQXBpRXJyb3IsIGNvbnRlbnRzOiBhbnksIHN0YXQ6IERyb3Bib3guRmlsZS5TdGF0KSA9PiB7XG4gICAgICAgIGlmICghZXJyKSB7XG4gICAgICAgICAgdGhpcy51cGRhdGVDYWNoZWRJbmZvKHAsIHN0YXQsIGNvbnRlbnRzLnNsaWNlKDApKTtcbiAgICAgICAgfVxuICAgICAgICBjYihlcnIsIGNvbnRlbnRzLCBzdGF0KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyB3cml0ZUZpbGUocDogc3RyaW5nLCBjb250ZW50czogQXJyYXlCdWZmZXIsIGNiOiAoZXJyb3I6IERyb3Bib3guQXBpRXJyb3IsIHN0YXQ/OiBEcm9wYm94LkZpbGUuU3RhdCkgPT4gdm9pZCk6IHZvaWQge1xuICAgIHRoaXMuX3dyYXAoKGludGVyY2VwdENiKSA9PiB7XG4gICAgICB0aGlzLl9jbGllbnQud3JpdGVGaWxlKHAsIGNvbnRlbnRzLCBpbnRlcmNlcHRDYik7XG4gICAgfSwgKGVycjogRHJvcGJveC5BcGlFcnJvciwgc3RhdDogRHJvcGJveC5GaWxlLlN0YXQpID0+IHtcbiAgICAgIGlmICghZXJyKSB7XG4gICAgICAgIHRoaXMudXBkYXRlQ2FjaGVkSW5mbyhwLCBzdGF0LCBjb250ZW50cy5zbGljZSgwKSk7XG4gICAgICB9XG4gICAgICBjYihlcnIsIHN0YXQpO1xuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIG1rZGlyKHA6IHN0cmluZywgY2I6IChlcnJvcj86IERyb3Bib3guQXBpRXJyb3IpID0+IHZvaWQpOiB2b2lkIHtcbiAgICB0aGlzLl93cmFwKChpbnRlcmNlcHRDYikgPT4ge1xuICAgICAgdGhpcy5fY2xpZW50Lm1rZGlyKHAsIGludGVyY2VwdENiKTtcbiAgICB9LCAoZXJyOiBEcm9wYm94LkFwaUVycm9yLCBzdGF0OiBEcm9wYm94LkZpbGUuU3RhdCkgPT4ge1xuICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgdGhpcy51cGRhdGVDYWNoZWRJbmZvKHAsIHN0YXQsIFtdKTtcbiAgICAgIH1cbiAgICAgIGNiKGVycik7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogV3JhcHMgYW4gb3BlcmF0aW9uIHN1Y2ggdGhhdCB3ZSByZXRyeSBhIGZhaWxlZCBvcGVyYXRpb24gMyB0aW1lcy5cbiAgICogTmVjZXNzYXJ5IHRvIGRlYWwgd2l0aCBEcm9wYm94IHJhdGUgbGltaXRpbmcuXG4gICAqXG4gICAqIEBwYXJhbSBwZXJmb3JtT3AgRnVuY3Rpb24gdGhhdCBwZXJmb3JtcyB0aGUgb3BlcmF0aW9uLiBXaWxsIGJlIGNhbGxlZCB1cCB0byB0aHJlZSB0aW1lcy5cbiAgICogQHBhcmFtIGNiIENhbGxlZCB3aGVuIHRoZSBvcGVyYXRpb24gc3VjY2VlZHMsIGZhaWxzIGluIGEgbm9uLXRlbXBvcmFyeSBtYW5uZXIsIG9yIGZhaWxzIHRocmVlIHRpbWVzLlxuICAgKi9cbiAgcHJpdmF0ZSBfd3JhcChwZXJmb3JtT3A6IChpbnRlcmNlcHRDYjogKGVycm9yOiBEcm9wYm94LkFwaUVycm9yKSA9PiB2b2lkKSA9PiB2b2lkLCBjYjogRnVuY3Rpb24pOiB2b2lkIHtcbiAgICBsZXQgbnVtUnVuID0gMDtcbiAgICBjb25zdCBpbnRlcmNlcHRDYiA9IGZ1bmN0aW9uKGVycm9yOiBEcm9wYm94LkFwaUVycm9yKTogdm9pZCB7XG4gICAgICAgIC8vIFRpbWVvdXQgZHVyYXRpb24sIGluIHNlY29uZHMuXG4gICAgICAgIGNvbnN0IHRpbWVvdXREdXJhdGlvbjogbnVtYmVyID0gMjtcbiAgICAgICAgaWYgKGVycm9yICYmIDMgPiAoKytudW1SdW4pKSB7XG4gICAgICAgICAgc3dpdGNoIChlcnJvci5zdGF0dXMpIHtcbiAgICAgICAgICAgIGNhc2UgRHJvcGJveC5BcGlFcnJvci5TRVJWRVJfRVJST1I6XG4gICAgICAgICAgICBjYXNlIERyb3Bib3guQXBpRXJyb3IuTkVUV09SS19FUlJPUjpcbiAgICAgICAgICAgIGNhc2UgRHJvcGJveC5BcGlFcnJvci5SQVRFX0xJTUlURUQ6XG4gICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHBlcmZvcm1PcChpbnRlcmNlcHRDYik7XG4gICAgICAgICAgICAgIH0sIHRpbWVvdXREdXJhdGlvbiAqIDEwMDApO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIGNiLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYi5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgcGVyZm9ybU9wKGludGVyY2VwdENiKTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0Q2FjaGVkSW5mbyhwOiBzdHJpbmcpOiBJQ2FjaGVkUGF0aEluZm8ge1xuICAgIHJldHVybiB0aGlzLl9jYWNoZVtwLnRvTG93ZXJDYXNlKCldO1xuICB9XG5cbiAgcHJpdmF0ZSBwdXRDYWNoZWRJbmZvKHA6IHN0cmluZywgY2FjaGU6IElDYWNoZWRQYXRoSW5mbyk6IHZvaWQge1xuICAgIHRoaXMuX2NhY2hlW3AudG9Mb3dlckNhc2UoKV0gPSBjYWNoZTtcbiAgfVxuXG4gIHByaXZhdGUgZGVsZXRlQ2FjaGVkSW5mbyhwOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBkZWxldGUgdGhpcy5fY2FjaGVbcC50b0xvd2VyQ2FzZSgpXTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0Q2FjaGVkRGlySW5mbyhwOiBzdHJpbmcpOiBJQ2FjaGVkRGlySW5mbyB8IG51bGwge1xuICAgIGNvbnN0IGluZm8gPSB0aGlzLmdldENhY2hlZEluZm8ocCk7XG4gICAgaWYgKGlzRGlySW5mbyhpbmZvKSkge1xuICAgICAgcmV0dXJuIGluZm87XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZ2V0Q2FjaGVkRmlsZUluZm8ocDogc3RyaW5nKTogSUNhY2hlZEZpbGVJbmZvIHwgbnVsbCB7XG4gICAgY29uc3QgaW5mbyA9IHRoaXMuZ2V0Q2FjaGVkSW5mbyhwKTtcbiAgICBpZiAoaXNGaWxlSW5mbyhpbmZvKSkge1xuICAgICAgcmV0dXJuIGluZm87XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgdXBkYXRlQ2FjaGVkRGlySW5mbyhwOiBzdHJpbmcsIHN0YXQ6IERyb3Bib3guRmlsZS5TdGF0LCBjb250ZW50czogc3RyaW5nW10gfCBudWxsID0gbnVsbCk6IHZvaWQge1xuICAgIGNvbnN0IGNhY2hlZEluZm8gPSB0aGlzLmdldENhY2hlZEluZm8ocCk7XG4gICAgLy8gRHJvcGJveCB1c2VzIHRoZSAqY29udGVudEhhc2gqIHByb3BlcnR5IGZvciBkaXJlY3Rvcmllcy5cbiAgICAvLyBJZ25vcmUgc3RhdCBvYmplY3RzIHcvbyBhIGNvbnRlbnRIYXNoIGRlZmluZWQ7IHRob3NlIGFjdHVhbGx5IGV4aXN0ISEhXG4gICAgLy8gKEV4YW1wbGU6IHJlYWRkaXIgcmV0dXJucyBhbiBhcnJheSBvZiBzdGF0IG9ianM7IHN0YXQgb2JqcyBmb3IgZGlycyBpbiB0aGF0IGNvbnRleHQgaGF2ZSBubyBjb250ZW50SGFzaClcbiAgICBpZiAoc3RhdC5jb250ZW50SGFzaCAhPT0gbnVsbCAmJiAoY2FjaGVkSW5mbyA9PT0gdW5kZWZpbmVkIHx8IGNhY2hlZEluZm8uc3RhdC5jb250ZW50SGFzaCAhPT0gc3RhdC5jb250ZW50SGFzaCkpIHtcbiAgICAgIHRoaXMucHV0Q2FjaGVkSW5mbyhwLCA8SUNhY2hlZERpckluZm8+IHtcbiAgICAgICAgc3RhdDogc3RhdCxcbiAgICAgICAgY29udGVudHM6IGNvbnRlbnRzXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHVwZGF0ZUNhY2hlZEZpbGVJbmZvKHA6IHN0cmluZywgc3RhdDogRHJvcGJveC5GaWxlLlN0YXQsIGNvbnRlbnRzOiBBcnJheUJ1ZmZlciB8IG51bGwgPSBudWxsKTogdm9pZCB7XG4gICAgY29uc3QgY2FjaGVkSW5mbyA9IHRoaXMuZ2V0Q2FjaGVkSW5mbyhwKTtcbiAgICAvLyBEcm9wYm94IHVzZXMgdGhlICp2ZXJzaW9uVGFnKiBwcm9wZXJ0eSBmb3IgZmlsZXMuXG4gICAgLy8gSWdub3JlIHN0YXQgb2JqZWN0cyB3L28gYSB2ZXJzaW9uVGFnIGRlZmluZWQuXG4gICAgaWYgKHN0YXQudmVyc2lvblRhZyAhPT0gbnVsbCAmJiAoY2FjaGVkSW5mbyA9PT0gdW5kZWZpbmVkIHx8IGNhY2hlZEluZm8uc3RhdC52ZXJzaW9uVGFnICE9PSBzdGF0LnZlcnNpb25UYWcpKSB7XG4gICAgICB0aGlzLnB1dENhY2hlZEluZm8ocCwgPElDYWNoZWRGaWxlSW5mbz4ge1xuICAgICAgICBzdGF0OiBzdGF0LFxuICAgICAgICBjb250ZW50czogY29udGVudHNcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgdXBkYXRlQ2FjaGVkSW5mbyhwOiBzdHJpbmcsIHN0YXQ6IERyb3Bib3guRmlsZS5TdGF0LCBjb250ZW50czogQXJyYXlCdWZmZXIgfCBzdHJpbmdbXSB8IG51bGwgPSBudWxsKTogdm9pZCB7XG4gICAgaWYgKHN0YXQuaXNGaWxlICYmIGlzQXJyYXlCdWZmZXIoY29udGVudHMpKSB7XG4gICAgICB0aGlzLnVwZGF0ZUNhY2hlZEZpbGVJbmZvKHAsIHN0YXQsIGNvbnRlbnRzKTtcbiAgICB9IGVsc2UgaWYgKHN0YXQuaXNGb2xkZXIgJiYgQXJyYXkuaXNBcnJheShjb250ZW50cykpIHtcbiAgICAgIHRoaXMudXBkYXRlQ2FjaGVkRGlySW5mbyhwLCBzdGF0LCBjb250ZW50cyk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBEcm9wYm94RmlsZSBleHRlbmRzIFByZWxvYWRGaWxlPERyb3Bib3hGaWxlU3lzdGVtPiBpbXBsZW1lbnRzIEZpbGUge1xuICBjb25zdHJ1Y3RvcihfZnM6IERyb3Bib3hGaWxlU3lzdGVtLCBfcGF0aDogc3RyaW5nLCBfZmxhZzogRmlsZUZsYWcsIF9zdGF0OiBTdGF0cywgY29udGVudHM/OiBCdWZmZXIpIHtcbiAgICBzdXBlcihfZnMsIF9wYXRoLCBfZmxhZywgX3N0YXQsIGNvbnRlbnRzKTtcbiAgfVxuXG4gIHB1YmxpYyBzeW5jKGNiOiBCRlNPbmVBcmdDYWxsYmFjayk6IHZvaWQge1xuICAgIGlmICh0aGlzLmlzRGlydHkoKSkge1xuICAgICAgY29uc3QgYnVmZmVyID0gdGhpcy5nZXRCdWZmZXIoKSxcbiAgICAgICAgYXJyYXlCdWZmZXIgPSBidWZmZXIyQXJyYXlCdWZmZXIoYnVmZmVyKTtcbiAgICAgIHRoaXMuX2ZzLl93cml0ZUZpbGVTdHJpY3QodGhpcy5nZXRQYXRoKCksIGFycmF5QnVmZmVyLCAoZT86IEFwaUVycm9yKSA9PiB7XG4gICAgICAgIGlmICghZSkge1xuICAgICAgICAgIHRoaXMucmVzZXREaXJ0eSgpO1xuICAgICAgICB9XG4gICAgICAgIGNiKGUpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNiKCk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGNsb3NlKGNiOiBCRlNPbmVBcmdDYWxsYmFjayk6IHZvaWQge1xuICAgIHRoaXMuc3luYyhjYik7XG4gIH1cbn1cblxuLyoqXG4gKiBPcHRpb25zIGZvciB0aGUgRHJvcGJveCBmaWxlIHN5c3RlbS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBEcm9wYm94RmlsZVN5c3RlbU9wdGlvbnMge1xuICAvLyBBbiAqYXV0aGVudGljYXRlZCogRHJvcGJveCBjbGllbnQuIE11c3QgYmUgZnJvbSB0aGUgMC4xMCBKUyBTREsuXG4gIGNsaWVudDogRHJvcGJveC5DbGllbnQ7XG59XG5cbi8qKlxuICogQSByZWFkL3dyaXRlIGZpbGUgc3lzdGVtIGJhY2tlZCBieSBEcm9wYm94IGNsb3VkIHN0b3JhZ2UuXG4gKlxuICogVXNlcyB0aGUgRHJvcGJveCBWMSBBUEkuXG4gKlxuICogTk9URTogWW91IG11c3QgdXNlIHRoZSB2MC4xMCB2ZXJzaW9uIG9mIHRoZSBbRHJvcGJveCBKYXZhU2NyaXB0IFNES10oaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZHJvcGJveCkuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERyb3Bib3hGaWxlU3lzdGVtIGV4dGVuZHMgQmFzZUZpbGVTeXN0ZW0gaW1wbGVtZW50cyBGaWxlU3lzdGVtIHtcbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBOYW1lID0gXCJEcm9wYm94XCI7XG5cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBPcHRpb25zOiBGaWxlU3lzdGVtT3B0aW9ucyA9IHtcbiAgICBjbGllbnQ6IHtcbiAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICBkZXNjcmlwdGlvbjogXCJBbiAqYXV0aGVudGljYXRlZCogRHJvcGJveCBjbGllbnQuIE11c3QgYmUgZnJvbSB0aGUgMC4xMCBKUyBTREsuXCIsXG4gICAgICB2YWxpZGF0b3I6IChvcHQ6IERyb3Bib3guQ2xpZW50LCBjYjogQkZTT25lQXJnQ2FsbGJhY2spOiB2b2lkID0+IHtcbiAgICAgICAgaWYgKG9wdC5pc0F1dGhlbnRpY2F0ZWQgJiYgb3B0LmlzQXV0aGVudGljYXRlZCgpKSB7XG4gICAgICAgICAgY2IoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYihuZXcgQXBpRXJyb3IoRXJyb3JDb2RlLkVJTlZBTCwgYCdjbGllbnQnIG9wdGlvbiBtdXN0IGJlIGFuIGF1dGhlbnRpY2F0ZWQgRHJvcGJveCBjbGllbnQgZnJvbSB0aGUgdjAuMTAgSlMgU0RLLmApKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBEcm9wYm94RmlsZVN5c3RlbSBpbnN0YW5jZSB3aXRoIHRoZSBnaXZlbiBvcHRpb25zLlxuICAgKiBNdXN0IGJlIGdpdmVuIGFuICphdXRoZW50aWNhdGVkKiBEcm9wYm94SlMgY2xpZW50IGZyb20gdGhlIG9sZCB2MC4xMCB2ZXJzaW9uIG9mIHRoZSBEcm9wYm94IEpTIFNESy5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgQ3JlYXRlKG9wdHM6IERyb3Bib3hGaWxlU3lzdGVtT3B0aW9ucywgY2I6IEJGU0NhbGxiYWNrPERyb3Bib3hGaWxlU3lzdGVtPik6IHZvaWQge1xuICAgIGNiKG51bGwsIG5ldyBEcm9wYm94RmlsZVN5c3RlbShvcHRzLmNsaWVudCwgZmFsc2UpKTtcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgaXNBdmFpbGFibGUoKTogYm9vbGVhbiB7XG4gICAgLy8gQ2hlY2tzIGlmIHRoZSBEcm9wYm94IGxpYnJhcnkgaXMgbG9hZGVkLlxuICAgIHJldHVybiB0eXBlb2YgRHJvcGJveCAhPT0gJ3VuZGVmaW5lZCc7XG4gIH1cblxuICAvLyBUaGUgRHJvcGJveCBjbGllbnQuXG4gIHByaXZhdGUgX2NsaWVudDogQ2FjaGVkRHJvcGJveENsaWVudDtcblxuICAvKipcbiAgICogKipEZXByZWNhdGVkLiBQbGVhc2UgdXNlIERyb3Bib3guQ3JlYXRlKCkgbWV0aG9kIGluc3RlYWQuKipcbiAgICpcbiAgICogQ29uc3RydWN0cyBhIERyb3Bib3gtYmFja2VkIGZpbGUgc3lzdGVtIHVzaW5nIHRoZSAqYXV0aGVudGljYXRlZCogRHJvcGJveEpTIGNsaWVudC5cbiAgICpcbiAgICogTm90ZSB0aGF0IHlvdSBtdXN0IHVzZSB0aGUgb2xkIHYwLjEwIHZlcnNpb24gb2YgdGhlIERyb3Bib3ggSmF2YVNjcmlwdCBTREsuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihjbGllbnQ6IERyb3Bib3guQ2xpZW50LCBkZXByZWNhdGVNc2cgPSB0cnVlKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9jbGllbnQgPSBuZXcgQ2FjaGVkRHJvcGJveENsaWVudChjbGllbnQpO1xuICAgIGRlcHJlY2F0aW9uTWVzc2FnZShkZXByZWNhdGVNc2csIERyb3Bib3hGaWxlU3lzdGVtLk5hbWUsIHsgY2xpZW50OiBcImF1dGhlbnRpY2F0ZWQgZHJvcGJveCBjbGllbnQgaW5zdGFuY2VcIiB9KTtcbiAgICBjb25zdHJ1Y3RFcnJvckNvZGVMb29rdXAoKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXROYW1lKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIERyb3Bib3hGaWxlU3lzdGVtLk5hbWU7XG4gIH1cblxuICBwdWJsaWMgaXNSZWFkT25seSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBEcm9wYm94IGRvZXNuJ3Qgc3VwcG9ydCBzeW1saW5rcywgcHJvcGVydGllcywgb3Igc3luY2hyb25vdXMgY2FsbHNcblxuICBwdWJsaWMgc3VwcG9ydHNTeW1saW5rcygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBwdWJsaWMgc3VwcG9ydHNQcm9wcygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBwdWJsaWMgc3VwcG9ydHNTeW5jaCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBwdWJsaWMgZW1wdHkobWFpbkNiOiBCRlNPbmVBcmdDYWxsYmFjayk6IHZvaWQge1xuICAgIHRoaXMuX2NsaWVudC5yZWFkZGlyKCcvJywgKGVycm9yLCBmaWxlcykgPT4ge1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIG1haW5DYih0aGlzLmNvbnZlcnQoZXJyb3IsICcvJykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZGVsZXRlRmlsZSA9IChmaWxlOiBzdHJpbmcsIGNiOiBCRlNPbmVBcmdDYWxsYmFjaykgPT4ge1xuICAgICAgICAgIGNvbnN0IHAgPSBwYXRoLmpvaW4oJy8nLCBmaWxlKTtcbiAgICAgICAgICB0aGlzLl9jbGllbnQucmVtb3ZlKHAsIChlcnIpID0+IHtcbiAgICAgICAgICAgIGNiKGVyciA/IHRoaXMuY29udmVydChlcnIsIHApIDogbnVsbCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGZpbmlzaGVkID0gKGVycj86IEFwaUVycm9yKSA9PiB7XG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgbWFpbkNiKGVycik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1haW5DYigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gWFhYOiA8YW55PiB0eXBpbmcgaXMgdG8gZ2V0IGFyb3VuZCBvdmVybHktcmVzdHJpY3RpdmUgRXJyb3JDYWxsYmFjayB0eXBpbmcuXG4gICAgICAgIGFzeW5jRWFjaChmaWxlcyEsIDxhbnk+IGRlbGV0ZUZpbGUsIDxhbnk+IGZpbmlzaGVkKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gcHVibGljIHJlbmFtZShvbGRQYXRoOiBzdHJpbmcsIG5ld1BhdGg6IHN0cmluZywgY2I6IEJGU09uZUFyZ0NhbGxiYWNrKTogdm9pZCB7XG4gICAgdGhpcy5fY2xpZW50Lm1vdmUob2xkUGF0aCwgbmV3UGF0aCwgKGVycm9yKSA9PiB7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgLy8gdGhlIG1vdmUgaXMgcGVybWl0dGVkIGlmIG5ld1BhdGggaXMgYSBmaWxlLlxuICAgICAgICAvLyBDaGVjayBpZiB0aGlzIGlzIHRoZSBjYXNlLCBhbmQgcmVtb3ZlIGlmIHNvLlxuICAgICAgICB0aGlzLl9jbGllbnQuc3RhdChuZXdQYXRoLCAoZXJyb3IyLCBzdGF0KSA9PiB7XG4gICAgICAgICAgaWYgKGVycm9yMiB8fCBzdGF0IS5pc0ZvbGRlcikge1xuICAgICAgICAgICAgY29uc3QgbWlzc2luZ1BhdGggPSAoPGFueT4gZXJyb3IucmVzcG9uc2UpLmVycm9yLmluZGV4T2Yob2xkUGF0aCkgPiAtMSA/IG9sZFBhdGggOiBuZXdQYXRoO1xuICAgICAgICAgICAgY2IodGhpcy5jb252ZXJ0KGVycm9yLCBtaXNzaW5nUGF0aCkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBEZWxldGUgZmlsZSwgcmVwZWF0IHJlbmFtZS5cbiAgICAgICAgICAgIHRoaXMuX2NsaWVudC5yZW1vdmUobmV3UGF0aCwgKGVycm9yMikgPT4ge1xuICAgICAgICAgICAgICBpZiAoZXJyb3IyKSB7XG4gICAgICAgICAgICAgICAgY2IodGhpcy5jb252ZXJ0KGVycm9yMiwgbmV3UGF0aCkpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucmVuYW1lKG9sZFBhdGgsIG5ld1BhdGgsIGNiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNiKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBwdWJsaWMgc3RhdChwYXRoOiBzdHJpbmcsIGlzTHN0YXQ6IGJvb2xlYW4sIGNiOiBCRlNDYWxsYmFjazxTdGF0cz4pOiB2b2lkIHtcbiAgICAvLyBJZ25vcmUgbHN0YXQgY2FzZSAtLSBEcm9wYm94IGRvZXNuJ3Qgc3VwcG9ydCBzeW1saW5rc1xuICAgIC8vIFN0YXQgdGhlIGZpbGVcbiAgICB0aGlzLl9jbGllbnQuc3RhdChwYXRoLCAoZXJyb3IsIHN0YXQpID0+IHtcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBjYih0aGlzLmNvbnZlcnQoZXJyb3IsIHBhdGgpKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdCAmJiBzdGF0LmlzUmVtb3ZlZCkge1xuICAgICAgICAvLyBEcm9wYm94IGtlZXBzIHRyYWNrIG9mIGRlbGV0ZWQgZmlsZXMsIHNvIGlmIGEgZmlsZSBoYXMgZXhpc3RlZCBpbiB0aGVcbiAgICAgICAgLy8gcGFzdCBidXQgZG9lc24ndCBhbnkgbG9uZ2VyLCB5b3Ugd29udCBnZXQgYW4gZXJyb3JcbiAgICAgICAgY2IoQXBpRXJyb3IuRmlsZUVycm9yKEVycm9yQ29kZS5FTk9FTlQsIHBhdGgpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHN0YXRzID0gbmV3IFN0YXRzKHRoaXMuX3N0YXRUeXBlKHN0YXQhKSwgc3RhdCEuc2l6ZSk7XG4gICAgICAgIHJldHVybiBjYihudWxsLCBzdGF0cyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBwdWJsaWMgb3BlbihwYXRoOiBzdHJpbmcsIGZsYWdzOiBGaWxlRmxhZywgbW9kZTogbnVtYmVyLCBjYjogQkZTQ2FsbGJhY2s8RmlsZT4pOiB2b2lkIHtcbiAgICAvLyBUcnkgYW5kIGdldCB0aGUgZmlsZSdzIGNvbnRlbnRzXG4gICAgdGhpcy5fY2xpZW50LnJlYWRGaWxlKHBhdGgsIChlcnJvciwgY29udGVudCwgZGJTdGF0KSA9PiB7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgLy8gSWYgdGhlIGZpbGUncyBiZWluZyBvcGVuZWQgZm9yIHJlYWRpbmcgYW5kIGRvZXNuJ3QgZXhpc3QsIHJldHVybiBhblxuICAgICAgICAvLyBlcnJvclxuICAgICAgICBpZiAoZmxhZ3MuaXNSZWFkYWJsZSgpKSB7XG4gICAgICAgICAgY2IodGhpcy5jb252ZXJ0KGVycm9yLCBwYXRoKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3dpdGNoIChlcnJvci5zdGF0dXMpIHtcbiAgICAgICAgICAgIC8vIElmIGl0J3MgYmVpbmcgb3BlbmVkIGZvciB3cml0aW5nIG9yIGFwcGVuZGluZywgY3JlYXRlIGl0IHNvIHRoYXRcbiAgICAgICAgICAgIC8vIGl0IGNhbiBiZSB3cml0dGVuIHRvXG4gICAgICAgICAgICBjYXNlIERyb3Bib3guQXBpRXJyb3IuTk9UX0ZPVU5EOlxuICAgICAgICAgICAgICBjb25zdCBhYiA9IG5ldyBBcnJheUJ1ZmZlcigwKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dyaXRlRmlsZVN0cmljdChwYXRoLCBhYiwgKGVycm9yMjogQXBpRXJyb3IsIHN0YXQ/OiBEcm9wYm94LkZpbGUuU3RhdCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcjIpIHtcbiAgICAgICAgICAgICAgICAgIGNiKGVycm9yMik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGZpbGUgPSB0aGlzLl9tYWtlRmlsZShwYXRoLCBmbGFncywgc3RhdCEsIGFycmF5QnVmZmVyMkJ1ZmZlcihhYikpO1xuICAgICAgICAgICAgICAgICAgY2IobnVsbCwgZmlsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHJldHVybiBjYih0aGlzLmNvbnZlcnQoZXJyb3IsIHBhdGgpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE5vIGVycm9yXG4gICAgICAgIGxldCBidWZmZXI6IEJ1ZmZlcjtcbiAgICAgICAgLy8gRHJvcGJveC5qcyBzZWVtcyB0byBzZXQgYGNvbnRlbnRgIHRvIGBudWxsYCByYXRoZXIgdGhhbiB0byBhbiBlbXB0eVxuICAgICAgICAvLyBidWZmZXIgd2hlbiByZWFkaW5nIGFuIGVtcHR5IGZpbGUuIE5vdCBzdXJlIHdoeSB0aGlzIGlzLlxuICAgICAgICBpZiAoY29udGVudCA9PT0gbnVsbCkge1xuICAgICAgICAgIGJ1ZmZlciA9IGVtcHR5QnVmZmVyKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnVmZmVyID0gYXJyYXlCdWZmZXIyQnVmZmVyKGNvbnRlbnQhKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmaWxlID0gdGhpcy5fbWFrZUZpbGUocGF0aCwgZmxhZ3MsIGRiU3RhdCEsIGJ1ZmZlcik7XG4gICAgICAgIHJldHVybiBjYihudWxsLCBmaWxlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyBfd3JpdGVGaWxlU3RyaWN0KHA6IHN0cmluZywgZGF0YTogQXJyYXlCdWZmZXIsIGNiOiBCRlNDYWxsYmFjazxEcm9wYm94LkZpbGUuU3RhdD4pOiB2b2lkIHtcbiAgICBjb25zdCBwYXJlbnQgPSBwYXRoLmRpcm5hbWUocCk7XG4gICAgdGhpcy5zdGF0KHBhcmVudCwgZmFsc2UsIChlcnJvcjogQXBpRXJyb3IsIHN0YXQ/OiBTdGF0cyk6IHZvaWQgPT4ge1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGNiKEFwaUVycm9yLkZpbGVFcnJvcihFcnJvckNvZGUuRU5PRU5ULCBwYXJlbnQpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2NsaWVudC53cml0ZUZpbGUocCwgZGF0YSwgKGVycm9yMiwgc3RhdCkgPT4ge1xuICAgICAgICAgIGlmIChlcnJvcjIpIHtcbiAgICAgICAgICAgIGNiKHRoaXMuY29udmVydChlcnJvcjIsIHApKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2IobnVsbCwgc3RhdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcml2YXRlXG4gICAqIFJldHVybnMgYSBCcm93c2VyRlMgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgdHlwZSBvZiBhIERyb3Bib3guanMgc3RhdCBvYmplY3RcbiAgICovXG4gIHB1YmxpYyBfc3RhdFR5cGUoc3RhdDogRHJvcGJveC5GaWxlLlN0YXQpOiBGaWxlVHlwZSB7XG4gICAgcmV0dXJuIHN0YXQuaXNGaWxlID8gRmlsZVR5cGUuRklMRSA6IEZpbGVUeXBlLkRJUkVDVE9SWTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcml2YXRlXG4gICAqIFJldHVybnMgYSBCcm93c2VyRlMgb2JqZWN0IHJlcHJlc2VudGluZyBhIEZpbGUsIGNyZWF0ZWQgZnJvbSB0aGUgZGF0YVxuICAgKiByZXR1cm5lZCBieSBjYWxscyB0byB0aGUgRHJvcGJveCBBUEkuXG4gICAqL1xuICBwdWJsaWMgX21ha2VGaWxlKHBhdGg6IHN0cmluZywgZmxhZzogRmlsZUZsYWcsIHN0YXQ6IERyb3Bib3guRmlsZS5TdGF0LCBidWZmZXI6IEJ1ZmZlcik6IERyb3Bib3hGaWxlIHtcbiAgICBjb25zdCB0eXBlID0gdGhpcy5fc3RhdFR5cGUoc3RhdCk7XG4gICAgY29uc3Qgc3RhdHMgPSBuZXcgU3RhdHModHlwZSwgc3RhdC5zaXplKTtcbiAgICByZXR1cm4gbmV3IERyb3Bib3hGaWxlKHRoaXMsIHBhdGgsIGZsYWcsIHN0YXRzLCBidWZmZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFByaXZhdGVcbiAgICogRGVsZXRlIGEgZmlsZSBvciBkaXJlY3RvcnkgZnJvbSBEcm9wYm94XG4gICAqIGlzRmlsZSBzaG91bGQgcmVmbGVjdCB3aGljaCBjYWxsIHdhcyBtYWRlIHRvIHJlbW92ZSB0aGUgaXQgKGB1bmxpbmtgIG9yXG4gICAqIGBybWRpcmApLiBJZiB0aGlzIGRvZXNuJ3QgbWF0Y2ggd2hhdCdzIGFjdHVhbGx5IGF0IGBwYXRoYCwgYW4gZXJyb3Igd2lsbCBiZVxuICAgKiByZXR1cm5lZFxuICAgKi9cbiAgcHVibGljIF9yZW1vdmUocGF0aDogc3RyaW5nLCBjYjogQkZTT25lQXJnQ2FsbGJhY2ssIGlzRmlsZTogYm9vbGVhbik6IHZvaWQge1xuICAgIHRoaXMuX2NsaWVudC5zdGF0KHBhdGgsIChlcnJvciwgc3RhdCkgPT4ge1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGNiKHRoaXMuY29udmVydChlcnJvciwgcGF0aCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHN0YXQhLmlzRmlsZSAmJiAhaXNGaWxlKSB7XG4gICAgICAgICAgY2IoQXBpRXJyb3IuRmlsZUVycm9yKEVycm9yQ29kZS5FTk9URElSLCBwYXRoKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoIXN0YXQhLmlzRmlsZSAmJiBpc0ZpbGUpIHtcbiAgICAgICAgICBjYihBcGlFcnJvci5GaWxlRXJyb3IoRXJyb3JDb2RlLkVJU0RJUiwgcGF0aCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX2NsaWVudC5yZW1vdmUocGF0aCwgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgY2IodGhpcy5jb252ZXJ0KGVycm9yLCBwYXRoKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjYihudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIERlbGV0ZSBhIGZpbGVcbiAgICovXG4gIHB1YmxpYyB1bmxpbmsocGF0aDogc3RyaW5nLCBjYjogQkZTT25lQXJnQ2FsbGJhY2spOiB2b2lkIHtcbiAgICB0aGlzLl9yZW1vdmUocGF0aCwgY2IsIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlbGV0ZSBhIGRpcmVjdG9yeVxuICAgKi9cbiAgcHVibGljIHJtZGlyKHBhdGg6IHN0cmluZywgY2I6IEJGU09uZUFyZ0NhbGxiYWNrKTogdm9pZCB7XG4gICAgdGhpcy5fcmVtb3ZlKHBhdGgsIGNiLCBmYWxzZSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgZGlyZWN0b3J5XG4gICAqL1xuICBwdWJsaWMgbWtkaXIocDogc3RyaW5nLCBtb2RlOiBudW1iZXIsIGNiOiBCRlNPbmVBcmdDYWxsYmFjayk6IHZvaWQge1xuICAgIC8vIERyb3Bib3guanMnIGNsaWVudC5ta2RpcigpIGJlaGF2ZXMgbGlrZSBgbWtkaXIgLXBgLCBpLmUuIGl0IGNyZWF0ZXMgYVxuICAgIC8vIGRpcmVjdG9yeSBhbmQgYWxsIGl0cyBhbmNlc3RvcnMgaWYgdGhleSBkb24ndCBleGlzdC5cbiAgICAvLyBOb2RlJ3MgZnMubWtkaXIoKSBiZWhhdmVzIGxpa2UgYG1rZGlyYCwgaS5lLiBpdCB0aHJvd3MgYW4gZXJyb3IgaWYgYW4gYXR0ZW1wdFxuICAgIC8vIGlzIG1hZGUgdG8gY3JlYXRlIGEgZGlyZWN0b3J5IHdpdGhvdXQgYSBwYXJlbnQuXG4gICAgLy8gVG8gaGFuZGxlIHRoaXMgaW5jb25zaXN0ZW5jeSwgYSBjaGVjayBmb3IgdGhlIGV4aXN0ZW5jZSBvZiBgcGF0aGAncyBwYXJlbnRcbiAgICAvLyBtdXN0IGJlIHBlcmZvcm1lZCBiZWZvcmUgaXQgaXMgY3JlYXRlZCwgYW5kIGFuIGVycm9yIHRocm93biBpZiBpdCBkb2VzXG4gICAgLy8gbm90IGV4aXN0XG4gICAgY29uc3QgcGFyZW50ID0gcGF0aC5kaXJuYW1lKHApO1xuICAgIHRoaXMuX2NsaWVudC5zdGF0KHBhcmVudCwgKGVycm9yLCBzdGF0KSA9PiB7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgY2IodGhpcy5jb252ZXJ0KGVycm9yLCBwYXJlbnQpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2NsaWVudC5ta2RpcihwLCAoZXJyb3IpID0+IHtcbiAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNiKEFwaUVycm9yLkZpbGVFcnJvcihFcnJvckNvZGUuRUVYSVNULCBwKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNiKG51bGwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBuYW1lcyBvZiB0aGUgZmlsZXMgaW4gYSBkaXJlY3RvcnlcbiAgICovXG4gIHB1YmxpYyByZWFkZGlyKHBhdGg6IHN0cmluZywgY2I6IEJGU0NhbGxiYWNrPHN0cmluZ1tdPik6IHZvaWQge1xuICAgIHRoaXMuX2NsaWVudC5yZWFkZGlyKHBhdGgsIChlcnJvciwgZmlsZXMpID0+IHtcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICByZXR1cm4gY2IodGhpcy5jb252ZXJ0KGVycm9yKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY2IobnVsbCwgZmlsZXMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGEgRHJvcGJveC1KUyBlcnJvciBpbnRvIGEgQkZTIGVycm9yLlxuICAgKi9cbiAgcHVibGljIGNvbnZlcnQoZXJyOiBEcm9wYm94LkFwaUVycm9yLCBwYXRoOiBzdHJpbmcgfCBudWxsID0gbnVsbCk6IEFwaUVycm9yIHtcbiAgICBsZXQgZXJyb3JDb2RlID0gZXJyb3JDb2RlTG9va3VwW2Vyci5zdGF0dXNdO1xuICAgIGlmIChlcnJvckNvZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZXJyb3JDb2RlID0gRXJyb3JDb2RlLkVJTztcbiAgICB9XG5cbiAgICBpZiAoIXBhdGgpIHtcbiAgICAgIHJldHVybiBuZXcgQXBpRXJyb3IoZXJyb3JDb2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIEFwaUVycm9yLkZpbGVFcnJvcihlcnJvckNvZGUsIHBhdGgpO1xuICAgIH1cbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uLy4uLy4uLy4uL3NyYy9iYWNrZW5kL0Ryb3Bib3gudHMiLCJpbXBvcnQge1N5bmNocm9ub3VzRmlsZVN5c3RlbSwgQkZTT25lQXJnQ2FsbGJhY2ssIEJGU0NhbGxiYWNrLCBCRlNUaHJlZUFyZ0NhbGxiYWNrLCBGaWxlU3lzdGVtT3B0aW9uc30gZnJvbSAnLi4vY29yZS9maWxlX3N5c3RlbSc7XG5pbXBvcnQge2RlZmF1bHQgYXMgU3RhdHMsIEZpbGVUeXBlfSBmcm9tICcuLi9jb3JlL25vZGVfZnNfc3RhdHMnO1xuaW1wb3J0IHtGaWxlRmxhZ30gZnJvbSAnLi4vY29yZS9maWxlX2ZsYWcnO1xuaW1wb3J0IHtCYXNlRmlsZSwgRmlsZX0gZnJvbSAnLi4vY29yZS9maWxlJztcbmltcG9ydCB7dWludDhBcnJheTJCdWZmZXIsIGJ1ZmZlcjJVaW50OGFycmF5fSBmcm9tICcuLi9jb3JlL3V0aWwnO1xuaW1wb3J0IHtBcGlFcnJvciwgRXJyb3JDb2RlLCBFcnJvclN0cmluZ3N9IGZyb20gJy4uL2NvcmUvYXBpX2Vycm9yJztcbmltcG9ydCB7RW1zY3JpcHRlbkZTTm9kZX0gZnJvbSAnLi4vZ2VuZXJpYy9lbXNjcmlwdGVuX2ZzJztcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmludGVyZmFjZSBFbXNjcmlwdGVuRXJyb3Ige1xuICBub2RlOiBFbXNjcmlwdGVuRlNOb2RlO1xuICBlcnJubzogbnVtYmVyO1xufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZnVuY3Rpb24gY29udmVydEVycm9yKGU6IEVtc2NyaXB0ZW5FcnJvciwgcGF0aDogc3RyaW5nID0gJycpOiBBcGlFcnJvciB7XG4gIGNvbnN0IGVycm5vID0gZS5lcnJubztcbiAgbGV0IHBhcmVudCA9IGUubm9kZTtcbiAgY29uc3QgcGF0aHM6IHN0cmluZ1tdID0gW107XG4gIHdoaWxlIChwYXJlbnQpIHtcbiAgICBwYXRocy51bnNoaWZ0KHBhcmVudC5uYW1lKTtcbiAgICBpZiAocGFyZW50ID09PSBwYXJlbnQucGFyZW50KSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgfVxuICByZXR1cm4gbmV3IEFwaUVycm9yKGVycm5vLCBFcnJvclN0cmluZ3NbZXJybm9dLCBwYXRocy5sZW5ndGggPiAwID8gJy8nICsgcGF0aHMuam9pbignLycpIDogcGF0aCk7XG59XG5cbmV4cG9ydCBjbGFzcyBFbXNjcmlwdGVuRmlsZSBleHRlbmRzIEJhc2VGaWxlIGltcGxlbWVudHMgRmlsZSB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgX2ZzOiBFbXNjcmlwdGVuRmlsZVN5c3RlbSxcbiAgICBwcml2YXRlIF9GUzogYW55LFxuICAgIHByaXZhdGUgX3BhdGg6IHN0cmluZyxcbiAgICBwcml2YXRlIF9zdHJlYW06IGFueSkge1xuICAgIHN1cGVyKCk7XG4gIH1cbiAgcHVibGljIGdldFBvcygpOiBudW1iZXIgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgcHVibGljIGNsb3NlKGNiOiBCRlNPbmVBcmdDYWxsYmFjayk6IHZvaWQge1xuICAgIGxldCBlcnI6IEFwaUVycm9yIHwgbnVsbCA9IG51bGw7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuY2xvc2VTeW5jKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZXJyID0gZTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgY2IoZXJyKTtcbiAgICB9XG4gIH1cbiAgcHVibGljIGNsb3NlU3luYygpOiB2b2lkIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy5fRlMuY2xvc2UodGhpcy5fc3RyZWFtKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBjb252ZXJ0RXJyb3IoZSwgdGhpcy5fcGF0aCk7XG4gICAgfVxuICB9XG4gIHB1YmxpYyBzdGF0KGNiOiBCRlNDYWxsYmFjazxTdGF0cz4pOiB2b2lkIHtcbiAgICB0cnkge1xuICAgICAgY2IobnVsbCwgdGhpcy5zdGF0U3luYygpKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjYihlKTtcbiAgICB9XG4gIH1cbiAgcHVibGljIHN0YXRTeW5jKCk6IFN0YXRzIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHRoaXMuX2ZzLnN0YXRTeW5jKHRoaXMuX3BhdGgsIGZhbHNlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBjb252ZXJ0RXJyb3IoZSwgdGhpcy5fcGF0aCk7XG4gICAgfVxuICB9XG4gIHB1YmxpYyB0cnVuY2F0ZShsZW46IG51bWJlciwgY2I6IEJGU09uZUFyZ0NhbGxiYWNrKTogdm9pZCB7XG4gICAgbGV0IGVycjogQXBpRXJyb3IgfCBudWxsID0gbnVsbDtcbiAgICB0cnkge1xuICAgICAgdGhpcy50cnVuY2F0ZVN5bmMobGVuKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlcnIgPSBlO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBjYihlcnIpO1xuICAgIH1cbiAgfVxuICBwdWJsaWMgdHJ1bmNhdGVTeW5jKGxlbjogbnVtYmVyKTogdm9pZCB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuX0ZTLmZ0cnVuY2F0ZSh0aGlzLl9zdHJlYW0uZmQsIGxlbik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgY29udmVydEVycm9yKGUsIHRoaXMuX3BhdGgpO1xuICAgIH1cbiAgfVxuICBwdWJsaWMgd3JpdGUoYnVmZmVyOiBOb2RlQnVmZmVyLCBvZmZzZXQ6IG51bWJlciwgbGVuZ3RoOiBudW1iZXIsIHBvc2l0aW9uOiBudW1iZXIsIGNiOiBCRlNUaHJlZUFyZ0NhbGxiYWNrPG51bWJlciwgQnVmZmVyPik6IHZvaWQge1xuICAgIHRyeSB7XG4gICAgICBjYihudWxsLCB0aGlzLndyaXRlU3luYyhidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbiksIGJ1ZmZlcik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY2IoZSk7XG4gICAgfVxuICB9XG4gIHB1YmxpYyB3cml0ZVN5bmMoYnVmZmVyOiBOb2RlQnVmZmVyLCBvZmZzZXQ6IG51bWJlciwgbGVuZ3RoOiBudW1iZXIsIHBvc2l0aW9uOiBudW1iZXIgfCBudWxsKTogbnVtYmVyIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgdTggPSBidWZmZXIyVWludDhhcnJheShidWZmZXIpO1xuICAgICAgLy8gRW1zY3JpcHRlbiBpcyBwYXJ0aWN1bGFyIGFib3V0IHdoYXQgcG9zaXRpb24gaXMgc2V0IHRvLlxuICAgICAgY29uc3QgZW1Qb3NpdGlvbiA9IHBvc2l0aW9uID09PSBudWxsID8gdW5kZWZpbmVkIDogcG9zaXRpb247XG4gICAgICByZXR1cm4gdGhpcy5fRlMud3JpdGUodGhpcy5fc3RyZWFtLCB1OCwgb2Zmc2V0LCBsZW5ndGgsIGVtUG9zaXRpb24pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IGNvbnZlcnRFcnJvcihlLCB0aGlzLl9wYXRoKTtcbiAgICB9XG4gIH1cbiAgcHVibGljIHJlYWQoYnVmZmVyOiBOb2RlQnVmZmVyLCBvZmZzZXQ6IG51bWJlciwgbGVuZ3RoOiBudW1iZXIsIHBvc2l0aW9uOiBudW1iZXIsIGNiOiBCRlNUaHJlZUFyZ0NhbGxiYWNrPG51bWJlciwgQnVmZmVyPik6IHZvaWQge1xuICAgIHRyeSB7XG4gICAgICBjYihudWxsLCB0aGlzLnJlYWRTeW5jKGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uKSwgYnVmZmVyKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjYihlKTtcbiAgICB9XG4gIH1cbiAgcHVibGljIHJlYWRTeW5jKGJ1ZmZlcjogTm9kZUJ1ZmZlciwgb2Zmc2V0OiBudW1iZXIsIGxlbmd0aDogbnVtYmVyLCBwb3NpdGlvbjogbnVtYmVyIHwgbnVsbCk6IG51bWJlciB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHU4ID0gYnVmZmVyMlVpbnQ4YXJyYXkoYnVmZmVyKTtcbiAgICAgIC8vIEVtc2NyaXB0ZW4gaXMgcGFydGljdWxhciBhYm91dCB3aGF0IHBvc2l0aW9uIGlzIHNldCB0by5cbiAgICAgIGNvbnN0IGVtUG9zaXRpb24gPSBwb3NpdGlvbiA9PT0gbnVsbCA/IHVuZGVmaW5lZCA6IHBvc2l0aW9uO1xuICAgICAgcmV0dXJuIHRoaXMuX0ZTLnJlYWQodGhpcy5fc3RyZWFtLCB1OCwgb2Zmc2V0LCBsZW5ndGgsIGVtUG9zaXRpb24pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IGNvbnZlcnRFcnJvcihlLCB0aGlzLl9wYXRoKTtcbiAgICB9XG4gIH1cbiAgcHVibGljIHN5bmMoY2I6IEJGU09uZUFyZ0NhbGxiYWNrKTogdm9pZCB7XG4gICAgLy8gTk9QLlxuICAgIGNiKCk7XG4gIH1cbiAgcHVibGljIHN5bmNTeW5jKCk6IHZvaWQge1xuICAgIC8vIE5PUC5cbiAgfVxuICBwdWJsaWMgY2hvd24odWlkOiBudW1iZXIsIGdpZDogbnVtYmVyLCBjYjogQkZTT25lQXJnQ2FsbGJhY2spOiB2b2lkIHtcbiAgICBsZXQgZXJyOiBBcGlFcnJvciB8IG51bGwgPSBudWxsO1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmNob3duU3luYyh1aWQsIGdpZCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZXJyID0gZTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgY2IoZXJyKTtcbiAgICB9XG4gIH1cbiAgcHVibGljIGNob3duU3luYyh1aWQ6IG51bWJlciwgZ2lkOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy5fRlMuZmNob3duKHRoaXMuX3N0cmVhbS5mZCwgdWlkLCBnaWQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IGNvbnZlcnRFcnJvcihlLCB0aGlzLl9wYXRoKTtcbiAgICB9XG4gIH1cbiAgcHVibGljIGNobW9kKG1vZGU6IG51bWJlciwgY2I6IEJGU09uZUFyZ0NhbGxiYWNrKTogdm9pZCB7XG4gICAgbGV0IGVycjogQXBpRXJyb3IgfCBudWxsID0gbnVsbDtcbiAgICB0cnkge1xuICAgICAgdGhpcy5jaG1vZFN5bmMobW9kZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZXJyID0gZTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgY2IoZXJyKTtcbiAgICB9XG4gIH1cbiAgcHVibGljIGNobW9kU3luYyhtb2RlOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy5fRlMuZmNobW9kKHRoaXMuX3N0cmVhbS5mZCwgbW9kZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgY29udmVydEVycm9yKGUsIHRoaXMuX3BhdGgpO1xuICAgIH1cbiAgfVxuICBwdWJsaWMgdXRpbWVzKGF0aW1lOiBEYXRlLCBtdGltZTogRGF0ZSwgY2I6IEJGU09uZUFyZ0NhbGxiYWNrKTogdm9pZCB7XG4gICAgbGV0IGVycjogQXBpRXJyb3IgfCBudWxsID0gbnVsbDtcbiAgICB0cnkge1xuICAgICAgdGhpcy51dGltZXNTeW5jKGF0aW1lLCBtdGltZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZXJyID0gZTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgY2IoZXJyKTtcbiAgICB9XG4gIH1cbiAgcHVibGljIHV0aW1lc1N5bmMoYXRpbWU6IERhdGUsIG10aW1lOiBEYXRlKTogdm9pZCB7XG4gICAgdGhpcy5fZnMudXRpbWVzU3luYyh0aGlzLl9wYXRoLCBhdGltZSwgbXRpbWUpO1xuICB9XG59XG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvcHRpb25zIGZvciBFbXNjcmlwdGVuIGZpbGUgc3lzdGVtcy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBFbXNjcmlwdGVuRmlsZVN5c3RlbU9wdGlvbnMge1xuICAvLyBUaGUgRW1zY3JpcHRlbiBmaWxlIHN5c3RlbSB0byB1c2UgKGBGU2ApXG4gIEZTOiBhbnk7XG59XG5cbi8qKlxuICogTW91bnRzIGFuIEVtc2NyaXB0ZW4gZmlsZSBzeXN0ZW0gaW50byB0aGUgQnJvd3NlckZTIGZpbGUgc3lzdGVtLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFbXNjcmlwdGVuRmlsZVN5c3RlbSBleHRlbmRzIFN5bmNocm9ub3VzRmlsZVN5c3RlbSB7XG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgTmFtZSA9IFwiRW1zY3JpcHRlbkZpbGVTeXN0ZW1cIjtcblxuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IE9wdGlvbnM6IEZpbGVTeXN0ZW1PcHRpb25zID0ge1xuICAgIEZTOiB7XG4gICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgZGVzY3JpcHRpb246IFwiVGhlIEVtc2NyaXB0ZW4gZmlsZSBzeXN0ZW0gdG8gdXNlICh0aGUgYEZTYCB2YXJpYWJsZSlcIlxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGFuIEVtc2NyaXB0ZW5GaWxlU3lzdGVtIGluc3RhbmNlIHdpdGggdGhlIGdpdmVuIG9wdGlvbnMuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIENyZWF0ZShvcHRzOiBFbXNjcmlwdGVuRmlsZVN5c3RlbU9wdGlvbnMsIGNiOiBCRlNDYWxsYmFjazxFbXNjcmlwdGVuRmlsZVN5c3RlbT4pOiB2b2lkIHtcbiAgICBjYihudWxsLCBuZXcgRW1zY3JpcHRlbkZpbGVTeXN0ZW0ob3B0cy5GUykpO1xuICB9XG4gIHB1YmxpYyBzdGF0aWMgaXNBdmFpbGFibGUoKTogYm9vbGVhbiB7IHJldHVybiB0cnVlOyB9XG5cbiAgcHJpdmF0ZSBfRlM6IGFueTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIEJyb3dzZXJGUyBmaWxlIHN5c3RlbSBmb3IgdGhlIGdpdmVuIEVtc2NyaXB0ZW4gZmlsZSBzeXN0ZW0uXG4gICAqIEBwYXJhbSBfRlMgVGhlIEVtc2NyaXB0ZW4gZmlsZSBzeXN0ZW0gKGBGU2ApLlxuICAgKi9cbiAgY29uc3RydWN0b3IoX0ZTOiBhbnkpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX0ZTID0gX0ZTO1xuICB9XG4gIHB1YmxpYyBnZXROYW1lKCk6IHN0cmluZyB7IHJldHVybiB0aGlzLl9GUy5EQl9OQU1FKCk7IH1cbiAgcHVibGljIGlzUmVhZE9ubHkoKTogYm9vbGVhbiB7IHJldHVybiBmYWxzZTsgfVxuICBwdWJsaWMgc3VwcG9ydHNMaW5rcygpOiBib29sZWFuIHsgcmV0dXJuIHRydWU7IH1cbiAgcHVibGljIHN1cHBvcnRzUHJvcHMoKTogYm9vbGVhbiB7IHJldHVybiB0cnVlOyB9XG4gIHB1YmxpYyBzdXBwb3J0c1N5bmNoKCk6IGJvb2xlYW4geyByZXR1cm4gdHJ1ZTsgfVxuXG4gIHB1YmxpYyByZW5hbWVTeW5jKG9sZFBhdGg6IHN0cmluZywgbmV3UGF0aDogc3RyaW5nKTogdm9pZCB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuX0ZTLnJlbmFtZShvbGRQYXRoLCBuZXdQYXRoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoZS5lcnJubyA9PT0gRXJyb3JDb2RlLkVOT0VOVCkge1xuICAgICAgICB0aHJvdyBjb252ZXJ0RXJyb3IoZSwgdGhpcy5leGlzdHNTeW5jKG9sZFBhdGgpID8gbmV3UGF0aCA6IG9sZFBhdGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgY29udmVydEVycm9yKGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBzdGF0U3luYyhwOiBzdHJpbmcsIGlzTHN0YXQ6IGJvb2xlYW4pOiBTdGF0cyB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN0YXRzID0gaXNMc3RhdCA/IHRoaXMuX0ZTLmxzdGF0KHApIDogdGhpcy5fRlMuc3RhdChwKTtcbiAgICAgIGNvbnN0IGl0ZW1UeXBlID0gdGhpcy5tb2RlVG9GaWxlVHlwZShzdGF0cy5tb2RlKTtcbiAgICAgIHJldHVybiBuZXcgU3RhdHMoXG4gICAgICAgIGl0ZW1UeXBlLFxuICAgICAgICBzdGF0cy5zaXplLFxuICAgICAgICBzdGF0cy5tb2RlLFxuICAgICAgICBzdGF0cy5hdGltZSxcbiAgICAgICAgc3RhdHMubXRpbWUsXG4gICAgICAgIHN0YXRzLmN0aW1lXG4gICAgICApO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IGNvbnZlcnRFcnJvcihlLCBwKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgb3BlblN5bmMocDogc3RyaW5nLCBmbGFnOiBGaWxlRmxhZywgbW9kZTogbnVtYmVyKTogRW1zY3JpcHRlbkZpbGUge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdHJlYW0gPSB0aGlzLl9GUy5vcGVuKHAsIGZsYWcuZ2V0RmxhZ1N0cmluZygpLCBtb2RlKTtcbiAgICAgIGlmICh0aGlzLl9GUy5pc0RpcihzdHJlYW0ubm9kZS5tb2RlKSkge1xuICAgICAgICB0aGlzLl9GUy5jbG9zZShzdHJlYW0pO1xuICAgICAgICB0aHJvdyBBcGlFcnJvci5FSVNESVIocCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IEVtc2NyaXB0ZW5GaWxlKHRoaXMsIHRoaXMuX0ZTLCBwLCBzdHJlYW0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IGNvbnZlcnRFcnJvcihlLCBwKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgdW5saW5rU3luYyhwOiBzdHJpbmcpOiB2b2lkIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy5fRlMudW5saW5rKHApO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IGNvbnZlcnRFcnJvcihlLCBwKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgcm1kaXJTeW5jKHA6IHN0cmluZyk6IHZvaWQge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLl9GUy5ybWRpcihwKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBjb252ZXJ0RXJyb3IoZSwgcCk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIG1rZGlyU3luYyhwOiBzdHJpbmcsIG1vZGU6IG51bWJlcik6IHZvaWQge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLl9GUy5ta2RpcihwLCBtb2RlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBjb252ZXJ0RXJyb3IoZSwgcCk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHJlYWRkaXJTeW5jKHA6IHN0cmluZyk6IHN0cmluZ1tdIHtcbiAgICB0cnkge1xuICAgICAgLy8gRW1zY3JpcHRlbiByZXR1cm5zIGl0ZW1zIGZvciAnLicgYW5kICcuLicuIE5vZGUgZG9lcyBub3QuXG4gICAgICByZXR1cm4gdGhpcy5fRlMucmVhZGRpcihwKS5maWx0ZXIoKHA6IHN0cmluZykgPT4gcCAhPT0gJy4nICYmIHAgIT09ICcuLicpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IGNvbnZlcnRFcnJvcihlLCBwKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgdHJ1bmNhdGVTeW5jKHA6IHN0cmluZywgbGVuOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy5fRlMudHJ1bmNhdGUocCwgbGVuKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBjb252ZXJ0RXJyb3IoZSwgcCk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHJlYWRGaWxlU3luYyhwOiBzdHJpbmcsIGVuY29kaW5nOiBzdHJpbmcsIGZsYWc6IEZpbGVGbGFnKTogYW55IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZGF0YTogVWludDhBcnJheSA9IHRoaXMuX0ZTLnJlYWRGaWxlKHAsIHsgZmxhZ3M6IGZsYWcuZ2V0RmxhZ1N0cmluZygpIH0pO1xuICAgICAgY29uc3QgYnVmZiA9IHVpbnQ4QXJyYXkyQnVmZmVyKGRhdGEpO1xuICAgICAgaWYgKGVuY29kaW5nKSB7XG4gICAgICAgIHJldHVybiBidWZmLnRvU3RyaW5nKGVuY29kaW5nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBidWZmO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IGNvbnZlcnRFcnJvcihlLCBwKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgd3JpdGVGaWxlU3luYyhwOiBzdHJpbmcsIGRhdGE6IGFueSwgZW5jb2Rpbmc6IHN0cmluZywgZmxhZzogRmlsZUZsYWcsIG1vZGU6IG51bWJlcik6IHZvaWQge1xuICAgIHRyeSB7XG4gICAgICBpZiAoZW5jb2RpbmcpIHtcbiAgICAgICAgZGF0YSA9IEJ1ZmZlci5mcm9tKGRhdGEsIGVuY29kaW5nKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHU4ID0gYnVmZmVyMlVpbnQ4YXJyYXkoZGF0YSk7XG4gICAgICB0aGlzLl9GUy53cml0ZUZpbGUocCwgdTgsIHsgZmxhZ3M6IGZsYWcuZ2V0RmxhZ1N0cmluZygpLCBlbmNvZGluZzogJ2JpbmFyeScgfSk7XG4gICAgICB0aGlzLl9GUy5jaG1vZChwLCBtb2RlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBjb252ZXJ0RXJyb3IoZSwgcCk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGNobW9kU3luYyhwOiBzdHJpbmcsIGlzTGNobW9kOiBib29sZWFuLCBtb2RlOiBudW1iZXIpIHtcbiAgICB0cnkge1xuICAgICAgaXNMY2htb2QgPyB0aGlzLl9GUy5sY2htb2QocCwgbW9kZSkgOiB0aGlzLl9GUy5jaG1vZChwLCBtb2RlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBjb252ZXJ0RXJyb3IoZSwgcCk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGNob3duU3luYyhwOiBzdHJpbmcsIGlzTGNob3duOiBib29sZWFuLCB1aWQ6IG51bWJlciwgZ2lkOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0cnkge1xuICAgICAgaXNMY2hvd24gPyB0aGlzLl9GUy5sY2hvd24ocCwgdWlkLCBnaWQpIDogdGhpcy5fRlMuY2hvd24ocCwgdWlkLCBnaWQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IGNvbnZlcnRFcnJvcihlLCBwKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgc3ltbGlua1N5bmMoc3JjcGF0aDogc3RyaW5nLCBkc3RwYXRoOiBzdHJpbmcsIHR5cGU6IHN0cmluZyk6IHZvaWQge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLl9GUy5zeW1saW5rKHNyY3BhdGgsIGRzdHBhdGgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IGNvbnZlcnRFcnJvcihlKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgcmVhZGxpbmtTeW5jKHA6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB0aGlzLl9GUy5yZWFkbGluayhwKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBjb252ZXJ0RXJyb3IoZSwgcCk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHV0aW1lc1N5bmMocDogc3RyaW5nLCBhdGltZTogRGF0ZSwgbXRpbWU6IERhdGUpOiB2b2lkIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy5fRlMudXRpbWUocCwgYXRpbWUuZ2V0VGltZSgpLCBtdGltZS5nZXRUaW1lKCkpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IGNvbnZlcnRFcnJvcihlLCBwKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIG1vZGVUb0ZpbGVUeXBlKG1vZGU6IG51bWJlcik6IEZpbGVUeXBlIHtcbiAgICBpZiAodGhpcy5fRlMuaXNEaXIobW9kZSkpIHtcbiAgICAgIHJldHVybiBGaWxlVHlwZS5ESVJFQ1RPUlk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9GUy5pc0ZpbGUobW9kZSkpIHtcbiAgICAgIHJldHVybiBGaWxlVHlwZS5GSUxFO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fRlMuaXNMaW5rKG1vZGUpKSB7XG4gICAgICByZXR1cm4gRmlsZVR5cGUuU1lNTElOSztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgQXBpRXJyb3IuRVBFUk0oYEludmFsaWQgbW9kZTogJHttb2RlfWApO1xuICAgIH1cbiAgfVxuXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vLi4vLi4vLi4vc3JjL2JhY2tlbmQvRW1zY3JpcHRlbi50cyIsImltcG9ydCB7QmFzZUZpbGVTeXN0ZW0sIEZpbGVTeXN0ZW0sIEJGU0NhbGxiYWNrLCBGaWxlU3lzdGVtT3B0aW9uc30gZnJvbSAnLi4vY29yZS9maWxlX3N5c3RlbSc7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IHtBcGlFcnJvcn0gZnJvbSAnLi4vY29yZS9hcGlfZXJyb3InO1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgYSBGb2xkZXJBZGFwdGVyIGZpbGUgc3lzdGVtLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEZvbGRlckFkYXB0ZXJPcHRpb25zIHtcbiAgLy8gVGhlIGZvbGRlciB0byB1c2UgYXMgdGhlIHJvb3QgZGlyZWN0b3J5LlxuICBmb2xkZXI6IHN0cmluZztcbiAgLy8gVGhlIGZpbGUgc3lzdGVtIHRvIHdyYXAuXG4gIHdyYXBwZWQ6IEZpbGVTeXN0ZW07XG59XG5cbi8qKlxuICogVGhlIEZvbGRlckFkYXB0ZXIgZmlsZSBzeXN0ZW0gd3JhcHMgYSBmaWxlIHN5c3RlbSwgYW5kIHNjb3BlcyBhbGwgaW50ZXJhY3Rpb25zIHRvIGEgc3ViZm9sZGVyIG9mIHRoYXQgZmlsZSBzeXN0ZW0uXG4gKlxuICogRXhhbXBsZTogR2l2ZW4gYSBmaWxlIHN5c3RlbSBgZm9vYCB3aXRoIGZvbGRlciBgYmFyYCBhbmQgZmlsZSBgYmFyL2JhemAuLi5cbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBCcm93c2VyRlMuY29uZmlndXJlKHtcbiAqICAgZnM6IFwiRm9sZGVyQWRhcHRlclwiLFxuICogICBvcHRpb25zOiB7XG4gKiAgICAgZm9sZGVyOiBcImJhclwiLFxuICogICAgIHdyYXBwZWQ6IGZvb1xuICogICB9XG4gKiB9LCBmdW5jdGlvbihlKSB7XG4gKiAgIHZhciBmcyA9IEJyb3dzZXJGUy5CRlNSZXF1aXJlKCdmcycpO1xuICogICBmcy5yZWFkZGlyU3luYygnLycpOyAvLyBbJ2JheiddXG4gKiB9KTtcbiAqIGBgYFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGb2xkZXJBZGFwdGVyIGV4dGVuZHMgQmFzZUZpbGVTeXN0ZW0gaW1wbGVtZW50cyBGaWxlU3lzdGVtIHtcbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBOYW1lID0gXCJGb2xkZXJBZGFwdGVyXCI7XG5cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBPcHRpb25zOiBGaWxlU3lzdGVtT3B0aW9ucyA9IHtcbiAgICBmb2xkZXI6IHtcbiAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICBkZXNjcmlwdGlvbjogXCJUaGUgZm9sZGVyIHRvIHVzZSBhcyB0aGUgcm9vdCBkaXJlY3RvcnlcIlxuICAgIH0sXG4gICAgd3JhcHBlZDoge1xuICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgIGRlc2NyaXB0aW9uOiBcIlRoZSBmaWxlIHN5c3RlbSB0byB3cmFwXCJcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBGb2xkZXJBZGFwdGVyIGluc3RhbmNlIHdpdGggdGhlIGdpdmVuIG9wdGlvbnMuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIENyZWF0ZShvcHRzOiBGb2xkZXJBZGFwdGVyT3B0aW9ucywgY2I6IEJGU0NhbGxiYWNrPEZvbGRlckFkYXB0ZXI+KTogdm9pZCB7XG4gICAgY2IobnVsbCwgbmV3IEZvbGRlckFkYXB0ZXIob3B0cy5mb2xkZXIsIG9wdHMud3JhcHBlZCkpO1xuICB9XG4gIHB1YmxpYyBzdGF0aWMgaXNBdmFpbGFibGUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBwdWJsaWMgX3dyYXBwZWQ6IEZpbGVTeXN0ZW07XG4gIHB1YmxpYyBfZm9sZGVyOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBXcmFwcyBhIGZpbGUgc3lzdGVtLCBhbmQgdXNlcyB0aGUgZ2l2ZW4gZm9sZGVyIGFzIGl0cyByb290LlxuICAgKlxuICAgKiBAcGFyYW0gZm9sZGVyIFRoZSBmb2xkZXIgdG8gdXNlIGFzIHRoZSByb290IGRpcmVjdG9yeS5cbiAgICogQHBhcmFtIHdyYXBwZWQgVGhlIGZpbGUgc3lzdGVtIHRvIHdyYXAuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihmb2xkZXI6IHN0cmluZywgd3JhcHBlZDogRmlsZVN5c3RlbSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fZm9sZGVyID0gZm9sZGVyO1xuICAgIHRoaXMuX3dyYXBwZWQgPSB3cmFwcGVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgdGhlIGZpbGUgc3lzdGVtLiBFbnN1cmVzIHRoYXQgdGhlIHdyYXBwZWQgZmlsZSBzeXN0ZW1cbiAgICogaGFzIHRoZSBnaXZlbiBmb2xkZXIuXG4gICAqL1xuICBwdWJsaWMgaW5pdGlhbGl6ZShjYjogKGU/OiBBcGlFcnJvcikgPT4gdm9pZCkge1xuICAgIHRoaXMuX3dyYXBwZWQuZXhpc3RzKHRoaXMuX2ZvbGRlciwgKGV4aXN0czogYm9vbGVhbikgPT4ge1xuICAgICAgaWYgKGV4aXN0cykge1xuICAgICAgICBjYigpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl93cmFwcGVkLmlzUmVhZE9ubHkoKSkge1xuICAgICAgICBjYihBcGlFcnJvci5FTk9FTlQodGhpcy5fZm9sZGVyKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl93cmFwcGVkLm1rZGlyKHRoaXMuX2ZvbGRlciwgMHgxZmYsIGNiKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyBnZXROYW1lKCk6IHN0cmluZyB7IHJldHVybiB0aGlzLl93cmFwcGVkLmdldE5hbWUoKTsgfVxuICBwdWJsaWMgaXNSZWFkT25seSgpOiBib29sZWFuIHsgcmV0dXJuIHRoaXMuX3dyYXBwZWQuaXNSZWFkT25seSgpOyB9XG4gIHB1YmxpYyBzdXBwb3J0c1Byb3BzKCk6IGJvb2xlYW4geyByZXR1cm4gdGhpcy5fd3JhcHBlZC5zdXBwb3J0c1Byb3BzKCk7IH1cbiAgcHVibGljIHN1cHBvcnRzU3luY2goKTogYm9vbGVhbiB7IHJldHVybiB0aGlzLl93cmFwcGVkLnN1cHBvcnRzU3luY2goKTsgfVxuICBwdWJsaWMgc3VwcG9ydHNMaW5rcygpOiBib29sZWFuIHsgcmV0dXJuIGZhbHNlOyB9XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5mdW5jdGlvbiB0cmFuc2xhdGVFcnJvcihmb2xkZXI6IHN0cmluZywgZTogYW55KTogYW55IHtcbiAgaWYgKGUgIT09IG51bGwgJiYgdHlwZW9mIGUgPT09ICdvYmplY3QnKSB7XG4gICAgY29uc3QgZXJyID0gPEFwaUVycm9yPiBlO1xuICAgIGxldCBwID0gZXJyLnBhdGg7XG4gICAgaWYgKHApIHtcbiAgICAgIHAgPSAnLycgKyBwYXRoLnJlbGF0aXZlKGZvbGRlciwgcCk7XG4gICAgICBlcnIubWVzc2FnZSA9IGVyci5tZXNzYWdlLnJlcGxhY2UoZXJyLnBhdGghLCBwKTtcbiAgICAgIGVyci5wYXRoID0gcDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGU7XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5mdW5jdGlvbiB3cmFwQ2FsbGJhY2soZm9sZGVyOiBzdHJpbmcsIGNiOiBhbnkpOiBhbnkge1xuICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGVycjogQXBpRXJyb3IpIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICBhcmd1bWVudHNbMF0gPSB0cmFuc2xhdGVFcnJvcihmb2xkZXIsIGVycik7XG4gICAgICB9XG4gICAgICAoPEZ1bmN0aW9uPiBjYikuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjYjtcbiAgfVxufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZnVuY3Rpb24gd3JhcEZ1bmN0aW9uKG5hbWU6IHN0cmluZywgd3JhcEZpcnN0OiBib29sZWFuLCB3cmFwU2Vjb25kOiBib29sZWFuKTogRnVuY3Rpb24ge1xuICBpZiAobmFtZS5zbGljZShuYW1lLmxlbmd0aCAtIDQpICE9PSAnU3luYycpIHtcbiAgICAvLyBBc3luYyBmdW5jdGlvbi4gVHJhbnNsYXRlIGVycm9yIGluIGNhbGxiYWNrLlxuICAgIHJldHVybiBmdW5jdGlvbih0aGlzOiBGb2xkZXJBZGFwdGVyKSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKHdyYXBGaXJzdCkge1xuICAgICAgICAgIGFyZ3VtZW50c1swXSA9IHBhdGguam9pbih0aGlzLl9mb2xkZXIsIGFyZ3VtZW50c1swXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdyYXBTZWNvbmQpIHtcbiAgICAgICAgICBhcmd1bWVudHNbMV0gPSBwYXRoLmpvaW4odGhpcy5fZm9sZGVyLCBhcmd1bWVudHNbMV0pO1xuICAgICAgICB9XG4gICAgICAgIGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV0gPSB3cmFwQ2FsbGJhY2sodGhpcy5fZm9sZGVyLCBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoPGFueT4gdGhpcy5fd3JhcHBlZClbbmFtZV0uYXBwbHkodGhpcy5fd3JhcHBlZCwgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIC8vIFN5bmMgZnVuY3Rpb24uIFRyYW5zbGF0ZSBlcnJvciBpbiBjYXRjaC5cbiAgICByZXR1cm4gZnVuY3Rpb24odGhpczogRm9sZGVyQWRhcHRlcikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHdyYXBGaXJzdCkge1xuICAgICAgICAgIGFyZ3VtZW50c1swXSA9IHBhdGguam9pbih0aGlzLl9mb2xkZXIsIGFyZ3VtZW50c1swXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdyYXBTZWNvbmQpIHtcbiAgICAgICAgICBhcmd1bWVudHNbMV0gPSBwYXRoLmpvaW4odGhpcy5fZm9sZGVyLCBhcmd1bWVudHNbMV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoPGFueT4gdGhpcy5fd3JhcHBlZClbbmFtZV0uYXBwbHkodGhpcy5fd3JhcHBlZCwgYXJndW1lbnRzKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgdHJhbnNsYXRlRXJyb3IodGhpcy5fZm9sZGVyLCBlKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59XG5cbi8vIEZpcnN0IGFyZ3VtZW50IGlzIGEgcGF0aC5cblsnZGlza1NwYWNlJywgJ3N0YXQnLCAnc3RhdFN5bmMnLCAnb3BlbicsICdvcGVuU3luYycsICd1bmxpbmsnLCAndW5saW5rU3luYycsXG4gJ3JtZGlyJywgJ3JtZGlyU3luYycsICdta2RpcicsICdta2RpclN5bmMnLCAncmVhZGRpcicsICdyZWFkZGlyU3luYycsICdleGlzdHMnLFxuICdleGlzdHNTeW5jJywgJ3JlYWxwYXRoJywgJ3JlYWxwYXRoU3luYycsICd0cnVuY2F0ZScsICd0cnVuY2F0ZVN5bmMnLCAncmVhZEZpbGUnLFxuICdyZWFkRmlsZVN5bmMnLCAnd3JpdGVGaWxlJywgJ3dyaXRlRmlsZVN5bmMnLCAnYXBwZW5kRmlsZScsICdhcHBlbmRGaWxlU3luYycsXG4gJ2NobW9kJywgJ2NobW9kU3luYycsICdjaG93bicsICdjaG93blN5bmMnLCAndXRpbWVzJywgJ3V0aW1lc1N5bmMnLCAncmVhZGxpbmsnLFxuICdyZWFkbGlua1N5bmMnXS5mb3JFYWNoKChuYW1lOiBzdHJpbmcpID0+IHtcbiAgKDxhbnk+IEZvbGRlckFkYXB0ZXIucHJvdG90eXBlKVtuYW1lXSA9IHdyYXBGdW5jdGlvbihuYW1lLCB0cnVlLCBmYWxzZSk7XG59KTtcblxuLy8gRmlyc3QgYW5kIHNlY29uZCBhcmd1bWVudHMgYXJlIHBhdGhzLlxuWydyZW5hbWUnLCAncmVuYW1lU3luYycsICdsaW5rJywgJ2xpbmtTeW5jJywgJ3N5bWxpbmsnLCAnc3ltbGlua1N5bmMnXS5mb3JFYWNoKChuYW1lOiBzdHJpbmcpID0+IHtcbiAgKDxhbnk+IEZvbGRlckFkYXB0ZXIucHJvdG90eXBlKVtuYW1lXSA9IHdyYXBGdW5jdGlvbihuYW1lLCB0cnVlLCB0cnVlKTtcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uLy4uLy4uLy4uL3NyYy9iYWNrZW5kL0ZvbGRlckFkYXB0ZXIudHMiLCIvKipcbiAqIEV4cG9ydHMgdGhlIGdsb2JhbCBzY29wZSB2YXJpYWJsZS5cbiAqIEluIHRoZSBtYWluIGJyb3dzZXIgdGhyZWFkLCB0aGlzIGlzIFwid2luZG93XCIuXG4gKiBJbiBhIFdlYldvcmtlciwgdGhpcyBpcyBcInNlbGZcIi5cbiAqIEluIE5vZGUsIHRoaXMgaXMgXCJnbG9iYWxcIi5cbiAqIEBoaWRkZW5cbiAqIEBwcml2YXRlXG4gKi9cbmRlY2xhcmUgdmFyIGdsb2JhbDogYW55O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCB0b0V4cG9ydDogYW55O1xuaWYgKHR5cGVvZih3aW5kb3cpICE9PSAndW5kZWZpbmVkJykge1xuICB0b0V4cG9ydCA9IHdpbmRvdztcbn0gZWxzZSBpZiAodHlwZW9mKHNlbGYpICE9PSAndW5kZWZpbmVkJykge1xuICB0b0V4cG9ydCA9IHNlbGY7XG59IGVsc2Uge1xuICB0b0V4cG9ydCA9IGdsb2JhbDtcbn1cbmV4cG9ydCBkZWZhdWx0IHRvRXhwb3J0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uLy4uLy4uLy4uL3NyYy9jb3JlL2dsb2JhbC50cyIsImltcG9ydCBQcmVsb2FkRmlsZSBmcm9tICcuLi9nZW5lcmljL3ByZWxvYWRfZmlsZSc7XG5pbXBvcnQge0Jhc2VGaWxlU3lzdGVtLCBGaWxlU3lzdGVtIGFzIElGaWxlU3lzdGVtLCBCRlNPbmVBcmdDYWxsYmFjaywgQkZTQ2FsbGJhY2ssIEZpbGVTeXN0ZW1PcHRpb25zfSBmcm9tICcuLi9jb3JlL2ZpbGVfc3lzdGVtJztcbmltcG9ydCB7QXBpRXJyb3IsIEVycm9yQ29kZX0gZnJvbSAnLi4vY29yZS9hcGlfZXJyb3InO1xuaW1wb3J0IHtGaWxlRmxhZywgQWN0aW9uVHlwZX0gZnJvbSAnLi4vY29yZS9maWxlX2ZsYWcnO1xuaW1wb3J0IHtkZWZhdWx0IGFzIFN0YXRzLCBGaWxlVHlwZX0gZnJvbSAnLi4vY29yZS9ub2RlX2ZzX3N0YXRzJztcbmltcG9ydCB7RmlsZSBhcyBJRmlsZX0gZnJvbSAnLi4vY29yZS9maWxlJztcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgZ2xvYmFsIGZyb20gJy4uL2NvcmUvZ2xvYmFsJztcbmltcG9ydCB7ZWFjaCBhcyBhc3luY0VhY2h9IGZyb20gJ2FzeW5jJztcbmltcG9ydCB7YnVmZmVyMkFycmF5QnVmZmVyLCBhcnJheUJ1ZmZlcjJCdWZmZXIsIGRlcHJlY2F0aW9uTWVzc2FnZX0gZnJvbSAnLi4vY29yZS91dGlsJztcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmZ1bmN0aW9uIGlzRGlyZWN0b3J5RW50cnkoZW50cnk6IEVudHJ5KTogZW50cnkgaXMgRGlyZWN0b3J5RW50cnkge1xuICByZXR1cm4gZW50cnkuaXNEaXJlY3Rvcnk7XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBfZ2V0RlM6ICh0eXBlOiBudW1iZXIsIHNpemU6IG51bWJlciwgc3VjY2Vzc0NhbGxiYWNrOiBGaWxlU3lzdGVtQ2FsbGJhY2ssIGVycm9yQ2FsbGJhY2s/OiBFcnJvckNhbGxiYWNrKSA9PiB2b2lkID0gZ2xvYmFsLndlYmtpdFJlcXVlc3RGaWxlU3lzdGVtIHx8IGdsb2JhbC5yZXF1ZXN0RmlsZVN5c3RlbSB8fCBudWxsO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZnVuY3Rpb24gX3JlcXVlc3RRdW90YSh0eXBlOiBudW1iZXIsIHNpemU6IG51bWJlciwgc3VjY2VzczogKHNpemU6IG51bWJlcikgPT4gdm9pZCwgZXJyb3JDYWxsYmFjazogRXJyb3JDYWxsYmFjaykge1xuICAvLyBXZSBjYXN0IG5hdmlnYXRvciBhbmQgd2luZG93IHRvICc8YW55PicgYmVjYXVzZSBldmVyeXRoaW5nIGhlcmUgaXNcbiAgLy8gbm9uc3RhbmRhcmQgZnVuY3Rpb25hbGl0eSwgZGVzcGl0ZSB0aGUgZmFjdCB0aGF0IENocm9tZSBoYXMgdGhlIG9ubHlcbiAgLy8gaW1wbGVtZW50YXRpb24gb2YgdGhlIEhUTUw1RlMgYW5kIGlzIGxpa2VseSBkcml2aW5nIHRoZSBzdGFuZGFyZGl6YXRpb25cbiAgLy8gcHJvY2Vzcy4gVGh1cywgdGhlc2Ugb2JqZWN0cyBkZWZpbmVkIG9mZiBvZiBuYXZpZ2F0b3IgYW5kIHdpbmRvdyBhcmUgbm90XG4gIC8vIHByZXNlbnQgaW4gdGhlIERlZmluaXRlbHlUeXBlZCBUeXBlU2NyaXB0IHR5cGluZ3MgZm9yIEZpbGVTeXN0ZW0uXG4gIGlmICh0eXBlb2YgKDxhbnk+IG5hdmlnYXRvcilbJ3dlYmtpdFBlcnNpc3RlbnRTdG9yYWdlJ10gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIGdsb2JhbC5QRVJTSVNURU5UOlxuICAgICAgICAoPGFueT4gbmF2aWdhdG9yKS53ZWJraXRQZXJzaXN0ZW50U3RvcmFnZS5yZXF1ZXN0UXVvdGEoc2l6ZSwgc3VjY2VzcywgZXJyb3JDYWxsYmFjayk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBnbG9iYWwuVEVNUE9SQVJZOlxuICAgICAgICAoPGFueT4gbmF2aWdhdG9yKS53ZWJraXRUZW1wb3JhcnlTdG9yYWdlLnJlcXVlc3RRdW90YShzaXplLCBzdWNjZXNzLCBlcnJvckNhbGxiYWNrKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBlcnJvckNhbGxiYWNrKG5ldyBUeXBlRXJyb3IoYEludmFsaWQgc3RvcmFnZSB0eXBlOiAke3R5cGV9YCkpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgKDxhbnk+IGdsb2JhbCkud2Via2l0U3RvcmFnZUluZm8ucmVxdWVzdFF1b3RhKHR5cGUsIHNpemUsIHN1Y2Nlc3MsIGVycm9yQ2FsbGJhY2spO1xuICB9XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5mdW5jdGlvbiBfdG9BcnJheShsaXN0PzogYW55W10pOiBhbnlbXSB7XG4gIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChsaXN0IHx8IFtdLCAwKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gRE9NRXJyb3IgaW50byBhbiBhcHByb3ByaWF0ZSBBcGlFcnJvci5cbiAqIEB1cmwgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0RPTUVycm9yXG4gKiBAaGlkZGVuXG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRFcnJvcihlcnI6IERPTUVycm9yLCBwOiBzdHJpbmcsIGV4cGVjdGVkRGlyOiBib29sZWFuKTogQXBpRXJyb3Ige1xuICBzd2l0Y2ggKGVyci5uYW1lKSB7XG4gICAgLyogVGhlIHVzZXIgYWdlbnQgZmFpbGVkIHRvIGNyZWF0ZSBhIGZpbGUgb3IgZGlyZWN0b3J5IGR1ZSB0byB0aGUgZXhpc3RlbmNlIG9mIGEgZmlsZSBvclxuICAgICAgICBkaXJlY3Rvcnkgd2l0aCB0aGUgc2FtZSBwYXRoLiAgKi9cbiAgICBjYXNlIFwiUGF0aEV4aXN0c0Vycm9yXCI6XG4gICAgICByZXR1cm4gQXBpRXJyb3IuRUVYSVNUKHApO1xuICAgIC8qIFRoZSBvcGVyYXRpb24gZmFpbGVkIGJlY2F1c2UgaXQgd291bGQgY2F1c2UgdGhlIGFwcGxpY2F0aW9uIHRvIGV4Y2VlZCBpdHMgc3RvcmFnZSBxdW90YS4gICovXG4gICAgY2FzZSAnUXVvdGFFeGNlZWRlZEVycm9yJzpcbiAgICAgIHJldHVybiBBcGlFcnJvci5GaWxlRXJyb3IoRXJyb3JDb2RlLkVOT1NQQywgcCk7XG4gICAgLyogIEEgcmVxdWlyZWQgZmlsZSBvciBkaXJlY3RvcnkgY291bGQgbm90IGJlIGZvdW5kIGF0IHRoZSB0aW1lIGFuIG9wZXJhdGlvbiB3YXMgcHJvY2Vzc2VkLiAgICovXG4gICAgY2FzZSAnTm90Rm91bmRFcnJvcic6XG4gICAgICByZXR1cm4gQXBpRXJyb3IuRU5PRU5UKHApO1xuICAgIC8qIFRoaXMgaXMgYSBzZWN1cml0eSBlcnJvciBjb2RlIHRvIGJlIHVzZWQgaW4gc2l0dWF0aW9ucyBub3QgY292ZXJlZCBieSBhbnkgb3RoZXIgZXJyb3IgY29kZXMuXG4gICAgICAgIC0gQSByZXF1aXJlZCBmaWxlIHdhcyB1bnNhZmUgZm9yIGFjY2VzcyB3aXRoaW4gYSBXZWIgYXBwbGljYXRpb25cbiAgICAgICAgLSBUb28gbWFueSBjYWxscyBhcmUgYmVpbmcgbWFkZSBvbiBmaWxlc3lzdGVtIHJlc291cmNlcyAqL1xuICAgIGNhc2UgJ1NlY3VyaXR5RXJyb3InOlxuICAgICAgcmV0dXJuIEFwaUVycm9yLkZpbGVFcnJvcihFcnJvckNvZGUuRUFDQ0VTLCBwKTtcbiAgICAvKiBUaGUgbW9kaWZpY2F0aW9uIHJlcXVlc3RlZCB3YXMgaWxsZWdhbC4gRXhhbXBsZXMgb2YgaW52YWxpZCBtb2RpZmljYXRpb25zIGluY2x1ZGUgbW92aW5nIGFcbiAgICAgICAgZGlyZWN0b3J5IGludG8gaXRzIG93biBjaGlsZCwgbW92aW5nIGEgZmlsZSBpbnRvIGl0cyBwYXJlbnQgZGlyZWN0b3J5IHdpdGhvdXQgY2hhbmdpbmcgaXRzIG5hbWUsXG4gICAgICAgIG9yIGNvcHlpbmcgYSBkaXJlY3RvcnkgdG8gYSBwYXRoIG9jY3VwaWVkIGJ5IGEgZmlsZS4gICovXG4gICAgY2FzZSAnSW52YWxpZE1vZGlmaWNhdGlvbkVycm9yJzpcbiAgICAgIHJldHVybiBBcGlFcnJvci5GaWxlRXJyb3IoRXJyb3JDb2RlLkVQRVJNLCBwKTtcbiAgICAvKiBUaGUgdXNlciBoYXMgYXR0ZW1wdGVkIHRvIGxvb2sgdXAgYSBmaWxlIG9yIGRpcmVjdG9yeSwgYnV0IHRoZSBFbnRyeSBmb3VuZCBpcyBvZiB0aGUgd3JvbmcgdHlwZVxuICAgICAgICBbZS5nLiBpcyBhIERpcmVjdG9yeUVudHJ5IHdoZW4gdGhlIHVzZXIgcmVxdWVzdGVkIGEgRmlsZUVudHJ5XS4gICovXG4gICAgY2FzZSAnVHlwZU1pc21hdGNoRXJyb3InOlxuICAgICAgcmV0dXJuIEFwaUVycm9yLkZpbGVFcnJvcihleHBlY3RlZERpciA/IEVycm9yQ29kZS5FTk9URElSIDogRXJyb3JDb2RlLkVJU0RJUiwgcCk7XG4gICAgLyogQSBwYXRoIG9yIFVSTCBzdXBwbGllZCB0byB0aGUgQVBJIHdhcyBtYWxmb3JtZWQuICAqL1xuICAgIGNhc2UgXCJFbmNvZGluZ0Vycm9yXCI6XG4gICAgLyogQW4gb3BlcmF0aW9uIGRlcGVuZGVkIG9uIHN0YXRlIGNhY2hlZCBpbiBhbiBpbnRlcmZhY2Ugb2JqZWN0LCBidXQgdGhhdCBzdGF0ZSB0aGF0IGhhcyBjaGFuZ2VkXG4gICAgICAgIHNpbmNlIGl0IHdhcyByZWFkIGZyb20gZGlzay4gICovXG4gICAgY2FzZSBcIkludmFsaWRTdGF0ZUVycm9yXCI6XG4gICAgLyogVGhlIHVzZXIgYXR0ZW1wdGVkIHRvIHdyaXRlIHRvIGEgZmlsZSBvciBkaXJlY3Rvcnkgd2hpY2ggY291bGQgbm90IGJlIG1vZGlmaWVkIGR1ZSB0byB0aGUgc3RhdGVcbiAgICAgICAgb2YgdGhlIHVuZGVybHlpbmcgZmlsZXN5c3RlbS4gICovXG4gICAgY2FzZSBcIk5vTW9kaWZpY2F0aW9uQWxsb3dlZEVycm9yXCI6XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBBcGlFcnJvci5GaWxlRXJyb3IoRXJyb3JDb2RlLkVJTlZBTCwgcCk7XG4gIH1cbn1cblxuLy8gQSBub3RlIGFib3V0IGdldEZpbGUgYW5kIGdldERpcmVjdG9yeSBvcHRpb25zOlxuLy8gVGhlc2UgbWV0aG9kcyBhcmUgY2FsbGVkIGF0IG51bWVyb3VzIHBsYWNlcyBpbiB0aGlzIGZpbGUsIGFuZCBhcmUgcGFzc2VkXG4vLyBzb21lIGNvbWJpbmF0aW9uIG9mIHRoZXNlIHR3byBvcHRpb25zOlxuLy8gICAtIGNyZWF0ZTogSWYgdHJ1ZSwgdGhlIGVudHJ5IHdpbGwgYmUgY3JlYXRlZCBpZiBpdCBkb2Vzbid0IGV4aXN0LlxuLy8gICAgICAgICAgICAgSWYgZmFsc2UsIGFuIGVycm9yIHdpbGwgYmUgdGhyb3duIGlmIGl0IGRvZXNuJ3QgZXhpc3QuXG4vLyAgIC0gZXhjbHVzaXZlOiBJZiB0cnVlLCBvbmx5IGNyZWF0ZSB0aGUgZW50cnkgaWYgaXQgZG9lc24ndCBhbHJlYWR5IGV4aXN0LFxuLy8gICAgICAgICAgICAgICAgYW5kIHRocm93IGFuIGVycm9yIGlmIGl0IGRvZXMuXG5cbmV4cG9ydCBjbGFzcyBIVE1MNUZTRmlsZSBleHRlbmRzIFByZWxvYWRGaWxlPEhUTUw1RlM+IGltcGxlbWVudHMgSUZpbGUge1xuICBwcml2YXRlIF9lbnRyeTogRmlsZUVudHJ5O1xuXG4gIGNvbnN0cnVjdG9yKGZzOiBIVE1MNUZTLCBlbnRyeTogRmlsZUVudHJ5LCBwYXRoOiBzdHJpbmcsIGZsYWc6IEZpbGVGbGFnLCBzdGF0OiBTdGF0cywgY29udGVudHM/OiBCdWZmZXIpIHtcbiAgICBzdXBlcihmcywgcGF0aCwgZmxhZywgc3RhdCwgY29udGVudHMpO1xuICAgIHRoaXMuX2VudHJ5ID0gZW50cnk7XG4gIH1cblxuICBwdWJsaWMgc3luYyhjYjogQkZTT25lQXJnQ2FsbGJhY2spOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuaXNEaXJ0eSgpKSB7XG4gICAgICByZXR1cm4gY2IoKTtcbiAgICB9XG5cbiAgICB0aGlzLl9lbnRyeS5jcmVhdGVXcml0ZXIoKHdyaXRlcikgPT4ge1xuICAgICAgY29uc3QgYnVmZmVyID0gdGhpcy5nZXRCdWZmZXIoKTtcbiAgICAgIGNvbnN0IGJsb2IgPSBuZXcgQmxvYihbYnVmZmVyMkFycmF5QnVmZmVyKGJ1ZmZlcildKTtcbiAgICAgIGNvbnN0IGxlbmd0aCA9IGJsb2Iuc2l6ZTtcbiAgICAgIHdyaXRlci5vbndyaXRlZW5kID0gKGVycj86IGFueSkgPT4ge1xuICAgICAgICB3cml0ZXIub253cml0ZWVuZCA9IDxhbnk+IG51bGw7XG4gICAgICAgIHdyaXRlci5vbmVycm9yID0gPGFueT4gbnVsbDtcbiAgICAgICAgd3JpdGVyLnRydW5jYXRlKGxlbmd0aCk7XG4gICAgICAgIHRoaXMucmVzZXREaXJ0eSgpO1xuICAgICAgICBjYigpO1xuICAgICAgfTtcbiAgICAgIHdyaXRlci5vbmVycm9yID0gKGVycjogYW55KSA9PiB7XG4gICAgICAgIGNiKGNvbnZlcnRFcnJvcihlcnIsIHRoaXMuZ2V0UGF0aCgpLCBmYWxzZSkpO1xuICAgICAgfTtcbiAgICAgIHdyaXRlci53cml0ZShibG9iKTtcbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyBjbG9zZShjYjogQkZTT25lQXJnQ2FsbGJhY2spOiB2b2lkIHtcbiAgICB0aGlzLnN5bmMoY2IpO1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSFRNTDVGU09wdGlvbnMge1xuICAvLyBzdG9yYWdlIHF1b3RhIHRvIHJlcXVlc3QsIGluIG1lZ2FieXRlcy4gQWxsb2NhdGVkIHZhbHVlIG1heSBiZSBsZXNzLlxuICBzaXplPzogbnVtYmVyO1xuICAvLyB3aW5kb3cuUEVSU0lTVEVOVCBvciB3aW5kb3cuVEVNUE9SQVJZLiBEZWZhdWx0cyB0byBQRVJTSVNURU5ULlxuICB0eXBlPzogbnVtYmVyO1xufVxuXG4vKipcbiAqIEEgcmVhZC13cml0ZSBmaWxlc3lzdGVtIGJhY2tlZCBieSB0aGUgSFRNTDUgRmlsZVN5c3RlbSBBUEkuXG4gKlxuICogQXMgdGhlIEhUTUw1IEZpbGVTeXN0ZW0gaXMgb25seSBpbXBsZW1lbnRlZCBpbiBCbGluaywgdGhpcyBpbnRlcmZhY2UgaXNcbiAqIG9ubHkgYXZhaWxhYmxlIGluIENocm9tZS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSFRNTDVGUyBleHRlbmRzIEJhc2VGaWxlU3lzdGVtIGltcGxlbWVudHMgSUZpbGVTeXN0ZW0ge1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IE5hbWUgPSBcIkhUTUw1RlNcIjtcblxuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IE9wdGlvbnM6IEZpbGVTeXN0ZW1PcHRpb25zID0ge1xuICAgIHNpemU6IHtcbiAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgIGRlc2NyaXB0aW9uOiBcIlN0b3JhZ2UgcXVvdGEgdG8gcmVxdWVzdCwgaW4gbWVnYWJ5dGVzLiBBbGxvY2F0ZWQgdmFsdWUgbWF5IGJlIGxlc3MuIERlZmF1bHRzIHRvIDUuXCJcbiAgICB9LFxuICAgIHR5cGU6IHtcbiAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgIGRlc2NyaXB0aW9uOiBcIndpbmRvdy5QRVJTSVNURU5UIG9yIHdpbmRvdy5URU1QT1JBUlkuIERlZmF1bHRzIHRvIFBFUlNJU1RFTlQuXCJcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gSFRNTDVGUyBpbnN0YW5jZSB3aXRoIHRoZSBnaXZlbiBvcHRpb25zLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBDcmVhdGUob3B0czogSFRNTDVGU09wdGlvbnMsIGNiOiBCRlNDYWxsYmFjazxIVE1MNUZTPik6IHZvaWQge1xuICAgIGNvbnN0IGZzID0gbmV3IEhUTUw1RlMob3B0cy5zaXplLCBvcHRzLnR5cGUsIGZhbHNlKTtcbiAgICBmcy5hbGxvY2F0ZSgoZSkgPT4gZSA/IGNiKGUpIDogY2IobnVsbCwgZnMpLCBmYWxzZSk7XG4gIH1cbiAgcHVibGljIHN0YXRpYyBpc0F2YWlsYWJsZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gISFfZ2V0RlM7XG4gIH1cblxuICAvLyBIVE1MNUZpbGUgcmVhY2hlcyBpbnRvIEhUTUw1RlMuIDovXG4gIHB1YmxpYyBmczogRmlsZVN5c3RlbTtcbiAgcHJpdmF0ZSBzaXplOiBudW1iZXI7XG4gIHByaXZhdGUgdHlwZTogbnVtYmVyO1xuICAvKipcbiAgICogKipEZXByZWNhdGVkLiBQbGVhc2UgdXNlIEhUTUw1RlMuQ3JlYXRlKCkgbWV0aG9kIGluc3RlYWQuKipcbiAgICpcbiAgICogQ3JlYXRlcyBhIG5ldyBIVE1MNSBGaWxlU3lzdGVtLWJhY2tlZCBCcm93c2VyRlMgZmlsZSBzeXN0ZW0gb2YgdGhlIGdpdmVuIHNpemVcbiAgICogYW5kIHN0b3JhZ2UgdHlwZS5cbiAgICpcbiAgICogKipJTVBPUlRBTlQqKjogWW91IG11c3QgY2FsbCBgYWxsb2NhdGVgIG9uIHRoZSByZXN1bHRpbmcgb2JqZWN0IGJlZm9yZSB0aGUgZmlsZSBzeXN0ZW1cbiAgICogY2FuIGJlIHVzZWQuXG4gICAqXG4gICAqIEBwYXJhbSBzaXplIHN0b3JhZ2UgcXVvdGEgdG8gcmVxdWVzdCwgaW4gbWVnYWJ5dGVzLiBBbGxvY2F0ZWQgdmFsdWUgbWF5IGJlIGxlc3MuXG4gICAqIEBwYXJhbSB0eXBlIHdpbmRvdy5QRVJTSVNURU5UIG9yIHdpbmRvdy5URU1QT1JBUlkuIERlZmF1bHRzIHRvIFBFUlNJU1RFTlQuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihzaXplOiBudW1iZXIgPSA1LCB0eXBlOiBudW1iZXIgPSBnbG9iYWwuUEVSU0lTVEVOVCwgZGVwcmVjYXRlTXNnID0gdHJ1ZSkge1xuICAgIHN1cGVyKCk7XG4gICAgLy8gQ29udmVydCBNQiB0byBieXRlcy5cbiAgICB0aGlzLnNpemUgPSAxMDI0ICogMTAyNCAqIHNpemU7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICBkZXByZWNhdGlvbk1lc3NhZ2UoZGVwcmVjYXRlTXNnLCBIVE1MNUZTLk5hbWUsIHtzaXplOiBzaXplLCB0eXBlOiB0eXBlfSk7XG4gIH1cblxuICBwdWJsaWMgZ2V0TmFtZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiBIVE1MNUZTLk5hbWU7XG4gIH1cblxuICBwdWJsaWMgaXNSZWFkT25seSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBwdWJsaWMgc3VwcG9ydHNTeW1saW5rcygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBwdWJsaWMgc3VwcG9ydHNQcm9wcygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBwdWJsaWMgc3VwcG9ydHNTeW5jaCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogKipEZXByZWNhdGVkLiBQbGVhc2UgdXNlIENyZWF0ZSgpIG1ldGhvZCBpbnN0ZWFkIHRvIGNyZWF0ZSBhbmQgYWxsb2NhdGUgYW4gSFRNTDVGUy4qKlxuICAgKlxuICAgKiBSZXF1ZXN0cyBhIHN0b3JhZ2UgcXVvdGEgZnJvbSB0aGUgYnJvd3NlciB0byBiYWNrIHRoaXMgRlMuXG4gICAqIE11c3QgYmUgY2FsbGVkIGJlZm9yZSBmaWxlIHN5c3RlbSBjYW4gYmUgdXNlZCFcbiAgICovXG4gIHB1YmxpYyBhbGxvY2F0ZShjYjogQkZTT25lQXJnQ2FsbGJhY2sgPSAoKSA9PiB7Lypub3AqL30sIGRlcHJlY2F0ZU1zZyA9IHRydWUpOiB2b2lkIHtcbiAgICBpZiAoZGVwcmVjYXRlTXNnKSB7XG4gICAgICBjb25zb2xlLndhcm4oYFtIVE1MNUZTXSBIVE1MNUZTLmFsbG9jYXRlKCkgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2UuIFBsZWFzZSB1c2UgJ0hUTUw1RlMuQ3JlYXRlKHt0eXBlOiAke3RoaXMudHlwZX0sIHNpemU6ICR7dGhpcy5zaXplfX0sIGNiKScgdG8gY3JlYXRlIGFuZCBhbGxvY2F0ZSBIVE1MNUZTIGluc3RhbmNlcy5gKTtcbiAgICB9XG4gICAgY29uc3Qgc3VjY2VzcyA9IChmczogRmlsZVN5c3RlbSk6IHZvaWQgPT4ge1xuICAgICAgdGhpcy5mcyA9IGZzO1xuICAgICAgY2IoKTtcbiAgICB9O1xuICAgIGNvbnN0IGVycm9yID0gKGVycjogRE9NRXhjZXB0aW9uKTogdm9pZCA9PiB7XG4gICAgICBjYihjb252ZXJ0RXJyb3IoZXJyLCBcIi9cIiwgdHJ1ZSkpO1xuICAgIH07XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gZ2xvYmFsLlBFUlNJU1RFTlQpIHtcbiAgICAgIF9yZXF1ZXN0UXVvdGEodGhpcy50eXBlLCB0aGlzLnNpemUsIChncmFudGVkOiBudW1iZXIpID0+IHtcbiAgICAgICAgX2dldEZTKHRoaXMudHlwZSwgZ3JhbnRlZCwgc3VjY2VzcywgZXJyb3IpO1xuICAgICAgfSwgZXJyb3IpO1xuICAgIH0gZWxzZSB7XG4gICAgICBfZ2V0RlModGhpcy50eXBlLCB0aGlzLnNpemUsIHN1Y2Nlc3MsIGVycm9yKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlcyBldmVyeXRoaW5nIGluIHRoZSBGUy4gVXNlZCBmb3IgdGVzdGluZy5cbiAgICogS2FybWEgY2xlYXJzIHRoZSBzdG9yYWdlIGFmdGVyIHlvdSBxdWl0IGl0IGJ1dCBub3QgYmV0d2VlbiBydW5zIG9mIHRoZSB0ZXN0XG4gICAqIHN1aXRlLCBhbmQgdGhlIHRlc3RzIGV4cGVjdCBhbiBlbXB0eSBGUyBldmVyeSB0aW1lLlxuICAgKi9cbiAgcHVibGljIGVtcHR5KG1haW5DYjogQkZTT25lQXJnQ2FsbGJhY2spOiB2b2lkIHtcbiAgICAvLyBHZXQgYSBsaXN0IG9mIGFsbCBlbnRyaWVzIGluIHRoZSByb290IGRpcmVjdG9yeSB0byBkZWxldGUgdGhlbVxuICAgIHRoaXMuX3JlYWRkaXIoJy8nLCAoZXJyOiBBcGlFcnJvciwgZW50cmllcz86IEVudHJ5W10pOiB2b2lkID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGVtcHR5IEZTJyk7XG4gICAgICAgIG1haW5DYihlcnIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQ2FsbGVkIHdoZW4gZXZlcnkgZW50cnkgaGFzIGJlZW4gb3BlcmF0ZWQgb25cbiAgICAgICAgY29uc3QgZmluaXNoZWQgPSAoZXI6IGFueSk6IHZvaWQgPT4ge1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gZW1wdHkgRlNcIik7XG4gICAgICAgICAgICBtYWluQ2IoZXJyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWFpbkNiKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBSZW1vdmVzIGZpbGVzIGFuZCByZWN1cnNpdmVseSByZW1vdmVzIGRpcmVjdG9yaWVzXG4gICAgICAgIGNvbnN0IGRlbGV0ZUVudHJ5ID0gKGVudHJ5OiBFbnRyeSwgY2I6IChlPzogYW55KSA9PiB2b2lkKTogdm9pZCA9PiB7XG4gICAgICAgICAgY29uc3Qgc3VjYyA9ICgpID0+IHtcbiAgICAgICAgICAgIGNiKCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBjb25zdCBlcnJvciA9IChlcnI6IERPTUV4Y2VwdGlvbikgPT4ge1xuICAgICAgICAgICAgY2IoY29udmVydEVycm9yKGVyciwgZW50cnkuZnVsbFBhdGgsICFlbnRyeS5pc0RpcmVjdG9yeSkpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKGlzRGlyZWN0b3J5RW50cnkoZW50cnkpKSB7XG4gICAgICAgICAgICBlbnRyeS5yZW1vdmVSZWN1cnNpdmVseShzdWNjLCBlcnJvcik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVudHJ5LnJlbW92ZShzdWNjLCBlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBMb29wIHRocm91Z2ggdGhlIGVudHJpZXMgYW5kIHJlbW92ZSB0aGVtLCB0aGVuIGNhbGwgdGhlIGNhbGxiYWNrXG4gICAgICAgIC8vIHdoZW4gdGhleSdyZSBhbGwgZmluaXNoZWQuXG4gICAgICAgIGFzeW5jRWFjaChlbnRyaWVzISwgZGVsZXRlRW50cnksIGZpbmlzaGVkKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyByZW5hbWUob2xkUGF0aDogc3RyaW5nLCBuZXdQYXRoOiBzdHJpbmcsIGNiOiBCRlNPbmVBcmdDYWxsYmFjayk6IHZvaWQge1xuICAgIGxldCBzZW1hcGhvcmU6IG51bWJlciA9IDI7XG4gICAgbGV0IHN1Y2Nlc3NDb3VudDogbnVtYmVyID0gMDtcbiAgICBjb25zdCByb290OiBEaXJlY3RvcnlFbnRyeSA9IHRoaXMuZnMucm9vdDtcbiAgICBsZXQgY3VycmVudFBhdGg6IHN0cmluZyA9IG9sZFBhdGg7XG4gICAgY29uc3QgZXJyb3IgPSAoZXJyOiBET01FeGNlcHRpb24pOiB2b2lkID0+IHtcbiAgICAgIGlmICgtLXNlbWFwaG9yZSA8PSAwKSB7XG4gICAgICAgICAgY2IoY29udmVydEVycm9yKGVyciwgY3VycmVudFBhdGgsIGZhbHNlKSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBzdWNjZXNzID0gKGZpbGU6IEVudHJ5KTogdm9pZCA9PiB7XG4gICAgICBpZiAoKytzdWNjZXNzQ291bnQgPT09IDIpIHtcbiAgICAgICAgcmV0dXJuIGNiKG5ldyBBcGlFcnJvcihFcnJvckNvZGUuRUlOVkFMLCBcIlNvbWV0aGluZyB3YXMgaWRlbnRpZmllZCBhcyBib3RoIGEgZmlsZSBhbmQgYSBkaXJlY3RvcnkuIFRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbi5cIikpO1xuICAgICAgfVxuXG4gICAgICAvLyBTUEVDSUFMIENBU0U6IElmIG5ld1BhdGggPT09IG9sZFBhdGgsIGFuZCB0aGUgcGF0aCBleGlzdHMsIHRoZW5cbiAgICAgIC8vIHRoaXMgb3BlcmF0aW9uIHRyaXZpYWxseSBzdWNjZWVkcy5cbiAgICAgIGlmIChvbGRQYXRoID09PSBuZXdQYXRoKSB7XG4gICAgICAgIHJldHVybiBjYigpO1xuICAgICAgfVxuXG4gICAgICAvLyBHZXQgdGhlIG5ldyBwYXJlbnQgZGlyZWN0b3J5LlxuICAgICAgY3VycmVudFBhdGggPSBwYXRoLmRpcm5hbWUobmV3UGF0aCk7XG4gICAgICByb290LmdldERpcmVjdG9yeShjdXJyZW50UGF0aCwge30sIChwYXJlbnREaXI6IERpcmVjdG9yeUVudHJ5KTogdm9pZCA9PiB7XG4gICAgICAgIGN1cnJlbnRQYXRoID0gcGF0aC5iYXNlbmFtZShuZXdQYXRoKTtcbiAgICAgICAgZmlsZS5tb3ZlVG8ocGFyZW50RGlyLCBjdXJyZW50UGF0aCwgKGVudHJ5OiBFbnRyeSk6IHZvaWQgPT4geyBjYigpOyB9LCAoZXJyOiBET01FeGNlcHRpb24pOiB2b2lkID0+IHtcbiAgICAgICAgICAvLyBTUEVDSUFMIENBU0U6IElmIG9sZFBhdGggaXMgYSBkaXJlY3RvcnksIGFuZCBuZXdQYXRoIGlzIGFcbiAgICAgICAgICAvLyBmaWxlLCByZW5hbWUgc2hvdWxkIGRlbGV0ZSB0aGUgZmlsZSBhbmQgcGVyZm9ybSB0aGUgbW92ZS5cbiAgICAgICAgICBpZiAoZmlsZS5pc0RpcmVjdG9yeSkge1xuICAgICAgICAgICAgY3VycmVudFBhdGggPSBuZXdQYXRoO1xuICAgICAgICAgICAgLy8gVW5saW5rIG9ubHkgd29ya3Mgb24gZmlsZXMuIFRyeSB0byBkZWxldGUgbmV3UGF0aC5cbiAgICAgICAgICAgIHRoaXMudW5saW5rKG5ld1BhdGgsIChlPyk6IHZvaWQgPT4ge1xuICAgICAgICAgICAgICBpZiAoZSkge1xuICAgICAgICAgICAgICAgIC8vIG5ld1BhdGggaXMgcHJvYmFibHkgYSBkaXJlY3RvcnkuXG4gICAgICAgICAgICAgICAgZXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBSZWN1ciwgbm93IHRoYXQgbmV3UGF0aCBkb2Vzbid0IGV4aXN0LlxuICAgICAgICAgICAgICAgIHRoaXMucmVuYW1lKG9sZFBhdGgsIG5ld1BhdGgsIGNiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVycm9yKGVycik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0sIGVycm9yKTtcbiAgICB9O1xuXG4gICAgLy8gV2UgZG9uJ3Qga25vdyBpZiBvbGRQYXRoIGlzIGEgKmZpbGUqIG9yIGEgKmRpcmVjdG9yeSosIGFuZCB0aGVyZSdzIG5vXG4gICAgLy8gd2F5IHRvIHN0YXQgaXRlbXMuIFNvIGxhdW5jaCBib3RoIHJlcXVlc3RzLCBzZWUgd2hpY2ggb25lIHN1Y2NlZWRzLlxuICAgIHJvb3QuZ2V0RmlsZShvbGRQYXRoLCB7fSwgc3VjY2VzcywgZXJyb3IpO1xuICAgIHJvb3QuZ2V0RGlyZWN0b3J5KG9sZFBhdGgsIHt9LCBzdWNjZXNzLCBlcnJvcik7XG4gIH1cblxuICBwdWJsaWMgc3RhdChwYXRoOiBzdHJpbmcsIGlzTHN0YXQ6IGJvb2xlYW4sIGNiOiBCRlNDYWxsYmFjazxTdGF0cz4pOiB2b2lkIHtcbiAgICAvLyBUaHJvdyBhbiBlcnJvciBpZiB0aGUgZW50cnkgZG9lc24ndCBleGlzdCwgYmVjYXVzZSB0aGVuIHRoZXJlJ3Mgbm90aGluZ1xuICAgIC8vIHRvIHN0YXQuXG4gICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgIGNyZWF0ZTogZmFsc2VcbiAgICB9O1xuICAgIC8vIENhbGxlZCB3aGVuIHRoZSBwYXRoIGhhcyBiZWVuIHN1Y2Nlc3NmdWxseSBsb2FkZWQgYXMgYSBmaWxlLlxuICAgIGNvbnN0IGxvYWRBc0ZpbGUgPSAoZW50cnk6IEZpbGVFbnRyeSk6IHZvaWQgPT4ge1xuICAgICAgY29uc3QgZmlsZUZyb21FbnRyeSA9IChmaWxlOiBGaWxlKTogdm9pZCA9PiB7XG4gICAgICAgIGNvbnN0IHN0YXQgPSBuZXcgU3RhdHMoRmlsZVR5cGUuRklMRSwgZmlsZS5zaXplKTtcbiAgICAgICAgY2IobnVsbCwgc3RhdCk7XG4gICAgICB9O1xuICAgICAgZW50cnkuZmlsZShmaWxlRnJvbUVudHJ5LCBmYWlsZWRUb0xvYWQpO1xuICAgIH07XG4gICAgLy8gQ2FsbGVkIHdoZW4gdGhlIHBhdGggaGFzIGJlZW4gc3VjY2Vzc2Z1bGx5IGxvYWRlZCBhcyBhIGRpcmVjdG9yeS5cbiAgICBjb25zdCBsb2FkQXNEaXIgPSAoZGlyOiBEaXJlY3RvcnlFbnRyeSk6IHZvaWQgPT4ge1xuICAgICAgLy8gRGlyZWN0b3J5IGVudHJ5IHNpemUgY2FuJ3QgYmUgZGV0ZXJtaW5lZCBmcm9tIHRoZSBIVE1MNSBGUyBBUEksIGFuZCBpc1xuICAgICAgLy8gaW1wbGVtZW50YXRpb24tZGVwZW5kYW50IGFueXdheSwgc28gYSBkdW1teSB2YWx1ZSBpcyB1c2VkLlxuICAgICAgY29uc3Qgc2l6ZSA9IDQwOTY7XG4gICAgICBjb25zdCBzdGF0ID0gbmV3IFN0YXRzKEZpbGVUeXBlLkRJUkVDVE9SWSwgc2l6ZSk7XG4gICAgICBjYihudWxsLCBzdGF0KTtcbiAgICB9O1xuICAgIC8vIENhbGxlZCB3aGVuIHRoZSBwYXRoIGNvdWxkbid0IGJlIG9wZW5lZCBhcyBhIGRpcmVjdG9yeSBvciBhIGZpbGUuXG4gICAgY29uc3QgZmFpbGVkVG9Mb2FkID0gKGVycjogRE9NRXhjZXB0aW9uKTogdm9pZCA9PiB7XG4gICAgICBjYihjb252ZXJ0RXJyb3IoZXJyLCBwYXRoLCBmYWxzZSAvKiBVbmtub3duIC8gaXJyZWxldmFudCAqLykpO1xuICAgIH07XG4gICAgLy8gQ2FsbGVkIHdoZW4gdGhlIHBhdGggY291bGRuJ3QgYmUgb3BlbmVkIGFzIGEgZmlsZSwgYnV0IG1pZ2h0IHN0aWxsIGJlIGFcbiAgICAvLyBkaXJlY3RvcnkuXG4gICAgY29uc3QgZmFpbGVkVG9Mb2FkQXNGaWxlID0gKCk6IHZvaWQgPT4ge1xuICAgICAgdGhpcy5mcy5yb290LmdldERpcmVjdG9yeShwYXRoLCBvcHRzLCBsb2FkQXNEaXIsIGZhaWxlZFRvTG9hZCk7XG4gICAgfTtcbiAgICAvLyBObyBtZXRob2QgY3VycmVudGx5IGV4aXN0cyB0byBkZXRlcm1pbmUgd2hldGhlciBhIHBhdGggcmVmZXJzIHRvIGFcbiAgICAvLyBkaXJlY3Rvcnkgb3IgYSBmaWxlLCBzbyB0aGlzIGltcGxlbWVudGF0aW9uIHRyaWVzIGJvdGggYW5kIHVzZXMgdGhlIGZpcnN0XG4gICAgLy8gb25lIHRoYXQgc3VjY2VlZHMuXG4gICAgdGhpcy5mcy5yb290LmdldEZpbGUocGF0aCwgb3B0cywgbG9hZEFzRmlsZSwgZmFpbGVkVG9Mb2FkQXNGaWxlKTtcbiAgfVxuXG4gIHB1YmxpYyBvcGVuKHA6IHN0cmluZywgZmxhZ3M6IEZpbGVGbGFnLCBtb2RlOiBudW1iZXIsIGNiOiBCRlNDYWxsYmFjazxJRmlsZT4pOiB2b2lkIHtcbiAgICAvLyBYWFg6IGVyciBpcyBhIERPTUVycm9yXG4gICAgY29uc3QgZXJyb3IgPSAoZXJyOiBhbnkpOiB2b2lkID0+IHtcbiAgICAgIGlmIChlcnIubmFtZSA9PT0gJ0ludmFsaWRNb2RpZmljYXRpb25FcnJvcicgJiYgZmxhZ3MuaXNFeGNsdXNpdmUoKSkge1xuICAgICAgICBjYihBcGlFcnJvci5FRVhJU1QocCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2IoY29udmVydEVycm9yKGVyciwgcCwgZmFsc2UpKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5mcy5yb290LmdldEZpbGUocCwge1xuICAgICAgY3JlYXRlOiBmbGFncy5wYXRoTm90RXhpc3RzQWN0aW9uKCkgPT09IEFjdGlvblR5cGUuQ1JFQVRFX0ZJTEUsXG4gICAgICBleGNsdXNpdmU6IGZsYWdzLmlzRXhjbHVzaXZlKClcbiAgICB9LCAoZW50cnk6IEZpbGVFbnRyeSk6IHZvaWQgPT4ge1xuICAgICAgLy8gVHJ5IHRvIGZldGNoIGNvcnJlc3BvbmRpbmcgZmlsZS5cbiAgICAgIGVudHJ5LmZpbGUoKGZpbGU6IEZpbGUpOiB2b2lkID0+IHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgICAgcmVhZGVyLm9ubG9hZGVuZCA9IChldmVudDogRXZlbnQpOiB2b2lkID0+IHtcbiAgICAgICAgICBjb25zdCBiZnNGaWxlID0gdGhpcy5fbWFrZUZpbGUocCwgZW50cnksIGZsYWdzLCBmaWxlLCA8QXJyYXlCdWZmZXI+IHJlYWRlci5yZXN1bHQpO1xuICAgICAgICAgIGNiKG51bGwsIGJmc0ZpbGUpO1xuICAgICAgICB9O1xuICAgICAgICByZWFkZXIub25lcnJvciA9IChldjogRXZlbnQpID0+IHtcbiAgICAgICAgICBlcnJvcihyZWFkZXIuZXJyb3IpO1xuICAgICAgICB9O1xuICAgICAgICByZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoZmlsZSk7XG4gICAgICB9LCBlcnJvcik7XG4gICAgfSwgZXJyb3IpO1xuICB9XG5cbiAgcHVibGljIHVubGluayhwYXRoOiBzdHJpbmcsIGNiOiBCRlNPbmVBcmdDYWxsYmFjayk6IHZvaWQge1xuICAgIHRoaXMuX3JlbW92ZShwYXRoLCBjYiwgdHJ1ZSk7XG4gIH1cblxuICBwdWJsaWMgcm1kaXIocGF0aDogc3RyaW5nLCBjYjogQkZTT25lQXJnQ2FsbGJhY2spOiB2b2lkIHtcbiAgICAvLyBDaGVjayBpZiBkaXJlY3RvcnkgaXMgbm9uLWVtcHR5LCBmaXJzdC5cbiAgICB0aGlzLnJlYWRkaXIocGF0aCwgKGUsIGZpbGVzPykgPT4ge1xuICAgICAgaWYgKGUpIHtcbiAgICAgICAgY2IoZSk7XG4gICAgICB9IGVsc2UgaWYgKGZpbGVzIS5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNiKEFwaUVycm9yLkVOT1RFTVBUWShwYXRoKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9yZW1vdmUocGF0aCwgY2IsIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyBta2RpcihwYXRoOiBzdHJpbmcsIG1vZGU6IG51bWJlciwgY2I6IEJGU09uZUFyZ0NhbGxiYWNrKTogdm9pZCB7XG4gICAgLy8gQ3JlYXRlIHRoZSBkaXJlY3RvcnksIGJ1dCB0aHJvdyBhbiBlcnJvciBpZiBpdCBhbHJlYWR5IGV4aXN0cywgYXMgcGVyXG4gICAgLy8gbWtkaXIoMSlcbiAgICBjb25zdCBvcHRzID0ge1xuICAgICAgY3JlYXRlOiB0cnVlLFxuICAgICAgZXhjbHVzaXZlOiB0cnVlXG4gICAgfTtcbiAgICBjb25zdCBzdWNjZXNzID0gKGRpcjogRGlyZWN0b3J5RW50cnkpOiB2b2lkID0+IHtcbiAgICAgIGNiKCk7XG4gICAgfTtcbiAgICBjb25zdCBlcnJvciA9IChlcnI6IERPTUV4Y2VwdGlvbik6IHZvaWQgPT4ge1xuICAgICAgY2IoY29udmVydEVycm9yKGVyciwgcGF0aCwgdHJ1ZSkpO1xuICAgIH07XG4gICAgdGhpcy5mcy5yb290LmdldERpcmVjdG9yeShwYXRoLCBvcHRzLCBzdWNjZXNzLCBlcnJvcik7XG4gIH1cblxuICAvKipcbiAgICogTWFwIF9yZWFkZGlyJ3MgbGlzdCBvZiBgRmlsZUVudHJ5YHMgdG8gdGhlaXIgbmFtZXMgYW5kIHJldHVybiB0aGF0LlxuICAgKi9cbiAgcHVibGljIHJlYWRkaXIocGF0aDogc3RyaW5nLCBjYjogQkZTQ2FsbGJhY2s8c3RyaW5nW10+KTogdm9pZCB7XG4gICAgdGhpcy5fcmVhZGRpcihwYXRoLCAoZTogQXBpRXJyb3IsIGVudHJpZXM/OiBFbnRyeVtdKTogdm9pZCA9PiB7XG4gICAgICBpZiAoZW50cmllcykge1xuICAgICAgICBjb25zdCBydjogc3RyaW5nW10gPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiBlbnRyaWVzKSB7XG4gICAgICAgICAgcnYucHVzaChlbnRyeS5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBjYihudWxsLCBydik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY2IoZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIEJyb3dzZXJGUyBvYmplY3QgcmVwcmVzZW50aW5nIGEgRmlsZS5cbiAgICovXG4gIHByaXZhdGUgX21ha2VGaWxlKHBhdGg6IHN0cmluZywgZW50cnk6IEZpbGVFbnRyeSwgZmxhZzogRmlsZUZsYWcsIHN0YXQ6IEZpbGUsIGRhdGE6IEFycmF5QnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKDApKTogSFRNTDVGU0ZpbGUge1xuICAgIGNvbnN0IHN0YXRzID0gbmV3IFN0YXRzKEZpbGVUeXBlLkZJTEUsIHN0YXQuc2l6ZSk7XG4gICAgY29uc3QgYnVmZmVyID0gYXJyYXlCdWZmZXIyQnVmZmVyKGRhdGEpO1xuICAgIHJldHVybiBuZXcgSFRNTDVGU0ZpbGUodGhpcywgZW50cnksIHBhdGgsIGZsYWcsIHN0YXRzLCBidWZmZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gYXJyYXkgb2YgYEZpbGVFbnRyeWBzLiBVc2VkIGludGVybmFsbHkgYnkgZW1wdHkgYW5kIHJlYWRkaXIuXG4gICAqL1xuICBwcml2YXRlIF9yZWFkZGlyKHBhdGg6IHN0cmluZywgY2I6IEJGU0NhbGxiYWNrPEVudHJ5W10+KTogdm9pZCB7XG4gICAgY29uc3QgZXJyb3IgPSAoZXJyOiBET01FeGNlcHRpb24pOiB2b2lkID0+IHtcbiAgICAgIGNiKGNvbnZlcnRFcnJvcihlcnIsIHBhdGgsIHRydWUpKTtcbiAgICB9O1xuICAgIC8vIEdyYWIgdGhlIHJlcXVlc3RlZCBkaXJlY3RvcnkuXG4gICAgdGhpcy5mcy5yb290LmdldERpcmVjdG9yeShwYXRoLCB7IGNyZWF0ZTogZmFsc2UgfSwgKGRpckVudHJ5OiBEaXJlY3RvcnlFbnRyeSkgPT4ge1xuICAgICAgY29uc3QgcmVhZGVyID0gZGlyRW50cnkuY3JlYXRlUmVhZGVyKCk7XG4gICAgICBsZXQgZW50cmllczogRW50cnlbXSA9IFtdO1xuXG4gICAgICAvLyBDYWxsIHRoZSByZWFkZXIucmVhZEVudHJpZXMoKSB1bnRpbCBubyBtb3JlIHJlc3VsdHMgYXJlIHJldHVybmVkLlxuICAgICAgY29uc3QgcmVhZEVudHJpZXMgPSAoKSA9PiB7XG4gICAgICAgIHJlYWRlci5yZWFkRW50cmllcygoKHJlc3VsdHMpID0+IHtcbiAgICAgICAgICBpZiAocmVzdWx0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGVudHJpZXMgPSBlbnRyaWVzLmNvbmNhdChfdG9BcnJheShyZXN1bHRzKSk7XG4gICAgICAgICAgICByZWFkRW50cmllcygpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYihudWxsLCBlbnRyaWVzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pLCBlcnJvcik7XG4gICAgICB9O1xuICAgICAgcmVhZEVudHJpZXMoKTtcbiAgICB9LCBlcnJvcik7XG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlIGEgZmlsZSBvciBkaXJlY3RvcnkgZnJvbSB0aGUgZmlsZSBzeXN0ZW1cbiAgICogaXNGaWxlIHNob3VsZCByZWZsZWN0IHdoaWNoIGNhbGwgd2FzIG1hZGUgdG8gcmVtb3ZlIHRoZSBpdCAoYHVubGlua2Agb3JcbiAgICogYHJtZGlyYCkuIElmIHRoaXMgZG9lc24ndCBtYXRjaCB3aGF0J3MgYWN0dWFsbHkgYXQgYHBhdGhgLCBhbiBlcnJvciB3aWxsIGJlXG4gICAqIHJldHVybmVkXG4gICAqL1xuICBwcml2YXRlIF9yZW1vdmUocGF0aDogc3RyaW5nLCBjYjogQkZTT25lQXJnQ2FsbGJhY2ssIGlzRmlsZTogYm9vbGVhbik6IHZvaWQge1xuICAgIGNvbnN0IHN1Y2Nlc3MgPSAoZW50cnk6IEVudHJ5KTogdm9pZCA9PiB7XG4gICAgICBjb25zdCBzdWNjID0gKCkgPT4ge1xuICAgICAgICBjYigpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGVyciA9IChlcnI6IERPTUV4Y2VwdGlvbikgPT4ge1xuICAgICAgICBjYihjb252ZXJ0RXJyb3IoZXJyLCBwYXRoLCAhaXNGaWxlKSk7XG4gICAgICB9O1xuICAgICAgZW50cnkucmVtb3ZlKHN1Y2MsIGVycik7XG4gICAgfTtcbiAgICBjb25zdCBlcnJvciA9IChlcnI6IERPTUV4Y2VwdGlvbik6IHZvaWQgPT4ge1xuICAgICAgY2IoY29udmVydEVycm9yKGVyciwgcGF0aCwgIWlzRmlsZSkpO1xuICAgIH07XG4gICAgLy8gRGVsZXRpbmcgdGhlIGVudHJ5LCBzbyBkb24ndCBjcmVhdGUgaXRcbiAgICBjb25zdCBvcHRzID0ge1xuICAgICAgY3JlYXRlOiBmYWxzZVxuICAgIH07XG5cbiAgICBpZiAoaXNGaWxlKSB7XG4gICAgICB0aGlzLmZzLnJvb3QuZ2V0RmlsZShwYXRoLCBvcHRzLCBzdWNjZXNzLCBlcnJvcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZnMucm9vdC5nZXREaXJlY3RvcnkocGF0aCwgb3B0cywgc3VjY2VzcywgZXJyb3IpO1xuICAgIH1cbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uLy4uLy4uLy4uL3NyYy9iYWNrZW5kL0hUTUw1RlMudHMiLCJpbXBvcnQge2RlZmF1bHQgYXMgU3RhdHMsIEZpbGVUeXBlfSBmcm9tICcuLi9jb3JlL25vZGVfZnNfc3RhdHMnO1xuXG4vKipcbiAqIEdlbmVyaWMgaW5vZGUgZGVmaW5pdGlvbiB0aGF0IGNhbiBlYXNpbHkgYmUgc2VyaWFsaXplZC5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW5vZGUge1xuICAvKipcbiAgICogQ29udmVydHMgdGhlIGJ1ZmZlciBpbnRvIGFuIElub2RlLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBmcm9tQnVmZmVyKGJ1ZmZlcjogQnVmZmVyKTogSW5vZGUge1xuICAgIGlmIChidWZmZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTk9cIik7XG4gICAgfVxuICAgIHJldHVybiBuZXcgSW5vZGUoYnVmZmVyLnRvU3RyaW5nKCdhc2NpaScsIDMwKSxcbiAgICAgIGJ1ZmZlci5yZWFkVUludDMyTEUoMCksXG4gICAgICBidWZmZXIucmVhZFVJbnQxNkxFKDQpLFxuICAgICAgYnVmZmVyLnJlYWREb3VibGVMRSg2KSxcbiAgICAgIGJ1ZmZlci5yZWFkRG91YmxlTEUoMTQpLFxuICAgICAgYnVmZmVyLnJlYWREb3VibGVMRSgyMilcbiAgICApO1xuICB9XG5cbiAgY29uc3RydWN0b3IocHVibGljIGlkOiBzdHJpbmcsXG4gICAgICAgICAgICAgIHB1YmxpYyBzaXplOiBudW1iZXIsXG4gICAgICAgICAgICAgIHB1YmxpYyBtb2RlOiBudW1iZXIsXG4gICAgICAgICAgICAgIHB1YmxpYyBhdGltZTogbnVtYmVyLFxuICAgICAgICAgICAgICBwdWJsaWMgbXRpbWU6IG51bWJlcixcbiAgICAgICAgICAgICAgcHVibGljIGN0aW1lOiBudW1iZXIpIHsgfVxuXG4gIC8qKlxuICAgKiBIYW5keSBmdW5jdGlvbiB0aGF0IGNvbnZlcnRzIHRoZSBJbm9kZSB0byBhIE5vZGUgU3RhdHMgb2JqZWN0LlxuICAgKi9cbiAgcHVibGljIHRvU3RhdHMoKTogU3RhdHMge1xuICAgIHJldHVybiBuZXcgU3RhdHMoXG4gICAgICAodGhpcy5tb2RlICYgMHhGMDAwKSA9PT0gRmlsZVR5cGUuRElSRUNUT1JZID8gRmlsZVR5cGUuRElSRUNUT1JZIDogRmlsZVR5cGUuRklMRSxcbiAgICAgIHRoaXMuc2l6ZSwgdGhpcy5tb2RlLCBuZXcgRGF0ZSh0aGlzLmF0aW1lKSwgbmV3IERhdGUodGhpcy5tdGltZSksIG5ldyBEYXRlKHRoaXMuY3RpbWUpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHNpemUgb2YgdGhpcyBJbm9kZSwgaW4gYnl0ZXMuXG4gICAqL1xuICBwdWJsaWMgZ2V0U2l6ZSgpOiBudW1iZXIge1xuICAgIC8vIEFTU1VNUFRJT046IElEIGlzIEFTQ0lJICgxIGJ5dGUgcGVyIGNoYXIpLlxuICAgIHJldHVybiAzMCArIHRoaXMuaWQubGVuZ3RoO1xuICB9XG5cbiAgLyoqXG4gICAqIFdyaXRlcyB0aGUgaW5vZGUgaW50byB0aGUgc3RhcnQgb2YgdGhlIGJ1ZmZlci5cbiAgICovXG4gIHB1YmxpYyB0b0J1ZmZlcihidWZmOiBCdWZmZXIgPSBCdWZmZXIuYWxsb2ModGhpcy5nZXRTaXplKCkpKTogQnVmZmVyIHtcbiAgICBidWZmLndyaXRlVUludDMyTEUodGhpcy5zaXplLCAwKTtcbiAgICBidWZmLndyaXRlVUludDE2TEUodGhpcy5tb2RlLCA0KTtcbiAgICBidWZmLndyaXRlRG91YmxlTEUodGhpcy5hdGltZSwgNik7XG4gICAgYnVmZi53cml0ZURvdWJsZUxFKHRoaXMubXRpbWUsIDE0KTtcbiAgICBidWZmLndyaXRlRG91YmxlTEUodGhpcy5jdGltZSwgMjIpO1xuICAgIGJ1ZmYud3JpdGUodGhpcy5pZCwgMzAsIHRoaXMuaWQubGVuZ3RoLCAnYXNjaWknKTtcbiAgICByZXR1cm4gYnVmZjtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBJbm9kZSB1c2luZyBpbmZvcm1hdGlvbiBmcm9tIHRoZSBzdGF0cyBvYmplY3QuIFVzZWQgYnkgZmlsZVxuICAgKiBzeXN0ZW1zIGF0IHN5bmMgdGltZSwgZS5nLjpcbiAgICogLSBQcm9ncmFtIG9wZW5zIGZpbGUgYW5kIGdldHMgYSBGaWxlIG9iamVjdC5cbiAgICogLSBQcm9ncmFtIG11dGF0ZXMgZmlsZS4gRmlsZSBvYmplY3QgaXMgcmVzcG9uc2libGUgZm9yIG1haW50YWluaW5nXG4gICAqICAgbWV0YWRhdGEgY2hhbmdlcyBsb2NhbGx5IC0tIHR5cGljYWxseSBpbiBhIFN0YXRzIG9iamVjdC5cbiAgICogLSBQcm9ncmFtIGNsb3NlcyBmaWxlLiBGaWxlIG9iamVjdCdzIG1ldGFkYXRhIGNoYW5nZXMgYXJlIHN5bmNlZCB3aXRoIHRoZVxuICAgKiAgIGZpbGUgc3lzdGVtLlxuICAgKiBAcmV0dXJuIFRydWUgaWYgYW55IGNoYW5nZXMgaGF2ZSBvY2N1cnJlZC5cbiAgICovXG4gIHB1YmxpYyB1cGRhdGUoc3RhdHM6IFN0YXRzKTogYm9vbGVhbiB7XG4gICAgbGV0IGhhc0NoYW5nZWQgPSBmYWxzZTtcbiAgICBpZiAodGhpcy5zaXplICE9PSBzdGF0cy5zaXplKSB7XG4gICAgICB0aGlzLnNpemUgPSBzdGF0cy5zaXplO1xuICAgICAgaGFzQ2hhbmdlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubW9kZSAhPT0gc3RhdHMubW9kZSkge1xuICAgICAgdGhpcy5tb2RlID0gc3RhdHMubW9kZTtcbiAgICAgIGhhc0NoYW5nZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGNvbnN0IGF0aW1lTXMgPSBzdGF0cy5hdGltZS5nZXRUaW1lKCk7XG4gICAgaWYgKHRoaXMuYXRpbWUgIT09IGF0aW1lTXMpIHtcbiAgICAgIHRoaXMuYXRpbWUgPSBhdGltZU1zO1xuICAgICAgaGFzQ2hhbmdlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgY29uc3QgbXRpbWVNcyA9IHN0YXRzLm10aW1lLmdldFRpbWUoKTtcbiAgICBpZiAodGhpcy5tdGltZSAhPT0gbXRpbWVNcykge1xuICAgICAgdGhpcy5tdGltZSA9IG10aW1lTXM7XG4gICAgICBoYXNDaGFuZ2VkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBjb25zdCBjdGltZU1zID0gc3RhdHMuY3RpbWUuZ2V0VGltZSgpO1xuICAgIGlmICh0aGlzLmN0aW1lICE9PSBjdGltZU1zKSB7XG4gICAgICB0aGlzLmN0aW1lID0gY3RpbWVNcztcbiAgICAgIGhhc0NoYW5nZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBoYXNDaGFuZ2VkO1xuICB9XG5cbiAgLy8gWFhYOiBDb3BpZWQgZnJvbSBTdGF0cy4gU2hvdWxkIHJlY29uY2lsZSB0aGVzZSB0d28gaW50byBzb21ldGhpbmcgbW9yZVxuICAvLyAgICAgIGNvbXBhY3QuXG5cbiAgLyoqXG4gICAqIEByZXR1cm4gW0Jvb2xlYW5dIFRydWUgaWYgdGhpcyBpdGVtIGlzIGEgZmlsZS5cbiAgICovXG4gIHB1YmxpYyBpc0ZpbGUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuICh0aGlzLm1vZGUgJiAweEYwMDApID09PSBGaWxlVHlwZS5GSUxFO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4gW0Jvb2xlYW5dIFRydWUgaWYgdGhpcyBpdGVtIGlzIGEgZGlyZWN0b3J5LlxuICAgKi9cbiAgcHVibGljIGlzRGlyZWN0b3J5KCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAodGhpcy5tb2RlICYgMHhGMDAwKSA9PT0gRmlsZVR5cGUuRElSRUNUT1JZO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vLi4vLi4vLi4vc3JjL2dlbmVyaWMvaW5vZGUudHMiLCJpbXBvcnQge0Jhc2VGaWxlU3lzdGVtLCBTeW5jaHJvbm91c0ZpbGVTeXN0ZW0sIEJGU09uZUFyZ0NhbGxiYWNrLCBCRlNDYWxsYmFjaywgQkZTVGhyZWVBcmdDYWxsYmFja30gZnJvbSAnLi4vY29yZS9maWxlX3N5c3RlbSc7XG5pbXBvcnQge0FwaUVycm9yLCBFcnJvckNvZGV9IGZyb20gJy4uL2NvcmUvYXBpX2Vycm9yJztcbmltcG9ydCB7ZGVmYXVsdCBhcyBTdGF0cywgRmlsZVR5cGV9IGZyb20gJy4uL2NvcmUvbm9kZV9mc19zdGF0cyc7XG5pbXBvcnQge0ZpbGV9IGZyb20gJy4uL2NvcmUvZmlsZSc7XG5pbXBvcnQge0ZpbGVGbGFnfSBmcm9tICcuLi9jb3JlL2ZpbGVfZmxhZyc7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IElub2RlIGZyb20gJy4uL2dlbmVyaWMvaW5vZGUnO1xuaW1wb3J0IFByZWxvYWRGaWxlIGZyb20gJy4uL2dlbmVyaWMvcHJlbG9hZF9maWxlJztcbmltcG9ydCB7ZW1wdHlCdWZmZXJ9IGZyb20gJy4uL2NvcmUvdXRpbCc7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgUk9PVF9OT0RFX0lEOiBzdHJpbmcgPSBcIi9cIjtcbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgZW1wdHlEaXJOb2RlOiBCdWZmZXIgfCBudWxsID0gbnVsbDtcbi8qKlxuICogUmV0dXJucyBhbiBlbXB0eSBkaXJlY3Rvcnkgbm9kZS5cbiAqIEBoaWRkZW5cbiAqL1xuZnVuY3Rpb24gZ2V0RW1wdHlEaXJOb2RlKCk6IEJ1ZmZlciB7XG4gIGlmIChlbXB0eURpck5vZGUpIHtcbiAgICByZXR1cm4gZW1wdHlEaXJOb2RlO1xuICB9XG4gIHJldHVybiBlbXB0eURpck5vZGUgPSBCdWZmZXIuZnJvbShcInt9XCIpO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHJhbmRvbSBJRC5cbiAqIEBoaWRkZW5cbiAqL1xuZnVuY3Rpb24gR2VuZXJhdGVSYW5kb21JRCgpOiBzdHJpbmcge1xuICAvLyBGcm9tIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTA1MDM0L2hvdy10by1jcmVhdGUtYS1ndWlkLXV1aWQtaW4tamF2YXNjcmlwdFxuICByZXR1cm4gJ3h4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eCcucmVwbGFjZSgvW3h5XS9nLCBmdW5jdGlvbihjKSB7XG4gICAgY29uc3QgciA9IE1hdGgucmFuZG9tKCkgKiAxNiB8IDA7XG4gICAgY29uc3QgdiA9IGMgPT09ICd4JyA/IHIgOiAociAmIDB4MyB8IDB4OCk7XG4gICAgcmV0dXJuIHYudG9TdHJpbmcoMTYpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24uIENoZWNrcyBpZiAnZScgaXMgZGVmaW5lZC4gSWYgc28sIGl0IHRyaWdnZXJzIHRoZSBjYWxsYmFja1xuICogd2l0aCAnZScgYW5kIHJldHVybnMgZmFsc2UuIE90aGVyd2lzZSwgcmV0dXJucyB0cnVlLlxuICogQGhpZGRlblxuICovXG5mdW5jdGlvbiBub0Vycm9yKGU6IEFwaUVycm9yIHwgdW5kZWZpbmVkIHwgbnVsbCwgY2I6IChlOiBBcGlFcnJvcikgPT4gdm9pZCk6IGJvb2xlYW4ge1xuICBpZiAoZSkge1xuICAgIGNiKGUpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24uIENoZWNrcyBpZiAnZScgaXMgZGVmaW5lZC4gSWYgc28sIGl0IGFib3J0cyB0aGUgdHJhbnNhY3Rpb24sXG4gKiB0cmlnZ2VycyB0aGUgY2FsbGJhY2sgd2l0aCAnZScsIGFuZCByZXR1cm5zIGZhbHNlLiBPdGhlcndpc2UsIHJldHVybnMgdHJ1ZS5cbiAqIEBoaWRkZW5cbiAqL1xuZnVuY3Rpb24gbm9FcnJvclR4KGU6IEFwaUVycm9yIHwgdW5kZWZpbmVkIHwgbnVsbCwgdHg6IEFzeW5jS2V5VmFsdWVSV1RyYW5zYWN0aW9uLCBjYjogKGU6IEFwaUVycm9yKSA9PiB2b2lkKTogYm9vbGVhbiB7XG4gIGlmIChlKSB7XG4gICAgdHguYWJvcnQoKCkgPT4ge1xuICAgICAgY2IoZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYSAqc3luY2hyb25vdXMqIGtleS12YWx1ZSBzdG9yZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTeW5jS2V5VmFsdWVTdG9yZSB7XG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGUga2V5LXZhbHVlIHN0b3JlLlxuICAgKi9cbiAgbmFtZSgpOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBFbXB0aWVzIHRoZSBrZXktdmFsdWUgc3RvcmUgY29tcGxldGVseS5cbiAgICovXG4gIGNsZWFyKCk6IHZvaWQ7XG4gIC8qKlxuICAgKiBCZWdpbnMgYSBuZXcgcmVhZC1vbmx5IHRyYW5zYWN0aW9uLlxuICAgKi9cbiAgYmVnaW5UcmFuc2FjdGlvbih0eXBlOiBcInJlYWRvbmx5XCIpOiBTeW5jS2V5VmFsdWVST1RyYW5zYWN0aW9uO1xuICAvKipcbiAgICogQmVnaW5zIGEgbmV3IHJlYWQtd3JpdGUgdHJhbnNhY3Rpb24uXG4gICAqL1xuICBiZWdpblRyYW5zYWN0aW9uKHR5cGU6IFwicmVhZHdyaXRlXCIpOiBTeW5jS2V5VmFsdWVSV1RyYW5zYWN0aW9uO1xuICBiZWdpblRyYW5zYWN0aW9uKHR5cGU6IHN0cmluZyk6IFN5bmNLZXlWYWx1ZVJPVHJhbnNhY3Rpb247XG59XG5cbi8qKlxuICogQSByZWFkLW9ubHkgdHJhbnNhY3Rpb24gZm9yIGEgc3luY2hyb25vdXMga2V5IHZhbHVlIHN0b3JlLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFN5bmNLZXlWYWx1ZVJPVHJhbnNhY3Rpb24ge1xuICAvKipcbiAgICogUmV0cmlldmVzIHRoZSBkYXRhIGF0IHRoZSBnaXZlbiBrZXkuIFRocm93cyBhbiBBcGlFcnJvciBpZiBhbiBlcnJvciBvY2N1cnNcbiAgICogb3IgaWYgdGhlIGtleSBkb2VzIG5vdCBleGlzdC5cbiAgICogQHBhcmFtIGtleSBUaGUga2V5IHRvIGxvb2sgdW5kZXIgZm9yIGRhdGEuXG4gICAqIEByZXR1cm4gVGhlIGRhdGEgc3RvcmVkIHVuZGVyIHRoZSBrZXksIG9yIHVuZGVmaW5lZCBpZiBub3QgcHJlc2VudC5cbiAgICovXG4gIGdldChrZXk6IHN0cmluZyk6IEJ1ZmZlciB8IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBBIHJlYWQtd3JpdGUgdHJhbnNhY3Rpb24gZm9yIGEgc3luY2hyb25vdXMga2V5IHZhbHVlIHN0b3JlLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFN5bmNLZXlWYWx1ZVJXVHJhbnNhY3Rpb24gZXh0ZW5kcyBTeW5jS2V5VmFsdWVST1RyYW5zYWN0aW9uIHtcbiAgLyoqXG4gICAqIEFkZHMgdGhlIGRhdGEgdG8gdGhlIHN0b3JlIHVuZGVyIHRoZSBnaXZlbiBrZXkuXG4gICAqIEBwYXJhbSBrZXkgVGhlIGtleSB0byBhZGQgdGhlIGRhdGEgdW5kZXIuXG4gICAqIEBwYXJhbSBkYXRhIFRoZSBkYXRhIHRvIGFkZCB0byB0aGUgc3RvcmUuXG4gICAqIEBwYXJhbSBvdmVyd3JpdGUgSWYgJ3RydWUnLCBvdmVyd3JpdGUgYW55IGV4aXN0aW5nIGRhdGEuIElmICdmYWxzZScsXG4gICAqICAgYXZvaWRzIHN0b3JpbmcgdGhlIGRhdGEgaWYgdGhlIGtleSBleGlzdHMuXG4gICAqIEByZXR1cm4gVHJ1ZSBpZiBzdG9yYWdlIHN1Y2NlZWRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgcHV0KGtleTogc3RyaW5nLCBkYXRhOiBCdWZmZXIsIG92ZXJ3cml0ZTogYm9vbGVhbik6IGJvb2xlYW47XG4gIC8qKlxuICAgKiBEZWxldGVzIHRoZSBkYXRhIGF0IHRoZSBnaXZlbiBrZXkuXG4gICAqIEBwYXJhbSBrZXkgVGhlIGtleSB0byBkZWxldGUgZnJvbSB0aGUgc3RvcmUuXG4gICAqL1xuICBkZWwoa2V5OiBzdHJpbmcpOiB2b2lkO1xuICAvKipcbiAgICogQ29tbWl0cyB0aGUgdHJhbnNhY3Rpb24uXG4gICAqL1xuICBjb21taXQoKTogdm9pZDtcbiAgLyoqXG4gICAqIEFib3J0cyBhbmQgcm9sbHMgYmFjayB0aGUgdHJhbnNhY3Rpb24uXG4gICAqL1xuICBhYm9ydCgpOiB2b2lkO1xufVxuXG4vKipcbiAqIEFuIGludGVyZmFjZSBmb3Igc2ltcGxlIHN5bmNocm9ub3VzIGtleS12YWx1ZSBzdG9yZXMgdGhhdCBkb24ndCBoYXZlIHNwZWNpYWxcbiAqIHN1cHBvcnQgZm9yIHRyYW5zYWN0aW9ucyBhbmQgc3VjaC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTaW1wbGVTeW5jU3RvcmUge1xuICBnZXQoa2V5OiBzdHJpbmcpOiBCdWZmZXIgfCB1bmRlZmluZWQ7XG4gIHB1dChrZXk6IHN0cmluZywgZGF0YTogQnVmZmVyLCBvdmVyd3JpdGU6IGJvb2xlYW4pOiBib29sZWFuO1xuICBkZWwoa2V5OiBzdHJpbmcpOiB2b2lkO1xufVxuXG4vKipcbiAqIEEgc2ltcGxlIFJXIHRyYW5zYWN0aW9uIGZvciBzaW1wbGUgc3luY2hyb25vdXMga2V5LXZhbHVlIHN0b3Jlcy5cbiAqL1xuZXhwb3J0IGNsYXNzIFNpbXBsZVN5bmNSV1RyYW5zYWN0aW9uIGltcGxlbWVudHMgU3luY0tleVZhbHVlUldUcmFuc2FjdGlvbiB7XG4gIC8qKlxuICAgKiBTdG9yZXMgZGF0YSBpbiB0aGUga2V5cyB3ZSBtb2RpZnkgcHJpb3IgdG8gbW9kaWZ5aW5nIHRoZW0uXG4gICAqIEFsbG93cyB1cyB0byByb2xsIGJhY2sgY29tbWl0cy5cbiAgICovXG4gIHByaXZhdGUgb3JpZ2luYWxEYXRhOiB7IFtrZXk6IHN0cmluZ106IEJ1ZmZlciB8IHVuZGVmaW5lZCB9ID0ge307XG4gIC8qKlxuICAgKiBMaXN0IG9mIGtleXMgbW9kaWZpZWQgaW4gdGhpcyB0cmFuc2FjdGlvbiwgaWYgYW55LlxuICAgKi9cbiAgcHJpdmF0ZSBtb2RpZmllZEtleXM6IHN0cmluZ1tdID0gW107XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBzdG9yZTogU2ltcGxlU3luY1N0b3JlKSB7IH1cblxuICBwdWJsaWMgZ2V0KGtleTogc3RyaW5nKTogQnVmZmVyIHwgdW5kZWZpbmVkIHtcbiAgICBjb25zdCB2YWwgPSB0aGlzLnN0b3JlLmdldChrZXkpO1xuICAgIHRoaXMuc3Rhc2hPbGRWYWx1ZShrZXksIHZhbCk7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuXG4gIHB1YmxpYyBwdXQoa2V5OiBzdHJpbmcsIGRhdGE6IEJ1ZmZlciwgb3ZlcndyaXRlOiBib29sZWFuKTogYm9vbGVhbiB7XG4gICAgdGhpcy5tYXJrTW9kaWZpZWQoa2V5KTtcbiAgICByZXR1cm4gdGhpcy5zdG9yZS5wdXQoa2V5LCBkYXRhLCBvdmVyd3JpdGUpO1xuICB9XG5cbiAgcHVibGljIGRlbChrZXk6IHN0cmluZyk6IHZvaWQge1xuICAgIHRoaXMubWFya01vZGlmaWVkKGtleSk7XG4gICAgdGhpcy5zdG9yZS5kZWwoa2V5KTtcbiAgfVxuXG4gIHB1YmxpYyBjb21taXQoKTogdm9pZCB7LyogTk9QICovfVxuXG4gIHB1YmxpYyBhYm9ydCgpOiB2b2lkIHtcbiAgICAvLyBSb2xsYmFjayBvbGQgdmFsdWVzLlxuICAgIGZvciAoY29uc3Qga2V5IG9mIHRoaXMubW9kaWZpZWRLZXlzKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHRoaXMub3JpZ2luYWxEYXRhW2tleV07XG4gICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgIC8vIEtleSBkaWRuJ3QgZXhpc3QuXG4gICAgICAgIHRoaXMuc3RvcmUuZGVsKGtleSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBLZXkgZXhpc3RlZC4gU3RvcmUgb2xkIHZhbHVlLlxuICAgICAgICB0aGlzLnN0b3JlLnB1dChrZXksIHZhbHVlLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3Rhc2hlcyBnaXZlbiBrZXkgdmFsdWUgcGFpciBpbnRvIGBvcmlnaW5hbERhdGFgIGlmIGl0IGRvZXNuJ3QgYWxyZWFkeVxuICAgKiBleGlzdC4gQWxsb3dzIHVzIHRvIHN0YXNoIHZhbHVlcyB0aGUgcHJvZ3JhbSBpcyByZXF1ZXN0aW5nIGFueXdheSB0b1xuICAgKiBwcmV2ZW50IG5lZWRsZXNzIGBnZXRgIHJlcXVlc3RzIGlmIHRoZSBwcm9ncmFtIG1vZGlmaWVzIHRoZSBkYXRhIGxhdGVyXG4gICAqIG9uIGR1cmluZyB0aGUgdHJhbnNhY3Rpb24uXG4gICAqL1xuICBwcml2YXRlIHN0YXNoT2xkVmFsdWUoa2V5OiBzdHJpbmcsIHZhbHVlOiBCdWZmZXIgfCB1bmRlZmluZWQpIHtcbiAgICAvLyBLZWVwIG9ubHkgdGhlIGVhcmxpZXN0IHZhbHVlIGluIHRoZSB0cmFuc2FjdGlvbi5cbiAgICBpZiAoIXRoaXMub3JpZ2luYWxEYXRhLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIHRoaXMub3JpZ2luYWxEYXRhW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTWFya3MgdGhlIGdpdmVuIGtleSBhcyBtb2RpZmllZCwgYW5kIHN0YXNoZXMgaXRzIHZhbHVlIGlmIGl0IGhhcyBub3QgYmVlblxuICAgKiBzdGFzaGVkIGFscmVhZHkuXG4gICAqL1xuICBwcml2YXRlIG1hcmtNb2RpZmllZChrZXk6IHN0cmluZykge1xuICAgIGlmICh0aGlzLm1vZGlmaWVkS2V5cy5pbmRleE9mKGtleSkgPT09IC0xKSB7XG4gICAgICB0aGlzLm1vZGlmaWVkS2V5cy5wdXNoKGtleSk7XG4gICAgICBpZiAoIXRoaXMub3JpZ2luYWxEYXRhLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgdGhpcy5vcmlnaW5hbERhdGFba2V5XSA9IHRoaXMuc3RvcmUuZ2V0KGtleSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3luY0tleVZhbHVlRmlsZVN5c3RlbU9wdGlvbnMge1xuICAvKipcbiAgICogVGhlIGFjdHVhbCBrZXktdmFsdWUgc3RvcmUgdG8gcmVhZCBmcm9tL3dyaXRlIHRvLlxuICAgKi9cbiAgc3RvcmU6IFN5bmNLZXlWYWx1ZVN0b3JlO1xuICAvKipcbiAgICogU2hvdWxkIHRoZSBmaWxlIHN5c3RlbSBzdXBwb3J0IHByb3BlcnRpZXMgKG10aW1lL2F0aW1lL2N0aW1lL2NobW9kL2V0Yyk/XG4gICAqIEVuYWJsaW5nIHRoaXMgc2xpZ2h0bHkgaW5jcmVhc2VzIHRoZSBzdG9yYWdlIHNwYWNlIHBlciBmaWxlLCBhbmQgYWRkc1xuICAgKiBhdGltZSB1cGRhdGVzIGV2ZXJ5IHRpbWUgYSBmaWxlIGlzIGFjY2Vzc2VkLCBtdGltZSB1cGRhdGVzIGV2ZXJ5IHRpbWVcbiAgICogYSBmaWxlIGlzIG1vZGlmaWVkLCBhbmQgcGVybWlzc2lvbiBjaGVja3Mgb24gZXZlcnkgb3BlcmF0aW9uLlxuICAgKlxuICAgKiBEZWZhdWx0cyB0byAqZmFsc2UqLlxuICAgKi9cbiAgLy8gc3VwcG9ydFByb3BzPzogYm9vbGVhbjtcbiAgLyoqXG4gICAqIFNob3VsZCB0aGUgZmlsZSBzeXN0ZW0gc3VwcG9ydCBsaW5rcz9cbiAgICovXG4gIC8vIHN1cHBvcnRMaW5rcz86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBjbGFzcyBTeW5jS2V5VmFsdWVGaWxlIGV4dGVuZHMgUHJlbG9hZEZpbGU8U3luY0tleVZhbHVlRmlsZVN5c3RlbT4gaW1wbGVtZW50cyBGaWxlIHtcbiAgY29uc3RydWN0b3IoX2ZzOiBTeW5jS2V5VmFsdWVGaWxlU3lzdGVtLCBfcGF0aDogc3RyaW5nLCBfZmxhZzogRmlsZUZsYWcsIF9zdGF0OiBTdGF0cywgY29udGVudHM/OiBCdWZmZXIpIHtcbiAgICBzdXBlcihfZnMsIF9wYXRoLCBfZmxhZywgX3N0YXQsIGNvbnRlbnRzKTtcbiAgfVxuXG4gIHB1YmxpYyBzeW5jU3luYygpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5pc0RpcnR5KCkpIHtcbiAgICAgIHRoaXMuX2ZzLl9zeW5jU3luYyh0aGlzLmdldFBhdGgoKSwgdGhpcy5nZXRCdWZmZXIoKSwgdGhpcy5nZXRTdGF0cygpKTtcbiAgICAgIHRoaXMucmVzZXREaXJ0eSgpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBjbG9zZVN5bmMoKTogdm9pZCB7XG4gICAgdGhpcy5zeW5jU3luYygpO1xuICB9XG59XG5cbi8qKlxuICogQSBcIlN5bmNocm9ub3VzIGtleS12YWx1ZSBmaWxlIHN5c3RlbVwiLiBTdG9yZXMgZGF0YSB0by9yZXRyaWV2ZXMgZGF0YSBmcm9tIGFuXG4gKiB1bmRlcmx5aW5nIGtleS12YWx1ZSBzdG9yZS5cbiAqXG4gKiBXZSB1c2UgYSB1bmlxdWUgSUQgZm9yIGVhY2ggbm9kZSBpbiB0aGUgZmlsZSBzeXN0ZW0uIFRoZSByb290IG5vZGUgaGFzIGFcbiAqIGZpeGVkIElELlxuICogQHRvZG8gSW50cm9kdWNlIE5vZGUgSUQgY2FjaGluZy5cbiAqIEB0b2RvIENoZWNrIG1vZGVzLlxuICovXG5leHBvcnQgY2xhc3MgU3luY0tleVZhbHVlRmlsZVN5c3RlbSBleHRlbmRzIFN5bmNocm9ub3VzRmlsZVN5c3RlbSB7XG4gIHB1YmxpYyBzdGF0aWMgaXNBdmFpbGFibGUoKTogYm9vbGVhbiB7IHJldHVybiB0cnVlOyB9XG5cbiAgcHJpdmF0ZSBzdG9yZTogU3luY0tleVZhbHVlU3RvcmU7XG5cbiAgY29uc3RydWN0b3Iob3B0aW9uczogU3luY0tleVZhbHVlRmlsZVN5c3RlbU9wdGlvbnMpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuc3RvcmUgPSBvcHRpb25zLnN0b3JlO1xuICAgIC8vIElOVkFSSUFOVDogRW5zdXJlIHRoYXQgdGhlIHJvb3QgZXhpc3RzLlxuICAgIHRoaXMubWFrZVJvb3REaXJlY3RvcnkoKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXROYW1lKCk6IHN0cmluZyB7IHJldHVybiB0aGlzLnN0b3JlLm5hbWUoKTsgfVxuICBwdWJsaWMgaXNSZWFkT25seSgpOiBib29sZWFuIHsgcmV0dXJuIGZhbHNlOyB9XG4gIHB1YmxpYyBzdXBwb3J0c1N5bWxpbmtzKCk6IGJvb2xlYW4geyByZXR1cm4gZmFsc2U7IH1cbiAgcHVibGljIHN1cHBvcnRzUHJvcHMoKTogYm9vbGVhbiB7IHJldHVybiBmYWxzZTsgfVxuICBwdWJsaWMgc3VwcG9ydHNTeW5jaCgpOiBib29sZWFuIHsgcmV0dXJuIHRydWU7IH1cblxuICAvKipcbiAgICogRGVsZXRlIGFsbCBjb250ZW50cyBzdG9yZWQgaW4gdGhlIGZpbGUgc3lzdGVtLlxuICAgKi9cbiAgcHVibGljIGVtcHR5KCk6IHZvaWQge1xuICAgIHRoaXMuc3RvcmUuY2xlYXIoKTtcbiAgICAvLyBJTlZBUklBTlQ6IFJvb3QgYWx3YXlzIGV4aXN0cy5cbiAgICB0aGlzLm1ha2VSb290RGlyZWN0b3J5KCk7XG4gIH1cblxuICBwdWJsaWMgcmVuYW1lU3luYyhvbGRQYXRoOiBzdHJpbmcsIG5ld1BhdGg6IHN0cmluZyk6IHZvaWQge1xuICAgIGNvbnN0IHR4ID0gdGhpcy5zdG9yZS5iZWdpblRyYW5zYWN0aW9uKCdyZWFkd3JpdGUnKSxcbiAgICAgIG9sZFBhcmVudCA9IHBhdGguZGlybmFtZShvbGRQYXRoKSwgb2xkTmFtZSA9IHBhdGguYmFzZW5hbWUob2xkUGF0aCksXG4gICAgICBuZXdQYXJlbnQgPSBwYXRoLmRpcm5hbWUobmV3UGF0aCksIG5ld05hbWUgPSBwYXRoLmJhc2VuYW1lKG5ld1BhdGgpLFxuICAgICAgLy8gUmVtb3ZlIG9sZFBhdGggZnJvbSBwYXJlbnQncyBkaXJlY3RvcnkgbGlzdGluZy5cbiAgICAgIG9sZERpck5vZGUgPSB0aGlzLmZpbmRJTm9kZSh0eCwgb2xkUGFyZW50KSxcbiAgICAgIG9sZERpckxpc3QgPSB0aGlzLmdldERpckxpc3RpbmcodHgsIG9sZFBhcmVudCwgb2xkRGlyTm9kZSk7XG5cbiAgICBpZiAoIW9sZERpckxpc3Rbb2xkTmFtZV0pIHtcbiAgICAgIHRocm93IEFwaUVycm9yLkVOT0VOVChvbGRQYXRoKTtcbiAgICB9XG4gICAgY29uc3Qgbm9kZUlkOiBzdHJpbmcgPSBvbGREaXJMaXN0W29sZE5hbWVdO1xuICAgIGRlbGV0ZSBvbGREaXJMaXN0W29sZE5hbWVdO1xuXG4gICAgLy8gSW52YXJpYW50OiBDYW4ndCBtb3ZlIGEgZm9sZGVyIGluc2lkZSBpdHNlbGYuXG4gICAgLy8gVGhpcyBmdW5ueSBsaXR0bGUgaGFjayBlbnN1cmVzIHRoYXQgdGhlIGNoZWNrIHBhc3NlcyBvbmx5IGlmIG9sZFBhdGhcbiAgICAvLyBpcyBhIHN1YnBhdGggb2YgbmV3UGFyZW50LiBXZSBhcHBlbmQgJy8nIHRvIGF2b2lkIG1hdGNoaW5nIGZvbGRlcnMgdGhhdFxuICAgIC8vIGFyZSBhIHN1YnN0cmluZyBvZiB0aGUgYm90dG9tLW1vc3QgZm9sZGVyIGluIHRoZSBwYXRoLlxuICAgIGlmICgobmV3UGFyZW50ICsgJy8nKS5pbmRleE9mKG9sZFBhdGggKyAnLycpID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgQXBpRXJyb3IoRXJyb3JDb2RlLkVCVVNZLCBvbGRQYXJlbnQpO1xuICAgIH1cblxuICAgIC8vIEFkZCBuZXdQYXRoIHRvIHBhcmVudCdzIGRpcmVjdG9yeSBsaXN0aW5nLlxuICAgIGxldCBuZXdEaXJOb2RlOiBJbm9kZSwgbmV3RGlyTGlzdDogdHlwZW9mIG9sZERpckxpc3Q7XG4gICAgaWYgKG5ld1BhcmVudCA9PT0gb2xkUGFyZW50KSB7XG4gICAgICAvLyBQcmV2ZW50IHVzIGZyb20gcmUtZ3JhYmJpbmcgdGhlIHNhbWUgZGlyZWN0b3J5IGxpc3RpbmcsIHdoaWNoIHN0aWxsXG4gICAgICAvLyBjb250YWlucyBvbGROYW1lLlxuICAgICAgbmV3RGlyTm9kZSA9IG9sZERpck5vZGU7XG4gICAgICBuZXdEaXJMaXN0ID0gb2xkRGlyTGlzdDtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3RGlyTm9kZSA9IHRoaXMuZmluZElOb2RlKHR4LCBuZXdQYXJlbnQpO1xuICAgICAgbmV3RGlyTGlzdCA9IHRoaXMuZ2V0RGlyTGlzdGluZyh0eCwgbmV3UGFyZW50LCBuZXdEaXJOb2RlKTtcbiAgICB9XG5cbiAgICBpZiAobmV3RGlyTGlzdFtuZXdOYW1lXSkge1xuICAgICAgLy8gSWYgaXQncyBhIGZpbGUsIGRlbGV0ZSBpdC5cbiAgICAgIGNvbnN0IG5ld05hbWVOb2RlID0gdGhpcy5nZXRJTm9kZSh0eCwgbmV3UGF0aCwgbmV3RGlyTGlzdFtuZXdOYW1lXSk7XG4gICAgICBpZiAobmV3TmFtZU5vZGUuaXNGaWxlKCkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0eC5kZWwobmV3TmFtZU5vZGUuaWQpO1xuICAgICAgICAgIHR4LmRlbChuZXdEaXJMaXN0W25ld05hbWVdKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHR4LmFib3J0KCk7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSWYgaXQncyBhIGRpcmVjdG9yeSwgdGhyb3cgYSBwZXJtaXNzaW9ucyBlcnJvci5cbiAgICAgICAgdGhyb3cgQXBpRXJyb3IuRVBFUk0obmV3UGF0aCk7XG4gICAgICB9XG4gICAgfVxuICAgIG5ld0Rpckxpc3RbbmV3TmFtZV0gPSBub2RlSWQ7XG5cbiAgICAvLyBDb21taXQgdGhlIHR3byBjaGFuZ2VkIGRpcmVjdG9yeSBsaXN0aW5ncy5cbiAgICB0cnkge1xuICAgICAgdHgucHV0KG9sZERpck5vZGUuaWQsIEJ1ZmZlci5mcm9tKEpTT04uc3RyaW5naWZ5KG9sZERpckxpc3QpKSwgdHJ1ZSk7XG4gICAgICB0eC5wdXQobmV3RGlyTm9kZS5pZCwgQnVmZmVyLmZyb20oSlNPTi5zdHJpbmdpZnkobmV3RGlyTGlzdCkpLCB0cnVlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0eC5hYm9ydCgpO1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG5cbiAgICB0eC5jb21taXQoKTtcbiAgfVxuXG4gIHB1YmxpYyBzdGF0U3luYyhwOiBzdHJpbmcsIGlzTHN0YXQ6IGJvb2xlYW4pOiBTdGF0cyB7XG4gICAgLy8gR2V0IHRoZSBpbm9kZSB0byB0aGUgaXRlbSwgY29udmVydCBpdCBpbnRvIGEgU3RhdHMgb2JqZWN0LlxuICAgIHJldHVybiB0aGlzLmZpbmRJTm9kZSh0aGlzLnN0b3JlLmJlZ2luVHJhbnNhY3Rpb24oJ3JlYWRvbmx5JyksIHApLnRvU3RhdHMoKTtcbiAgfVxuXG4gIHB1YmxpYyBjcmVhdGVGaWxlU3luYyhwOiBzdHJpbmcsIGZsYWc6IEZpbGVGbGFnLCBtb2RlOiBudW1iZXIpOiBGaWxlIHtcbiAgICBjb25zdCB0eCA9IHRoaXMuc3RvcmUuYmVnaW5UcmFuc2FjdGlvbigncmVhZHdyaXRlJyksXG4gICAgICBkYXRhID0gZW1wdHlCdWZmZXIoKSxcbiAgICAgIG5ld0ZpbGUgPSB0aGlzLmNvbW1pdE5ld0ZpbGUodHgsIHAsIEZpbGVUeXBlLkZJTEUsIG1vZGUsIGRhdGEpO1xuICAgIC8vIE9wZW4gdGhlIGZpbGUuXG4gICAgcmV0dXJuIG5ldyBTeW5jS2V5VmFsdWVGaWxlKHRoaXMsIHAsIGZsYWcsIG5ld0ZpbGUudG9TdGF0cygpLCBkYXRhKTtcbiAgfVxuXG4gIHB1YmxpYyBvcGVuRmlsZVN5bmMocDogc3RyaW5nLCBmbGFnOiBGaWxlRmxhZyk6IEZpbGUge1xuICAgIGNvbnN0IHR4ID0gdGhpcy5zdG9yZS5iZWdpblRyYW5zYWN0aW9uKCdyZWFkb25seScpLFxuICAgICAgbm9kZSA9IHRoaXMuZmluZElOb2RlKHR4LCBwKSxcbiAgICAgIGRhdGEgPSB0eC5nZXQobm9kZS5pZCk7XG4gICAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgQXBpRXJyb3IuRU5PRU5UKHApO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFN5bmNLZXlWYWx1ZUZpbGUodGhpcywgcCwgZmxhZywgbm9kZS50b1N0YXRzKCksIGRhdGEpO1xuICB9XG5cbiAgcHVibGljIHVubGlua1N5bmMocDogc3RyaW5nKTogdm9pZCB7XG4gICAgdGhpcy5yZW1vdmVFbnRyeShwLCBmYWxzZSk7XG4gIH1cblxuICBwdWJsaWMgcm1kaXJTeW5jKHA6IHN0cmluZyk6IHZvaWQge1xuICAgIC8vIENoZWNrIGZpcnN0IGlmIGRpcmVjdG9yeSBpcyBlbXB0eS5cbiAgICBpZiAodGhpcy5yZWFkZGlyU3luYyhwKS5sZW5ndGggPiAwKSB7XG4gICAgICB0aHJvdyBBcGlFcnJvci5FTk9URU1QVFkocCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVtb3ZlRW50cnkocCwgdHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIG1rZGlyU3luYyhwOiBzdHJpbmcsIG1vZGU6IG51bWJlcik6IHZvaWQge1xuICAgIGNvbnN0IHR4ID0gdGhpcy5zdG9yZS5iZWdpblRyYW5zYWN0aW9uKCdyZWFkd3JpdGUnKSxcbiAgICAgIGRhdGEgPSBCdWZmZXIuZnJvbSgne30nKTtcbiAgICB0aGlzLmNvbW1pdE5ld0ZpbGUodHgsIHAsIEZpbGVUeXBlLkRJUkVDVE9SWSwgbW9kZSwgZGF0YSk7XG4gIH1cblxuICBwdWJsaWMgcmVhZGRpclN5bmMocDogc3RyaW5nKTogc3RyaW5nW10ge1xuICAgIGNvbnN0IHR4ID0gdGhpcy5zdG9yZS5iZWdpblRyYW5zYWN0aW9uKCdyZWFkb25seScpO1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLmdldERpckxpc3RpbmcodHgsIHAsIHRoaXMuZmluZElOb2RlKHR4LCBwKSkpO1xuICB9XG5cbiAgcHVibGljIF9zeW5jU3luYyhwOiBzdHJpbmcsIGRhdGE6IEJ1ZmZlciwgc3RhdHM6IFN0YXRzKTogdm9pZCB7XG4gICAgLy8gQHRvZG8gRW5zdXJlIG10aW1lIHVwZGF0ZXMgcHJvcGVybHksIGFuZCB1c2UgdGhhdCB0byBkZXRlcm1pbmUgaWYgYSBkYXRhXG4gICAgLy8gICAgICAgdXBkYXRlIGlzIHJlcXVpcmVkLlxuICAgIGNvbnN0IHR4ID0gdGhpcy5zdG9yZS5iZWdpblRyYW5zYWN0aW9uKCdyZWFkd3JpdGUnKSxcbiAgICAgIC8vIFdlIHVzZSB0aGUgX2ZpbmRJbm9kZSBoZWxwZXIgYmVjYXVzZSB3ZSBhY3R1YWxseSBuZWVkIHRoZSBJTm9kZSBpZC5cbiAgICAgIGZpbGVJbm9kZUlkID0gdGhpcy5fZmluZElOb2RlKHR4LCBwYXRoLmRpcm5hbWUocCksIHBhdGguYmFzZW5hbWUocCkpLFxuICAgICAgZmlsZUlub2RlID0gdGhpcy5nZXRJTm9kZSh0eCwgcCwgZmlsZUlub2RlSWQpLFxuICAgICAgaW5vZGVDaGFuZ2VkID0gZmlsZUlub2RlLnVwZGF0ZShzdGF0cyk7XG5cbiAgICB0cnkge1xuICAgICAgLy8gU3luYyBkYXRhLlxuICAgICAgdHgucHV0KGZpbGVJbm9kZS5pZCwgZGF0YSwgdHJ1ZSk7XG4gICAgICAvLyBTeW5jIG1ldGFkYXRhLlxuICAgICAgaWYgKGlub2RlQ2hhbmdlZCkge1xuICAgICAgICB0eC5wdXQoZmlsZUlub2RlSWQsIGZpbGVJbm9kZS50b0J1ZmZlcigpLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0eC5hYm9ydCgpO1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gICAgdHguY29tbWl0KCk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSByb290IGRpcmVjdG9yeSBleGlzdHMuIENyZWF0ZXMgaXQgaWYgaXQgZG9lc24ndC5cbiAgICovXG4gIHByaXZhdGUgbWFrZVJvb3REaXJlY3RvcnkoKSB7XG4gICAgY29uc3QgdHggPSB0aGlzLnN0b3JlLmJlZ2luVHJhbnNhY3Rpb24oJ3JlYWR3cml0ZScpO1xuICAgIGlmICh0eC5nZXQoUk9PVF9OT0RFX0lEKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBDcmVhdGUgbmV3IGlub2RlLlxuICAgICAgY29uc3QgY3VyclRpbWUgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpLFxuICAgICAgICAvLyBNb2RlIDA2NjZcbiAgICAgICAgZGlySW5vZGUgPSBuZXcgSW5vZGUoR2VuZXJhdGVSYW5kb21JRCgpLCA0MDk2LCA1MTEgfCBGaWxlVHlwZS5ESVJFQ1RPUlksIGN1cnJUaW1lLCBjdXJyVGltZSwgY3VyclRpbWUpO1xuICAgICAgLy8gSWYgdGhlIHJvb3QgZG9lc24ndCBleGlzdCwgdGhlIGZpcnN0IHJhbmRvbSBJRCBzaG91bGRuJ3QgZXhpc3QsXG4gICAgICAvLyBlaXRoZXIuXG4gICAgICB0eC5wdXQoZGlySW5vZGUuaWQsIGdldEVtcHR5RGlyTm9kZSgpLCBmYWxzZSk7XG4gICAgICB0eC5wdXQoUk9PVF9OT0RFX0lELCBkaXJJbm9kZS50b0J1ZmZlcigpLCBmYWxzZSk7XG4gICAgICB0eC5jb21taXQoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSGVscGVyIGZ1bmN0aW9uIGZvciBmaW5kSU5vZGUuXG4gICAqIEBwYXJhbSBwYXJlbnQgVGhlIHBhcmVudCBkaXJlY3Rvcnkgb2YgdGhlIGZpbGUgd2UgYXJlIGF0dGVtcHRpbmcgdG8gZmluZC5cbiAgICogQHBhcmFtIGZpbGVuYW1lIFRoZSBmaWxlbmFtZSBvZiB0aGUgaW5vZGUgd2UgYXJlIGF0dGVtcHRpbmcgdG8gZmluZCwgbWludXNcbiAgICogICB0aGUgcGFyZW50LlxuICAgKiBAcmV0dXJuIHN0cmluZyBUaGUgSUQgb2YgdGhlIGZpbGUncyBpbm9kZSBpbiB0aGUgZmlsZSBzeXN0ZW0uXG4gICAqL1xuICBwcml2YXRlIF9maW5kSU5vZGUodHg6IFN5bmNLZXlWYWx1ZVJPVHJhbnNhY3Rpb24sIHBhcmVudDogc3RyaW5nLCBmaWxlbmFtZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBjb25zdCByZWFkRGlyZWN0b3J5ID0gKGlub2RlOiBJbm9kZSk6IHN0cmluZyA9PiB7XG4gICAgICAvLyBHZXQgdGhlIHJvb3QncyBkaXJlY3RvcnkgbGlzdGluZy5cbiAgICAgIGNvbnN0IGRpckxpc3QgPSB0aGlzLmdldERpckxpc3RpbmcodHgsIHBhcmVudCwgaW5vZGUpO1xuICAgICAgLy8gR2V0IHRoZSBmaWxlJ3MgSUQuXG4gICAgICBpZiAoZGlyTGlzdFtmaWxlbmFtZV0pIHtcbiAgICAgICAgcmV0dXJuIGRpckxpc3RbZmlsZW5hbWVdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgQXBpRXJyb3IuRU5PRU5UKHBhdGgucmVzb2x2ZShwYXJlbnQsIGZpbGVuYW1lKSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAocGFyZW50ID09PSAnLycpIHtcbiAgICAgIGlmIChmaWxlbmFtZSA9PT0gJycpIHtcbiAgICAgICAgLy8gQkFTRSBDQVNFICMxOiBSZXR1cm4gdGhlIHJvb3QncyBJRC5cbiAgICAgICAgcmV0dXJuIFJPT1RfTk9ERV9JRDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEJBU0UgQ0FTRSAjMjogRmluZCB0aGUgaXRlbSBpbiB0aGUgcm9vdCBuZG9lLlxuICAgICAgICByZXR1cm4gcmVhZERpcmVjdG9yeSh0aGlzLmdldElOb2RlKHR4LCBwYXJlbnQsIFJPT1RfTk9ERV9JRCkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcmVhZERpcmVjdG9yeSh0aGlzLmdldElOb2RlKHR4LCBwYXJlbnQgKyBwYXRoLnNlcCArIGZpbGVuYW1lLFxuICAgICAgICB0aGlzLl9maW5kSU5vZGUodHgsIHBhdGguZGlybmFtZShwYXJlbnQpLCBwYXRoLmJhc2VuYW1lKHBhcmVudCkpKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZpbmRzIHRoZSBJbm9kZSBvZiB0aGUgZ2l2ZW4gcGF0aC5cbiAgICogQHBhcmFtIHAgVGhlIHBhdGggdG8gbG9vayB1cC5cbiAgICogQHJldHVybiBUaGUgSW5vZGUgb2YgdGhlIHBhdGggcC5cbiAgICogQHRvZG8gbWVtb2l6ZS9jYWNoZVxuICAgKi9cbiAgcHJpdmF0ZSBmaW5kSU5vZGUodHg6IFN5bmNLZXlWYWx1ZVJPVHJhbnNhY3Rpb24sIHA6IHN0cmluZyk6IElub2RlIHtcbiAgICByZXR1cm4gdGhpcy5nZXRJTm9kZSh0eCwgcCwgdGhpcy5fZmluZElOb2RlKHR4LCBwYXRoLmRpcm5hbWUocCksIHBhdGguYmFzZW5hbWUocCkpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHaXZlbiB0aGUgSUQgb2YgYSBub2RlLCByZXRyaWV2ZXMgdGhlIGNvcnJlc3BvbmRpbmcgSW5vZGUuXG4gICAqIEBwYXJhbSB0eCBUaGUgdHJhbnNhY3Rpb24gdG8gdXNlLlxuICAgKiBAcGFyYW0gcCBUaGUgY29ycmVzcG9uZGluZyBwYXRoIHRvIHRoZSBmaWxlICh1c2VkIGZvciBlcnJvciBtZXNzYWdlcykuXG4gICAqIEBwYXJhbSBpZCBUaGUgSUQgdG8gbG9vayB1cC5cbiAgICovXG4gIHByaXZhdGUgZ2V0SU5vZGUodHg6IFN5bmNLZXlWYWx1ZVJPVHJhbnNhY3Rpb24sIHA6IHN0cmluZywgaWQ6IHN0cmluZyk6IElub2RlIHtcbiAgICBjb25zdCBpbm9kZSA9IHR4LmdldChpZCk7XG4gICAgaWYgKGlub2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IEFwaUVycm9yLkVOT0VOVChwKTtcbiAgICB9XG4gICAgcmV0dXJuIElub2RlLmZyb21CdWZmZXIoaW5vZGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdpdmVuIHRoZSBJbm9kZSBvZiBhIGRpcmVjdG9yeSwgcmV0cmlldmVzIHRoZSBjb3JyZXNwb25kaW5nIGRpcmVjdG9yeVxuICAgKiBsaXN0aW5nLlxuICAgKi9cbiAgcHJpdmF0ZSBnZXREaXJMaXN0aW5nKHR4OiBTeW5jS2V5VmFsdWVST1RyYW5zYWN0aW9uLCBwOiBzdHJpbmcsIGlub2RlOiBJbm9kZSk6IHsgW2ZpbGVOYW1lOiBzdHJpbmddOiBzdHJpbmcgfSB7XG4gICAgaWYgKCFpbm9kZS5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICB0aHJvdyBBcGlFcnJvci5FTk9URElSKHApO1xuICAgIH1cbiAgICBjb25zdCBkYXRhID0gdHguZ2V0KGlub2RlLmlkKTtcbiAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBBcGlFcnJvci5FTk9FTlQocCk7XG4gICAgfVxuICAgIHJldHVybiBKU09OLnBhcnNlKGRhdGEudG9TdHJpbmcoKSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBub2RlIHVuZGVyIGEgcmFuZG9tIElELiBSZXRyaWVzIDUgdGltZXMgYmVmb3JlIGdpdmluZyB1cCBpblxuICAgKiB0aGUgZXhjZWVkaW5nbHkgdW5saWtlbHkgY2hhbmNlIHRoYXQgd2UgdHJ5IHRvIHJldXNlIGEgcmFuZG9tIEdVSUQuXG4gICAqIEByZXR1cm4gVGhlIEdVSUQgdGhhdCB0aGUgZGF0YSB3YXMgc3RvcmVkIHVuZGVyLlxuICAgKi9cbiAgcHJpdmF0ZSBhZGROZXdOb2RlKHR4OiBTeW5jS2V5VmFsdWVSV1RyYW5zYWN0aW9uLCBkYXRhOiBCdWZmZXIpOiBzdHJpbmcge1xuICAgIGNvbnN0IHJldHJpZXMgPSAwO1xuICAgIGxldCBjdXJySWQ6IHN0cmluZztcbiAgICB3aGlsZSAocmV0cmllcyA8IDUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGN1cnJJZCA9IEdlbmVyYXRlUmFuZG9tSUQoKTtcbiAgICAgICAgdHgucHV0KGN1cnJJZCwgZGF0YSwgZmFsc2UpO1xuICAgICAgICByZXR1cm4gY3VycklkO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBJZ25vcmUgYW5kIHJlcm9sbC5cbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IEFwaUVycm9yKEVycm9yQ29kZS5FSU8sICdVbmFibGUgdG8gY29tbWl0IGRhdGEgdG8ga2V5LXZhbHVlIHN0b3JlLicpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbW1pdHMgYSBuZXcgZmlsZSAod2VsbCwgYSBGSUxFIG9yIGEgRElSRUNUT1JZKSB0byB0aGUgZmlsZSBzeXN0ZW0gd2l0aFxuICAgKiB0aGUgZ2l2ZW4gbW9kZS5cbiAgICogTm90ZTogVGhpcyB3aWxsIGNvbW1pdCB0aGUgdHJhbnNhY3Rpb24uXG4gICAqIEBwYXJhbSBwIFRoZSBwYXRoIHRvIHRoZSBuZXcgZmlsZS5cbiAgICogQHBhcmFtIHR5cGUgVGhlIHR5cGUgb2YgdGhlIG5ldyBmaWxlLlxuICAgKiBAcGFyYW0gbW9kZSBUaGUgbW9kZSB0byBjcmVhdGUgdGhlIG5ldyBmaWxlIHdpdGguXG4gICAqIEBwYXJhbSBkYXRhIFRoZSBkYXRhIHRvIHN0b3JlIGF0IHRoZSBmaWxlJ3MgZGF0YSBub2RlLlxuICAgKiBAcmV0dXJuIFRoZSBJbm9kZSBmb3IgdGhlIG5ldyBmaWxlLlxuICAgKi9cbiAgcHJpdmF0ZSBjb21taXROZXdGaWxlKHR4OiBTeW5jS2V5VmFsdWVSV1RyYW5zYWN0aW9uLCBwOiBzdHJpbmcsIHR5cGU6IEZpbGVUeXBlLCBtb2RlOiBudW1iZXIsIGRhdGE6IEJ1ZmZlcik6IElub2RlIHtcbiAgICBjb25zdCBwYXJlbnREaXIgPSBwYXRoLmRpcm5hbWUocCksXG4gICAgICBmbmFtZSA9IHBhdGguYmFzZW5hbWUocCksXG4gICAgICBwYXJlbnROb2RlID0gdGhpcy5maW5kSU5vZGUodHgsIHBhcmVudERpciksXG4gICAgICBkaXJMaXN0aW5nID0gdGhpcy5nZXREaXJMaXN0aW5nKHR4LCBwYXJlbnREaXIsIHBhcmVudE5vZGUpLFxuICAgICAgY3VyclRpbWUgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuXG4gICAgLy8gSW52YXJpYW50OiBUaGUgcm9vdCBhbHdheXMgZXhpc3RzLlxuICAgIC8vIElmIHdlIGRvbid0IGNoZWNrIHRoaXMgcHJpb3IgdG8gdGFraW5nIHN0ZXBzIGJlbG93LCB3ZSB3aWxsIGNyZWF0ZSBhXG4gICAgLy8gZmlsZSB3aXRoIG5hbWUgJycgaW4gcm9vdCBzaG91bGQgcCA9PSAnLycuXG4gICAgaWYgKHAgPT09ICcvJykge1xuICAgICAgdGhyb3cgQXBpRXJyb3IuRUVYSVNUKHApO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIGZpbGUgYWxyZWFkeSBleGlzdHMuXG4gICAgaWYgKGRpckxpc3RpbmdbZm5hbWVdKSB7XG4gICAgICB0aHJvdyBBcGlFcnJvci5FRVhJU1QocCk7XG4gICAgfVxuXG4gICAgbGV0IGZpbGVOb2RlOiBJbm9kZTtcbiAgICB0cnkge1xuICAgICAgLy8gQ29tbWl0IGRhdGEuXG4gICAgICBjb25zdCBkYXRhSWQgPSB0aGlzLmFkZE5ld05vZGUodHgsIGRhdGEpO1xuICAgICAgZmlsZU5vZGUgPSBuZXcgSW5vZGUoZGF0YUlkLCBkYXRhLmxlbmd0aCwgbW9kZSB8IHR5cGUsIGN1cnJUaW1lLCBjdXJyVGltZSwgY3VyclRpbWUpO1xuICAgICAgLy8gQ29tbWl0IGZpbGUgbm9kZS5cbiAgICAgIGNvbnN0IGZpbGVOb2RlSWQgPSB0aGlzLmFkZE5ld05vZGUodHgsIGZpbGVOb2RlLnRvQnVmZmVyKCkpO1xuICAgICAgLy8gVXBkYXRlIGFuZCBjb21taXQgcGFyZW50IGRpcmVjdG9yeSBsaXN0aW5nLlxuICAgICAgZGlyTGlzdGluZ1tmbmFtZV0gPSBmaWxlTm9kZUlkO1xuICAgICAgdHgucHV0KHBhcmVudE5vZGUuaWQsIEJ1ZmZlci5mcm9tKEpTT04uc3RyaW5naWZ5KGRpckxpc3RpbmcpKSwgdHJ1ZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdHguYWJvcnQoKTtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuICAgIHR4LmNvbW1pdCgpO1xuICAgIHJldHVybiBmaWxlTm9kZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYWxsIHRyYWNlcyBvZiB0aGUgZ2l2ZW4gcGF0aCBmcm9tIHRoZSBmaWxlIHN5c3RlbS5cbiAgICogQHBhcmFtIHAgVGhlIHBhdGggdG8gcmVtb3ZlIGZyb20gdGhlIGZpbGUgc3lzdGVtLlxuICAgKiBAcGFyYW0gaXNEaXIgRG9lcyB0aGUgcGF0aCBiZWxvbmcgdG8gYSBkaXJlY3RvcnksIG9yIGEgZmlsZT9cbiAgICogQHRvZG8gVXBkYXRlIG10aW1lLlxuICAgKi9cbiAgcHJpdmF0ZSByZW1vdmVFbnRyeShwOiBzdHJpbmcsIGlzRGlyOiBib29sZWFuKTogdm9pZCB7XG4gICAgY29uc3QgdHggPSB0aGlzLnN0b3JlLmJlZ2luVHJhbnNhY3Rpb24oJ3JlYWR3cml0ZScpLFxuICAgICAgcGFyZW50OiBzdHJpbmcgPSBwYXRoLmRpcm5hbWUocCksXG4gICAgICBwYXJlbnROb2RlID0gdGhpcy5maW5kSU5vZGUodHgsIHBhcmVudCksXG4gICAgICBwYXJlbnRMaXN0aW5nID0gdGhpcy5nZXREaXJMaXN0aW5nKHR4LCBwYXJlbnQsIHBhcmVudE5vZGUpLFxuICAgICAgZmlsZU5hbWU6IHN0cmluZyA9IHBhdGguYmFzZW5hbWUocCk7XG5cbiAgICBpZiAoIXBhcmVudExpc3RpbmdbZmlsZU5hbWVdKSB7XG4gICAgICB0aHJvdyBBcGlFcnJvci5FTk9FTlQocCk7XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIGZyb20gZGlyZWN0b3J5IGxpc3Rpbmcgb2YgcGFyZW50LlxuICAgIGNvbnN0IGZpbGVOb2RlSWQgPSBwYXJlbnRMaXN0aW5nW2ZpbGVOYW1lXTtcbiAgICBkZWxldGUgcGFyZW50TGlzdGluZ1tmaWxlTmFtZV07XG5cbiAgICAvLyBHZXQgZmlsZSBpbm9kZS5cbiAgICBjb25zdCBmaWxlTm9kZSA9IHRoaXMuZ2V0SU5vZGUodHgsIHAsIGZpbGVOb2RlSWQpO1xuICAgIGlmICghaXNEaXIgJiYgZmlsZU5vZGUuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgdGhyb3cgQXBpRXJyb3IuRUlTRElSKHApO1xuICAgIH0gZWxzZSBpZiAoaXNEaXIgJiYgIWZpbGVOb2RlLmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgIHRocm93IEFwaUVycm9yLkVOT1RESVIocCk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIC8vIERlbGV0ZSBkYXRhLlxuICAgICAgdHguZGVsKGZpbGVOb2RlLmlkKTtcbiAgICAgIC8vIERlbGV0ZSBub2RlLlxuICAgICAgdHguZGVsKGZpbGVOb2RlSWQpO1xuICAgICAgLy8gVXBkYXRlIGRpcmVjdG9yeSBsaXN0aW5nLlxuICAgICAgdHgucHV0KHBhcmVudE5vZGUuaWQsIEJ1ZmZlci5mcm9tKEpTT04uc3RyaW5naWZ5KHBhcmVudExpc3RpbmcpKSwgdHJ1ZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdHguYWJvcnQoKTtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuICAgIC8vIFN1Y2Nlc3MuXG4gICAgdHguY29tbWl0KCk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIGFuICphc3luY2hyb25vdXMqIGtleS12YWx1ZSBzdG9yZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBBc3luY0tleVZhbHVlU3RvcmUge1xuICAvKipcbiAgICogVGhlIG5hbWUgb2YgdGhlIGtleS12YWx1ZSBzdG9yZS5cbiAgICovXG4gIG5hbWUoKTogc3RyaW5nO1xuICAvKipcbiAgICogRW1wdGllcyB0aGUga2V5LXZhbHVlIHN0b3JlIGNvbXBsZXRlbHkuXG4gICAqL1xuICBjbGVhcihjYjogQkZTT25lQXJnQ2FsbGJhY2spOiB2b2lkO1xuICAvKipcbiAgICogQmVnaW5zIGEgcmVhZC13cml0ZSB0cmFuc2FjdGlvbi5cbiAgICovXG4gIGJlZ2luVHJhbnNhY3Rpb24odHlwZTogJ3JlYWR3cml0ZScpOiBBc3luY0tleVZhbHVlUldUcmFuc2FjdGlvbjtcbiAgLyoqXG4gICAqIEJlZ2lucyBhIHJlYWQtb25seSB0cmFuc2FjdGlvbi5cbiAgICovXG4gIGJlZ2luVHJhbnNhY3Rpb24odHlwZTogJ3JlYWRvbmx5Jyk6IEFzeW5jS2V5VmFsdWVST1RyYW5zYWN0aW9uO1xuICBiZWdpblRyYW5zYWN0aW9uKHR5cGU6IHN0cmluZyk6IEFzeW5jS2V5VmFsdWVST1RyYW5zYWN0aW9uO1xufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYW4gYXN5bmNocm9ub3VzIHJlYWQtb25seSB0cmFuc2FjdGlvbi5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBBc3luY0tleVZhbHVlUk9UcmFuc2FjdGlvbiB7XG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIGRhdGEgYXQgdGhlIGdpdmVuIGtleS5cbiAgICogQHBhcmFtIGtleSBUaGUga2V5IHRvIGxvb2sgdW5kZXIgZm9yIGRhdGEuXG4gICAqL1xuICBnZXQoa2V5OiBzdHJpbmcsIGNiOiBCRlNDYWxsYmFjazxCdWZmZXI+KTogdm9pZDtcbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIGFzeW5jaHJvbm91cyByZWFkLXdyaXRlIHRyYW5zYWN0aW9uLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEFzeW5jS2V5VmFsdWVSV1RyYW5zYWN0aW9uIGV4dGVuZHMgQXN5bmNLZXlWYWx1ZVJPVHJhbnNhY3Rpb24ge1xuICAvKipcbiAgICogQWRkcyB0aGUgZGF0YSB0byB0aGUgc3RvcmUgdW5kZXIgdGhlIGdpdmVuIGtleS4gT3ZlcndyaXRlcyBhbnkgZXhpc3RpbmdcbiAgICogZGF0YS5cbiAgICogQHBhcmFtIGtleSBUaGUga2V5IHRvIGFkZCB0aGUgZGF0YSB1bmRlci5cbiAgICogQHBhcmFtIGRhdGEgVGhlIGRhdGEgdG8gYWRkIHRvIHRoZSBzdG9yZS5cbiAgICogQHBhcmFtIG92ZXJ3cml0ZSBJZiAndHJ1ZScsIG92ZXJ3cml0ZSBhbnkgZXhpc3RpbmcgZGF0YS4gSWYgJ2ZhbHNlJyxcbiAgICogICBhdm9pZHMgd3JpdGluZyB0aGUgZGF0YSBpZiB0aGUga2V5IGV4aXN0cy5cbiAgICogQHBhcmFtIGNiIFRyaWdnZXJlZCB3aXRoIGFuIGVycm9yIGFuZCB3aGV0aGVyIG9yIG5vdCB0aGUgdmFsdWUgd2FzXG4gICAqICAgY29tbWl0dGVkLlxuICAgKi9cbiAgcHV0KGtleTogc3RyaW5nLCBkYXRhOiBCdWZmZXIsIG92ZXJ3cml0ZTogYm9vbGVhbiwgY2I6IChlOiBBcGlFcnJvcixcbiAgICBjb21taXR0ZWQ/OiBib29sZWFuKSA9PiB2b2lkKTogdm9pZDtcbiAgLyoqXG4gICAqIERlbGV0ZXMgdGhlIGRhdGEgYXQgdGhlIGdpdmVuIGtleS5cbiAgICogQHBhcmFtIGtleSBUaGUga2V5IHRvIGRlbGV0ZSBmcm9tIHRoZSBzdG9yZS5cbiAgICovXG4gIGRlbChrZXk6IHN0cmluZywgY2I6IEJGU09uZUFyZ0NhbGxiYWNrKTogdm9pZDtcbiAgLyoqXG4gICAqIENvbW1pdHMgdGhlIHRyYW5zYWN0aW9uLlxuICAgKi9cbiAgY29tbWl0KGNiOiBCRlNPbmVBcmdDYWxsYmFjayk6IHZvaWQ7XG4gIC8qKlxuICAgKiBBYm9ydHMgYW5kIHJvbGxzIGJhY2sgdGhlIHRyYW5zYWN0aW9uLlxuICAgKi9cbiAgYWJvcnQoY2I6IEJGU09uZUFyZ0NhbGxiYWNrKTogdm9pZDtcbn1cblxuZXhwb3J0IGNsYXNzIEFzeW5jS2V5VmFsdWVGaWxlIGV4dGVuZHMgUHJlbG9hZEZpbGU8QXN5bmNLZXlWYWx1ZUZpbGVTeXN0ZW0+IGltcGxlbWVudHMgRmlsZSB7XG4gIGNvbnN0cnVjdG9yKF9mczogQXN5bmNLZXlWYWx1ZUZpbGVTeXN0ZW0sIF9wYXRoOiBzdHJpbmcsIF9mbGFnOiBGaWxlRmxhZywgX3N0YXQ6IFN0YXRzLCBjb250ZW50cz86IEJ1ZmZlcikge1xuICAgIHN1cGVyKF9mcywgX3BhdGgsIF9mbGFnLCBfc3RhdCwgY29udGVudHMpO1xuICB9XG5cbiAgcHVibGljIHN5bmMoY2I6IEJGU09uZUFyZ0NhbGxiYWNrKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuaXNEaXJ0eSgpKSB7XG4gICAgICB0aGlzLl9mcy5fc3luYyh0aGlzLmdldFBhdGgoKSwgdGhpcy5nZXRCdWZmZXIoKSwgdGhpcy5nZXRTdGF0cygpLCAoZT86IEFwaUVycm9yKSA9PiB7XG4gICAgICAgIGlmICghZSkge1xuICAgICAgICAgIHRoaXMucmVzZXREaXJ0eSgpO1xuICAgICAgICB9XG4gICAgICAgIGNiKGUpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNiKCk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGNsb3NlKGNiOiBCRlNPbmVBcmdDYWxsYmFjayk6IHZvaWQge1xuICAgIHRoaXMuc3luYyhjYik7XG4gIH1cbn1cblxuLyoqXG4gKiBBbiBcIkFzeW5jaHJvbm91cyBrZXktdmFsdWUgZmlsZSBzeXN0ZW1cIi4gU3RvcmVzIGRhdGEgdG8vcmV0cmlldmVzIGRhdGEgZnJvbVxuICogYW4gdW5kZXJseWluZyBhc3luY2hyb25vdXMga2V5LXZhbHVlIHN0b3JlLlxuICovXG5leHBvcnQgY2xhc3MgQXN5bmNLZXlWYWx1ZUZpbGVTeXN0ZW0gZXh0ZW5kcyBCYXNlRmlsZVN5c3RlbSB7XG4gIHB1YmxpYyBzdGF0aWMgaXNBdmFpbGFibGUoKTogYm9vbGVhbiB7IHJldHVybiB0cnVlOyB9XG5cbiAgcHJvdGVjdGVkIHN0b3JlOiBBc3luY0tleVZhbHVlU3RvcmU7XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBmaWxlIHN5c3RlbS4gVHlwaWNhbGx5IGNhbGxlZCBieSBzdWJjbGFzc2VzJyBhc3luY1xuICAgKiBjb25zdHJ1Y3RvcnMuXG4gICAqL1xuICBwdWJsaWMgaW5pdChzdG9yZTogQXN5bmNLZXlWYWx1ZVN0b3JlLCBjYjogQkZTT25lQXJnQ2FsbGJhY2spIHtcbiAgICB0aGlzLnN0b3JlID0gc3RvcmU7XG4gICAgLy8gSU5WQVJJQU5UOiBFbnN1cmUgdGhhdCB0aGUgcm9vdCBleGlzdHMuXG4gICAgdGhpcy5tYWtlUm9vdERpcmVjdG9yeShjYik7XG4gIH1cbiAgcHVibGljIGdldE5hbWUoKTogc3RyaW5nIHsgcmV0dXJuIHRoaXMuc3RvcmUubmFtZSgpOyB9XG4gIHB1YmxpYyBpc1JlYWRPbmx5KCk6IGJvb2xlYW4geyByZXR1cm4gZmFsc2U7IH1cbiAgcHVibGljIHN1cHBvcnRzU3ltbGlua3MoKTogYm9vbGVhbiB7IHJldHVybiBmYWxzZTsgfVxuICBwdWJsaWMgc3VwcG9ydHNQcm9wcygpOiBib29sZWFuIHsgcmV0dXJuIGZhbHNlOyB9XG4gIHB1YmxpYyBzdXBwb3J0c1N5bmNoKCk6IGJvb2xlYW4geyByZXR1cm4gZmFsc2U7IH1cblxuICAvKipcbiAgICogRGVsZXRlIGFsbCBjb250ZW50cyBzdG9yZWQgaW4gdGhlIGZpbGUgc3lzdGVtLlxuICAgKi9cbiAgcHVibGljIGVtcHR5KGNiOiBCRlNPbmVBcmdDYWxsYmFjayk6IHZvaWQge1xuICAgIHRoaXMuc3RvcmUuY2xlYXIoKGU/KSA9PiB7XG4gICAgICBpZiAobm9FcnJvcihlLCBjYikpIHtcbiAgICAgICAgLy8gSU5WQVJJQU5UOiBSb290IGFsd2F5cyBleGlzdHMuXG4gICAgICAgIHRoaXMubWFrZVJvb3REaXJlY3RvcnkoY2IpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIHJlbmFtZShvbGRQYXRoOiBzdHJpbmcsIG5ld1BhdGg6IHN0cmluZywgY2I6IEJGU09uZUFyZ0NhbGxiYWNrKTogdm9pZCB7XG4gICAgY29uc3QgdHggPSB0aGlzLnN0b3JlLmJlZ2luVHJhbnNhY3Rpb24oJ3JlYWR3cml0ZScpO1xuICAgIGNvbnN0IG9sZFBhcmVudCA9IHBhdGguZGlybmFtZShvbGRQYXRoKSwgb2xkTmFtZSA9IHBhdGguYmFzZW5hbWUob2xkUGF0aCk7XG4gICAgY29uc3QgbmV3UGFyZW50ID0gcGF0aC5kaXJuYW1lKG5ld1BhdGgpLCBuZXdOYW1lID0gcGF0aC5iYXNlbmFtZShuZXdQYXRoKTtcbiAgICBjb25zdCBpbm9kZXM6IHsgW3BhdGg6IHN0cmluZ106IElub2RlIH0gPSB7fTtcbiAgICBjb25zdCBsaXN0czoge1xuICAgICAgW3BhdGg6IHN0cmluZ106IHsgW2ZpbGU6IHN0cmluZ106IHN0cmluZyB9XG4gICAgfSA9IHt9O1xuICAgIGxldCBlcnJvck9jY3VycmVkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvLyBJbnZhcmlhbnQ6IENhbid0IG1vdmUgYSBmb2xkZXIgaW5zaWRlIGl0c2VsZi5cbiAgICAvLyBUaGlzIGZ1bm55IGxpdHRsZSBoYWNrIGVuc3VyZXMgdGhhdCB0aGUgY2hlY2sgcGFzc2VzIG9ubHkgaWYgb2xkUGF0aFxuICAgIC8vIGlzIGEgc3VicGF0aCBvZiBuZXdQYXJlbnQuIFdlIGFwcGVuZCAnLycgdG8gYXZvaWQgbWF0Y2hpbmcgZm9sZGVycyB0aGF0XG4gICAgLy8gYXJlIGEgc3Vic3RyaW5nIG9mIHRoZSBib3R0b20tbW9zdCBmb2xkZXIgaW4gdGhlIHBhdGguXG4gICAgaWYgKChuZXdQYXJlbnQgKyAnLycpLmluZGV4T2Yob2xkUGF0aCArICcvJykgPT09IDApIHtcbiAgICAgIHJldHVybiBjYihuZXcgQXBpRXJyb3IoRXJyb3JDb2RlLkVCVVNZLCBvbGRQYXJlbnQpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXNwb25zaWJsZSBmb3IgUGhhc2UgMiBvZiB0aGUgcmVuYW1lIG9wZXJhdGlvbjogTW9kaWZ5aW5nIGFuZFxuICAgICAqIGNvbW1pdHRpbmcgdGhlIGRpcmVjdG9yeSBsaXN0aW5ncy4gQ2FsbGVkIG9uY2Ugd2UgaGF2ZSBzdWNjZXNzZnVsbHlcbiAgICAgKiByZXRyaWV2ZWQgYm90aCB0aGUgb2xkIGFuZCBuZXcgcGFyZW50J3MgaW5vZGVzIGFuZCBsaXN0aW5ncy5cbiAgICAgKi9cbiAgICBjb25zdCB0aGVPbGVTd2l0Y2hhcm9vID0gKCk6IHZvaWQgPT4ge1xuICAgICAgLy8gU2FuaXR5IGNoZWNrOiBFbnN1cmUgYm90aCBwYXRocyBhcmUgcHJlc2VudCwgYW5kIG5vIGVycm9yIGhhcyBvY2N1cnJlZC5cbiAgICAgIGlmIChlcnJvck9jY3VycmVkIHx8ICFsaXN0cy5oYXNPd25Qcm9wZXJ0eShvbGRQYXJlbnQpIHx8ICFsaXN0cy5oYXNPd25Qcm9wZXJ0eShuZXdQYXJlbnQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9sZFBhcmVudExpc3QgPSBsaXN0c1tvbGRQYXJlbnRdLCBvbGRQYXJlbnRJTm9kZSA9IGlub2Rlc1tvbGRQYXJlbnRdLFxuICAgICAgICBuZXdQYXJlbnRMaXN0ID0gbGlzdHNbbmV3UGFyZW50XSwgbmV3UGFyZW50SU5vZGUgPSBpbm9kZXNbbmV3UGFyZW50XTtcblxuICAgICAgLy8gRGVsZXRlIGZpbGUgZnJvbSBvbGQgcGFyZW50LlxuICAgICAgaWYgKCFvbGRQYXJlbnRMaXN0W29sZE5hbWVdKSB7XG4gICAgICAgIGNiKEFwaUVycm9yLkVOT0VOVChvbGRQYXRoKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBmaWxlSWQgPSBvbGRQYXJlbnRMaXN0W29sZE5hbWVdO1xuICAgICAgICBkZWxldGUgb2xkUGFyZW50TGlzdFtvbGROYW1lXTtcblxuICAgICAgICAvLyBGaW5pc2hlcyBvZmYgdGhlIHJlbmFtaW5nIHByb2Nlc3MgYnkgYWRkaW5nIHRoZSBmaWxlIHRvIHRoZSBuZXdcbiAgICAgICAgLy8gcGFyZW50LlxuICAgICAgICBjb25zdCBjb21wbGV0ZVJlbmFtZSA9ICgpID0+IHtcbiAgICAgICAgICBuZXdQYXJlbnRMaXN0W25ld05hbWVdID0gZmlsZUlkO1xuICAgICAgICAgIC8vIENvbW1pdCBvbGQgcGFyZW50J3MgbGlzdC5cbiAgICAgICAgICB0eC5wdXQob2xkUGFyZW50SU5vZGUuaWQsIEJ1ZmZlci5mcm9tKEpTT04uc3RyaW5naWZ5KG9sZFBhcmVudExpc3QpKSwgdHJ1ZSwgKGU6IEFwaUVycm9yKSA9PiB7XG4gICAgICAgICAgICBpZiAobm9FcnJvclR4KGUsIHR4LCBjYikpIHtcbiAgICAgICAgICAgICAgaWYgKG9sZFBhcmVudCA9PT0gbmV3UGFyZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gRE9ORSFcbiAgICAgICAgICAgICAgICB0eC5jb21taXQoY2IpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIENvbW1pdCBuZXcgcGFyZW50J3MgbGlzdC5cbiAgICAgICAgICAgICAgICB0eC5wdXQobmV3UGFyZW50SU5vZGUuaWQsIEJ1ZmZlci5mcm9tKEpTT04uc3RyaW5naWZ5KG5ld1BhcmVudExpc3QpKSwgdHJ1ZSwgKGU6IEFwaUVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICBpZiAobm9FcnJvclR4KGUsIHR4LCBjYikpIHtcbiAgICAgICAgICAgICAgICAgICAgdHguY29tbWl0KGNiKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChuZXdQYXJlbnRMaXN0W25ld05hbWVdKSB7XG4gICAgICAgICAgLy8gJ25ld1BhdGgnIGFscmVhZHkgZXhpc3RzLiBDaGVjayBpZiBpdCdzIGEgZmlsZSBvciBhIGRpcmVjdG9yeSwgYW5kXG4gICAgICAgICAgLy8gYWN0IGFjY29yZGluZ2x5LlxuICAgICAgICAgIHRoaXMuZ2V0SU5vZGUodHgsIG5ld1BhdGgsIG5ld1BhcmVudExpc3RbbmV3TmFtZV0sIChlOiBBcGlFcnJvciwgaW5vZGU/OiBJbm9kZSkgPT4ge1xuICAgICAgICAgICAgaWYgKG5vRXJyb3JUeChlLCB0eCwgY2IpKSB7XG4gICAgICAgICAgICAgIGlmIChpbm9kZSEuaXNGaWxlKCkpIHtcbiAgICAgICAgICAgICAgICAvLyBEZWxldGUgdGhlIGZpbGUgYW5kIGNvbnRpbnVlLlxuICAgICAgICAgICAgICAgIHR4LmRlbChpbm9kZSEuaWQsIChlPzogQXBpRXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAgIGlmIChub0Vycm9yVHgoZSwgdHgsIGNiKSkge1xuICAgICAgICAgICAgICAgICAgICB0eC5kZWwobmV3UGFyZW50TGlzdFtuZXdOYW1lXSwgKGU/OiBBcGlFcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChub0Vycm9yVHgoZSwgdHgsIGNiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxldGVSZW5hbWUoKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIENhbid0IG92ZXJ3cml0ZSBhIGRpcmVjdG9yeSB1c2luZyByZW5hbWUuXG4gICAgICAgICAgICAgICAgdHguYWJvcnQoKGU/KSA9PiB7XG4gICAgICAgICAgICAgICAgICBjYihBcGlFcnJvci5FUEVSTShuZXdQYXRoKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb21wbGV0ZVJlbmFtZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdyYWJzIGEgcGF0aCdzIGlub2RlIGFuZCBkaXJlY3RvcnkgbGlzdGluZywgYW5kIHNob3ZlcyBpdCBpbnRvIHRoZVxuICAgICAqIGlub2RlcyBhbmQgbGlzdHMgaGFzaGVzLlxuICAgICAqL1xuICAgIGNvbnN0IHByb2Nlc3NJbm9kZUFuZExpc3RpbmdzID0gKHA6IHN0cmluZyk6IHZvaWQgPT4ge1xuICAgICAgdGhpcy5maW5kSU5vZGVBbmREaXJMaXN0aW5nKHR4LCBwLCAoZT86IEFwaUVycm9yIHwgbnVsbCwgbm9kZT86IElub2RlLCBkaXJMaXN0Pzoge1tuYW1lOiBzdHJpbmddOiBzdHJpbmd9KTogdm9pZCA9PiB7XG4gICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgaWYgKCFlcnJvck9jY3VycmVkKSB7XG4gICAgICAgICAgICBlcnJvck9jY3VycmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHR4LmFib3J0KCgpID0+IHtcbiAgICAgICAgICAgICAgY2IoZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gSWYgZXJyb3IgaGFzIG9jY3VycmVkIGFscmVhZHksIGp1c3Qgc3RvcCBoZXJlLlxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlub2Rlc1twXSA9IG5vZGUhO1xuICAgICAgICAgIGxpc3RzW3BdID0gZGlyTGlzdCE7XG4gICAgICAgICAgdGhlT2xlU3dpdGNoYXJvbygpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgcHJvY2Vzc0lub2RlQW5kTGlzdGluZ3Mob2xkUGFyZW50KTtcbiAgICBpZiAob2xkUGFyZW50ICE9PSBuZXdQYXJlbnQpIHtcbiAgICAgIHByb2Nlc3NJbm9kZUFuZExpc3RpbmdzKG5ld1BhcmVudCk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHN0YXQocDogc3RyaW5nLCBpc0xzdGF0OiBib29sZWFuLCBjYjogQkZTQ2FsbGJhY2s8U3RhdHM+KTogdm9pZCB7XG4gICAgY29uc3QgdHggPSB0aGlzLnN0b3JlLmJlZ2luVHJhbnNhY3Rpb24oJ3JlYWRvbmx5Jyk7XG4gICAgdGhpcy5maW5kSU5vZGUodHgsIHAsIChlOiBBcGlFcnJvciwgaW5vZGU/OiBJbm9kZSk6IHZvaWQgPT4ge1xuICAgICAgaWYgKG5vRXJyb3IoZSwgY2IpKSB7XG4gICAgICAgIGNiKG51bGwsIGlub2RlIS50b1N0YXRzKCkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIGNyZWF0ZUZpbGUocDogc3RyaW5nLCBmbGFnOiBGaWxlRmxhZywgbW9kZTogbnVtYmVyLCBjYjogQkZTQ2FsbGJhY2s8RmlsZT4pOiB2b2lkIHtcbiAgICBjb25zdCB0eCA9IHRoaXMuc3RvcmUuYmVnaW5UcmFuc2FjdGlvbigncmVhZHdyaXRlJyksXG4gICAgICBkYXRhID0gZW1wdHlCdWZmZXIoKTtcblxuICAgIHRoaXMuY29tbWl0TmV3RmlsZSh0eCwgcCwgRmlsZVR5cGUuRklMRSwgbW9kZSwgZGF0YSwgKGU6IEFwaUVycm9yLCBuZXdGaWxlPzogSW5vZGUpOiB2b2lkID0+IHtcbiAgICAgIGlmIChub0Vycm9yKGUsIGNiKSkge1xuICAgICAgICBjYihudWxsLCBuZXcgQXN5bmNLZXlWYWx1ZUZpbGUodGhpcywgcCwgZmxhZywgbmV3RmlsZSEudG9TdGF0cygpLCBkYXRhKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBwdWJsaWMgb3BlbkZpbGUocDogc3RyaW5nLCBmbGFnOiBGaWxlRmxhZywgY2I6IEJGU0NhbGxiYWNrPEZpbGU+KTogdm9pZCB7XG4gICAgY29uc3QgdHggPSB0aGlzLnN0b3JlLmJlZ2luVHJhbnNhY3Rpb24oJ3JlYWRvbmx5Jyk7XG4gICAgLy8gU3RlcCAxOiBHcmFiIHRoZSBmaWxlJ3MgaW5vZGUuXG4gICAgdGhpcy5maW5kSU5vZGUodHgsIHAsIChlOiBBcGlFcnJvciwgaW5vZGU/OiBJbm9kZSkgPT4ge1xuICAgICAgaWYgKG5vRXJyb3IoZSwgY2IpKSB7XG4gICAgICAgIC8vIFN0ZXAgMjogR3JhYiB0aGUgZmlsZSdzIGRhdGEuXG4gICAgICAgIHR4LmdldChpbm9kZSEuaWQsIChlOiBBcGlFcnJvciwgZGF0YT86IEJ1ZmZlcik6IHZvaWQgPT4ge1xuICAgICAgICAgIGlmIChub0Vycm9yKGUsIGNiKSkge1xuICAgICAgICAgICAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBjYihBcGlFcnJvci5FTk9FTlQocCkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY2IobnVsbCwgbmV3IEFzeW5jS2V5VmFsdWVGaWxlKHRoaXMsIHAsIGZsYWcsIGlub2RlIS50b1N0YXRzKCksIGRhdGEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIHVubGluayhwOiBzdHJpbmcsIGNiOiBCRlNPbmVBcmdDYWxsYmFjayk6IHZvaWQge1xuICAgIHRoaXMucmVtb3ZlRW50cnkocCwgZmFsc2UsIGNiKTtcbiAgfVxuXG4gIHB1YmxpYyBybWRpcihwOiBzdHJpbmcsIGNiOiBCRlNPbmVBcmdDYWxsYmFjayk6IHZvaWQge1xuICAgIC8vIENoZWNrIGZpcnN0IGlmIGRpcmVjdG9yeSBpcyBlbXB0eS5cbiAgICB0aGlzLnJlYWRkaXIocCwgKGVyciwgZmlsZXM/KSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGNiKGVycik7XG4gICAgICB9IGVsc2UgaWYgKGZpbGVzIS5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNiKEFwaUVycm9yLkVOT1RFTVBUWShwKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJlbW92ZUVudHJ5KHAsIHRydWUsIGNiKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyBta2RpcihwOiBzdHJpbmcsIG1vZGU6IG51bWJlciwgY2I6IEJGU09uZUFyZ0NhbGxiYWNrKTogdm9pZCB7XG4gICAgY29uc3QgdHggPSB0aGlzLnN0b3JlLmJlZ2luVHJhbnNhY3Rpb24oJ3JlYWR3cml0ZScpLFxuICAgICAgZGF0YSA9IEJ1ZmZlci5mcm9tKCd7fScpO1xuICAgIHRoaXMuY29tbWl0TmV3RmlsZSh0eCwgcCwgRmlsZVR5cGUuRElSRUNUT1JZLCBtb2RlLCBkYXRhLCBjYik7XG4gIH1cblxuICBwdWJsaWMgcmVhZGRpcihwOiBzdHJpbmcsIGNiOiBCRlNDYWxsYmFjazxzdHJpbmdbXT4pOiB2b2lkIHtcbiAgICBjb25zdCB0eCA9IHRoaXMuc3RvcmUuYmVnaW5UcmFuc2FjdGlvbigncmVhZG9ubHknKTtcbiAgICB0aGlzLmZpbmRJTm9kZSh0eCwgcCwgKGU6IEFwaUVycm9yLCBpbm9kZT86IElub2RlKSA9PiB7XG4gICAgICBpZiAobm9FcnJvcihlLCBjYikpIHtcbiAgICAgICAgdGhpcy5nZXREaXJMaXN0aW5nKHR4LCBwLCBpbm9kZSEsIChlOiBBcGlFcnJvciwgZGlyTGlzdGluZz86IHtbbmFtZTogc3RyaW5nXTogc3RyaW5nfSkgPT4ge1xuICAgICAgICAgIGlmIChub0Vycm9yKGUsIGNiKSkge1xuICAgICAgICAgICAgY2IobnVsbCwgT2JqZWN0LmtleXMoZGlyTGlzdGluZykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBwdWJsaWMgX3N5bmMocDogc3RyaW5nLCBkYXRhOiBCdWZmZXIsIHN0YXRzOiBTdGF0cywgY2I6IEJGU09uZUFyZ0NhbGxiYWNrKTogdm9pZCB7XG4gICAgLy8gQHRvZG8gRW5zdXJlIG10aW1lIHVwZGF0ZXMgcHJvcGVybHksIGFuZCB1c2UgdGhhdCB0byBkZXRlcm1pbmUgaWYgYSBkYXRhXG4gICAgLy8gICAgICAgdXBkYXRlIGlzIHJlcXVpcmVkLlxuICAgIGNvbnN0IHR4ID0gdGhpcy5zdG9yZS5iZWdpblRyYW5zYWN0aW9uKCdyZWFkd3JpdGUnKTtcbiAgICAvLyBTdGVwIDE6IEdldCB0aGUgZmlsZSBub2RlJ3MgSUQuXG4gICAgdGhpcy5fZmluZElOb2RlKHR4LCBwYXRoLmRpcm5hbWUocCksIHBhdGguYmFzZW5hbWUocCksIChlOiBBcGlFcnJvciwgZmlsZUlub2RlSWQ/OiBzdHJpbmcpOiB2b2lkID0+IHtcbiAgICAgIGlmIChub0Vycm9yVHgoZSwgdHgsIGNiKSkge1xuICAgICAgICAvLyBTdGVwIDI6IEdldCB0aGUgZmlsZSBpbm9kZS5cbiAgICAgICAgdGhpcy5nZXRJTm9kZSh0eCwgcCwgZmlsZUlub2RlSWQhLCAoZTogQXBpRXJyb3IsIGZpbGVJbm9kZT86IElub2RlKTogdm9pZCA9PiB7XG4gICAgICAgICAgaWYgKG5vRXJyb3JUeChlLCB0eCwgY2IpKSB7XG4gICAgICAgICAgICBjb25zdCBpbm9kZUNoYW5nZWQ6IGJvb2xlYW4gPSBmaWxlSW5vZGUhLnVwZGF0ZShzdGF0cyk7XG4gICAgICAgICAgICAvLyBTdGVwIDM6IFN5bmMgdGhlIGRhdGEuXG4gICAgICAgICAgICB0eC5wdXQoZmlsZUlub2RlIS5pZCwgZGF0YSwgdHJ1ZSwgKGU6IEFwaUVycm9yKTogdm9pZCA9PiB7XG4gICAgICAgICAgICAgIGlmIChub0Vycm9yVHgoZSwgdHgsIGNiKSkge1xuICAgICAgICAgICAgICAgIC8vIFN0ZXAgNDogU3luYyB0aGUgbWV0YWRhdGEgKGlmIGl0IGNoYW5nZWQpIVxuICAgICAgICAgICAgICAgIGlmIChpbm9kZUNoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICAgIHR4LnB1dChmaWxlSW5vZGVJZCEsIGZpbGVJbm9kZSEudG9CdWZmZXIoKSwgdHJ1ZSwgKGU6IEFwaUVycm9yKTogdm9pZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub0Vycm9yVHgoZSwgdHgsIGNiKSkge1xuICAgICAgICAgICAgICAgICAgICAgIHR4LmNvbW1pdChjYik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAvLyBObyBuZWVkIHRvIHN5bmMgbWV0YWRhdGE7IHJldHVybi5cbiAgICAgICAgICAgICAgICAgIHR4LmNvbW1pdChjYik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgcm9vdCBkaXJlY3RvcnkgZXhpc3RzLiBDcmVhdGVzIGl0IGlmIGl0IGRvZXNuJ3QuXG4gICAqL1xuICBwcml2YXRlIG1ha2VSb290RGlyZWN0b3J5KGNiOiBCRlNPbmVBcmdDYWxsYmFjaykge1xuICAgIGNvbnN0IHR4ID0gdGhpcy5zdG9yZS5iZWdpblRyYW5zYWN0aW9uKCdyZWFkd3JpdGUnKTtcbiAgICB0eC5nZXQoUk9PVF9OT0RFX0lELCAoZTogQXBpRXJyb3IsIGRhdGE/OiBCdWZmZXIpID0+IHtcbiAgICAgIGlmIChlIHx8IGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBDcmVhdGUgbmV3IGlub2RlLlxuICAgICAgICBjb25zdCBjdXJyVGltZSA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCksXG4gICAgICAgICAgLy8gTW9kZSAwNjY2XG4gICAgICAgICAgZGlySW5vZGUgPSBuZXcgSW5vZGUoR2VuZXJhdGVSYW5kb21JRCgpLCA0MDk2LCA1MTEgfCBGaWxlVHlwZS5ESVJFQ1RPUlksIGN1cnJUaW1lLCBjdXJyVGltZSwgY3VyclRpbWUpO1xuICAgICAgICAvLyBJZiB0aGUgcm9vdCBkb2Vzbid0IGV4aXN0LCB0aGUgZmlyc3QgcmFuZG9tIElEIHNob3VsZG4ndCBleGlzdCxcbiAgICAgICAgLy8gZWl0aGVyLlxuICAgICAgICB0eC5wdXQoZGlySW5vZGUuaWQsIGdldEVtcHR5RGlyTm9kZSgpLCBmYWxzZSwgKGU/OiBBcGlFcnJvcikgPT4ge1xuICAgICAgICAgIGlmIChub0Vycm9yVHgoZSwgdHgsIGNiKSkge1xuICAgICAgICAgICAgdHgucHV0KFJPT1RfTk9ERV9JRCwgZGlySW5vZGUudG9CdWZmZXIoKSwgZmFsc2UsIChlPzogQXBpRXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgICAgICB0eC5hYm9ydCgoKSA9PiB7IGNiKGUpOyB9KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0eC5jb21taXQoY2IpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gV2UncmUgZ29vZC5cbiAgICAgICAgdHguY29tbWl0KGNiKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIZWxwZXIgZnVuY3Rpb24gZm9yIGZpbmRJTm9kZS5cbiAgICogQHBhcmFtIHBhcmVudCBUaGUgcGFyZW50IGRpcmVjdG9yeSBvZiB0aGUgZmlsZSB3ZSBhcmUgYXR0ZW1wdGluZyB0byBmaW5kLlxuICAgKiBAcGFyYW0gZmlsZW5hbWUgVGhlIGZpbGVuYW1lIG9mIHRoZSBpbm9kZSB3ZSBhcmUgYXR0ZW1wdGluZyB0byBmaW5kLCBtaW51c1xuICAgKiAgIHRoZSBwYXJlbnQuXG4gICAqIEBwYXJhbSBjYiBQYXNzZWQgYW4gZXJyb3Igb3IgdGhlIElEIG9mIHRoZSBmaWxlJ3MgaW5vZGUgaW4gdGhlIGZpbGUgc3lzdGVtLlxuICAgKi9cbiAgcHJpdmF0ZSBfZmluZElOb2RlKHR4OiBBc3luY0tleVZhbHVlUk9UcmFuc2FjdGlvbiwgcGFyZW50OiBzdHJpbmcsIGZpbGVuYW1lOiBzdHJpbmcsIGNiOiBCRlNDYWxsYmFjazxzdHJpbmc+KTogdm9pZCB7XG4gICAgY29uc3QgaGFuZGxlRGlyZWN0b3J5TGlzdGluZ3MgPSAoZT86IEFwaUVycm9yIHwgbnVsbCwgaW5vZGU/OiBJbm9kZSwgZGlyTGlzdD86IHtbbmFtZTogc3RyaW5nXTogc3RyaW5nfSk6IHZvaWQgPT4ge1xuICAgICAgaWYgKGUpIHtcbiAgICAgICAgY2IoZSk7XG4gICAgICB9IGVsc2UgaWYgKGRpckxpc3QhW2ZpbGVuYW1lXSkge1xuICAgICAgICBjYihudWxsLCBkaXJMaXN0IVtmaWxlbmFtZV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2IoQXBpRXJyb3IuRU5PRU5UKHBhdGgucmVzb2x2ZShwYXJlbnQsIGZpbGVuYW1lKSkpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAocGFyZW50ID09PSAnLycpIHtcbiAgICAgIGlmIChmaWxlbmFtZSA9PT0gJycpIHtcbiAgICAgICAgLy8gQkFTRSBDQVNFICMxOiBSZXR1cm4gdGhlIHJvb3QncyBJRC5cbiAgICAgICAgY2IobnVsbCwgUk9PVF9OT0RFX0lEKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEJBU0UgQ0FTRSAjMjogRmluZCB0aGUgaXRlbSBpbiB0aGUgcm9vdCBub2RlLlxuICAgICAgICB0aGlzLmdldElOb2RlKHR4LCBwYXJlbnQsIFJPT1RfTk9ERV9JRCwgKGU6IEFwaUVycm9yLCBpbm9kZT86IElub2RlKTogdm9pZCA9PiB7XG4gICAgICAgICAgaWYgKG5vRXJyb3IoZSwgY2IpKSB7XG4gICAgICAgICAgICB0aGlzLmdldERpckxpc3RpbmcodHgsIHBhcmVudCwgaW5vZGUhLCAoZTogQXBpRXJyb3IsIGRpckxpc3Q/OiB7W25hbWU6IHN0cmluZ106IHN0cmluZ30pOiB2b2lkID0+IHtcbiAgICAgICAgICAgICAgLy8gaGFuZGxlX2RpcmVjdG9yeV9saXN0aW5ncyB3aWxsIGhhbmRsZSBlIGZvciB1cy5cbiAgICAgICAgICAgICAgaGFuZGxlRGlyZWN0b3J5TGlzdGluZ3MoZSwgaW5vZGUsIGRpckxpc3QpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gR2V0IHRoZSBwYXJlbnQgZGlyZWN0b3J5J3MgSU5vZGUsIGFuZCBmaW5kIHRoZSBmaWxlIGluIGl0cyBkaXJlY3RvcnlcbiAgICAgIC8vIGxpc3RpbmcuXG4gICAgICB0aGlzLmZpbmRJTm9kZUFuZERpckxpc3RpbmcodHgsIHBhcmVudCwgaGFuZGxlRGlyZWN0b3J5TGlzdGluZ3MpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kcyB0aGUgSW5vZGUgb2YgdGhlIGdpdmVuIHBhdGguXG4gICAqIEBwYXJhbSBwIFRoZSBwYXRoIHRvIGxvb2sgdXAuXG4gICAqIEBwYXJhbSBjYiBQYXNzZWQgYW4gZXJyb3Igb3IgdGhlIElub2RlIG9mIHRoZSBwYXRoIHAuXG4gICAqIEB0b2RvIG1lbW9pemUvY2FjaGVcbiAgICovXG4gIHByaXZhdGUgZmluZElOb2RlKHR4OiBBc3luY0tleVZhbHVlUk9UcmFuc2FjdGlvbiwgcDogc3RyaW5nLCBjYjogQkZTQ2FsbGJhY2s8SW5vZGU+KTogdm9pZCB7XG4gICAgdGhpcy5fZmluZElOb2RlKHR4LCBwYXRoLmRpcm5hbWUocCksIHBhdGguYmFzZW5hbWUocCksIChlOiBBcGlFcnJvciwgaWQ/OiBzdHJpbmcpOiB2b2lkID0+IHtcbiAgICAgIGlmIChub0Vycm9yKGUsIGNiKSkge1xuICAgICAgICB0aGlzLmdldElOb2RlKHR4LCBwLCBpZCEsIGNiKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHaXZlbiB0aGUgSUQgb2YgYSBub2RlLCByZXRyaWV2ZXMgdGhlIGNvcnJlc3BvbmRpbmcgSW5vZGUuXG4gICAqIEBwYXJhbSB0eCBUaGUgdHJhbnNhY3Rpb24gdG8gdXNlLlxuICAgKiBAcGFyYW0gcCBUaGUgY29ycmVzcG9uZGluZyBwYXRoIHRvIHRoZSBmaWxlICh1c2VkIGZvciBlcnJvciBtZXNzYWdlcykuXG4gICAqIEBwYXJhbSBpZCBUaGUgSUQgdG8gbG9vayB1cC5cbiAgICogQHBhcmFtIGNiIFBhc3NlZCBhbiBlcnJvciBvciB0aGUgaW5vZGUgdW5kZXIgdGhlIGdpdmVuIGlkLlxuICAgKi9cbiAgcHJpdmF0ZSBnZXRJTm9kZSh0eDogQXN5bmNLZXlWYWx1ZVJPVHJhbnNhY3Rpb24sIHA6IHN0cmluZywgaWQ6IHN0cmluZywgY2I6IEJGU0NhbGxiYWNrPElub2RlPik6IHZvaWQge1xuICAgIHR4LmdldChpZCwgKGU6IEFwaUVycm9yLCBkYXRhPzogQnVmZmVyKTogdm9pZCA9PiB7XG4gICAgICBpZiAobm9FcnJvcihlLCBjYikpIHtcbiAgICAgICAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGNiKEFwaUVycm9yLkVOT0VOVChwKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2IobnVsbCwgSW5vZGUuZnJvbUJ1ZmZlcihkYXRhKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHaXZlbiB0aGUgSW5vZGUgb2YgYSBkaXJlY3RvcnksIHJldHJpZXZlcyB0aGUgY29ycmVzcG9uZGluZyBkaXJlY3RvcnlcbiAgICogbGlzdGluZy5cbiAgICovXG4gIHByaXZhdGUgZ2V0RGlyTGlzdGluZyh0eDogQXN5bmNLZXlWYWx1ZVJPVHJhbnNhY3Rpb24sIHA6IHN0cmluZywgaW5vZGU6IElub2RlLCBjYjogQkZTQ2FsbGJhY2s8eyBbZmlsZU5hbWU6IHN0cmluZ106IHN0cmluZyB9Pik6IHZvaWQge1xuICAgIGlmICghaW5vZGUuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgY2IoQXBpRXJyb3IuRU5PVERJUihwKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHR4LmdldChpbm9kZS5pZCwgKGU6IEFwaUVycm9yLCBkYXRhPzogQnVmZmVyKTogdm9pZCA9PiB7XG4gICAgICAgIGlmIChub0Vycm9yKGUsIGNiKSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjYihudWxsLCBKU09OLnBhcnNlKGRhdGEhLnRvU3RyaW5nKCkpKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBPY2N1cnMgd2hlbiBkYXRhIGlzIHVuZGVmaW5lZCwgb3IgY29ycmVzcG9uZHMgdG8gc29tZXRoaW5nIG90aGVyXG4gICAgICAgICAgICAvLyB0aGFuIGEgZGlyZWN0b3J5IGxpc3RpbmcuIFRoZSBsYXR0ZXIgc2hvdWxkIG5ldmVyIG9jY3VyIHVubGVzc1xuICAgICAgICAgICAgLy8gdGhlIGZpbGUgc3lzdGVtIGlzIGNvcnJ1cHRlZC5cbiAgICAgICAgICAgIGNiKEFwaUVycm9yLkVOT0VOVChwKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2l2ZW4gYSBwYXRoIHRvIGEgZGlyZWN0b3J5LCByZXRyaWV2ZXMgdGhlIGNvcnJlc3BvbmRpbmcgSU5vZGUgYW5kXG4gICAqIGRpcmVjdG9yeSBsaXN0aW5nLlxuICAgKi9cbiAgcHJpdmF0ZSBmaW5kSU5vZGVBbmREaXJMaXN0aW5nKHR4OiBBc3luY0tleVZhbHVlUk9UcmFuc2FjdGlvbiwgcDogc3RyaW5nLCBjYjogQkZTVGhyZWVBcmdDYWxsYmFjazxJbm9kZSwgeyBbZmlsZU5hbWU6IHN0cmluZ106IHN0cmluZyB9Pik6IHZvaWQge1xuICAgIHRoaXMuZmluZElOb2RlKHR4LCBwLCAoZTogQXBpRXJyb3IsIGlub2RlPzogSW5vZGUpOiB2b2lkID0+IHtcbiAgICAgIGlmIChub0Vycm9yKGUsIGNiKSkge1xuICAgICAgICB0aGlzLmdldERpckxpc3RpbmcodHgsIHAsIGlub2RlISwgKGUsIGxpc3Rpbmc/KSA9PiB7XG4gICAgICAgICAgaWYgKG5vRXJyb3IoZSwgY2IpKSB7XG4gICAgICAgICAgICBjYihudWxsLCBpbm9kZSEsIGxpc3RpbmchKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBuZXcgbm9kZSB1bmRlciBhIHJhbmRvbSBJRC4gUmV0cmllcyA1IHRpbWVzIGJlZm9yZSBnaXZpbmcgdXAgaW5cbiAgICogdGhlIGV4Y2VlZGluZ2x5IHVubGlrZWx5IGNoYW5jZSB0aGF0IHdlIHRyeSB0byByZXVzZSBhIHJhbmRvbSBHVUlELlxuICAgKiBAcGFyYW0gY2IgUGFzc2VkIGFuIGVycm9yIG9yIHRoZSBHVUlEIHRoYXQgdGhlIGRhdGEgd2FzIHN0b3JlZCB1bmRlci5cbiAgICovXG4gIHByaXZhdGUgYWRkTmV3Tm9kZSh0eDogQXN5bmNLZXlWYWx1ZVJXVHJhbnNhY3Rpb24sIGRhdGE6IEJ1ZmZlciwgY2I6IEJGU0NhbGxiYWNrPHN0cmluZz4pOiB2b2lkIHtcbiAgICBsZXQgcmV0cmllcyA9IDAsIGN1cnJJZDogc3RyaW5nO1xuICAgIGNvbnN0IHJlcm9sbCA9ICgpID0+IHtcbiAgICAgIGlmICgrK3JldHJpZXMgPT09IDUpIHtcbiAgICAgICAgLy8gTWF4IHJldHJpZXMgaGl0LiBSZXR1cm4gd2l0aCBhbiBlcnJvci5cbiAgICAgICAgY2IobmV3IEFwaUVycm9yKEVycm9yQ29kZS5FSU8sICdVbmFibGUgdG8gY29tbWl0IGRhdGEgdG8ga2V5LXZhbHVlIHN0b3JlLicpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRyeSBhZ2Fpbi5cbiAgICAgICAgY3VycklkID0gR2VuZXJhdGVSYW5kb21JRCgpO1xuICAgICAgICB0eC5wdXQoY3VycklkLCBkYXRhLCBmYWxzZSwgKGU6IEFwaUVycm9yLCBjb21taXR0ZWQ/OiBib29sZWFuKSA9PiB7XG4gICAgICAgICAgaWYgKGUgfHwgIWNvbW1pdHRlZCkge1xuICAgICAgICAgICAgcmVyb2xsKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFN1Y2Nlc3NmdWxseSBzdG9yZWQgdW5kZXIgJ2N1cnJJZCcuXG4gICAgICAgICAgICBjYihudWxsLCBjdXJySWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICByZXJvbGwoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21taXRzIGEgbmV3IGZpbGUgKHdlbGwsIGEgRklMRSBvciBhIERJUkVDVE9SWSkgdG8gdGhlIGZpbGUgc3lzdGVtIHdpdGhcbiAgICogdGhlIGdpdmVuIG1vZGUuXG4gICAqIE5vdGU6IFRoaXMgd2lsbCBjb21taXQgdGhlIHRyYW5zYWN0aW9uLlxuICAgKiBAcGFyYW0gcCBUaGUgcGF0aCB0byB0aGUgbmV3IGZpbGUuXG4gICAqIEBwYXJhbSB0eXBlIFRoZSB0eXBlIG9mIHRoZSBuZXcgZmlsZS5cbiAgICogQHBhcmFtIG1vZGUgVGhlIG1vZGUgdG8gY3JlYXRlIHRoZSBuZXcgZmlsZSB3aXRoLlxuICAgKiBAcGFyYW0gZGF0YSBUaGUgZGF0YSB0byBzdG9yZSBhdCB0aGUgZmlsZSdzIGRhdGEgbm9kZS5cbiAgICogQHBhcmFtIGNiIFBhc3NlZCBhbiBlcnJvciBvciB0aGUgSW5vZGUgZm9yIHRoZSBuZXcgZmlsZS5cbiAgICovXG4gIHByaXZhdGUgY29tbWl0TmV3RmlsZSh0eDogQXN5bmNLZXlWYWx1ZVJXVHJhbnNhY3Rpb24sIHA6IHN0cmluZywgdHlwZTogRmlsZVR5cGUsIG1vZGU6IG51bWJlciwgZGF0YTogQnVmZmVyLCBjYjogQkZTQ2FsbGJhY2s8SW5vZGU+KTogdm9pZCB7XG4gICAgY29uc3QgcGFyZW50RGlyID0gcGF0aC5kaXJuYW1lKHApLFxuICAgICAgZm5hbWUgPSBwYXRoLmJhc2VuYW1lKHApLFxuICAgICAgY3VyclRpbWUgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuXG4gICAgLy8gSW52YXJpYW50OiBUaGUgcm9vdCBhbHdheXMgZXhpc3RzLlxuICAgIC8vIElmIHdlIGRvbid0IGNoZWNrIHRoaXMgcHJpb3IgdG8gdGFraW5nIHN0ZXBzIGJlbG93LCB3ZSB3aWxsIGNyZWF0ZSBhXG4gICAgLy8gZmlsZSB3aXRoIG5hbWUgJycgaW4gcm9vdCBzaG91bGQgcCA9PSAnLycuXG4gICAgaWYgKHAgPT09ICcvJykge1xuICAgICAgcmV0dXJuIGNiKEFwaUVycm9yLkVFWElTVChwKSk7XG4gICAgfVxuXG4gICAgLy8gTGV0J3MgYnVpbGQgYSBweXJhbWlkIG9mIGNvZGUhXG5cbiAgICAvLyBTdGVwIDE6IEdldCB0aGUgcGFyZW50IGRpcmVjdG9yeSdzIGlub2RlIGFuZCBkaXJlY3RvcnkgbGlzdGluZ1xuICAgIHRoaXMuZmluZElOb2RlQW5kRGlyTGlzdGluZyh0eCwgcGFyZW50RGlyLCAoZT86IEFwaUVycm9yIHwgbnVsbCwgcGFyZW50Tm9kZT86IElub2RlLCBkaXJMaXN0aW5nPzoge1tuYW1lOiBzdHJpbmddOiBzdHJpbmd9KTogdm9pZCA9PiB7XG4gICAgICBpZiAobm9FcnJvclR4KGUsIHR4LCBjYikpIHtcbiAgICAgICAgaWYgKGRpckxpc3RpbmchW2ZuYW1lXSkge1xuICAgICAgICAgIC8vIEZpbGUgYWxyZWFkeSBleGlzdHMuXG4gICAgICAgICAgdHguYWJvcnQoKCkgPT4ge1xuICAgICAgICAgICAgY2IoQXBpRXJyb3IuRUVYSVNUKHApKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBTdGVwIDI6IENvbW1pdCBkYXRhIHRvIHN0b3JlLlxuICAgICAgICAgIHRoaXMuYWRkTmV3Tm9kZSh0eCwgZGF0YSwgKGU6IEFwaUVycm9yLCBkYXRhSWQ/OiBzdHJpbmcpOiB2b2lkID0+IHtcbiAgICAgICAgICAgIGlmIChub0Vycm9yVHgoZSwgdHgsIGNiKSkge1xuICAgICAgICAgICAgICAvLyBTdGVwIDM6IENvbW1pdCB0aGUgZmlsZSdzIGlub2RlIHRvIHRoZSBzdG9yZS5cbiAgICAgICAgICAgICAgY29uc3QgZmlsZUlub2RlID0gbmV3IElub2RlKGRhdGFJZCEsIGRhdGEubGVuZ3RoLCBtb2RlIHwgdHlwZSwgY3VyclRpbWUsIGN1cnJUaW1lLCBjdXJyVGltZSk7XG4gICAgICAgICAgICAgIHRoaXMuYWRkTmV3Tm9kZSh0eCwgZmlsZUlub2RlLnRvQnVmZmVyKCksIChlOiBBcGlFcnJvciwgZmlsZUlub2RlSWQ/OiBzdHJpbmcpOiB2b2lkID0+IHtcbiAgICAgICAgICAgICAgICBpZiAobm9FcnJvclR4KGUsIHR4LCBjYikpIHtcbiAgICAgICAgICAgICAgICAgIC8vIFN0ZXAgNDogVXBkYXRlIHBhcmVudCBkaXJlY3RvcnkncyBsaXN0aW5nLlxuICAgICAgICAgICAgICAgICAgZGlyTGlzdGluZyFbZm5hbWVdID0gZmlsZUlub2RlSWQhO1xuICAgICAgICAgICAgICAgICAgdHgucHV0KHBhcmVudE5vZGUhLmlkLCBCdWZmZXIuZnJvbShKU09OLnN0cmluZ2lmeShkaXJMaXN0aW5nKSksIHRydWUsIChlOiBBcGlFcnJvcik6IHZvaWQgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9FcnJvclR4KGUsIHR4LCBjYikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBTdGVwIDU6IENvbW1pdCBhbmQgcmV0dXJuIHRoZSBuZXcgaW5vZGUuXG4gICAgICAgICAgICAgICAgICAgICAgdHguY29tbWl0KChlPzogQXBpRXJyb3IpOiB2b2lkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub0Vycm9yVHgoZSwgdHgsIGNiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjYihudWxsLCBmaWxlSW5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGFsbCB0cmFjZXMgb2YgdGhlIGdpdmVuIHBhdGggZnJvbSB0aGUgZmlsZSBzeXN0ZW0uXG4gICAqIEBwYXJhbSBwIFRoZSBwYXRoIHRvIHJlbW92ZSBmcm9tIHRoZSBmaWxlIHN5c3RlbS5cbiAgICogQHBhcmFtIGlzRGlyIERvZXMgdGhlIHBhdGggYmVsb25nIHRvIGEgZGlyZWN0b3J5LCBvciBhIGZpbGU/XG4gICAqIEB0b2RvIFVwZGF0ZSBtdGltZS5cbiAgICovXG4gIHByaXZhdGUgcmVtb3ZlRW50cnkocDogc3RyaW5nLCBpc0RpcjogYm9vbGVhbiwgY2I6IEJGU09uZUFyZ0NhbGxiYWNrKTogdm9pZCB7XG4gICAgY29uc3QgdHggPSB0aGlzLnN0b3JlLmJlZ2luVHJhbnNhY3Rpb24oJ3JlYWR3cml0ZScpLFxuICAgICAgcGFyZW50OiBzdHJpbmcgPSBwYXRoLmRpcm5hbWUocCksIGZpbGVOYW1lOiBzdHJpbmcgPSBwYXRoLmJhc2VuYW1lKHApO1xuICAgIC8vIFN0ZXAgMTogR2V0IHBhcmVudCBkaXJlY3RvcnkncyBub2RlIGFuZCBkaXJlY3RvcnkgbGlzdGluZy5cbiAgICB0aGlzLmZpbmRJTm9kZUFuZERpckxpc3RpbmcodHgsIHBhcmVudCwgKGU/OiBBcGlFcnJvciB8IG51bGwsIHBhcmVudE5vZGU/OiBJbm9kZSwgcGFyZW50TGlzdGluZz86IHtbbmFtZTogc3RyaW5nXTogc3RyaW5nfSk6IHZvaWQgPT4ge1xuICAgICAgaWYgKG5vRXJyb3JUeChlLCB0eCwgY2IpKSB7XG4gICAgICAgIGlmICghcGFyZW50TGlzdGluZyFbZmlsZU5hbWVdKSB7XG4gICAgICAgICAgdHguYWJvcnQoKCkgPT4ge1xuICAgICAgICAgICAgY2IoQXBpRXJyb3IuRU5PRU5UKHApKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBSZW1vdmUgZnJvbSBkaXJlY3RvcnkgbGlzdGluZyBvZiBwYXJlbnQuXG4gICAgICAgICAgY29uc3QgZmlsZU5vZGVJZCA9IHBhcmVudExpc3RpbmchW2ZpbGVOYW1lXTtcbiAgICAgICAgICBkZWxldGUgcGFyZW50TGlzdGluZyFbZmlsZU5hbWVdO1xuICAgICAgICAgIC8vIFN0ZXAgMjogR2V0IGZpbGUgaW5vZGUuXG4gICAgICAgICAgdGhpcy5nZXRJTm9kZSh0eCwgcCwgZmlsZU5vZGVJZCwgKGU6IEFwaUVycm9yLCBmaWxlTm9kZT86IElub2RlKTogdm9pZCA9PiB7XG4gICAgICAgICAgICBpZiAobm9FcnJvclR4KGUsIHR4LCBjYikpIHtcbiAgICAgICAgICAgICAgaWYgKCFpc0RpciAmJiBmaWxlTm9kZSEuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgICAgICAgICAgIHR4LmFib3J0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgIGNiKEFwaUVycm9yLkVJU0RJUihwKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNEaXIgJiYgIWZpbGVOb2RlIS5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICAgICAgICAgICAgdHguYWJvcnQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgY2IoQXBpRXJyb3IuRU5PVERJUihwKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gU3RlcCAzOiBEZWxldGUgZGF0YS5cbiAgICAgICAgICAgICAgICB0eC5kZWwoZmlsZU5vZGUhLmlkLCAoZT86IEFwaUVycm9yKTogdm9pZCA9PiB7XG4gICAgICAgICAgICAgICAgICBpZiAobm9FcnJvclR4KGUsIHR4LCBjYikpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU3RlcCA0OiBEZWxldGUgbm9kZS5cbiAgICAgICAgICAgICAgICAgICAgdHguZGVsKGZpbGVOb2RlSWQsIChlPzogQXBpRXJyb3IpOiB2b2lkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAobm9FcnJvclR4KGUsIHR4LCBjYikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN0ZXAgNTogVXBkYXRlIGRpcmVjdG9yeSBsaXN0aW5nLlxuICAgICAgICAgICAgICAgICAgICAgICAgdHgucHV0KHBhcmVudE5vZGUhLmlkLCBCdWZmZXIuZnJvbShKU09OLnN0cmluZ2lmeShwYXJlbnRMaXN0aW5nKSksIHRydWUsIChlOiBBcGlFcnJvcik6IHZvaWQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9FcnJvclR4KGUsIHR4LCBjYikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eC5jb21taXQoY2IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uLy4uLy4uLy4uL3NyYy9nZW5lcmljL2tleV92YWx1ZV9maWxlc3lzdGVtLnRzIiwiaW1wb3J0IHtCRlNDYWxsYmFjaywgRmlsZVN5c3RlbU9wdGlvbnN9IGZyb20gJy4uL2NvcmUvZmlsZV9zeXN0ZW0nO1xuaW1wb3J0IHtTeW5jS2V5VmFsdWVTdG9yZSwgU2ltcGxlU3luY1N0b3JlLCBTaW1wbGVTeW5jUldUcmFuc2FjdGlvbiwgU3luY0tleVZhbHVlUldUcmFuc2FjdGlvbiwgU3luY0tleVZhbHVlRmlsZVN5c3RlbX0gZnJvbSAnLi4vZ2VuZXJpYy9rZXlfdmFsdWVfZmlsZXN5c3RlbSc7XG5cbi8qKlxuICogQSBzaW1wbGUgaW4tbWVtb3J5IGtleS12YWx1ZSBzdG9yZSBiYWNrZWQgYnkgYSBKYXZhU2NyaXB0IG9iamVjdC5cbiAqL1xuZXhwb3J0IGNsYXNzIEluTWVtb3J5U3RvcmUgaW1wbGVtZW50cyBTeW5jS2V5VmFsdWVTdG9yZSwgU2ltcGxlU3luY1N0b3JlIHtcbiAgcHJpdmF0ZSBzdG9yZTogeyBba2V5OiBzdHJpbmddOiBCdWZmZXIgfSA9IHt9O1xuXG4gIHB1YmxpYyBuYW1lKCkgeyByZXR1cm4gSW5NZW1vcnlGaWxlU3lzdGVtLk5hbWU7IH1cbiAgcHVibGljIGNsZWFyKCkgeyB0aGlzLnN0b3JlID0ge307IH1cblxuICBwdWJsaWMgYmVnaW5UcmFuc2FjdGlvbih0eXBlOiBzdHJpbmcpOiBTeW5jS2V5VmFsdWVSV1RyYW5zYWN0aW9uIHtcbiAgICByZXR1cm4gbmV3IFNpbXBsZVN5bmNSV1RyYW5zYWN0aW9uKHRoaXMpO1xuICB9XG5cbiAgcHVibGljIGdldChrZXk6IHN0cmluZyk6IEJ1ZmZlciB7XG4gICAgcmV0dXJuIHRoaXMuc3RvcmVba2V5XTtcbiAgfVxuXG4gIHB1YmxpYyBwdXQoa2V5OiBzdHJpbmcsIGRhdGE6IEJ1ZmZlciwgb3ZlcndyaXRlOiBib29sZWFuKTogYm9vbGVhbiB7XG4gICAgaWYgKCFvdmVyd3JpdGUgJiYgdGhpcy5zdG9yZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuc3RvcmVba2V5XSA9IGRhdGE7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBwdWJsaWMgZGVsKGtleTogc3RyaW5nKTogdm9pZCB7XG4gICAgZGVsZXRlIHRoaXMuc3RvcmVba2V5XTtcbiAgfVxufVxuXG4vKipcbiAqIEEgc2ltcGxlIGluLW1lbW9yeSBmaWxlIHN5c3RlbSBiYWNrZWQgYnkgYW4gSW5NZW1vcnlTdG9yZS5cbiAqIEZpbGVzIGFyZSBub3QgcGVyc2lzdGVkIGFjcm9zcyBwYWdlIGxvYWRzLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJbk1lbW9yeUZpbGVTeXN0ZW0gZXh0ZW5kcyBTeW5jS2V5VmFsdWVGaWxlU3lzdGVtIHtcbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBOYW1lID0gXCJJbk1lbW9yeVwiO1xuXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgT3B0aW9uczogRmlsZVN5c3RlbU9wdGlvbnMgPSB7fTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBJbk1lbW9yeUZpbGVTeXN0ZW0gaW5zdGFuY2UuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIENyZWF0ZShvcHRpb25zOiBhbnksIGNiOiBCRlNDYWxsYmFjazxJbk1lbW9yeUZpbGVTeXN0ZW0+KTogdm9pZCB7XG4gICAgY2IobnVsbCwgbmV3IEluTWVtb3J5RmlsZVN5c3RlbSgpKTtcbiAgfVxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcih7IHN0b3JlOiBuZXcgSW5NZW1vcnlTdG9yZSgpIH0pO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vLi4vLi4vLi4vc3JjL2JhY2tlbmQvSW5NZW1vcnkudHMiLCJpbXBvcnQge0JGU09uZUFyZ0NhbGxiYWNrLCBCRlNDYWxsYmFjaywgRmlsZVN5c3RlbU9wdGlvbnN9IGZyb20gJy4uL2NvcmUvZmlsZV9zeXN0ZW0nO1xuaW1wb3J0IHtBc3luY0tleVZhbHVlUk9UcmFuc2FjdGlvbiwgQXN5bmNLZXlWYWx1ZVJXVHJhbnNhY3Rpb24sIEFzeW5jS2V5VmFsdWVTdG9yZSwgQXN5bmNLZXlWYWx1ZUZpbGVTeXN0ZW19IGZyb20gJy4uL2dlbmVyaWMva2V5X3ZhbHVlX2ZpbGVzeXN0ZW0nO1xuaW1wb3J0IHtBcGlFcnJvciwgRXJyb3JDb2RlfSBmcm9tICcuLi9jb3JlL2FwaV9lcnJvcic7XG5pbXBvcnQgZ2xvYmFsIGZyb20gJy4uL2NvcmUvZ2xvYmFsJztcbmltcG9ydCB7YXJyYXlCdWZmZXIyQnVmZmVyLCBidWZmZXIyQXJyYXlCdWZmZXIsIGRlcHJlY2F0aW9uTWVzc2FnZX0gZnJvbSAnLi4vY29yZS91dGlsJztcbi8qKlxuICogR2V0IHRoZSBpbmRleGVkREIgY29uc3RydWN0b3IgZm9yIHRoZSBjdXJyZW50IGJyb3dzZXIuXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGluZGV4ZWREQjogSURCRmFjdG9yeSA9IGdsb2JhbC5pbmRleGVkREIgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKDxhbnk+IGdsb2JhbCkubW96SW5kZXhlZERCIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICg8YW55PiBnbG9iYWwpLndlYmtpdEluZGV4ZWREQiB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICBnbG9iYWwubXNJbmRleGVkREI7XG5cbi8qKlxuICogQ29udmVydHMgYSBET01FeGNlcHRpb24gb3IgYSBET01FcnJvciBmcm9tIGFuIEluZGV4ZWREQiBldmVudCBpbnRvIGFcbiAqIHN0YW5kYXJkaXplZCBCcm93c2VyRlMgQVBJIGVycm9yLlxuICogQGhpZGRlblxuICovXG5mdW5jdGlvbiBjb252ZXJ0RXJyb3IoZToge25hbWU6IHN0cmluZ30sIG1lc3NhZ2U6IHN0cmluZyA9IGUudG9TdHJpbmcoKSk6IEFwaUVycm9yIHtcbiAgc3dpdGNoIChlLm5hbWUpIHtcbiAgICBjYXNlIFwiTm90Rm91bmRFcnJvclwiOlxuICAgICAgcmV0dXJuIG5ldyBBcGlFcnJvcihFcnJvckNvZGUuRU5PRU5ULCBtZXNzYWdlKTtcbiAgICBjYXNlIFwiUXVvdGFFeGNlZWRlZEVycm9yXCI6XG4gICAgICByZXR1cm4gbmV3IEFwaUVycm9yKEVycm9yQ29kZS5FTk9TUEMsIG1lc3NhZ2UpO1xuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBUaGUgcmVzdCBkbyBub3Qgc2VlbSB0byBtYXAgY2xlYW5seSB0byBzdGFuZGFyZCBlcnJvciBjb2Rlcy5cbiAgICAgIHJldHVybiBuZXcgQXBpRXJyb3IoRXJyb3JDb2RlLkVJTywgbWVzc2FnZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBQcm9kdWNlcyBhIG5ldyBvbmVycm9yIGhhbmRsZXIgZm9yIElEQi4gT3VyIGVycm9ycyBhcmUgYWx3YXlzIGZhdGFsLCBzbyB3ZVxuICogaGFuZGxlIHRoZW0gZ2VuZXJpY2FsbHk6IENhbGwgdGhlIHVzZXItc3VwcGxpZWQgY2FsbGJhY2sgd2l0aCBhIHRyYW5zbGF0ZWRcbiAqIHZlcnNpb24gb2YgdGhlIGVycm9yLCBhbmQgbGV0IHRoZSBlcnJvciBidWJibGUgdXAuXG4gKiBAaGlkZGVuXG4gKi9cbmZ1bmN0aW9uIG9uRXJyb3JIYW5kbGVyKGNiOiAoZTogQXBpRXJyb3IpID0+IHZvaWQsIGNvZGU6IEVycm9yQ29kZSA9IEVycm9yQ29kZS5FSU8sIG1lc3NhZ2U6IHN0cmluZyB8IG51bGwgPSBudWxsKTogKGU/OiBhbnkpID0+IHZvaWQge1xuICByZXR1cm4gZnVuY3Rpb24oZT86IGFueSk6IHZvaWQge1xuICAgIC8vIFByZXZlbnQgdGhlIGVycm9yIGZyb20gY2FuY2VsaW5nIHRoZSB0cmFuc2FjdGlvbi5cbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgY2IobmV3IEFwaUVycm9yKGNvZGUsIG1lc3NhZ2UgIT09IG51bGwgPyBtZXNzYWdlIDogdW5kZWZpbmVkKSk7XG4gIH07XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5leHBvcnQgY2xhc3MgSW5kZXhlZERCUk9UcmFuc2FjdGlvbiBpbXBsZW1lbnRzIEFzeW5jS2V5VmFsdWVST1RyYW5zYWN0aW9uIHtcbiAgY29uc3RydWN0b3IocHVibGljIHR4OiBJREJUcmFuc2FjdGlvbiwgcHVibGljIHN0b3JlOiBJREJPYmplY3RTdG9yZSkgeyB9XG5cbiAgcHVibGljIGdldChrZXk6IHN0cmluZywgY2I6IEJGU0NhbGxiYWNrPEJ1ZmZlcj4pOiB2b2lkIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcjogSURCUmVxdWVzdCA9IHRoaXMuc3RvcmUuZ2V0KGtleSk7XG4gICAgICByLm9uZXJyb3IgPSBvbkVycm9ySGFuZGxlcihjYik7XG4gICAgICByLm9uc3VjY2VzcyA9IChldmVudCkgPT4ge1xuICAgICAgICAvLyBJREIgcmV0dXJucyB0aGUgdmFsdWUgJ3VuZGVmaW5lZCcgd2hlbiB5b3UgdHJ5IHRvIGdldCBrZXlzIHRoYXRcbiAgICAgICAgLy8gZG9uJ3QgZXhpc3QuIFRoZSBjYWxsZXIgZXhwZWN0cyB0aGlzIGJlaGF2aW9yLlxuICAgICAgICBjb25zdCByZXN1bHQ6IGFueSA9ICg8YW55PiBldmVudC50YXJnZXQpLnJlc3VsdDtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY2IobnVsbCwgcmVzdWx0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBJREIgZGF0YSBpcyBzdG9yZWQgYXMgYW4gQXJyYXlCdWZmZXJcbiAgICAgICAgICBjYihudWxsLCBhcnJheUJ1ZmZlcjJCdWZmZXIocmVzdWx0KSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY2IoY29udmVydEVycm9yKGUpKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBjbGFzcyBJbmRleGVkREJSV1RyYW5zYWN0aW9uIGV4dGVuZHMgSW5kZXhlZERCUk9UcmFuc2FjdGlvbiBpbXBsZW1lbnRzIEFzeW5jS2V5VmFsdWVSV1RyYW5zYWN0aW9uLCBBc3luY0tleVZhbHVlUk9UcmFuc2FjdGlvbiB7XG4gIGNvbnN0cnVjdG9yKHR4OiBJREJUcmFuc2FjdGlvbiwgc3RvcmU6IElEQk9iamVjdFN0b3JlKSB7XG4gICAgc3VwZXIodHgsIHN0b3JlKTtcbiAgfVxuXG4gIHB1YmxpYyBwdXQoa2V5OiBzdHJpbmcsIGRhdGE6IEJ1ZmZlciwgb3ZlcndyaXRlOiBib29sZWFuLCBjYjogQkZTQ2FsbGJhY2s8Ym9vbGVhbj4pOiB2b2lkIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgYXJyYXlidWZmZXIgPSBidWZmZXIyQXJyYXlCdWZmZXIoZGF0YSk7XG4gICAgICBsZXQgcjogSURCUmVxdWVzdDtcbiAgICAgIGlmIChvdmVyd3JpdGUpIHtcbiAgICAgICAgciA9IHRoaXMuc3RvcmUucHV0KGFycmF5YnVmZmVyLCBrZXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gJ2FkZCcgd2lsbCBuZXZlciBvdmVyd3JpdGUgYW4gZXhpc3Rpbmcga2V5LlxuICAgICAgICByID0gdGhpcy5zdG9yZS5hZGQoYXJyYXlidWZmZXIsIGtleSk7XG4gICAgICB9XG4gICAgICAvLyBYWFg6IE5FRUQgVE8gUkVUVVJOIEZBTFNFIFdIRU4gQUREIEhBUyBBIEtFWSBDT05GTElDVC4gTk8gRVJST1IuXG4gICAgICByLm9uZXJyb3IgPSBvbkVycm9ySGFuZGxlcihjYik7XG4gICAgICByLm9uc3VjY2VzcyA9IChldmVudCkgPT4ge1xuICAgICAgICBjYihudWxsLCB0cnVlKTtcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY2IoY29udmVydEVycm9yKGUpKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgZGVsKGtleTogc3RyaW5nLCBjYjogQkZTT25lQXJnQ2FsbGJhY2spOiB2b2lkIHtcbiAgICB0cnkge1xuICAgICAgLy8gTk9URTogSUU4IGhhcyBhIGJ1ZyB3aXRoIGlkZW50aWZpZXJzIG5hbWVkICdkZWxldGUnIHVubGVzcyB1c2VkIGFzIGEgc3RyaW5nXG4gICAgICAvLyBsaWtlIHRoaXMuXG4gICAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNjQ3OTE1MlxuICAgICAgY29uc3QgcjogSURCUmVxdWVzdCA9IHRoaXMuc3RvcmVbJ2RlbGV0ZSddKGtleSk7XG4gICAgICByLm9uZXJyb3IgPSBvbkVycm9ySGFuZGxlcihjYik7XG4gICAgICByLm9uc3VjY2VzcyA9IChldmVudCkgPT4ge1xuICAgICAgICBjYigpO1xuICAgICAgfTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjYihjb252ZXJ0RXJyb3IoZSkpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBjb21taXQoY2I6IEJGU09uZUFyZ0NhbGxiYWNrKTogdm9pZCB7XG4gICAgLy8gUmV0dXJuIHRvIHRoZSBldmVudCBsb29wIHRvIGNvbW1pdCB0aGUgdHJhbnNhY3Rpb24uXG4gICAgc2V0VGltZW91dChjYiwgMCk7XG4gIH1cblxuICBwdWJsaWMgYWJvcnQoY2I6IEJGU09uZUFyZ0NhbGxiYWNrKTogdm9pZCB7XG4gICAgbGV0IF9lOiBBcGlFcnJvciB8IG51bGwgPSBudWxsO1xuICAgIHRyeSB7XG4gICAgICB0aGlzLnR4LmFib3J0KCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgX2UgPSBjb252ZXJ0RXJyb3IoZSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGNiKF9lKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEluZGV4ZWREQlN0b3JlIGltcGxlbWVudHMgQXN5bmNLZXlWYWx1ZVN0b3JlIHtcbiAgcHJpdmF0ZSBkYjogSURCRGF0YWJhc2U7XG5cbiAgY29uc3RydWN0b3IoY2I6IEJGU0NhbGxiYWNrPEluZGV4ZWREQlN0b3JlPiwgcHJpdmF0ZSBzdG9yZU5hbWU6IHN0cmluZyA9ICdicm93c2VyZnMnKSB7XG4gICAgY29uc3Qgb3BlblJlcTogSURCT3BlbkRCUmVxdWVzdCA9IGluZGV4ZWREQi5vcGVuKHRoaXMuc3RvcmVOYW1lLCAxKTtcblxuICAgIG9wZW5SZXEub251cGdyYWRlbmVlZGVkID0gKGV2ZW50KSA9PiB7XG4gICAgICBjb25zdCBkYjogSURCRGF0YWJhc2UgPSAoPGFueT4gZXZlbnQudGFyZ2V0KS5yZXN1bHQ7XG4gICAgICAvLyBIdWguIFRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbjsgd2UncmUgYXQgdmVyc2lvbiAxLiBXaHkgZG9lcyBhbm90aGVyXG4gICAgICAvLyBkYXRhYmFzZSBleGlzdD9cbiAgICAgIGlmIChkYi5vYmplY3RTdG9yZU5hbWVzLmNvbnRhaW5zKHRoaXMuc3RvcmVOYW1lKSkge1xuICAgICAgICBkYi5kZWxldGVPYmplY3RTdG9yZSh0aGlzLnN0b3JlTmFtZSk7XG4gICAgICB9XG4gICAgICBkYi5jcmVhdGVPYmplY3RTdG9yZSh0aGlzLnN0b3JlTmFtZSk7XG4gICAgfTtcblxuICAgIG9wZW5SZXEub25zdWNjZXNzID0gKGV2ZW50KSA9PiB7XG4gICAgICB0aGlzLmRiID0gKDxhbnk+IGV2ZW50LnRhcmdldCkucmVzdWx0O1xuICAgICAgY2IobnVsbCwgdGhpcyk7XG4gICAgfTtcblxuICAgIG9wZW5SZXEub25lcnJvciA9IG9uRXJyb3JIYW5kbGVyKGNiLCBFcnJvckNvZGUuRUFDQ0VTKTtcbiAgfVxuXG4gIHB1YmxpYyBuYW1lKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIEluZGV4ZWREQkZpbGVTeXN0ZW0uTmFtZSArIFwiIC0gXCIgKyB0aGlzLnN0b3JlTmFtZTtcbiAgfVxuXG4gIHB1YmxpYyBjbGVhcihjYjogQkZTT25lQXJnQ2FsbGJhY2spOiB2b2lkIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgdHggPSB0aGlzLmRiLnRyYW5zYWN0aW9uKHRoaXMuc3RvcmVOYW1lLCAncmVhZHdyaXRlJyksXG4gICAgICAgIG9iamVjdFN0b3JlID0gdHgub2JqZWN0U3RvcmUodGhpcy5zdG9yZU5hbWUpLFxuICAgICAgICByOiBJREJSZXF1ZXN0ID0gb2JqZWN0U3RvcmUuY2xlYXIoKTtcbiAgICAgIHIub25zdWNjZXNzID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIC8vIFVzZSBzZXRUaW1lb3V0IHRvIGNvbW1pdCB0cmFuc2FjdGlvbi5cbiAgICAgICAgc2V0VGltZW91dChjYiwgMCk7XG4gICAgICB9O1xuICAgICAgci5vbmVycm9yID0gb25FcnJvckhhbmRsZXIoY2IpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNiKGNvbnZlcnRFcnJvcihlKSk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGJlZ2luVHJhbnNhY3Rpb24odHlwZTogJ3JlYWRvbmx5Jyk6IEFzeW5jS2V5VmFsdWVST1RyYW5zYWN0aW9uO1xuICBwdWJsaWMgYmVnaW5UcmFuc2FjdGlvbih0eXBlOiAncmVhZHdyaXRlJyk6IEFzeW5jS2V5VmFsdWVSV1RyYW5zYWN0aW9uO1xuICBwdWJsaWMgYmVnaW5UcmFuc2FjdGlvbih0eXBlOiBzdHJpbmcgPSAncmVhZG9ubHknKTogQXN5bmNLZXlWYWx1ZVJPVHJhbnNhY3Rpb24ge1xuICAgIGNvbnN0IHR4ID0gdGhpcy5kYi50cmFuc2FjdGlvbih0aGlzLnN0b3JlTmFtZSwgdHlwZSksXG4gICAgICBvYmplY3RTdG9yZSA9IHR4Lm9iamVjdFN0b3JlKHRoaXMuc3RvcmVOYW1lKTtcbiAgICBpZiAodHlwZSA9PT0gJ3JlYWR3cml0ZScpIHtcbiAgICAgIHJldHVybiBuZXcgSW5kZXhlZERCUldUcmFuc2FjdGlvbih0eCwgb2JqZWN0U3RvcmUpO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3JlYWRvbmx5Jykge1xuICAgICAgcmV0dXJuIG5ldyBJbmRleGVkREJST1RyYW5zYWN0aW9uKHR4LCBvYmplY3RTdG9yZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBBcGlFcnJvcihFcnJvckNvZGUuRUlOVkFMLCAnSW52YWxpZCB0cmFuc2FjdGlvbiB0eXBlLicpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIEluZGV4ZWREQiBmaWxlIHN5c3RlbS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJbmRleGVkREJGaWxlU3lzdGVtT3B0aW9ucyB7XG4gIC8vIFRoZSBuYW1lIG9mIHRoaXMgZmlsZSBzeXN0ZW0uIFlvdSBjYW4gaGF2ZSBtdWx0aXBsZSBJbmRleGVkREIgZmlsZSBzeXN0ZW1zIG9wZXJhdGluZ1xuICAvLyBhdCBvbmNlLCBidXQgZWFjaCBtdXN0IGhhdmUgYSBkaWZmZXJlbnQgbmFtZS5cbiAgc3RvcmVOYW1lPzogc3RyaW5nO1xufVxuXG4vKipcbiAqIEEgZmlsZSBzeXN0ZW0gdGhhdCB1c2VzIHRoZSBJbmRleGVkREIga2V5IHZhbHVlIGZpbGUgc3lzdGVtLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJbmRleGVkREJGaWxlU3lzdGVtIGV4dGVuZHMgQXN5bmNLZXlWYWx1ZUZpbGVTeXN0ZW0ge1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IE5hbWUgPSBcIkluZGV4ZWREQlwiO1xuXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgT3B0aW9uczogRmlsZVN5c3RlbU9wdGlvbnMgPSB7XG4gICAgc3RvcmVOYW1lOiB7XG4gICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICBkZXNjcmlwdGlvbjogXCJUaGUgbmFtZSBvZiB0aGlzIGZpbGUgc3lzdGVtLiBZb3UgY2FuIGhhdmUgbXVsdGlwbGUgSW5kZXhlZERCIGZpbGUgc3lzdGVtcyBvcGVyYXRpbmcgYXQgb25jZSwgYnV0IGVhY2ggbXVzdCBoYXZlIGEgZGlmZmVyZW50IG5hbWUuXCJcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYW4gSW5kZXhlZERCIGZpbGUgc3lzdGVtIHdpdGggdGhlIGdpdmVuIG9wdGlvbnMuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIENyZWF0ZShvcHRzOiBJbmRleGVkREJGaWxlU3lzdGVtT3B0aW9ucywgY2I6IEJGU0NhbGxiYWNrPEluZGV4ZWREQkZpbGVTeXN0ZW0+KTogdm9pZCB7XG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLXVudXNlZC1uZXdcbiAgICBuZXcgSW5kZXhlZERCRmlsZVN5c3RlbShjYiwgb3B0cy5zdG9yZU5hbWUsIGZhbHNlKTtcbiAgICAvLyB0c2xpbnQ6ZW5hYmxlLW5leHQtbGluZTpuby11bnVzZWQtbmV3XG4gIH1cbiAgcHVibGljIHN0YXRpYyBpc0F2YWlsYWJsZSgpOiBib29sZWFuIHtcbiAgICAvLyBJbiBTYWZhcmkncyBwcml2YXRlIGJyb3dzaW5nIG1vZGUsIGluZGV4ZWREQi5vcGVuIHJldHVybnMgTlVMTC5cbiAgICAvLyBJbiBGaXJlZm94LCBpdCB0aHJvd3MgYW4gZXhjZXB0aW9uLlxuICAgIC8vIEluIENocm9tZSwgaXQgXCJqdXN0IHdvcmtzXCIsIGFuZCBjbGVhcnMgdGhlIGRhdGFiYXNlIHdoZW4geW91IGxlYXZlIHRoZSBwYWdlLlxuICAgIC8vIFVudGVzdGVkOiBPcGVyYSwgSUUuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB0eXBlb2YgaW5kZXhlZERCICE9PSAndW5kZWZpbmVkJyAmJiBudWxsICE9PSBpbmRleGVkREIub3BlbihcIl9fYnJvd3NlcmZzX3Rlc3RfX1wiKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiAqKkRlcHJlY2F0ZWQuIFVzZSBJbmRleGVkREIuQ3JlYXRlKCkgbWV0aG9kIGluc3RlYWQuKipcbiAgICpcbiAgICogQ29uc3RydWN0cyBhbiBJbmRleGVkREIgZmlsZSBzeXN0ZW0uXG4gICAqIEBwYXJhbSBjYiBDYWxsZWQgb25jZSB0aGUgZGF0YWJhc2UgaXMgaW5zdGFudGlhdGVkIGFuZCByZWFkeSBmb3IgdXNlLlxuICAgKiAgIFBhc3NlcyBhbiBlcnJvciBpZiB0aGVyZSB3YXMgYW4gaXNzdWUgaW5zdGFudGlhdGluZyB0aGUgZGF0YWJhc2UuXG4gICAqIEBwYXJhbSBzdG9yZU5hbWUgVGhlIG5hbWUgb2YgdGhpcyBmaWxlIHN5c3RlbS4gWW91IGNhbiBoYXZlXG4gICAqICAgbXVsdGlwbGUgSW5kZXhlZERCIGZpbGUgc3lzdGVtcyBvcGVyYXRpbmcgYXQgb25jZSwgYnV0IGVhY2ggbXVzdCBoYXZlXG4gICAqICAgYSBkaWZmZXJlbnQgbmFtZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGNiOiBCRlNDYWxsYmFjazxJbmRleGVkREJGaWxlU3lzdGVtPiwgc3RvcmVOYW1lPzogc3RyaW5nLCBkZXByZWNhdGVNc2c6IGJvb2xlYW4gPSB0cnVlKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnN0b3JlID0gbmV3IEluZGV4ZWREQlN0b3JlKChlKTogdm9pZCA9PiB7XG4gICAgICBpZiAoZSkge1xuICAgICAgICBjYihlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaW5pdCh0aGlzLnN0b3JlLCAoZT8pID0+IHtcbiAgICAgICAgICBjYihlLCB0aGlzKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwgc3RvcmVOYW1lKTtcbiAgICBkZXByZWNhdGlvbk1lc3NhZ2UoZGVwcmVjYXRlTXNnLCBJbmRleGVkREJGaWxlU3lzdGVtLk5hbWUsIHtzdG9yZU5hbWU6IHN0b3JlTmFtZX0pO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vLi4vLi4vLi4vc3JjL2JhY2tlbmQvSW5kZXhlZERCLnRzIiwiaW1wb3J0IHtCRlNDYWxsYmFjaywgRmlsZVN5c3RlbU9wdGlvbnN9IGZyb20gJy4uL2NvcmUvZmlsZV9zeXN0ZW0nO1xuaW1wb3J0IHtTeW5jS2V5VmFsdWVTdG9yZSwgU2ltcGxlU3luY1N0b3JlLCBTeW5jS2V5VmFsdWVGaWxlU3lzdGVtLCBTaW1wbGVTeW5jUldUcmFuc2FjdGlvbiwgU3luY0tleVZhbHVlUldUcmFuc2FjdGlvbn0gZnJvbSAnLi4vZ2VuZXJpYy9rZXlfdmFsdWVfZmlsZXN5c3RlbSc7XG5pbXBvcnQge0FwaUVycm9yLCBFcnJvckNvZGV9IGZyb20gJy4uL2NvcmUvYXBpX2Vycm9yJztcbmltcG9ydCBnbG9iYWwgZnJvbSAnLi4vY29yZS9nbG9iYWwnO1xuXG4vKipcbiAqIFNvbWUgdmVyc2lvbnMgb2YgRkYgYW5kIGFsbCB2ZXJzaW9ucyBvZiBJRSBkbyBub3Qgc3VwcG9ydCB0aGUgZnVsbCByYW5nZSBvZlxuICogMTYtYml0IG51bWJlcnMgZW5jb2RlZCBhcyBjaGFyYWN0ZXJzLCBhcyB0aGV5IGVuZm9yY2UgVVRGLTE2IHJlc3RyaWN0aW9ucy5cbiAqIEB1cmwgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMTE3MDcxNi9hcmUtdGhlcmUtYW55LWNoYXJhY3RlcnMtdGhhdC1hcmUtbm90LWFsbG93ZWQtaW4tbG9jYWxzdG9yYWdlLzExMTczNjczIzExMTczNjczXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBzdXBwb3J0c0JpbmFyeVN0cmluZzogYm9vbGVhbiA9IGZhbHNlLFxuICBiaW5hcnlFbmNvZGluZzogc3RyaW5nO1xudHJ5IHtcbiAgZ2xvYmFsLmxvY2FsU3RvcmFnZS5zZXRJdGVtKFwiX190ZXN0X19cIiwgU3RyaW5nLmZyb21DaGFyQ29kZSgweEQ4MDApKTtcbiAgc3VwcG9ydHNCaW5hcnlTdHJpbmcgPSBnbG9iYWwubG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJfX3Rlc3RfX1wiKSA9PT0gU3RyaW5nLmZyb21DaGFyQ29kZSgweEQ4MDApO1xufSBjYXRjaCAoZSkge1xuICAvLyBJRSB0aHJvd3MgYW4gZXhjZXB0aW9uLlxuICBzdXBwb3J0c0JpbmFyeVN0cmluZyA9IGZhbHNlO1xufVxuYmluYXJ5RW5jb2RpbmcgPSBzdXBwb3J0c0JpbmFyeVN0cmluZyA/ICdiaW5hcnlfc3RyaW5nJyA6ICdiaW5hcnlfc3RyaW5nX2llJztcbmlmICghQnVmZmVyLmlzRW5jb2RpbmcoYmluYXJ5RW5jb2RpbmcpKSB7XG4gIC8vIEZhbGxiYWNrIGZvciBub24gQnJvd3NlckZTIGltcGxlbWVudGF0aW9ucyBvZiBidWZmZXIgdGhhdCBsYWNrIGFcbiAgLy8gYmluYXJ5X3N0cmluZyBmb3JtYXQuXG4gIGJpbmFyeUVuY29kaW5nID0gXCJiYXNlNjRcIjtcbn1cblxuLyoqXG4gKiBBIHN5bmNocm9ub3VzIGtleS12YWx1ZSBzdG9yZSBiYWNrZWQgYnkgbG9jYWxTdG9yYWdlLlxuICovXG5leHBvcnQgY2xhc3MgTG9jYWxTdG9yYWdlU3RvcmUgaW1wbGVtZW50cyBTeW5jS2V5VmFsdWVTdG9yZSwgU2ltcGxlU3luY1N0b3JlIHtcbiAgcHVibGljIG5hbWUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gTG9jYWxTdG9yYWdlRmlsZVN5c3RlbS5OYW1lO1xuICB9XG5cbiAgcHVibGljIGNsZWFyKCk6IHZvaWQge1xuICAgIGdsb2JhbC5sb2NhbFN0b3JhZ2UuY2xlYXIoKTtcbiAgfVxuXG4gIHB1YmxpYyBiZWdpblRyYW5zYWN0aW9uKHR5cGU6IHN0cmluZyk6IFN5bmNLZXlWYWx1ZVJXVHJhbnNhY3Rpb24ge1xuICAgIC8vIE5vIG5lZWQgdG8gZGlmZmVyZW50aWF0ZS5cbiAgICByZXR1cm4gbmV3IFNpbXBsZVN5bmNSV1RyYW5zYWN0aW9uKHRoaXMpO1xuICB9XG5cbiAgcHVibGljIGdldChrZXk6IHN0cmluZyk6IEJ1ZmZlciB8IHVuZGVmaW5lZCB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRhdGEgPSBnbG9iYWwubG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KTtcbiAgICAgIGlmIChkYXRhICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShkYXRhLCBiaW5hcnlFbmNvZGluZyk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gRG8gbm90aGluZy5cbiAgICB9XG4gICAgLy8gS2V5IGRvZXNuJ3QgZXhpc3QsIG9yIGEgZmFpbHVyZSBvY2N1cnJlZC5cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgcHVibGljIHB1dChrZXk6IHN0cmluZywgZGF0YTogQnVmZmVyLCBvdmVyd3JpdGU6IGJvb2xlYW4pOiBib29sZWFuIHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFvdmVyd3JpdGUgJiYgZ2xvYmFsLmxvY2FsU3RvcmFnZS5nZXRJdGVtKGtleSkgIT09IG51bGwpIHtcbiAgICAgICAgLy8gRG9uJ3Qgd2FudCB0byBvdmVyd3JpdGUgdGhlIGtleSFcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgZ2xvYmFsLmxvY2FsU3RvcmFnZS5zZXRJdGVtKGtleSwgZGF0YS50b1N0cmluZyhiaW5hcnlFbmNvZGluZykpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IEFwaUVycm9yKEVycm9yQ29kZS5FTk9TUEMsIFwiTG9jYWxTdG9yYWdlIGlzIGZ1bGwuXCIpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBkZWwoa2V5OiBzdHJpbmcpOiB2b2lkIHtcbiAgICB0cnkge1xuICAgICAgZ2xvYmFsLmxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKGtleSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IEFwaUVycm9yKEVycm9yQ29kZS5FSU8sIFwiVW5hYmxlIHRvIGRlbGV0ZSBrZXkgXCIgKyBrZXkgKyBcIjogXCIgKyBlKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBBIHN5bmNocm9ub3VzIGZpbGUgc3lzdGVtIGJhY2tlZCBieSBsb2NhbFN0b3JhZ2UuIENvbm5lY3RzIG91clxuICogTG9jYWxTdG9yYWdlU3RvcmUgdG8gb3VyIFN5bmNLZXlWYWx1ZUZpbGVTeXN0ZW0uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExvY2FsU3RvcmFnZUZpbGVTeXN0ZW0gZXh0ZW5kcyBTeW5jS2V5VmFsdWVGaWxlU3lzdGVtIHtcbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBOYW1lID0gXCJMb2NhbFN0b3JhZ2VcIjtcblxuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IE9wdGlvbnM6IEZpbGVTeXN0ZW1PcHRpb25zID0ge307XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBMb2NhbFN0b3JhZ2VGaWxlU3lzdGVtIGluc3RhbmNlLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBDcmVhdGUob3B0aW9uczogYW55LCBjYjogQkZTQ2FsbGJhY2s8TG9jYWxTdG9yYWdlRmlsZVN5c3RlbT4pOiB2b2lkIHtcbiAgICBjYihudWxsLCBuZXcgTG9jYWxTdG9yYWdlRmlsZVN5c3RlbSgpKTtcbiAgfVxuICBwdWJsaWMgc3RhdGljIGlzQXZhaWxhYmxlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0eXBlb2YgZ2xvYmFsLmxvY2FsU3RvcmFnZSAhPT0gJ3VuZGVmaW5lZCc7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgTG9jYWxTdG9yYWdlIGZpbGUgc3lzdGVtIHVzaW5nIHRoZSBjb250ZW50cyBvZiBgbG9jYWxTdG9yYWdlYC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKCkgeyBzdXBlcih7IHN0b3JlOiBuZXcgTG9jYWxTdG9yYWdlU3RvcmUoKSB9KTsgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uLy4uLy4uLy4uL3NyYy9iYWNrZW5kL0xvY2FsU3RvcmFnZS50cyIsImltcG9ydCB7RmlsZVN5c3RlbSwgQmFzZUZpbGVTeXN0ZW0sIEJGU09uZUFyZ0NhbGxiYWNrLCBCRlNDYWxsYmFjaywgRmlsZVN5c3RlbU9wdGlvbnN9IGZyb20gJy4uL2NvcmUvZmlsZV9zeXN0ZW0nO1xuaW1wb3J0IEluTWVtb3J5RmlsZVN5c3RlbSBmcm9tICcuL0luTWVtb3J5JztcbmltcG9ydCB7QXBpRXJyb3IsIEVycm9yQ29kZX0gZnJvbSAnLi4vY29yZS9hcGlfZXJyb3InO1xuaW1wb3J0IGZzIGZyb20gJy4uL2NvcmUvbm9kZV9mcyc7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IHtta2RpcnBTeW5jfSBmcm9tICcuLi9jb3JlL3V0aWwnO1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIE1vdW50YWJsZUZpbGVTeXN0ZW0gYmFja2VuZC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBNb3VudGFibGVGaWxlU3lzdGVtT3B0aW9ucyB7XG4gIC8vIExvY2F0aW9ucyBvZiBtb3VudCBwb2ludHMuIENhbiBiZSBlbXB0eS5cbiAgW21vdW50UG9pbnQ6IHN0cmluZ106IEZpbGVTeXN0ZW07XG59XG5cbi8qKlxuICogVGhlIE1vdW50YWJsZUZpbGVTeXN0ZW0gYWxsb3dzIHlvdSB0byBtb3VudCBtdWx0aXBsZSBiYWNrZW5kIHR5cGVzIG9yXG4gKiBtdWx0aXBsZSBpbnN0YW50aWF0aW9ucyBvZiB0aGUgc2FtZSBiYWNrZW5kIGludG8gYSBzaW5nbGUgZmlsZSBzeXN0ZW0gdHJlZS5cbiAqIFRoZSBmaWxlIHN5c3RlbXMgZG8gbm90IG5lZWQgdG8ga25vdyBhYm91dCBlYWNoIG90aGVyOyBhbGwgaW50ZXJhY3Rpb25zIGFyZVxuICogYXV0b21hdGljYWxseSBmYWNpbGl0YXRlZCB0aHJvdWdoIHRoaXMgaW50ZXJmYWNlLlxuICpcbiAqIEZvciBleGFtcGxlLCBpZiBhIGZpbGUgc3lzdGVtIGlzIG1vdW50ZWQgYXQgL21udC9ibGFoLCBhbmQgYSByZXF1ZXN0IGNhbWUgaW5cbiAqIGZvciAvbW50L2JsYWgvZm9vLnR4dCwgdGhlIGZpbGUgc3lzdGVtIHdvdWxkIHNlZSBhIHJlcXVlc3QgZm9yIC9mb28udHh0LlxuICpcbiAqIFlvdSBjYW4gbW91bnQgZmlsZSBzeXN0ZW1zIHdoZW4geW91IGNvbmZpZ3VyZSB0aGUgZmlsZSBzeXN0ZW06XG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBCcm93c2VyRlMuY29uZmlndXJlKHtcbiAqICAgZnM6IFwiTW91bnRhYmxlRmlsZVN5c3RlbVwiLFxuICogICBvcHRpb25zOiB7XG4gKiAgICAgJy9kYXRhJzogeyBmczogJ1htbEh0dHBSZXF1ZXN0Jywgb3B0aW9uczogeyBpbmRleDogXCJodHRwOi8vbXlzaXRlLmNvbS9maWxlcy9pbmRleC5qc29uXCIgfSB9LFxuICogICAgICcvaG9tZSc6IHsgZnM6ICdMb2NhbFN0b3JhZ2UnIH1cbiAqICAgfVxuICogfSwgZnVuY3Rpb24oZSkge1xuICpcbiAqIH0pO1xuICogYGBgXG4gKlxuICogRm9yIGFkdmFuY2VkIHVzZXJzLCB5b3UgY2FuIGFsc28gbW91bnQgZmlsZSBzeXN0ZW1zICphZnRlciogTUZTIGlzIGNvbnN0cnVjdGVkOlxuICogYGBgamF2YXNjcmlwdFxuICogQnJvd3NlckZTLkZpbGVTeXN0ZW0uWG1sSHR0cFJlcXVlc3QuQ3JlYXRlKHtcbiAqICAgaW5kZXg6IFwiaHR0cDovL215c2l0ZS5jb20vZmlsZXMvaW5kZXguanNvblwiXG4gKiB9LCBmdW5jdGlvbihlLCB4aHJmcykge1xuICogICBCcm93c2VyRlMuRmlsZVN5c3RlbS5Nb3VudGFibGVGaWxlU3lzdGVtLkNyZWF0ZSh7XG4gKiAgICAgJy9kYXRhJzogeGhyZnNcbiAqICAgfSwgZnVuY3Rpb24oZSwgbWZzKSB7XG4gKiAgICAgQnJvd3NlckZTLmluaXRpYWxpemUobWZzKTtcbiAqXG4gKiAgICAgLy8gQWRkZWQgYWZ0ZXItdGhlLWZhY3QuLi5cbiAqICAgICBCcm93c2VyRlMuRmlsZVN5c3RlbS5Mb2NhbFN0b3JhZ2UuQ3JlYXRlKGZ1bmN0aW9uKGUsIGxzZnMpIHtcbiAqICAgICAgIG1mcy5tb3VudCgnL2hvbWUnLCBsc2ZzKTtcbiAqICAgICB9KTtcbiAqICAgfSk7XG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIFNpbmNlIE1vdW50YWJsZUZpbGVTeXN0ZW0gc2ltcGx5IHByb3hpZXMgcmVxdWVzdHMgdG8gbW91bnRlZCBmaWxlIHN5c3RlbXMsIGl0IHN1cHBvcnRzIGFsbCBvZiB0aGUgb3BlcmF0aW9ucyB0aGF0IHRoZSBtb3VudGVkIGZpbGUgc3lzdGVtcyBzdXBwb3J0LlxuICpcbiAqIFdpdGggbm8gbW91bnRlZCBmaWxlIHN5c3RlbXMsIGBNb3VudGFibGVGaWxlU3lzdGVtYCBhY3RzIGFzIGEgc2ltcGxlIGBJbk1lbW9yeWAgZmlsZXN5c3RlbS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTW91bnRhYmxlRmlsZVN5c3RlbSBleHRlbmRzIEJhc2VGaWxlU3lzdGVtIGltcGxlbWVudHMgRmlsZVN5c3RlbSB7XG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgTmFtZSA9IFwiTW91bnRhYmxlRmlsZVN5c3RlbVwiO1xuXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgT3B0aW9uczogRmlsZVN5c3RlbU9wdGlvbnMgPSB7fTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIE1vdW50YWJsZUZpbGVTeXN0ZW0gaW5zdGFuY2Ugd2l0aCB0aGUgZ2l2ZW4gb3B0aW9ucy5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgQ3JlYXRlKG9wdHM6IE1vdW50YWJsZUZpbGVTeXN0ZW1PcHRpb25zLCBjYjogQkZTQ2FsbGJhY2s8TW91bnRhYmxlRmlsZVN5c3RlbT4pOiB2b2lkIHtcbiAgICBjb25zdCBmcyA9IG5ldyBNb3VudGFibGVGaWxlU3lzdGVtKCk7XG4gICAgT2JqZWN0LmtleXMob3B0cykuZm9yRWFjaCgobW91bnRQb2ludCkgPT4ge1xuICAgICAgZnMubW91bnQobW91bnRQb2ludCwgb3B0c1ttb3VudFBvaW50XSk7XG4gICAgfSk7XG4gICAgY2IobnVsbCwgZnMpO1xuICB9XG4gIHB1YmxpYyBzdGF0aWMgaXNBdmFpbGFibGUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBwcml2YXRlIG1udE1hcDoge1twYXRoOiBzdHJpbmddOiBGaWxlU3lzdGVtfTtcbiAgLy8gQ29udGFpbnMgdGhlIGxpc3Qgb2YgbW91bnQgcG9pbnRzIGluIG1udE1hcCwgc29ydGVkIGJ5IHN0cmluZyBsZW5ndGggaW4gZGVjcmVhc2luZyBvcmRlci5cbiAgLy8gRW5zdXJlcyB0aGF0IHdlIHNjYW4gdGhlIG1vc3Qgc3BlY2lmaWMgbW91bnQgcG9pbnRzIGZvciBhIG1hdGNoIGZpcnN0LCB3aGljaCBsZXRzIHVzXG4gIC8vIG5lc3QgbW91bnQgcG9pbnRzLlxuICBwcml2YXRlIG1vdW50TGlzdDogc3RyaW5nW10gPSBbXTtcbiAgcHJpdmF0ZSByb290RnM6IEZpbGVTeXN0ZW07XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcsIGVtcHR5IE1vdW50YWJsZUZpbGVTeXN0ZW0uXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMubW50TWFwID0ge307XG4gICAgLy8gVGhlIEluTWVtb3J5IGZpbGUgc3lzdGVtIHNlcnZlcyBwdXJlbHkgdG8gcHJvdmlkZSBkaXJlY3RvcnkgbGlzdGluZ3MgZm9yXG4gICAgLy8gbW91bnRlZCBmaWxlIHN5c3RlbXMuXG4gICAgdGhpcy5yb290RnMgPSBuZXcgSW5NZW1vcnlGaWxlU3lzdGVtKCk7XG4gIH1cblxuICAvKipcbiAgICogTW91bnRzIHRoZSBmaWxlIHN5c3RlbSBhdCB0aGUgZ2l2ZW4gbW91bnQgcG9pbnQuXG4gICAqL1xuICBwdWJsaWMgbW91bnQobW91bnRQb2ludDogc3RyaW5nLCBmczogRmlsZVN5c3RlbSk6IHZvaWQge1xuICAgIGlmIChtb3VudFBvaW50WzBdICE9PSAnLycpIHtcbiAgICAgIG1vdW50UG9pbnQgPSBgLyR7bW91bnRQb2ludH1gO1xuICAgIH1cbiAgICBtb3VudFBvaW50ID0gcGF0aC5yZXNvbHZlKG1vdW50UG9pbnQpO1xuICAgIGlmICh0aGlzLm1udE1hcFttb3VudFBvaW50XSkge1xuICAgICAgdGhyb3cgbmV3IEFwaUVycm9yKEVycm9yQ29kZS5FSU5WQUwsIFwiTW91bnQgcG9pbnQgXCIgKyBtb3VudFBvaW50ICsgXCIgaXMgYWxyZWFkeSB0YWtlbi5cIik7XG4gICAgfVxuICAgIG1rZGlycFN5bmMobW91bnRQb2ludCwgMHgxZmYsIHRoaXMucm9vdEZzKTtcbiAgICB0aGlzLm1udE1hcFttb3VudFBvaW50XSA9IGZzO1xuICAgIHRoaXMubW91bnRMaXN0LnB1c2gobW91bnRQb2ludCk7XG4gICAgdGhpcy5tb3VudExpc3QgPSB0aGlzLm1vdW50TGlzdC5zb3J0KChhLCBiKSA9PiBiLmxlbmd0aCAtIGEubGVuZ3RoKTtcbiAgfVxuXG4gIHB1YmxpYyB1bW91bnQobW91bnRQb2ludDogc3RyaW5nKTogdm9pZCB7XG4gICAgaWYgKG1vdW50UG9pbnRbMF0gIT09ICcvJykge1xuICAgICAgbW91bnRQb2ludCA9IGAvJHttb3VudFBvaW50fWA7XG4gICAgfVxuICAgIG1vdW50UG9pbnQgPSBwYXRoLnJlc29sdmUobW91bnRQb2ludCk7XG4gICAgaWYgKCF0aGlzLm1udE1hcFttb3VudFBvaW50XSkge1xuICAgICAgdGhyb3cgbmV3IEFwaUVycm9yKEVycm9yQ29kZS5FSU5WQUwsIFwiTW91bnQgcG9pbnQgXCIgKyBtb3VudFBvaW50ICsgXCIgaXMgYWxyZWFkeSB1bm1vdW50ZWQuXCIpO1xuICAgIH1cbiAgICBkZWxldGUgdGhpcy5tbnRNYXBbbW91bnRQb2ludF07XG4gICAgdGhpcy5tb3VudExpc3Quc3BsaWNlKHRoaXMubW91bnRMaXN0LmluZGV4T2YobW91bnRQb2ludCksIDEpO1xuXG4gICAgd2hpbGUgKG1vdW50UG9pbnQgIT09ICcvJykge1xuICAgICAgaWYgKHRoaXMucm9vdEZzLnJlYWRkaXJTeW5jKG1vdW50UG9pbnQpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLnJvb3RGcy5ybWRpclN5bmMobW91bnRQb2ludCk7XG4gICAgICAgIG1vdW50UG9pbnQgPSBwYXRoLmRpcm5hbWUobW91bnRQb2ludCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZmlsZSBzeXN0ZW0gdGhhdCB0aGUgcGF0aCBwb2ludHMgdG8uXG4gICAqL1xuICBwdWJsaWMgX2dldEZzKHBhdGg6IHN0cmluZyk6IHtmczogRmlsZVN5c3RlbTsgcGF0aDogc3RyaW5nfSB7XG4gICAgY29uc3QgbW91bnRMaXN0ID0gdGhpcy5tb3VudExpc3QsIGxlbiA9IG1vdW50TGlzdC5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgY29uc3QgbW91bnRQb2ludCA9IG1vdW50TGlzdFtpXTtcbiAgICAgIC8vIFdlIGtub3cgcGF0aCBpcyBub3JtYWxpemVkLCBzbyBpdCBpcyBhIHN1YnN0cmluZyBvZiB0aGUgbW91bnQgcG9pbnQuXG4gICAgICBpZiAobW91bnRQb2ludC5sZW5ndGggPD0gcGF0aC5sZW5ndGggJiYgcGF0aC5pbmRleE9mKG1vdW50UG9pbnQpID09PSAwKSB7XG4gICAgICAgIHBhdGggPSBwYXRoLnN1YnN0cihtb3VudFBvaW50Lmxlbmd0aCA+IDEgPyBtb3VudFBvaW50Lmxlbmd0aCA6IDApO1xuICAgICAgICBpZiAocGF0aCA9PT0gJycpIHtcbiAgICAgICAgICBwYXRoID0gJy8nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7ZnM6IHRoaXMubW50TWFwW21vdW50UG9pbnRdLCBwYXRoOiBwYXRofTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gUXVlcnkgb3VyIHJvb3QgZmlsZSBzeXN0ZW0uXG4gICAgcmV0dXJuIHtmczogdGhpcy5yb290RnMsIHBhdGg6IHBhdGh9O1xuICB9XG5cbiAgLy8gR2xvYmFsIGluZm9ybWF0aW9uIG1ldGhvZHNcblxuICBwdWJsaWMgZ2V0TmFtZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiBNb3VudGFibGVGaWxlU3lzdGVtLk5hbWU7XG4gIH1cblxuICBwdWJsaWMgZGlza1NwYWNlKHBhdGg6IHN0cmluZywgY2I6ICh0b3RhbDogbnVtYmVyLCBmcmVlOiBudW1iZXIpID0+IHZvaWQpOiB2b2lkIHtcbiAgICBjYigwLCAwKTtcbiAgfVxuXG4gIHB1YmxpYyBpc1JlYWRPbmx5KCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHB1YmxpYyBzdXBwb3J0c0xpbmtzKCk6IGJvb2xlYW4ge1xuICAgIC8vIEknbSBub3QgcmVhZHkgZm9yIGNyb3NzLUZTIGxpbmtzIHlldC5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBwdWJsaWMgc3VwcG9ydHNQcm9wcygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBwdWJsaWMgc3VwcG9ydHNTeW5jaCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaXhlcyB1cCBlcnJvciBtZXNzYWdlcyBzbyB0aGV5IG1lbnRpb24gdGhlIG1vdW50ZWQgZmlsZSBsb2NhdGlvbiByZWxhdGl2ZVxuICAgKiB0byB0aGUgTUZTIHJvb3QsIG5vdCB0byB0aGUgcGFydGljdWxhciBGUydzIHJvb3QuXG4gICAqIE11dGF0ZXMgdGhlIGlucHV0IGVycm9yLCBhbmQgcmV0dXJucyBpdC5cbiAgICovXG4gIHB1YmxpYyBzdGFuZGFyZGl6ZUVycm9yKGVycjogQXBpRXJyb3IsIHBhdGg6IHN0cmluZywgcmVhbFBhdGg6IHN0cmluZyk6IEFwaUVycm9yIHtcbiAgICBjb25zdCBpbmRleCA9IGVyci5tZXNzYWdlLmluZGV4T2YocGF0aCk7XG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgZXJyLm1lc3NhZ2UgPSBlcnIubWVzc2FnZS5zdWJzdHIoMCwgaW5kZXgpICsgcmVhbFBhdGggKyBlcnIubWVzc2FnZS5zdWJzdHIoaW5kZXggKyBwYXRoLmxlbmd0aCk7XG4gICAgICBlcnIucGF0aCA9IHJlYWxQYXRoO1xuICAgIH1cbiAgICByZXR1cm4gZXJyO1xuICB9XG5cbiAgLy8gVGhlIGZvbGxvd2luZyBtZXRob2RzIGludm9sdmUgbXVsdGlwbGUgZmlsZSBzeXN0ZW1zLCBhbmQgdGh1cyBoYXZlIGN1c3RvbVxuICAvLyBsb2dpYy5cbiAgLy8gTm90ZSB0aGF0IHdlIGdvIHRocm91Z2ggdGhlIE5vZGUgQVBJIHRvIHVzZSBpdHMgcm9idXN0IGRlZmF1bHQgYXJndW1lbnRcbiAgLy8gcHJvY2Vzc2luZy5cblxuICBwdWJsaWMgcmVuYW1lKG9sZFBhdGg6IHN0cmluZywgbmV3UGF0aDogc3RyaW5nLCBjYjogQkZTT25lQXJnQ2FsbGJhY2spOiB2b2lkIHtcbiAgICAvLyBTY2VuYXJpbyAxOiBvbGQgYW5kIG5ldyBhcmUgb24gc2FtZSBGUy5cbiAgICBjb25zdCBmczFydiA9IHRoaXMuX2dldEZzKG9sZFBhdGgpO1xuICAgIGNvbnN0IGZzMnJ2ID0gdGhpcy5fZ2V0RnMobmV3UGF0aCk7XG4gICAgaWYgKGZzMXJ2LmZzID09PSBmczJydi5mcykge1xuICAgICAgcmV0dXJuIGZzMXJ2LmZzLnJlbmFtZShmczFydi5wYXRoLCBmczJydi5wYXRoLCAoZT86IEFwaUVycm9yKSA9PiB7XG4gICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgdGhpcy5zdGFuZGFyZGl6ZUVycm9yKHRoaXMuc3RhbmRhcmRpemVFcnJvcihlLCBmczFydi5wYXRoLCBvbGRQYXRoKSwgZnMycnYucGF0aCwgbmV3UGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgY2IoZSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBTY2VuYXJpbyAyOiBEaWZmZXJlbnQgZmlsZSBzeXN0ZW1zLlxuICAgIC8vIFJlYWQgb2xkIGZpbGUsIHdyaXRlIG5ldyBmaWxlLCBkZWxldGUgb2xkIGZpbGUuXG4gICAgcmV0dXJuIGZzLnJlYWRGaWxlKG9sZFBhdGgsIGZ1bmN0aW9uKGVycjogQXBpRXJyb3IsIGRhdGE/OiBhbnkpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGNiKGVycik7XG4gICAgICB9XG4gICAgICBmcy53cml0ZUZpbGUobmV3UGF0aCwgZGF0YSwgZnVuY3Rpb24oZXJyOiBBcGlFcnJvcikge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgcmV0dXJuIGNiKGVycik7XG4gICAgICAgIH1cbiAgICAgICAgZnMudW5saW5rKG9sZFBhdGgsIGNiKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIHJlbmFtZVN5bmMob2xkUGF0aDogc3RyaW5nLCBuZXdQYXRoOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAvLyBTY2VuYXJpbyAxOiBvbGQgYW5kIG5ldyBhcmUgb24gc2FtZSBGUy5cbiAgICBjb25zdCBmczFydiA9IHRoaXMuX2dldEZzKG9sZFBhdGgpO1xuICAgIGNvbnN0IGZzMnJ2ID0gdGhpcy5fZ2V0RnMobmV3UGF0aCk7XG4gICAgaWYgKGZzMXJ2LmZzID09PSBmczJydi5mcykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGZzMXJ2LmZzLnJlbmFtZVN5bmMoZnMxcnYucGF0aCwgZnMycnYucGF0aCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRoaXMuc3RhbmRhcmRpemVFcnJvcih0aGlzLnN0YW5kYXJkaXplRXJyb3IoZSwgZnMxcnYucGF0aCwgb2xkUGF0aCksIGZzMnJ2LnBhdGgsIG5ld1BhdGgpO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBTY2VuYXJpbyAyOiBEaWZmZXJlbnQgZmlsZSBzeXN0ZW1zLlxuICAgIGNvbnN0IGRhdGEgPSBmcy5yZWFkRmlsZVN5bmMob2xkUGF0aCk7XG4gICAgZnMud3JpdGVGaWxlU3luYyhuZXdQYXRoLCBkYXRhKTtcbiAgICByZXR1cm4gZnMudW5saW5rU3luYyhvbGRQYXRoKTtcbiAgfVxuXG4gIHB1YmxpYyByZWFkZGlyU3luYyhwOiBzdHJpbmcpOiBzdHJpbmdbXSB7XG4gICAgY29uc3QgZnNJbmZvID0gdGhpcy5fZ2V0RnMocCk7XG5cbiAgICAvLyBJZiBudWxsLCByb290ZnMgZGlkIG5vdCBoYXZlIHRoZSBkaXJlY3RvcnlcbiAgICAvLyAob3IgdGhlIHRhcmdldCBGUyBpcyB0aGUgcm9vdCBmcykuXG4gICAgbGV0IHJ2OiBzdHJpbmdbXSB8IG51bGwgPSBudWxsO1xuICAgIC8vIE1vdW50IHBvaW50cyBhcmUgYWxsIGRlZmluZWQgaW4gdGhlIHJvb3QgRlMuXG4gICAgLy8gRW5zdXJlIHRoYXQgd2UgbGlzdCB0aG9zZSwgdG9vLlxuICAgIGlmIChmc0luZm8uZnMgIT09IHRoaXMucm9vdEZzKSB7XG4gICAgICB0cnkge1xuICAgICAgICBydiA9IHRoaXMucm9vdEZzLnJlYWRkaXJTeW5jKHApO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBJZ25vcmUuXG4gICAgICB9XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJ2MiA9IGZzSW5mby5mcy5yZWFkZGlyU3luYyhmc0luZm8ucGF0aCk7XG4gICAgICBpZiAocnYgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHJ2MjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZpbHRlciBvdXQgZHVwbGljYXRlcy5cbiAgICAgICAgcmV0dXJuIHJ2Mi5jb25jYXQocnYuZmlsdGVyKCh2YWwpID0+IHJ2Mi5pbmRleE9mKHZhbCkgPT09IC0xKSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKHJ2ID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IHRoaXMuc3RhbmRhcmRpemVFcnJvcihlLCBmc0luZm8ucGF0aCwgcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGUgcm9vdCBGUyBoYWQgc29tZXRoaW5nLlxuICAgICAgICByZXR1cm4gcnY7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHJlYWRkaXIocDogc3RyaW5nLCBjYjogQkZTQ2FsbGJhY2s8c3RyaW5nW10+KTogdm9pZCB7XG4gICAgY29uc3QgZnNJbmZvID0gdGhpcy5fZ2V0RnMocCk7XG4gICAgZnNJbmZvLmZzLnJlYWRkaXIoZnNJbmZvLnBhdGgsIChlcnIsIGZpbGVzKSA9PiB7XG4gICAgICBpZiAoZnNJbmZvLmZzICE9PSB0aGlzLnJvb3RGcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHJ2ID0gdGhpcy5yb290RnMucmVhZGRpclN5bmMocCk7XG4gICAgICAgICAgaWYgKGZpbGVzKSB7XG4gICAgICAgICAgICAvLyBGaWx0ZXIgb3V0IGR1cGxpY2F0ZXMuXG4gICAgICAgICAgICBmaWxlcyA9IGZpbGVzLmNvbmNhdChydi5maWx0ZXIoKHZhbCkgPT4gZmlsZXMhLmluZGV4T2YodmFsKSA9PT0gLTEpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZmlsZXMgPSBydjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAvLyBSb290IEZTIGFuZCB0YXJnZXQgRlMgZGlkIG5vdCBoYXZlIGRpcmVjdG9yeS5cbiAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gY2IodGhpcy5zdGFuZGFyZGl6ZUVycm9yKGVyciwgZnNJbmZvLnBhdGgsIHApKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZXJyKSB7XG4gICAgICAgIC8vIFJvb3QgRlMgYW5kIHRhcmdldCBGUyBhcmUgdGhlIHNhbWUsIGFuZCBkaWQgbm90IGhhdmUgZGlyZWN0b3J5LlxuICAgICAgICByZXR1cm4gY2IodGhpcy5zdGFuZGFyZGl6ZUVycm9yKGVyciwgZnNJbmZvLnBhdGgsIHApKTtcbiAgICAgIH1cblxuICAgICAgY2IobnVsbCwgZmlsZXMpO1xuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIHJtZGlyU3luYyhwOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBjb25zdCBmc0luZm8gPSB0aGlzLl9nZXRGcyhwKTtcbiAgICBpZiAodGhpcy5fY29udGFpbnNNb3VudFB0KHApKSB7XG4gICAgICB0aHJvdyBBcGlFcnJvci5FTk9URU1QVFkocCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZzSW5mby5mcy5ybWRpclN5bmMoZnNJbmZvLnBhdGgpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyB0aGlzLnN0YW5kYXJkaXplRXJyb3IoZSwgZnNJbmZvLnBhdGgsIHApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBybWRpcihwOiBzdHJpbmcsIGNiOiBCRlNPbmVBcmdDYWxsYmFjayk6IHZvaWQge1xuICAgIGNvbnN0IGZzSW5mbyA9IHRoaXMuX2dldEZzKHApO1xuICAgIGlmICh0aGlzLl9jb250YWluc01vdW50UHQocCkpIHtcbiAgICAgIGNiKEFwaUVycm9yLkVOT1RFTVBUWShwKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZzSW5mby5mcy5ybWRpcihmc0luZm8ucGF0aCwgKGVycj8pID0+IHtcbiAgICAgICAgY2IoZXJyID8gdGhpcy5zdGFuZGFyZGl6ZUVycm9yKGVyciwgZnNJbmZvLnBhdGgsIHApIDogbnVsbCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBwYXRoIGNvbnRhaW5zIGEgbW91bnQgcG9pbnQuXG4gICAqL1xuICBwcml2YXRlIF9jb250YWluc01vdW50UHQocDogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgY29uc3QgbW91bnRQb2ludHMgPSB0aGlzLm1vdW50TGlzdCwgbGVuID0gbW91bnRQb2ludHMubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGNvbnN0IHB0ID0gbW91bnRQb2ludHNbaV07XG4gICAgICBpZiAocHQubGVuZ3RoID49IHAubGVuZ3RoICYmIHB0LnNsaWNlKDAsIHAubGVuZ3RoKSA9PT0gcCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogVHJpY2t5OiBEZWZpbmUgYWxsIG9mIHRoZSBmdW5jdGlvbnMgdGhhdCBtZXJlbHkgZm9yd2FyZCBhcmd1bWVudHMgdG8gdGhlXG4gKiByZWxldmFudCBmaWxlIHN5c3RlbSwgb3IgcmV0dXJuL3Rocm93IGFuIGVycm9yLlxuICogVGFrZSBhZHZhbnRhZ2Ugb2YgdGhlIGZhY3QgdGhhdCB0aGUgKmZpcnN0KiBhcmd1bWVudCBpcyBhbHdheXMgdGhlIHBhdGgsIGFuZFxuICogdGhlICpsYXN0KiBpcyB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gKGlmIGFzeW5jKS5cbiAqIEB0b2RvIENhbiB1c2UgbnVtQXJncyB0byBtYWtlIHByb3h5aW5nIG1vcmUgZWZmaWNpZW50LlxuICogQGhpZGRlblxuICovXG5mdW5jdGlvbiBkZWZpbmVGY24obmFtZTogc3RyaW5nLCBpc1N5bmM6IGJvb2xlYW4sIG51bUFyZ3M6IG51bWJlcik6ICguLi5hcmdzOiBhbnlbXSkgPT4gYW55IHtcbiAgaWYgKGlzU3luYykge1xuICAgIHJldHVybiBmdW5jdGlvbih0aGlzOiBNb3VudGFibGVGaWxlU3lzdGVtLCAuLi5hcmdzOiBhbnlbXSkge1xuICAgICAgY29uc3QgcGF0aCA9IGFyZ3NbMF07XG4gICAgICBjb25zdCBydiA9IHRoaXMuX2dldEZzKHBhdGgpO1xuICAgICAgYXJnc1swXSA9IHJ2LnBhdGg7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gKDxhbnk+IHJ2LmZzKVtuYW1lXS5hcHBseShydi5mcywgYXJncyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRoaXMuc3RhbmRhcmRpemVFcnJvcihlLCBydi5wYXRoLCBwYXRoKTtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmdW5jdGlvbih0aGlzOiBNb3VudGFibGVGaWxlU3lzdGVtLCAuLi5hcmdzOiBhbnlbXSkge1xuICAgICAgY29uc3QgcGF0aCA9IGFyZ3NbMF07XG4gICAgICBjb25zdCBydiA9IHRoaXMuX2dldEZzKHBhdGgpO1xuICAgICAgYXJnc1swXSA9IHJ2LnBhdGg7XG4gICAgICBpZiAodHlwZW9mIGFyZ3NbYXJncy5sZW5ndGggLSAxXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjb25zdCBjYiA9IGFyZ3NbYXJncy5sZW5ndGggLSAxXTtcbiAgICAgICAgYXJnc1thcmdzLmxlbmd0aCAtIDFdID0gKC4uLmFyZ3M6IGFueVtdKSA9PiB7XG4gICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID4gMCAmJiBhcmdzWzBdIGluc3RhbmNlb2YgQXBpRXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhbmRhcmRpemVFcnJvcihhcmdzWzBdLCBydi5wYXRoLCBwYXRoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2IuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gKDxhbnk+IHJ2LmZzKVtuYW1lXS5hcHBseShydi5mcywgYXJncyk7XG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgZnNDbWRNYXAgPSBbXG4gICAvLyAxIGFyZyBmdW5jdGlvbnNcbiAgIFsnZXhpc3RzJywgJ3VubGluaycsICdyZWFkbGluayddLFxuICAgLy8gMiBhcmcgZnVuY3Rpb25zXG4gICBbJ3N0YXQnLCAnbWtkaXInLCAncmVhbHBhdGgnLCAndHJ1bmNhdGUnXSxcbiAgIC8vIDMgYXJnIGZ1bmN0aW9uc1xuICAgWydvcGVuJywgJ3JlYWRGaWxlJywgJ2NobW9kJywgJ3V0aW1lcyddLFxuICAgLy8gNCBhcmcgZnVuY3Rpb25zXG4gICBbJ2Nob3duJ10sXG4gICAvLyA1IGFyZyBmdW5jdGlvbnNcbiAgIFsnd3JpdGVGaWxlJywgJ2FwcGVuZEZpbGUnXV07XG5cbmZvciAobGV0IGkgPSAwOyBpIDwgZnNDbWRNYXAubGVuZ3RoOyBpKyspIHtcbiAgY29uc3QgY21kcyA9IGZzQ21kTWFwW2ldO1xuICBmb3IgKGNvbnN0IGZuTmFtZSBvZiBjbWRzKSB7XG4gICAgKDxhbnk+IE1vdW50YWJsZUZpbGVTeXN0ZW0ucHJvdG90eXBlKVtmbk5hbWVdID0gZGVmaW5lRmNuKGZuTmFtZSwgZmFsc2UsIGkgKyAxKTtcbiAgICAoPGFueT4gTW91bnRhYmxlRmlsZVN5c3RlbS5wcm90b3R5cGUpW2ZuTmFtZSArICdTeW5jJ10gPSBkZWZpbmVGY24oZm5OYW1lICsgJ1N5bmMnLCB0cnVlLCBpICsgMSk7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi8uLi8uLi8uLi9zcmMvYmFja2VuZC9Nb3VudGFibGVGaWxlU3lzdGVtLnRzIiwiaW1wb3J0IGdsb2JhbCBmcm9tICcuLi9jb3JlL2dsb2JhbCc7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgYmZzU2V0SW1tZWRpYXRlOiAoY2I6IEZ1bmN0aW9uKSA9PiBhbnk7XG5pZiAodHlwZW9mKHNldEltbWVkaWF0ZSkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgYmZzU2V0SW1tZWRpYXRlID0gc2V0SW1tZWRpYXRlO1xufSBlbHNlIHtcbiAgY29uc3QgZ1Njb3BlID0gZ2xvYmFsO1xuICBjb25zdCB0aW1lb3V0czogKCgpID0+IHZvaWQpW10gPSBbXTtcbiAgY29uc3QgbWVzc2FnZU5hbWUgPSBcInplcm8tdGltZW91dC1tZXNzYWdlXCI7XG4gIGNvbnN0IGNhblVzZVBvc3RNZXNzYWdlID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHR5cGVvZiBnU2NvcGUuaW1wb3J0U2NyaXB0cyAhPT0gJ3VuZGVmaW5lZCcgfHwgIWdTY29wZS5wb3N0TWVzc2FnZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsZXQgcG9zdE1lc3NhZ2VJc0FzeW5jID0gdHJ1ZTtcbiAgICBjb25zdCBvbGRPbk1lc3NhZ2UgPSBnU2NvcGUub25tZXNzYWdlO1xuICAgIGdTY29wZS5vbm1lc3NhZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgIHBvc3RNZXNzYWdlSXNBc3luYyA9IGZhbHNlO1xuICAgIH07XG4gICAgZ1Njb3BlLnBvc3RNZXNzYWdlKCcnLCAnKicpO1xuICAgIGdTY29wZS5vbm1lc3NhZ2UgPSBvbGRPbk1lc3NhZ2U7XG4gICAgcmV0dXJuIHBvc3RNZXNzYWdlSXNBc3luYztcbiAgfTtcbiAgaWYgKGNhblVzZVBvc3RNZXNzYWdlKCkpIHtcbiAgICBiZnNTZXRJbW1lZGlhdGUgPSBmdW5jdGlvbihmbjogKCkgPT4gdm9pZCkge1xuICAgICAgdGltZW91dHMucHVzaChmbik7XG4gICAgICBnU2NvcGUucG9zdE1lc3NhZ2UobWVzc2FnZU5hbWUsIFwiKlwiKTtcbiAgICB9O1xuICAgIGNvbnN0IGhhbmRsZU1lc3NhZ2UgPSBmdW5jdGlvbihldmVudDogTWVzc2FnZUV2ZW50KSB7XG4gICAgICBpZiAoZXZlbnQuc291cmNlID09PSBzZWxmICYmIGV2ZW50LmRhdGEgPT09IG1lc3NhZ2VOYW1lKSB7XG4gICAgICAgIGlmIChldmVudC5zdG9wUHJvcGFnYXRpb24pIHtcbiAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBldmVudC5jYW5jZWxCdWJibGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aW1lb3V0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY29uc3QgZm4gPSB0aW1lb3V0cy5zaGlmdCgpITtcbiAgICAgICAgICByZXR1cm4gZm4oKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgaWYgKGdTY29wZS5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICBnU2NvcGUuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGhhbmRsZU1lc3NhZ2UsIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnU2NvcGUuYXR0YWNoRXZlbnQoJ29ubWVzc2FnZScsIGhhbmRsZU1lc3NhZ2UpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChnU2NvcGUuTWVzc2FnZUNoYW5uZWwpIHtcbiAgICAvLyBXZWJXb3JrZXIgTWVzc2FnZUNoYW5uZWxcbiAgICBjb25zdCBjaGFubmVsID0gbmV3IGdTY29wZS5NZXNzYWdlQ2hhbm5lbCgpO1xuICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gKGV2ZW50OiBhbnkpID0+IHtcbiAgICAgIGlmICh0aW1lb3V0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiB0aW1lb3V0cy5zaGlmdCgpISgpO1xuICAgICAgfVxuICAgIH07XG4gICAgYmZzU2V0SW1tZWRpYXRlID0gKGZuOiAoKSA9PiB2b2lkKSA9PiB7XG4gICAgICB0aW1lb3V0cy5wdXNoKGZuKTtcbiAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoJycpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgYmZzU2V0SW1tZWRpYXRlID0gZnVuY3Rpb24oZm46ICgpID0+IHZvaWQpIHtcbiAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZuLCAwKTtcbiAgICB9O1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJmc1NldEltbWVkaWF0ZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi8uLi8uLi8uLi9zcmMvZ2VuZXJpYy9zZXRJbW1lZGlhdGUudHMiLCJpbXBvcnQgc2V0SW1tZWRpYXRlIGZyb20gJy4uL2dlbmVyaWMvc2V0SW1tZWRpYXRlJztcblxuLyoqXG4gKiBOb24tcmVjdXJzaXZlIG11dGV4XG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE11dGV4IHtcbiAgcHJpdmF0ZSBfbG9ja2VkOiBib29sZWFuID0gZmFsc2U7XG4gIHByaXZhdGUgX3dhaXRlcnM6IEZ1bmN0aW9uW10gPSBbXTtcblxuICBwdWJsaWMgbG9jayhjYjogRnVuY3Rpb24pOiB2b2lkIHtcbiAgICBpZiAodGhpcy5fbG9ja2VkKSB7XG4gICAgICB0aGlzLl93YWl0ZXJzLnB1c2goY2IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9sb2NrZWQgPSB0cnVlO1xuICAgIGNiKCk7XG4gIH1cblxuICBwdWJsaWMgdW5sb2NrKCk6IHZvaWQge1xuICAgIGlmICghdGhpcy5fbG9ja2VkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VubG9jayBvZiBhIG5vbi1sb2NrZWQgbXV0ZXgnKTtcbiAgICB9XG5cbiAgICBjb25zdCBuZXh0ID0gdGhpcy5fd2FpdGVycy5zaGlmdCgpO1xuICAgIC8vIGRvbid0IHVubG9jayAtIHdlIHdhbnQgdG8gcXVldWUgdXAgbmV4dCBmb3IgdGhlXG4gICAgLy8gX2VuZF8gb2YgdGhlIGN1cnJlbnQgdGFzayBleGVjdXRpb24sIGJ1dCB3ZSBkb24ndFxuICAgIC8vIHdhbnQgaXQgdG8gYmUgY2FsbGVkIGlubGluZSB3aXRoIHdoYXRldmVyIHRoZVxuICAgIC8vIGN1cnJlbnQgc3RhY2sgaXMuICBUaGlzIHdheSB3ZSBzdGlsbCBnZXQgdGhlIG5pY2VcbiAgICAvLyBiZWhhdmlvciB0aGF0IGFuIHVubG9jayBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBhXG4gICAgLy8gbG9jayB3b24ndCBjYXVzZSBzdGFydmF0aW9uLlxuICAgIGlmIChuZXh0KSB7XG4gICAgICBzZXRJbW1lZGlhdGUobmV4dCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fbG9ja2VkID0gZmFsc2U7XG4gIH1cblxuICBwdWJsaWMgdHJ5TG9jaygpOiBib29sZWFuIHtcbiAgICBpZiAodGhpcy5fbG9ja2VkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5fbG9ja2VkID0gdHJ1ZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHB1YmxpYyBpc0xvY2tlZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fbG9ja2VkO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vLi4vLi4vLi4vc3JjL2dlbmVyaWMvbXV0ZXgudHMiLCJpbXBvcnQgTXV0ZXggZnJvbSAnLi9tdXRleCc7XG5pbXBvcnQge0ZpbGVTeXN0ZW0sIEJGU09uZUFyZ0NhbGxiYWNrLCBCRlNDYWxsYmFja30gZnJvbSAnLi4vY29yZS9maWxlX3N5c3RlbSc7XG5pbXBvcnQge0FwaUVycm9yfSBmcm9tICcuLi9jb3JlL2FwaV9lcnJvcic7XG5pbXBvcnQge0ZpbGVGbGFnfSBmcm9tICcuLi9jb3JlL2ZpbGVfZmxhZyc7XG5pbXBvcnQge2RlZmF1bHQgYXMgU3RhdHN9IGZyb20gJy4uL2NvcmUvbm9kZV9mc19zdGF0cyc7XG5pbXBvcnQge0ZpbGV9IGZyb20gJy4uL2NvcmUvZmlsZSc7XG5cbi8qKlxuICogVGhpcyBjbGFzcyBzZXJpYWxpemVzIGFjY2VzcyB0byBhbiB1bmRlcmx5aW5nIGFzeW5jIGZpbGVzeXN0ZW0uXG4gKiBGb3IgZXhhbXBsZSwgb24gYW4gT3ZlcmxheUZTIGluc3RhbmNlIHdpdGggYW4gYXN5bmMgbG93ZXJcbiAqIGRpcmVjdG9yeSBvcGVyYXRpb25zIGxpa2UgcmVuYW1lIGFuZCBybWRpciBtYXkgaW52b2x2ZSBtdWx0aXBsZVxuICogcmVxdWVzdHMgaW52b2x2aW5nIGJvdGggdGhlIHVwcGVyIGFuZCBsb3dlciBmaWxlc3lzdGVtcyAtLSB0aGV5XG4gKiBhcmUgbm90IGV4ZWN1dGVkIGluIGEgc2luZ2xlIGF0b21pYyBzdGVwLiAgT3ZlcmxheUZTIHVzZXMgdGhpc1xuICogTG9ja2VkRlMgdG8gYXZvaWQgaGF2aW5nIHRvIHJlYXNvbiBhYm91dCB0aGUgY29ycmVjdG5lc3Mgb2ZcbiAqIG11bHRpcGxlIHJlcXVlc3RzIGludGVybGVhdmluZy5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTG9ja2VkRlM8VCBleHRlbmRzIEZpbGVTeXN0ZW0+IGltcGxlbWVudHMgRmlsZVN5c3RlbSB7XG4gIHByaXZhdGUgX2ZzOiBUO1xuICBwcml2YXRlIF9tdTogTXV0ZXg7XG5cbiAgY29uc3RydWN0b3IoZnM6IFQpIHtcbiAgICB0aGlzLl9mcyA9IGZzO1xuICAgIHRoaXMuX211ID0gbmV3IE11dGV4KCk7XG4gIH1cblxuICBwdWJsaWMgZ2V0TmFtZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiAnTG9ja2VkRlM8JyArIHRoaXMuX2ZzLmdldE5hbWUoKSAgKyAnPic7XG4gIH1cblxuICBwdWJsaWMgZ2V0RlNVbmxvY2tlZCgpOiBUIHtcbiAgICByZXR1cm4gdGhpcy5fZnM7XG4gIH1cblxuICBwdWJsaWMgaW5pdGlhbGl6ZShjYjogQkZTT25lQXJnQ2FsbGJhY2spOiB2b2lkIHtcbiAgICAvLyBGSVhNRTogY2hlY2sgdG8gc2VlIGlmIEZTIHN1cHBvcnRzIGluaXRpYWxpemF0aW9uXG4gICAgKDxhbnk+IHRoaXMuX2ZzKS5pbml0aWFsaXplKGNiKTtcbiAgfVxuXG4gIHB1YmxpYyBkaXNrU3BhY2UocDogc3RyaW5nLCBjYjogKHRvdGFsOiBudW1iZXIsIGZyZWU6IG51bWJlcikgPT4gYW55KTogdm9pZCB7XG4gICAgLy8gRklYTUU6IHNob3VsZCB0aGlzIGxvY2s/XG4gICAgdGhpcy5fZnMuZGlza1NwYWNlKHAsIGNiKTtcbiAgfVxuXG4gIHB1YmxpYyBpc1JlYWRPbmx5KCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9mcy5pc1JlYWRPbmx5KCk7XG4gIH1cblxuICBwdWJsaWMgc3VwcG9ydHNMaW5rcygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fZnMuc3VwcG9ydHNMaW5rcygpO1xuICB9XG5cbiAgcHVibGljIHN1cHBvcnRzUHJvcHMoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX2ZzLnN1cHBvcnRzUHJvcHMoKTtcbiAgfVxuXG4gIHB1YmxpYyBzdXBwb3J0c1N5bmNoKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9mcy5zdXBwb3J0c1N5bmNoKCk7XG4gIH1cblxuICBwdWJsaWMgcmVuYW1lKG9sZFBhdGg6IHN0cmluZywgbmV3UGF0aDogc3RyaW5nLCBjYjogQkZTT25lQXJnQ2FsbGJhY2spOiB2b2lkIHtcbiAgICB0aGlzLl9tdS5sb2NrKCgpID0+IHtcbiAgICAgIHRoaXMuX2ZzLnJlbmFtZShvbGRQYXRoLCBuZXdQYXRoLCAoZXJyPzogQXBpRXJyb3IpID0+IHtcbiAgICAgICAgdGhpcy5fbXUudW5sb2NrKCk7XG4gICAgICAgIGNiKGVycik7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyByZW5hbWVTeW5jKG9sZFBhdGg6IHN0cmluZywgbmV3UGF0aDogc3RyaW5nKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuX211LmlzTG9ja2VkKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBzeW5jIGNhbGwnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2ZzLnJlbmFtZVN5bmMob2xkUGF0aCwgbmV3UGF0aCk7XG4gIH1cblxuICBwdWJsaWMgc3RhdChwOiBzdHJpbmcsIGlzTHN0YXQ6IGJvb2xlYW4sIGNiOiBCRlNDYWxsYmFjazxTdGF0cz4pOiB2b2lkIHtcbiAgICB0aGlzLl9tdS5sb2NrKCgpID0+IHtcbiAgICAgIHRoaXMuX2ZzLnN0YXQocCwgaXNMc3RhdCwgKGVycj86IEFwaUVycm9yLCBzdGF0PzogU3RhdHMpID0+IHtcbiAgICAgICAgdGhpcy5fbXUudW5sb2NrKCk7XG4gICAgICAgIGNiKGVyciwgc3RhdCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyBzdGF0U3luYyhwOiBzdHJpbmcsIGlzTHN0YXQ6IGJvb2xlYW4pOiBTdGF0cyB7XG4gICAgaWYgKHRoaXMuX211LmlzTG9ja2VkKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBzeW5jIGNhbGwnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2ZzLnN0YXRTeW5jKHAsIGlzTHN0YXQpO1xuICB9XG5cbiAgcHVibGljIG9wZW4ocDogc3RyaW5nLCBmbGFnOiBGaWxlRmxhZywgbW9kZTogbnVtYmVyLCBjYjogQkZTQ2FsbGJhY2s8RmlsZT4pOiB2b2lkIHtcbiAgICB0aGlzLl9tdS5sb2NrKCgpID0+IHtcbiAgICAgIHRoaXMuX2ZzLm9wZW4ocCwgZmxhZywgbW9kZSwgKGVycj86IEFwaUVycm9yLCBmZD86IEZpbGUpID0+IHtcbiAgICAgICAgdGhpcy5fbXUudW5sb2NrKCk7XG4gICAgICAgIGNiKGVyciwgZmQpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBwdWJsaWMgb3BlblN5bmMocDogc3RyaW5nLCBmbGFnOiBGaWxlRmxhZywgbW9kZTogbnVtYmVyKTogRmlsZSB7XG4gICAgaWYgKHRoaXMuX211LmlzTG9ja2VkKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBzeW5jIGNhbGwnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2ZzLm9wZW5TeW5jKHAsIGZsYWcsIG1vZGUpO1xuICB9XG5cbiAgcHVibGljIHVubGluayhwOiBzdHJpbmcsIGNiOiBCRlNPbmVBcmdDYWxsYmFjayk6IHZvaWQge1xuICAgIHRoaXMuX211LmxvY2soKCkgPT4ge1xuICAgICAgdGhpcy5fZnMudW5saW5rKHAsIChlcnI/OiBBcGlFcnJvcikgPT4ge1xuICAgICAgICB0aGlzLl9tdS51bmxvY2soKTtcbiAgICAgICAgY2IoZXJyKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIHVubGlua1N5bmMocDogc3RyaW5nKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuX211LmlzTG9ja2VkKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBzeW5jIGNhbGwnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2ZzLnVubGlua1N5bmMocCk7XG4gIH1cblxuICBwdWJsaWMgcm1kaXIocDogc3RyaW5nLCBjYjogQkZTT25lQXJnQ2FsbGJhY2spOiB2b2lkIHtcbiAgICB0aGlzLl9tdS5sb2NrKCgpID0+IHtcbiAgICAgIHRoaXMuX2ZzLnJtZGlyKHAsIChlcnI/OiBBcGlFcnJvcikgPT4ge1xuICAgICAgICB0aGlzLl9tdS51bmxvY2soKTtcbiAgICAgICAgY2IoZXJyKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIHJtZGlyU3luYyhwOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5fbXUuaXNMb2NrZWQoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHN5bmMgY2FsbCcpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZnMucm1kaXJTeW5jKHApO1xuICB9XG5cbiAgcHVibGljIG1rZGlyKHA6IHN0cmluZywgbW9kZTogbnVtYmVyLCBjYjogQkZTT25lQXJnQ2FsbGJhY2spOiB2b2lkIHtcbiAgICB0aGlzLl9tdS5sb2NrKCgpID0+IHtcbiAgICAgIHRoaXMuX2ZzLm1rZGlyKHAsIG1vZGUsIChlcnI/OiBBcGlFcnJvcikgPT4ge1xuICAgICAgICB0aGlzLl9tdS51bmxvY2soKTtcbiAgICAgICAgY2IoZXJyKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIG1rZGlyU3luYyhwOiBzdHJpbmcsIG1vZGU6IG51bWJlcik6IHZvaWQge1xuICAgIGlmICh0aGlzLl9tdS5pc0xvY2tlZCgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc3luYyBjYWxsJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9mcy5ta2RpclN5bmMocCwgbW9kZSk7XG4gIH1cblxuICBwdWJsaWMgcmVhZGRpcihwOiBzdHJpbmcsIGNiOiBCRlNDYWxsYmFjazxzdHJpbmdbXT4pOiB2b2lkIHtcbiAgICB0aGlzLl9tdS5sb2NrKCgpID0+IHtcbiAgICAgIHRoaXMuX2ZzLnJlYWRkaXIocCwgKGVycj86IEFwaUVycm9yLCBmaWxlcz86IHN0cmluZ1tdKSA9PiB7XG4gICAgICAgIHRoaXMuX211LnVubG9jaygpO1xuICAgICAgICBjYihlcnIsIGZpbGVzKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIHJlYWRkaXJTeW5jKHA6IHN0cmluZyk6IHN0cmluZ1tdIHtcbiAgICBpZiAodGhpcy5fbXUuaXNMb2NrZWQoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHN5bmMgY2FsbCcpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZnMucmVhZGRpclN5bmMocCk7XG4gIH1cblxuICBwdWJsaWMgZXhpc3RzKHA6IHN0cmluZywgY2I6IChleGlzdHM6IGJvb2xlYW4pID0+IHZvaWQpOiB2b2lkIHtcbiAgICB0aGlzLl9tdS5sb2NrKCgpID0+IHtcbiAgICAgIHRoaXMuX2ZzLmV4aXN0cyhwLCAoZXhpc3RzOiBib29sZWFuKSA9PiB7XG4gICAgICAgIHRoaXMuX211LnVubG9jaygpO1xuICAgICAgICBjYihleGlzdHMpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBwdWJsaWMgZXhpc3RzU3luYyhwOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBpZiAodGhpcy5fbXUuaXNMb2NrZWQoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHN5bmMgY2FsbCcpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZnMuZXhpc3RzU3luYyhwKTtcbiAgfVxuXG4gIHB1YmxpYyByZWFscGF0aChwOiBzdHJpbmcsIGNhY2hlOiB7W3BhdGg6IHN0cmluZ106IHN0cmluZ30sIGNiOiBCRlNDYWxsYmFjazxzdHJpbmc+KTogdm9pZCB7XG4gICAgdGhpcy5fbXUubG9jaygoKSA9PiB7XG4gICAgICB0aGlzLl9mcy5yZWFscGF0aChwLCBjYWNoZSwgKGVycj86IEFwaUVycm9yLCByZXNvbHZlZFBhdGg/OiBzdHJpbmcpID0+IHtcbiAgICAgICAgdGhpcy5fbXUudW5sb2NrKCk7XG4gICAgICAgIGNiKGVyciwgcmVzb2x2ZWRQYXRoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIHJlYWxwYXRoU3luYyhwOiBzdHJpbmcsIGNhY2hlOiB7W3BhdGg6IHN0cmluZ106IHN0cmluZ30pOiBzdHJpbmcge1xuICAgIGlmICh0aGlzLl9tdS5pc0xvY2tlZCgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc3luYyBjYWxsJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9mcy5yZWFscGF0aFN5bmMocCwgY2FjaGUpO1xuICB9XG5cbiAgcHVibGljIHRydW5jYXRlKHA6IHN0cmluZywgbGVuOiBudW1iZXIsIGNiOiBCRlNPbmVBcmdDYWxsYmFjayk6IHZvaWQge1xuICAgIHRoaXMuX211LmxvY2soKCkgPT4ge1xuICAgICAgdGhpcy5fZnMudHJ1bmNhdGUocCwgbGVuLCAoZXJyPzogQXBpRXJyb3IpID0+IHtcbiAgICAgICAgdGhpcy5fbXUudW5sb2NrKCk7XG4gICAgICAgIGNiKGVycik7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyB0cnVuY2F0ZVN5bmMocDogc3RyaW5nLCBsZW46IG51bWJlcik6IHZvaWQge1xuICAgIGlmICh0aGlzLl9tdS5pc0xvY2tlZCgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc3luYyBjYWxsJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9mcy50cnVuY2F0ZVN5bmMocCwgbGVuKTtcbiAgfVxuXG4gIHB1YmxpYyByZWFkRmlsZShmbmFtZTogc3RyaW5nLCBlbmNvZGluZzogc3RyaW5nLCBmbGFnOiBGaWxlRmxhZywgY2I6IEJGU0NhbGxiYWNrPHN0cmluZyB8IEJ1ZmZlcj4pOiB2b2lkIHtcbiAgICB0aGlzLl9tdS5sb2NrKCgpID0+IHtcbiAgICAgIHRoaXMuX2ZzLnJlYWRGaWxlKGZuYW1lLCBlbmNvZGluZywgZmxhZywgKGVycj86IEFwaUVycm9yLCBkYXRhPzogYW55KSA9PiB7XG4gICAgICAgIHRoaXMuX211LnVubG9jaygpO1xuICAgICAgICBjYihlcnIsIGRhdGEpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBwdWJsaWMgcmVhZEZpbGVTeW5jKGZuYW1lOiBzdHJpbmcsIGVuY29kaW5nOiBzdHJpbmcsIGZsYWc6IEZpbGVGbGFnKTogYW55IHtcbiAgICBpZiAodGhpcy5fbXUuaXNMb2NrZWQoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHN5bmMgY2FsbCcpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZnMucmVhZEZpbGVTeW5jKGZuYW1lLCBlbmNvZGluZywgZmxhZyk7XG4gIH1cblxuICBwdWJsaWMgd3JpdGVGaWxlKGZuYW1lOiBzdHJpbmcsIGRhdGE6IGFueSwgZW5jb2Rpbmc6IHN0cmluZywgZmxhZzogRmlsZUZsYWcsIG1vZGU6IG51bWJlciwgY2I6IEJGU09uZUFyZ0NhbGxiYWNrKTogdm9pZCB7XG4gICAgdGhpcy5fbXUubG9jaygoKSA9PiB7XG4gICAgICB0aGlzLl9mcy53cml0ZUZpbGUoZm5hbWUsIGRhdGEsIGVuY29kaW5nLCBmbGFnLCBtb2RlLCAoZXJyPzogQXBpRXJyb3IpID0+IHtcbiAgICAgICAgdGhpcy5fbXUudW5sb2NrKCk7XG4gICAgICAgIGNiKGVycik7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyB3cml0ZUZpbGVTeW5jKGZuYW1lOiBzdHJpbmcsIGRhdGE6IGFueSwgZW5jb2Rpbmc6IHN0cmluZywgZmxhZzogRmlsZUZsYWcsIG1vZGU6IG51bWJlcik6IHZvaWQge1xuICAgIGlmICh0aGlzLl9tdS5pc0xvY2tlZCgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc3luYyBjYWxsJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9mcy53cml0ZUZpbGVTeW5jKGZuYW1lLCBkYXRhLCBlbmNvZGluZywgZmxhZywgbW9kZSk7XG4gIH1cblxuICBwdWJsaWMgYXBwZW5kRmlsZShmbmFtZTogc3RyaW5nLCBkYXRhOiBhbnksIGVuY29kaW5nOiBzdHJpbmcsIGZsYWc6IEZpbGVGbGFnLCBtb2RlOiBudW1iZXIsIGNiOiBCRlNPbmVBcmdDYWxsYmFjayk6IHZvaWQge1xuICAgIHRoaXMuX211LmxvY2soKCkgPT4ge1xuICAgICAgdGhpcy5fZnMuYXBwZW5kRmlsZShmbmFtZSwgZGF0YSwgZW5jb2RpbmcsIGZsYWcsIG1vZGUsIChlcnI/OiBBcGlFcnJvcikgPT4ge1xuICAgICAgICB0aGlzLl9tdS51bmxvY2soKTtcbiAgICAgICAgY2IoZXJyKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIGFwcGVuZEZpbGVTeW5jKGZuYW1lOiBzdHJpbmcsIGRhdGE6IGFueSwgZW5jb2Rpbmc6IHN0cmluZywgZmxhZzogRmlsZUZsYWcsIG1vZGU6IG51bWJlcik6IHZvaWQge1xuICAgIGlmICh0aGlzLl9tdS5pc0xvY2tlZCgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc3luYyBjYWxsJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9mcy5hcHBlbmRGaWxlU3luYyhmbmFtZSwgZGF0YSwgZW5jb2RpbmcsIGZsYWcsIG1vZGUpO1xuICB9XG5cbiAgcHVibGljIGNobW9kKHA6IHN0cmluZywgaXNMY2htb2Q6IGJvb2xlYW4sIG1vZGU6IG51bWJlciwgY2I6IEJGU09uZUFyZ0NhbGxiYWNrKTogdm9pZCB7XG4gICAgdGhpcy5fbXUubG9jaygoKSA9PiB7XG4gICAgICB0aGlzLl9mcy5jaG1vZChwLCBpc0xjaG1vZCwgbW9kZSwgKGVycj86IEFwaUVycm9yKSA9PiB7XG4gICAgICAgIHRoaXMuX211LnVubG9jaygpO1xuICAgICAgICBjYihlcnIpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBwdWJsaWMgY2htb2RTeW5jKHA6IHN0cmluZywgaXNMY2htb2Q6IGJvb2xlYW4sIG1vZGU6IG51bWJlcik6IHZvaWQge1xuICAgIGlmICh0aGlzLl9tdS5pc0xvY2tlZCgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc3luYyBjYWxsJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9mcy5jaG1vZFN5bmMocCwgaXNMY2htb2QsIG1vZGUpO1xuICB9XG5cbiAgcHVibGljIGNob3duKHA6IHN0cmluZywgaXNMY2hvd246IGJvb2xlYW4sIHVpZDogbnVtYmVyLCBnaWQ6IG51bWJlciwgY2I6IEJGU09uZUFyZ0NhbGxiYWNrKTogdm9pZCB7XG4gICAgdGhpcy5fbXUubG9jaygoKSA9PiB7XG4gICAgICB0aGlzLl9mcy5jaG93bihwLCBpc0xjaG93biwgdWlkLCBnaWQsIChlcnI/OiBBcGlFcnJvcikgPT4ge1xuICAgICAgICB0aGlzLl9tdS51bmxvY2soKTtcbiAgICAgICAgY2IoZXJyKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIGNob3duU3luYyhwOiBzdHJpbmcsIGlzTGNob3duOiBib29sZWFuLCB1aWQ6IG51bWJlciwgZ2lkOiBudW1iZXIpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5fbXUuaXNMb2NrZWQoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHN5bmMgY2FsbCcpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZnMuY2hvd25TeW5jKHAsIGlzTGNob3duLCB1aWQsIGdpZCk7XG4gIH1cblxuICBwdWJsaWMgdXRpbWVzKHA6IHN0cmluZywgYXRpbWU6IERhdGUsIG10aW1lOiBEYXRlLCBjYjogQkZTT25lQXJnQ2FsbGJhY2spOiB2b2lkIHtcbiAgICB0aGlzLl9tdS5sb2NrKCgpID0+IHtcbiAgICAgIHRoaXMuX2ZzLnV0aW1lcyhwLCBhdGltZSwgbXRpbWUsIChlcnI/OiBBcGlFcnJvcikgPT4ge1xuICAgICAgICB0aGlzLl9tdS51bmxvY2soKTtcbiAgICAgICAgY2IoZXJyKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIHV0aW1lc1N5bmMocDogc3RyaW5nLCBhdGltZTogRGF0ZSwgbXRpbWU6IERhdGUpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5fbXUuaXNMb2NrZWQoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHN5bmMgY2FsbCcpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZnMudXRpbWVzU3luYyhwLCBhdGltZSwgbXRpbWUpO1xuICB9XG5cbiAgcHVibGljIGxpbmsoc3JjcGF0aDogc3RyaW5nLCBkc3RwYXRoOiBzdHJpbmcsIGNiOiBCRlNPbmVBcmdDYWxsYmFjayk6IHZvaWQge1xuICAgIHRoaXMuX211LmxvY2soKCkgPT4ge1xuICAgICAgdGhpcy5fZnMubGluayhzcmNwYXRoLCBkc3RwYXRoLCAoZXJyPzogQXBpRXJyb3IpID0+IHtcbiAgICAgICAgdGhpcy5fbXUudW5sb2NrKCk7XG4gICAgICAgIGNiKGVycik7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyBsaW5rU3luYyhzcmNwYXRoOiBzdHJpbmcsIGRzdHBhdGg6IHN0cmluZyk6IHZvaWQge1xuICAgIGlmICh0aGlzLl9tdS5pc0xvY2tlZCgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc3luYyBjYWxsJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9mcy5saW5rU3luYyhzcmNwYXRoLCBkc3RwYXRoKTtcbiAgfVxuXG4gIHB1YmxpYyBzeW1saW5rKHNyY3BhdGg6IHN0cmluZywgZHN0cGF0aDogc3RyaW5nLCB0eXBlOiBzdHJpbmcsIGNiOiBCRlNPbmVBcmdDYWxsYmFjayk6IHZvaWQge1xuICAgIHRoaXMuX211LmxvY2soKCkgPT4ge1xuICAgICAgdGhpcy5fZnMuc3ltbGluayhzcmNwYXRoLCBkc3RwYXRoLCB0eXBlLCAoZXJyPzogQXBpRXJyb3IpID0+IHtcbiAgICAgICAgdGhpcy5fbXUudW5sb2NrKCk7XG4gICAgICAgIGNiKGVycik7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyBzeW1saW5rU3luYyhzcmNwYXRoOiBzdHJpbmcsIGRzdHBhdGg6IHN0cmluZywgdHlwZTogc3RyaW5nKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuX211LmlzTG9ja2VkKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBzeW5jIGNhbGwnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2ZzLnN5bWxpbmtTeW5jKHNyY3BhdGgsIGRzdHBhdGgsIHR5cGUpO1xuICB9XG5cbiAgcHVibGljIHJlYWRsaW5rKHA6IHN0cmluZywgY2I6IEJGU0NhbGxiYWNrPHN0cmluZz4pOiB2b2lkIHtcbiAgICB0aGlzLl9tdS5sb2NrKCgpID0+IHtcbiAgICAgIHRoaXMuX2ZzLnJlYWRsaW5rKHAsIChlcnI/OiBBcGlFcnJvciwgbGlua1N0cmluZz86IHN0cmluZykgPT4ge1xuICAgICAgICB0aGlzLl9tdS51bmxvY2soKTtcbiAgICAgICAgY2IoZXJyLCBsaW5rU3RyaW5nKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIHJlYWRsaW5rU3luYyhwOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGlmICh0aGlzLl9tdS5pc0xvY2tlZCgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc3luYyBjYWxsJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9mcy5yZWFkbGlua1N5bmMocCk7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi8uLi8uLi8uLi9zcmMvZ2VuZXJpYy9sb2NrZWRfZnMudHMiLCJpbXBvcnQge0ZpbGVTeXN0ZW0sIEJhc2VGaWxlU3lzdGVtLCBCRlNPbmVBcmdDYWxsYmFjaywgQkZTQ2FsbGJhY2ssIEZpbGVTeXN0ZW1PcHRpb25zfSBmcm9tICcuLi9jb3JlL2ZpbGVfc3lzdGVtJztcbmltcG9ydCB7QXBpRXJyb3IsIEVycm9yQ29kZX0gZnJvbSAnLi4vY29yZS9hcGlfZXJyb3InO1xuaW1wb3J0IHtGaWxlRmxhZywgQWN0aW9uVHlwZX0gZnJvbSAnLi4vY29yZS9maWxlX2ZsYWcnO1xuaW1wb3J0IHtGaWxlfSBmcm9tICcuLi9jb3JlL2ZpbGUnO1xuaW1wb3J0IHtkZXByZWNhdGlvbk1lc3NhZ2V9IGZyb20gJy4uL2NvcmUvdXRpbCc7XG5pbXBvcnQge2RlZmF1bHQgYXMgU3RhdHN9IGZyb20gJy4uL2NvcmUvbm9kZV9mc19zdGF0cyc7XG5pbXBvcnQgUHJlbG9hZEZpbGUgZnJvbSAnLi4vZ2VuZXJpYy9wcmVsb2FkX2ZpbGUnO1xuaW1wb3J0IExvY2tlZEZTIGZyb20gJy4uL2dlbmVyaWMvbG9ja2VkX2ZzJztcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgZGVsZXRpb25Mb2dQYXRoID0gJy8uZGVsZXRlZEZpbGVzLmxvZyc7XG5cbi8qKlxuICogR2l2ZW4gYSByZWFkLW9ubHkgbW9kZSwgbWFrZXMgaXQgd3JpdGFibGUuXG4gKiBAaGlkZGVuXG4gKi9cbmZ1bmN0aW9uIG1ha2VNb2RlV3JpdGFibGUobW9kZTogbnVtYmVyKTogbnVtYmVyIHtcbiAgcmV0dXJuIDBvMjIyIHwgbW9kZTtcbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmZ1bmN0aW9uIGdldEZsYWcoZjogc3RyaW5nKTogRmlsZUZsYWcge1xuICByZXR1cm4gRmlsZUZsYWcuZ2V0RmlsZUZsYWcoZik7XG59XG5cbi8qKlxuICogT3ZlcmxheXMgYSBSTyBmaWxlIHRvIG1ha2UgaXQgd3JpdGFibGUuXG4gKi9cbmNsYXNzIE92ZXJsYXlGaWxlIGV4dGVuZHMgUHJlbG9hZEZpbGU8VW5sb2NrZWRPdmVybGF5RlM+IGltcGxlbWVudHMgRmlsZSB7XG4gIGNvbnN0cnVjdG9yKGZzOiBVbmxvY2tlZE92ZXJsYXlGUywgcGF0aDogc3RyaW5nLCBmbGFnOiBGaWxlRmxhZywgc3RhdHM6IFN0YXRzLCBkYXRhOiBCdWZmZXIpIHtcbiAgICBzdXBlcihmcywgcGF0aCwgZmxhZywgc3RhdHMsIGRhdGEpO1xuICB9XG5cbiAgcHVibGljIHN5bmMoY2I6IEJGU09uZUFyZ0NhbGxiYWNrKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLmlzRGlydHkoKSkge1xuICAgICAgY2IobnVsbCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fZnMuX3N5bmNBc3luYyh0aGlzLCAoZXJyOiBBcGlFcnJvcikgPT4ge1xuICAgICAgdGhpcy5yZXNldERpcnR5KCk7XG4gICAgICBjYihlcnIpO1xuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIHN5bmNTeW5jKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmlzRGlydHkoKSkge1xuICAgICAgdGhpcy5fZnMuX3N5bmNTeW5jKHRoaXMpO1xuICAgICAgdGhpcy5yZXNldERpcnR5KCk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGNsb3NlKGNiOiBCRlNPbmVBcmdDYWxsYmFjayk6IHZvaWQge1xuICAgIHRoaXMuc3luYyhjYik7XG4gIH1cblxuICBwdWJsaWMgY2xvc2VTeW5jKCk6IHZvaWQge1xuICAgIHRoaXMuc3luY1N5bmMoKTtcbiAgfVxufVxuXG4vKipcbiAqICpJTlRFUk5BTCwgRE8gTk9UIFVTRSBESVJFQ1RMWSEqXG4gKlxuICogQ29yZSBPdmVybGF5RlMgY2xhc3MgdGhhdCBjb250YWlucyBubyBsb2NraW5nIHdoYXRzb2V2ZXIuIFdlIHdyYXAgdGhlc2Ugb2JqZWN0c1xuICogaW4gYSBMb2NrZWRGUyB0byBwcmV2ZW50IHJhY2VzLlxuICovXG5leHBvcnQgY2xhc3MgVW5sb2NrZWRPdmVybGF5RlMgZXh0ZW5kcyBCYXNlRmlsZVN5c3RlbSBpbXBsZW1lbnRzIEZpbGVTeXN0ZW0ge1xuICBwdWJsaWMgc3RhdGljIGlzQXZhaWxhYmxlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcHJpdmF0ZSBfd3JpdGFibGU6IEZpbGVTeXN0ZW07XG4gIHByaXZhdGUgX3JlYWRhYmxlOiBGaWxlU3lzdGVtO1xuICBwcml2YXRlIF9pc0luaXRpYWxpemVkOiBib29sZWFuID0gZmFsc2U7XG4gIHByaXZhdGUgX2luaXRpYWxpemVDYWxsYmFja3M6IChCRlNPbmVBcmdDYWxsYmFjaylbXSA9IFtdO1xuICBwcml2YXRlIF9kZWxldGVkRmlsZXM6IHtbcGF0aDogc3RyaW5nXTogYm9vbGVhbn0gPSB7fTtcbiAgcHJpdmF0ZSBfZGVsZXRlTG9nOiBzdHJpbmcgPSAnJztcbiAgLy8gSWYgJ3RydWUnLCB3ZSBoYXZlIHNjaGVkdWxlZCBhIGRlbGV0ZSBsb2cgdXBkYXRlLlxuICBwcml2YXRlIF9kZWxldGVMb2dVcGRhdGVQZW5kaW5nOiBib29sZWFuID0gZmFsc2U7XG4gIC8vIElmICd0cnVlJywgYSBkZWxldGUgbG9nIHVwZGF0ZSBpcyBuZWVkZWQgYWZ0ZXIgdGhlIHNjaGVkdWxlZCBkZWxldGUgbG9nXG4gIC8vIHVwZGF0ZSBmaW5pc2hlcy5cbiAgcHJpdmF0ZSBfZGVsZXRlTG9nVXBkYXRlTmVlZGVkOiBib29sZWFuID0gZmFsc2U7XG4gIC8vIElmIHRoZXJlIHdhcyBhbiBlcnJvciB1cGRhdGluZyB0aGUgZGVsZXRlIGxvZy4uLlxuICBwcml2YXRlIF9kZWxldGVMb2dFcnJvcjogQXBpRXJyb3IgfCBudWxsID0gbnVsbDtcblxuICBjb25zdHJ1Y3Rvcih3cml0YWJsZTogRmlsZVN5c3RlbSwgcmVhZGFibGU6IEZpbGVTeXN0ZW0pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX3dyaXRhYmxlID0gd3JpdGFibGU7XG4gICAgdGhpcy5fcmVhZGFibGUgPSByZWFkYWJsZTtcbiAgICBpZiAodGhpcy5fd3JpdGFibGUuaXNSZWFkT25seSgpKSB7XG4gICAgICB0aHJvdyBuZXcgQXBpRXJyb3IoRXJyb3JDb2RlLkVJTlZBTCwgXCJXcml0YWJsZSBmaWxlIHN5c3RlbSBtdXN0IGJlIHdyaXRhYmxlLlwiKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgZ2V0T3ZlcmxheWVkRmlsZVN5c3RlbXMoKTogeyByZWFkYWJsZTogRmlsZVN5c3RlbTsgd3JpdGFibGU6IEZpbGVTeXN0ZW07IH0ge1xuICAgIHJldHVybiB7XG4gICAgICByZWFkYWJsZTogdGhpcy5fcmVhZGFibGUsXG4gICAgICB3cml0YWJsZTogdGhpcy5fd3JpdGFibGVcbiAgICB9O1xuICB9XG5cbiAgcHVibGljIF9zeW5jQXN5bmMoZmlsZTogUHJlbG9hZEZpbGU8VW5sb2NrZWRPdmVybGF5RlM+LCBjYjogQkZTT25lQXJnQ2FsbGJhY2spOiB2b2lkIHtcbiAgICB0aGlzLmNyZWF0ZVBhcmVudERpcmVjdG9yaWVzQXN5bmMoZmlsZS5nZXRQYXRoKCksIChlcnI/OiBBcGlFcnJvcikgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gY2IoZXJyKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3dyaXRhYmxlLndyaXRlRmlsZShmaWxlLmdldFBhdGgoKSwgZmlsZS5nZXRCdWZmZXIoKSwgbnVsbCwgZ2V0RmxhZygndycpLCBmaWxlLmdldFN0YXRzKCkubW9kZSwgY2IpO1xuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIF9zeW5jU3luYyhmaWxlOiBQcmVsb2FkRmlsZTxVbmxvY2tlZE92ZXJsYXlGUz4pOiB2b2lkIHtcbiAgICB0aGlzLmNyZWF0ZVBhcmVudERpcmVjdG9yaWVzKGZpbGUuZ2V0UGF0aCgpKTtcbiAgICB0aGlzLl93cml0YWJsZS53cml0ZUZpbGVTeW5jKGZpbGUuZ2V0UGF0aCgpLCBmaWxlLmdldEJ1ZmZlcigpLCBudWxsLCBnZXRGbGFnKCd3JyksIGZpbGUuZ2V0U3RhdHMoKS5tb2RlKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXROYW1lKCkge1xuICAgIHJldHVybiBPdmVybGF5RlMuTmFtZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsZWQgb25jZSB0byBsb2FkIHVwIG1ldGFkYXRhIHN0b3JlZCBvbiB0aGUgd3JpdGFibGUgZmlsZSBzeXN0ZW0uXG4gICAqL1xuICBwdWJsaWMgaW5pdGlhbGl6ZShjYjogQkZTT25lQXJnQ2FsbGJhY2spOiB2b2lkIHtcbiAgICBjb25zdCBjYWxsYmFja0FycmF5ID0gdGhpcy5faW5pdGlhbGl6ZUNhbGxiYWNrcztcblxuICAgIGNvbnN0IGVuZCA9IChlPzogQXBpRXJyb3IpOiB2b2lkID0+IHtcbiAgICAgIHRoaXMuX2lzSW5pdGlhbGl6ZWQgPSAhZTtcbiAgICAgIHRoaXMuX2luaXRpYWxpemVDYWxsYmFja3MgPSBbXTtcbiAgICAgIGNhbGxiYWNrQXJyYXkuZm9yRWFjaCgoKGNiKSA9PiBjYihlKSkpO1xuICAgIH07XG5cbiAgICAvLyBpZiB3ZSdyZSBhbHJlYWR5IGluaXRpYWxpemVkLCBpbW1lZGlhdGVseSBpbnZva2UgdGhlIGNhbGxiYWNrXG4gICAgaWYgKHRoaXMuX2lzSW5pdGlhbGl6ZWQpIHtcbiAgICAgIHJldHVybiBjYigpO1xuICAgIH1cblxuICAgIGNhbGxiYWNrQXJyYXkucHVzaChjYik7XG4gICAgLy8gVGhlIGZpcnN0IGNhbGwgdG8gaW5pdGlhbGl6ZSBpbml0aWFsaXplcywgdGhlIHJlc3Qgd2FpdCBmb3IgaXQgdG8gY29tcGxldGUuXG4gICAgaWYgKGNhbGxiYWNrQXJyYXkubGVuZ3RoICE9PSAxKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gUmVhZCBkZWxldGlvbiBsb2csIHByb2Nlc3MgaW50byBtZXRhZGF0YS5cbiAgICB0aGlzLl93cml0YWJsZS5yZWFkRmlsZShkZWxldGlvbkxvZ1BhdGgsICd1dGY4JywgZ2V0RmxhZygncicpLCAoZXJyOiBBcGlFcnJvciwgZGF0YT86IHN0cmluZykgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICAvLyBFTk9FTlQgPT09IE5ld2x5LWluc3RhbnRpYXRlZCBmaWxlIHN5c3RlbSwgYW5kIHRodXMgZW1wdHkgbG9nLlxuICAgICAgICBpZiAoZXJyLmVycm5vICE9PSBFcnJvckNvZGUuRU5PRU5UKSB7XG4gICAgICAgICAgcmV0dXJuIGVuZChlcnIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9kZWxldGVMb2cgPSBkYXRhITtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3JlcGFyc2VEZWxldGlvbkxvZygpO1xuICAgICAgZW5kKCk7XG4gICAgfSk7XG4gIH1cblxuICBwdWJsaWMgaXNSZWFkT25seSgpOiBib29sZWFuIHsgcmV0dXJuIGZhbHNlOyB9XG4gIHB1YmxpYyBzdXBwb3J0c1N5bmNoKCk6IGJvb2xlYW4geyByZXR1cm4gdGhpcy5fcmVhZGFibGUuc3VwcG9ydHNTeW5jaCgpICYmIHRoaXMuX3dyaXRhYmxlLnN1cHBvcnRzU3luY2goKTsgfVxuICBwdWJsaWMgc3VwcG9ydHNMaW5rcygpOiBib29sZWFuIHsgcmV0dXJuIGZhbHNlOyB9XG4gIHB1YmxpYyBzdXBwb3J0c1Byb3BzKCk6IGJvb2xlYW4geyByZXR1cm4gdGhpcy5fcmVhZGFibGUuc3VwcG9ydHNQcm9wcygpICYmIHRoaXMuX3dyaXRhYmxlLnN1cHBvcnRzUHJvcHMoKTsgfVxuXG4gIHB1YmxpYyBnZXREZWxldGlvbkxvZygpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl9kZWxldGVMb2c7XG4gIH1cblxuICBwdWJsaWMgcmVzdG9yZURlbGV0aW9uTG9nKGxvZzogc3RyaW5nKTogdm9pZCB7XG4gICAgdGhpcy5fZGVsZXRlTG9nID0gbG9nO1xuICAgIHRoaXMuX3JlcGFyc2VEZWxldGlvbkxvZygpO1xuICAgIHRoaXMudXBkYXRlTG9nKCcnKTtcbiAgfVxuXG4gIHB1YmxpYyByZW5hbWUob2xkUGF0aDogc3RyaW5nLCBuZXdQYXRoOiBzdHJpbmcsIGNiOiBCRlNPbmVBcmdDYWxsYmFjayk6IHZvaWQge1xuICAgIGlmICghdGhpcy5jaGVja0luaXRBc3luYyhjYikgfHwgdGhpcy5jaGVja1BhdGhBc3luYyhvbGRQYXRoLCBjYikgfHwgdGhpcy5jaGVja1BhdGhBc3luYyhuZXdQYXRoLCBjYikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAob2xkUGF0aCA9PT0gZGVsZXRpb25Mb2dQYXRoIHx8IG5ld1BhdGggPT09IGRlbGV0aW9uTG9nUGF0aCkge1xuICAgICAgcmV0dXJuIGNiKEFwaUVycm9yLkVQRVJNKCdDYW5ub3QgcmVuYW1lIGRlbGV0aW9uIGxvZy4nKSk7XG4gICAgfVxuXG4gICAgLy8gbm90aGluZyB0byBkbyBpZiBwYXRocyBtYXRjaFxuICAgIGlmIChvbGRQYXRoID09PSBuZXdQYXRoKSB7XG4gICAgICByZXR1cm4gY2IoKTtcbiAgICB9XG5cbiAgICB0aGlzLnN0YXQob2xkUGF0aCwgZmFsc2UsIChvbGRFcnI6IEFwaUVycm9yLCBvbGRTdGF0cz86IFN0YXRzKSA9PiB7XG4gICAgICBpZiAob2xkRXJyKSB7XG4gICAgICAgIHJldHVybiBjYihvbGRFcnIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5zdGF0KG5ld1BhdGgsIGZhbHNlLCAobmV3RXJyOiBBcGlFcnJvciwgbmV3U3RhdHM/OiBTdGF0cykgPT4ge1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgLy8gcHJlY29uZGl0aW9uOiBib3RoIG9sZFBhdGggYW5kIG5ld1BhdGggZXhpc3QgYW5kIGFyZSBkaXJzLlxuICAgICAgICAvLyBkZWNyZWFzZXM6IHxmaWxlc3xcbiAgICAgICAgLy8gTmVlZCB0byBtb3ZlICpldmVyeSBmaWxlL2ZvbGRlciogY3VycmVudGx5IHN0b3JlZCBvblxuICAgICAgICAvLyByZWFkYWJsZSB0byBpdHMgbmV3IGxvY2F0aW9uIG9uIHdyaXRhYmxlLlxuICAgICAgICBmdW5jdGlvbiBjb3B5RGlyQ29udGVudHMoZmlsZXM6IHN0cmluZ1tdKTogdm9pZCB7XG4gICAgICAgICAgY29uc3QgZmlsZSA9IGZpbGVzLnNoaWZ0KCk7XG4gICAgICAgICAgaWYgKCFmaWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gY2IoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBvbGRGaWxlID0gcGF0aC5yZXNvbHZlKG9sZFBhdGgsIGZpbGUpO1xuICAgICAgICAgIGNvbnN0IG5ld0ZpbGUgPSBwYXRoLnJlc29sdmUobmV3UGF0aCwgZmlsZSk7XG5cbiAgICAgICAgICAvLyBSZWN1cnNpb24hIFNob3VsZCB3b3JrIGZvciBhbnkgbmVzdGVkIGZpbGVzIC8gZm9sZGVycy5cbiAgICAgICAgICBzZWxmLnJlbmFtZShvbGRGaWxlLCBuZXdGaWxlLCAoZXJyPzogQXBpRXJyb3IpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNiKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb3B5RGlyQ29udGVudHMoZmlsZXMpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG1vZGUgPSAwbzc3NztcblxuICAgICAgICAvLyBmcm9tIGxpbnV4J3MgcmVuYW1lKDIpIG1hbnBhZ2U6IG9sZHBhdGggY2FuIHNwZWNpZnkgYVxuICAgICAgICAvLyBkaXJlY3RvcnkuICBJbiB0aGlzIGNhc2UsIG5ld3BhdGggbXVzdCBlaXRoZXIgbm90IGV4aXN0LCBvclxuICAgICAgICAvLyBpdCBtdXN0IHNwZWNpZnkgYW4gZW1wdHkgZGlyZWN0b3J5LlxuICAgICAgICBpZiAob2xkU3RhdHMhLmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgICAgICBpZiAobmV3RXJyKSB7XG4gICAgICAgICAgICBpZiAobmV3RXJyLmVycm5vICE9PSBFcnJvckNvZGUuRU5PRU5UKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjYihuZXdFcnIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd3JpdGFibGUuZXhpc3RzKG9sZFBhdGgsIChleGlzdHM6IGJvb2xlYW4pID0+IHtcbiAgICAgICAgICAgICAgLy8gc2ltcGxlIGNhc2UgLSBib3RoIG9sZCBhbmQgbmV3IGFyZSBvbiB0aGUgd3JpdGFibGUgbGF5ZXJcbiAgICAgICAgICAgICAgaWYgKGV4aXN0cykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93cml0YWJsZS5yZW5hbWUob2xkUGF0aCwgbmV3UGF0aCwgY2IpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdGhpcy5fd3JpdGFibGUubWtkaXIobmV3UGF0aCwgbW9kZSwgKG1rZGlyRXJyPzogQXBpRXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAobWtkaXJFcnIpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjYihta2RpckVycik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVhZGFibGUucmVhZGRpcihvbGRQYXRoLCAoZXJyOiBBcGlFcnJvciwgZmlsZXM/OiBzdHJpbmdbXSkgPT4ge1xuICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2IoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGNvcHlEaXJDb250ZW50cyhmaWxlcyEpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG1vZGUgPSBuZXdTdGF0cyEubW9kZTtcbiAgICAgICAgICBpZiAoIW5ld1N0YXRzIS5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gY2IoQXBpRXJyb3IuRU5PVERJUihuZXdQYXRoKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5yZWFkZGlyKG5ld1BhdGgsIChyZWFkZGlyRXJyOiBBcGlFcnJvciwgZmlsZXM/OiBzdHJpbmdbXSkgPT4ge1xuICAgICAgICAgICAgaWYgKGZpbGVzICYmIGZpbGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXR1cm4gY2IoQXBpRXJyb3IuRU5PVEVNUFRZKG5ld1BhdGgpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fcmVhZGFibGUucmVhZGRpcihvbGRQYXRoLCAoZXJyOiBBcGlFcnJvciwgZmlsZXM/OiBzdHJpbmdbXSkgPT4ge1xuICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNiKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29weURpckNvbnRlbnRzKGZpbGVzISk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuZXdTdGF0cyAmJiBuZXdTdGF0cy5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICAgICAgcmV0dXJuIGNiKEFwaUVycm9yLkVJU0RJUihuZXdQYXRoKSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJlYWRGaWxlKG9sZFBhdGgsIG51bGwsIGdldEZsYWcoJ3InKSwgKGVycjogQXBpRXJyb3IsIGRhdGE/OiBhbnkpID0+IHtcbiAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gY2IoZXJyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdGhpcy53cml0ZUZpbGUobmV3UGF0aCwgZGF0YSwgbnVsbCwgZ2V0RmxhZygndycpLCBvbGRTdGF0cyEubW9kZSwgKGVycjogQXBpRXJyb3IpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNiKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy51bmxpbmsob2xkUGF0aCwgY2IpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIHJlbmFtZVN5bmMob2xkUGF0aDogc3RyaW5nLCBuZXdQYXRoOiBzdHJpbmcpOiB2b2lkIHtcbiAgICB0aGlzLmNoZWNrSW5pdGlhbGl6ZWQoKTtcbiAgICB0aGlzLmNoZWNrUGF0aChvbGRQYXRoKTtcbiAgICB0aGlzLmNoZWNrUGF0aChuZXdQYXRoKTtcbiAgICBpZiAob2xkUGF0aCA9PT0gZGVsZXRpb25Mb2dQYXRoIHx8IG5ld1BhdGggPT09IGRlbGV0aW9uTG9nUGF0aCkge1xuICAgICAgdGhyb3cgQXBpRXJyb3IuRVBFUk0oJ0Nhbm5vdCByZW5hbWUgZGVsZXRpb24gbG9nLicpO1xuICAgIH1cbiAgICAvLyBXcml0ZSBuZXdQYXRoIHVzaW5nIG9sZFBhdGgncyBjb250ZW50cywgZGVsZXRlIG9sZFBhdGguXG4gICAgY29uc3Qgb2xkU3RhdHMgPSB0aGlzLnN0YXRTeW5jKG9sZFBhdGgsIGZhbHNlKTtcbiAgICBpZiAob2xkU3RhdHMuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgLy8gT3B0aW1pemF0aW9uOiBEb24ndCBib3RoZXIgbW92aW5nIGlmIG9sZCA9PT0gbmV3LlxuICAgICAgaWYgKG9sZFBhdGggPT09IG5ld1BhdGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBsZXQgbW9kZSA9IDBvNzc3O1xuICAgICAgaWYgKHRoaXMuZXhpc3RzU3luYyhuZXdQYXRoKSkge1xuICAgICAgICBjb25zdCBzdGF0cyA9IHRoaXMuc3RhdFN5bmMobmV3UGF0aCwgZmFsc2UpO1xuICAgICAgICBtb2RlID0gc3RhdHMubW9kZTtcbiAgICAgICAgaWYgKHN0YXRzLmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgICAgICBpZiAodGhpcy5yZWFkZGlyU3luYyhuZXdQYXRoKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aHJvdyBBcGlFcnJvci5FTk9URU1QVFkobmV3UGF0aCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IEFwaUVycm9yLkVOT1RESVIobmV3UGF0aCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGFrZSBjYXJlIG9mIHdyaXRhYmxlIGZpcnN0LiBNb3ZlIGFueSBmaWxlcyB0aGVyZSwgb3IgY3JlYXRlIGFuIGVtcHR5IGRpcmVjdG9yeVxuICAgICAgLy8gaWYgaXQgZG9lc24ndCBleGlzdC5cbiAgICAgIGlmICh0aGlzLl93cml0YWJsZS5leGlzdHNTeW5jKG9sZFBhdGgpKSB7XG4gICAgICAgIHRoaXMuX3dyaXRhYmxlLnJlbmFtZVN5bmMob2xkUGF0aCwgbmV3UGF0aCk7XG4gICAgICB9IGVsc2UgaWYgKCF0aGlzLl93cml0YWJsZS5leGlzdHNTeW5jKG5ld1BhdGgpKSB7XG4gICAgICAgIHRoaXMuX3dyaXRhYmxlLm1rZGlyU3luYyhuZXdQYXRoLCBtb2RlKTtcbiAgICAgIH1cblxuICAgICAgLy8gTmVlZCB0byBtb3ZlICpldmVyeSBmaWxlL2ZvbGRlciogY3VycmVudGx5IHN0b3JlZCBvbiByZWFkYWJsZSB0byBpdHMgbmV3IGxvY2F0aW9uXG4gICAgICAvLyBvbiB3cml0YWJsZS5cbiAgICAgIGlmICh0aGlzLl9yZWFkYWJsZS5leGlzdHNTeW5jKG9sZFBhdGgpKSB7XG4gICAgICAgIHRoaXMuX3JlYWRhYmxlLnJlYWRkaXJTeW5jKG9sZFBhdGgpLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgICAgICAvLyBSZWN1cnNpb24hIFNob3VsZCB3b3JrIGZvciBhbnkgbmVzdGVkIGZpbGVzIC8gZm9sZGVycy5cbiAgICAgICAgICB0aGlzLnJlbmFtZVN5bmMocGF0aC5yZXNvbHZlKG9sZFBhdGgsIG5hbWUpLCBwYXRoLnJlc29sdmUobmV3UGF0aCwgbmFtZSkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMuZXhpc3RzU3luYyhuZXdQYXRoKSAmJiB0aGlzLnN0YXRTeW5jKG5ld1BhdGgsIGZhbHNlKS5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICAgIHRocm93IEFwaUVycm9yLkVJU0RJUihuZXdQYXRoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy53cml0ZUZpbGVTeW5jKG5ld1BhdGgsXG4gICAgICAgIHRoaXMucmVhZEZpbGVTeW5jKG9sZFBhdGgsIG51bGwsIGdldEZsYWcoJ3InKSksIG51bGwsIGdldEZsYWcoJ3cnKSwgb2xkU3RhdHMubW9kZSk7XG4gICAgfVxuXG4gICAgaWYgKG9sZFBhdGggIT09IG5ld1BhdGggJiYgdGhpcy5leGlzdHNTeW5jKG9sZFBhdGgpKSB7XG4gICAgICB0aGlzLnVubGlua1N5bmMob2xkUGF0aCk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHN0YXQocDogc3RyaW5nLCBpc0xzdGF0OiBib29sZWFuLCBjYjogQkZTQ2FsbGJhY2s8U3RhdHM+KTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLmNoZWNrSW5pdEFzeW5jKGNiKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl93cml0YWJsZS5zdGF0KHAsIGlzTHN0YXQsIChlcnI6IEFwaUVycm9yLCBzdGF0PzogU3RhdHMpID0+IHtcbiAgICAgIGlmIChlcnIgJiYgZXJyLmVycm5vID09PSBFcnJvckNvZGUuRU5PRU5UKSB7XG4gICAgICAgIGlmICh0aGlzLl9kZWxldGVkRmlsZXNbcF0pIHtcbiAgICAgICAgICBjYihBcGlFcnJvci5FTk9FTlQocCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3JlYWRhYmxlLnN0YXQocCwgaXNMc3RhdCwgKGVycjogQXBpRXJyb3IsIHN0YXQ/OiBTdGF0cykgPT4ge1xuICAgICAgICAgIGlmIChzdGF0KSB7XG4gICAgICAgICAgICAvLyBNYWtlIHRoZSBvbGRTdGF0J3MgbW9kZSB3cml0YWJsZS4gUHJlc2VydmUgdGhlIHRvcG1vc3RcbiAgICAgICAgICAgIC8vIHBhcnQgb2YgdGhlIG1vZGUsIHdoaWNoIHNwZWNpZmllcyBpZiBpdCBpcyBhIGZpbGUgb3IgYVxuICAgICAgICAgICAgLy8gZGlyZWN0b3J5LlxuICAgICAgICAgICAgc3RhdCA9IHN0YXQuY2xvbmUoKTtcbiAgICAgICAgICAgIHN0YXQubW9kZSA9IG1ha2VNb2RlV3JpdGFibGUoc3RhdC5tb2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2IoZXJyLCBzdGF0KTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYihlcnIsIHN0YXQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIHN0YXRTeW5jKHA6IHN0cmluZywgaXNMc3RhdDogYm9vbGVhbik6IFN0YXRzIHtcbiAgICB0aGlzLmNoZWNrSW5pdGlhbGl6ZWQoKTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlLnN0YXRTeW5jKHAsIGlzTHN0YXQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmICh0aGlzLl9kZWxldGVkRmlsZXNbcF0pIHtcbiAgICAgICAgdGhyb3cgQXBpRXJyb3IuRU5PRU5UKHApO1xuICAgICAgfVxuICAgICAgY29uc3Qgb2xkU3RhdCA9IHRoaXMuX3JlYWRhYmxlLnN0YXRTeW5jKHAsIGlzTHN0YXQpLmNsb25lKCk7XG4gICAgICAvLyBNYWtlIHRoZSBvbGRTdGF0J3MgbW9kZSB3cml0YWJsZS4gUHJlc2VydmUgdGhlIHRvcG1vc3QgcGFydCBvZiB0aGVcbiAgICAgIC8vIG1vZGUsIHdoaWNoIHNwZWNpZmllcyBpZiBpdCBpcyBhIGZpbGUgb3IgYSBkaXJlY3RvcnkuXG4gICAgICBvbGRTdGF0Lm1vZGUgPSBtYWtlTW9kZVdyaXRhYmxlKG9sZFN0YXQubW9kZSk7XG4gICAgICByZXR1cm4gb2xkU3RhdDtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgb3BlbihwOiBzdHJpbmcsIGZsYWc6IEZpbGVGbGFnLCBtb2RlOiBudW1iZXIsIGNiOiBCRlNDYWxsYmFjazxGaWxlPik6IHZvaWQge1xuICAgIGlmICghdGhpcy5jaGVja0luaXRBc3luYyhjYikgfHwgdGhpcy5jaGVja1BhdGhBc3luYyhwLCBjYikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zdGF0KHAsIGZhbHNlLCAoZXJyOiBBcGlFcnJvciwgc3RhdHM/OiBTdGF0cykgPT4ge1xuICAgICAgaWYgKHN0YXRzKSB7XG4gICAgICAgIHN3aXRjaCAoZmxhZy5wYXRoRXhpc3RzQWN0aW9uKCkpIHtcbiAgICAgICAgY2FzZSBBY3Rpb25UeXBlLlRSVU5DQVRFX0ZJTEU6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlUGFyZW50RGlyZWN0b3JpZXNBc3luYyhwLCAoZXJyPzogQXBpRXJyb3IpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNiKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl93cml0YWJsZS5vcGVuKHAsIGZsYWcsIG1vZGUsIGNiKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgY2FzZSBBY3Rpb25UeXBlLk5PUDpcbiAgICAgICAgICByZXR1cm4gdGhpcy5fd3JpdGFibGUuZXhpc3RzKHAsIChleGlzdHM6IGJvb2xlYW4pID0+IHtcbiAgICAgICAgICAgIGlmIChleGlzdHMpIHtcbiAgICAgICAgICAgICAgdGhpcy5fd3JpdGFibGUub3BlbihwLCBmbGFnLCBtb2RlLCBjYik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBhdCB0aGlzIHBvaW50IHdlIGtub3cgdGhlIHN0YXRzIG9iamVjdCB3ZSBnb3QgaXMgZnJvbVxuICAgICAgICAgICAgICAvLyB0aGUgcmVhZGFibGUgRlMuXG4gICAgICAgICAgICAgIHN0YXRzID0gc3RhdHMhLmNsb25lKCk7XG4gICAgICAgICAgICAgIHN0YXRzLm1vZGUgPSBtb2RlO1xuICAgICAgICAgICAgICB0aGlzLl9yZWFkYWJsZS5yZWFkRmlsZShwLCBudWxsLCBnZXRGbGFnKCdyJyksIChyZWFkRmlsZUVycjogQXBpRXJyb3IsIGRhdGE/OiBhbnkpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocmVhZEZpbGVFcnIpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjYihyZWFkRmlsZUVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzdGF0cyEuc2l6ZSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgIHN0YXRzIS5zaXplID0gZGF0YS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGYgPSBuZXcgT3ZlcmxheUZpbGUodGhpcywgcCwgZmxhZywgc3RhdHMhLCBkYXRhKTtcbiAgICAgICAgICAgICAgICBjYihudWxsLCBmKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIGNiKEFwaUVycm9yLkVFWElTVChwKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN3aXRjaCAoZmxhZy5wYXRoTm90RXhpc3RzQWN0aW9uKCkpIHtcbiAgICAgICAgY2FzZSBBY3Rpb25UeXBlLkNSRUFURV9GSUxFOlxuICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVBhcmVudERpcmVjdG9yaWVzQXN5bmMocCwgKGVycj86IEFwaUVycm9yKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjYihlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlLm9wZW4ocCwgZmxhZywgbW9kZSwgY2IpO1xuICAgICAgICAgIH0pO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBjYihBcGlFcnJvci5FTk9FTlQocCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBwdWJsaWMgb3BlblN5bmMocDogc3RyaW5nLCBmbGFnOiBGaWxlRmxhZywgbW9kZTogbnVtYmVyKTogRmlsZSB7XG4gICAgdGhpcy5jaGVja0luaXRpYWxpemVkKCk7XG4gICAgdGhpcy5jaGVja1BhdGgocCk7XG4gICAgaWYgKHAgPT09IGRlbGV0aW9uTG9nUGF0aCkge1xuICAgICAgdGhyb3cgQXBpRXJyb3IuRVBFUk0oJ0Nhbm5vdCBvcGVuIGRlbGV0aW9uIGxvZy4nKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZXhpc3RzU3luYyhwKSkge1xuICAgICAgc3dpdGNoIChmbGFnLnBhdGhFeGlzdHNBY3Rpb24oKSkge1xuICAgICAgICBjYXNlIEFjdGlvblR5cGUuVFJVTkNBVEVfRklMRTpcbiAgICAgICAgICB0aGlzLmNyZWF0ZVBhcmVudERpcmVjdG9yaWVzKHApO1xuICAgICAgICAgIHJldHVybiB0aGlzLl93cml0YWJsZS5vcGVuU3luYyhwLCBmbGFnLCBtb2RlKTtcbiAgICAgICAgY2FzZSBBY3Rpb25UeXBlLk5PUDpcbiAgICAgICAgICBpZiAodGhpcy5fd3JpdGFibGUuZXhpc3RzU3luYyhwKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlLm9wZW5TeW5jKHAsIGZsYWcsIG1vZGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYW4gT3ZlcmxheUZpbGUuXG4gICAgICAgICAgICBjb25zdCBidWYgPSB0aGlzLl9yZWFkYWJsZS5yZWFkRmlsZVN5bmMocCwgbnVsbCwgZ2V0RmxhZygncicpKTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRzID0gdGhpcy5fcmVhZGFibGUuc3RhdFN5bmMocCwgZmFsc2UpLmNsb25lKCk7XG4gICAgICAgICAgICBzdGF0cy5tb2RlID0gbW9kZTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgT3ZlcmxheUZpbGUodGhpcywgcCwgZmxhZywgc3RhdHMsIGJ1Zik7XG4gICAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IEFwaUVycm9yLkVFWElTVChwKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3dpdGNoIChmbGFnLnBhdGhOb3RFeGlzdHNBY3Rpb24oKSkge1xuICAgICAgICBjYXNlIEFjdGlvblR5cGUuQ1JFQVRFX0ZJTEU6XG4gICAgICAgICAgdGhpcy5jcmVhdGVQYXJlbnREaXJlY3RvcmllcyhwKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fd3JpdGFibGUub3BlblN5bmMocCwgZmxhZywgbW9kZSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgQXBpRXJyb3IuRU5PRU5UKHApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyB1bmxpbmsocDogc3RyaW5nLCBjYjogQkZTT25lQXJnQ2FsbGJhY2spOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuY2hlY2tJbml0QXN5bmMoY2IpIHx8IHRoaXMuY2hlY2tQYXRoQXN5bmMocCwgY2IpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZXhpc3RzKHAsIChleGlzdHM6IGJvb2xlYW4pID0+IHtcbiAgICAgIGlmICghZXhpc3RzKSB7XG4gICAgICAgIHJldHVybiBjYihBcGlFcnJvci5FTk9FTlQocCkpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl93cml0YWJsZS5leGlzdHMocCwgKHdyaXRhYmxlRXhpc3RzOiBib29sZWFuKSA9PiB7XG4gICAgICAgIGlmICh3cml0YWJsZUV4aXN0cykge1xuICAgICAgICAgIHJldHVybiB0aGlzLl93cml0YWJsZS51bmxpbmsocCwgKGVycjogQXBpRXJyb3IpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNiKGVycik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuZXhpc3RzKHAsIChyZWFkYWJsZUV4aXN0czogYm9vbGVhbikgPT4ge1xuICAgICAgICAgICAgICBpZiAocmVhZGFibGVFeGlzdHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlbGV0ZVBhdGgocCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2IobnVsbCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBpZiB0aGlzIG9ubHkgZXhpc3RzIG9uIHRoZSByZWFkYWJsZSBGUywgYWRkIGl0IHRvIHRoZVxuICAgICAgICAgIC8vIGRlbGV0ZSBtYXAuXG4gICAgICAgICAgdGhpcy5kZWxldGVQYXRoKHApO1xuICAgICAgICAgIGNiKG51bGwpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyB1bmxpbmtTeW5jKHA6IHN0cmluZyk6IHZvaWQge1xuICAgIHRoaXMuY2hlY2tJbml0aWFsaXplZCgpO1xuICAgIHRoaXMuY2hlY2tQYXRoKHApO1xuICAgIGlmICh0aGlzLmV4aXN0c1N5bmMocCkpIHtcbiAgICAgIGlmICh0aGlzLl93cml0YWJsZS5leGlzdHNTeW5jKHApKSB7XG4gICAgICAgIHRoaXMuX3dyaXRhYmxlLnVubGlua1N5bmMocCk7XG4gICAgICB9XG5cbiAgICAgIC8vIGlmIGl0IHN0aWxsIGV4aXN0cyBhZGQgdG8gdGhlIGRlbGV0ZSBsb2dcbiAgICAgIGlmICh0aGlzLmV4aXN0c1N5bmMocCkpIHtcbiAgICAgICAgdGhpcy5kZWxldGVQYXRoKHApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBBcGlFcnJvci5FTk9FTlQocCk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHJtZGlyKHA6IHN0cmluZywgY2I6IEJGU09uZUFyZ0NhbGxiYWNrKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLmNoZWNrSW5pdEFzeW5jKGNiKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHJtZGlyTG93ZXIgPSAoKTogdm9pZCA9PiB7XG4gICAgICB0aGlzLnJlYWRkaXIocCwgKGVycjogQXBpRXJyb3IsIGZpbGVzOiBzdHJpbmdbXSk6IHZvaWQgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgcmV0dXJuIGNiKGVycik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZmlsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIGNiKEFwaUVycm9yLkVOT1RFTVBUWShwKSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRlbGV0ZVBhdGgocCk7XG4gICAgICAgIGNiKG51bGwpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHRoaXMuZXhpc3RzKHAsIChleGlzdHM6IGJvb2xlYW4pID0+IHtcbiAgICAgIGlmICghZXhpc3RzKSB7XG4gICAgICAgIHJldHVybiBjYihBcGlFcnJvci5FTk9FTlQocCkpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl93cml0YWJsZS5leGlzdHMocCwgKHdyaXRhYmxlRXhpc3RzOiBib29sZWFuKSA9PiB7XG4gICAgICAgIGlmICh3cml0YWJsZUV4aXN0cykge1xuICAgICAgICAgIHRoaXMuX3dyaXRhYmxlLnJtZGlyKHAsIChlcnI6IEFwaUVycm9yKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjYihlcnIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9yZWFkYWJsZS5leGlzdHMocCwgKHJlYWRhYmxlRXhpc3RzOiBib29sZWFuKSA9PiB7XG4gICAgICAgICAgICAgIGlmIChyZWFkYWJsZUV4aXN0cykge1xuICAgICAgICAgICAgICAgIHJtZGlyTG93ZXIoKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBybWRpckxvd2VyKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIHJtZGlyU3luYyhwOiBzdHJpbmcpOiB2b2lkIHtcbiAgICB0aGlzLmNoZWNrSW5pdGlhbGl6ZWQoKTtcbiAgICBpZiAodGhpcy5leGlzdHNTeW5jKHApKSB7XG4gICAgICBpZiAodGhpcy5fd3JpdGFibGUuZXhpc3RzU3luYyhwKSkge1xuICAgICAgICB0aGlzLl93cml0YWJsZS5ybWRpclN5bmMocCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5leGlzdHNTeW5jKHApKSB7XG4gICAgICAgIC8vIENoZWNrIGlmIGRpcmVjdG9yeSBpcyBlbXB0eS5cbiAgICAgICAgaWYgKHRoaXMucmVhZGRpclN5bmMocCkubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHRocm93IEFwaUVycm9yLkVOT1RFTVBUWShwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmRlbGV0ZVBhdGgocCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgQXBpRXJyb3IuRU5PRU5UKHApO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBta2RpcihwOiBzdHJpbmcsIG1vZGU6IG51bWJlciwgY2I6IEJGU0NhbGxiYWNrPFN0YXRzPik6IHZvaWQge1xuICAgIGlmICghdGhpcy5jaGVja0luaXRBc3luYyhjYikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5leGlzdHMocCwgKGV4aXN0czogYm9vbGVhbikgPT4ge1xuICAgICAgaWYgKGV4aXN0cykge1xuICAgICAgICByZXR1cm4gY2IoQXBpRXJyb3IuRUVYSVNUKHApKTtcbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGJlbG93IHdpbGwgdGhyb3cgc2hvdWxkIGFueSBvZiB0aGUgcGFyZW50IGRpcmVjdG9yaWVzXG4gICAgICAvLyBmYWlsIHRvIGV4aXN0IG9uIF93cml0YWJsZS5cbiAgICAgIHRoaXMuY3JlYXRlUGFyZW50RGlyZWN0b3JpZXNBc3luYyhwLCAoZXJyOiBBcGlFcnJvcikgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgcmV0dXJuIGNiKGVycik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fd3JpdGFibGUubWtkaXIocCwgbW9kZSwgY2IpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBwdWJsaWMgbWtkaXJTeW5jKHA6IHN0cmluZywgbW9kZTogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5jaGVja0luaXRpYWxpemVkKCk7XG4gICAgaWYgKHRoaXMuZXhpc3RzU3luYyhwKSkge1xuICAgICAgdGhyb3cgQXBpRXJyb3IuRUVYSVNUKHApO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGUgYmVsb3cgd2lsbCB0aHJvdyBzaG91bGQgYW55IG9mIHRoZSBwYXJlbnQgZGlyZWN0b3JpZXMgZmFpbCB0byBleGlzdFxuICAgICAgLy8gb24gX3dyaXRhYmxlLlxuICAgICAgdGhpcy5jcmVhdGVQYXJlbnREaXJlY3RvcmllcyhwKTtcbiAgICAgIHRoaXMuX3dyaXRhYmxlLm1rZGlyU3luYyhwLCBtb2RlKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgcmVhZGRpcihwOiBzdHJpbmcsIGNiOiBCRlNDYWxsYmFjazxzdHJpbmdbXT4pOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuY2hlY2tJbml0QXN5bmMoY2IpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuc3RhdChwLCBmYWxzZSwgKGVycjogQXBpRXJyb3IsIGRpclN0YXRzPzogU3RhdHMpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGNiKGVycik7XG4gICAgICB9XG5cbiAgICAgIGlmICghZGlyU3RhdHMhLmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgICAgcmV0dXJuIGNiKEFwaUVycm9yLkVOT1RESVIocCkpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl93cml0YWJsZS5yZWFkZGlyKHAsIChlcnI6IEFwaUVycm9yLCB3RmlsZXM6IHN0cmluZ1tdKSA9PiB7XG4gICAgICAgIGlmIChlcnIgJiYgZXJyLmNvZGUgIT09ICdFTk9FTlQnKSB7XG4gICAgICAgICAgcmV0dXJuIGNiKGVycik7XG4gICAgICAgIH0gZWxzZSBpZiAoZXJyIHx8ICF3RmlsZXMpIHtcbiAgICAgICAgICB3RmlsZXMgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3JlYWRhYmxlLnJlYWRkaXIocCwgKGVycjogQXBpRXJyb3IsIHJGaWxlczogc3RyaW5nW10pID0+IHtcbiAgICAgICAgICAvLyBpZiB0aGUgZGlyZWN0b3J5IGRvZXNuJ3QgZXhpc3Qgb24gdGhlIGxvd2VyIEZTIHNldCByRmlsZXNcbiAgICAgICAgICAvLyBoZXJlIHRvIHNpbXBsaWZ5IHRoZSBmb2xsb3dpbmcgY29kZS5cbiAgICAgICAgICBpZiAoZXJyIHx8ICFyRmlsZXMpIHtcbiAgICAgICAgICAgIHJGaWxlcyA9IFtdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFJlYWRkaXIgaW4gYm90aCwgY2hlY2sgZGVsZXRlIGxvZyBvbiByZWFkLW9ubHkgZmlsZSBzeXN0ZW0ncyBmaWxlcywgbWVyZ2UsIHJldHVybi5cbiAgICAgICAgICBjb25zdCBzZWVuTWFwOiB7W25hbWU6IHN0cmluZ106IGJvb2xlYW59ID0ge307XG4gICAgICAgICAgY29uc3QgZmlsdGVyZWQ6IHN0cmluZ1tdID0gd0ZpbGVzLmNvbmNhdChyRmlsZXMuZmlsdGVyKChmUGF0aDogc3RyaW5nKSA9PlxuICAgICAgICAgICAgIXRoaXMuX2RlbGV0ZWRGaWxlc1tgJHtwfS8ke2ZQYXRofWBdXG4gICAgICAgICAgKSkuZmlsdGVyKChmUGF0aDogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgICAvLyBSZW1vdmUgZHVwbGljYXRlcy5cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9ICFzZWVuTWFwW2ZQYXRoXTtcbiAgICAgICAgICAgIHNlZW5NYXBbZlBhdGhdID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY2IobnVsbCwgZmlsdGVyZWQpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIHJlYWRkaXJTeW5jKHA6IHN0cmluZyk6IHN0cmluZ1tdIHtcbiAgICB0aGlzLmNoZWNrSW5pdGlhbGl6ZWQoKTtcbiAgICBjb25zdCBkaXJTdGF0cyA9IHRoaXMuc3RhdFN5bmMocCwgZmFsc2UpO1xuICAgIGlmICghZGlyU3RhdHMuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgdGhyb3cgQXBpRXJyb3IuRU5PVERJUihwKTtcbiAgICB9XG5cbiAgICAvLyBSZWFkZGlyIGluIGJvdGgsIGNoZWNrIGRlbGV0ZSBsb2cgb24gUk8gZmlsZSBzeXN0ZW0ncyBsaXN0aW5nLCBtZXJnZSwgcmV0dXJuLlxuICAgIGxldCBjb250ZW50czogc3RyaW5nW10gPSBbXTtcbiAgICB0cnkge1xuICAgICAgY29udGVudHMgPSBjb250ZW50cy5jb25jYXQodGhpcy5fd3JpdGFibGUucmVhZGRpclN5bmMocCkpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIE5PUC5cbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnRlbnRzID0gY29udGVudHMuY29uY2F0KHRoaXMuX3JlYWRhYmxlLnJlYWRkaXJTeW5jKHApLmZpbHRlcigoZlBhdGg6IHN0cmluZykgPT5cbiAgICAgICAgIXRoaXMuX2RlbGV0ZWRGaWxlc1tgJHtwfS8ke2ZQYXRofWBdXG4gICAgICApKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBOT1AuXG4gICAgfVxuICAgIGNvbnN0IHNlZW5NYXA6IHtbbmFtZTogc3RyaW5nXTogYm9vbGVhbn0gPSB7fTtcbiAgICByZXR1cm4gY29udGVudHMuZmlsdGVyKChmaWxlUDogc3RyaW5nKSA9PiB7XG4gICAgICBjb25zdCByZXN1bHQgPSAhc2Vlbk1hcFtmaWxlUF07XG4gICAgICBzZWVuTWFwW2ZpbGVQXSA9IHRydWU7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIGV4aXN0cyhwOiBzdHJpbmcsIGNiOiAoZXhpc3RzOiBib29sZWFuKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgLy8gQ2Fubm90IHBhc3MgYW4gZXJyb3IgYmFjayB0byBjYWxsYmFjaywgc28gdGhyb3cgYW4gZXhjZXB0aW9uIGluc3RlYWRcbiAgICAvLyBpZiBub3QgaW5pdGlhbGl6ZWQuXG4gICAgdGhpcy5jaGVja0luaXRpYWxpemVkKCk7XG4gICAgdGhpcy5fd3JpdGFibGUuZXhpc3RzKHAsIChleGlzdHNXcml0YWJsZTogYm9vbGVhbikgPT4ge1xuICAgICAgaWYgKGV4aXN0c1dyaXRhYmxlKSB7XG4gICAgICAgIHJldHVybiBjYih0cnVlKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fcmVhZGFibGUuZXhpc3RzKHAsIChleGlzdHNSZWFkYWJsZTogYm9vbGVhbikgPT4ge1xuICAgICAgICBjYihleGlzdHNSZWFkYWJsZSAmJiB0aGlzLl9kZWxldGVkRmlsZXNbcF0gIT09IHRydWUpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBwdWJsaWMgZXhpc3RzU3luYyhwOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICB0aGlzLmNoZWNrSW5pdGlhbGl6ZWQoKTtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGUuZXhpc3RzU3luYyhwKSB8fCAodGhpcy5fcmVhZGFibGUuZXhpc3RzU3luYyhwKSAmJiB0aGlzLl9kZWxldGVkRmlsZXNbcF0gIT09IHRydWUpO1xuICB9XG5cbiAgcHVibGljIGNobW9kKHA6IHN0cmluZywgaXNMY2htb2Q6IGJvb2xlYW4sIG1vZGU6IG51bWJlciwgY2I6IEJGU09uZUFyZ0NhbGxiYWNrKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLmNoZWNrSW5pdEFzeW5jKGNiKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLm9wZXJhdGVPbldyaXRhYmxlQXN5bmMocCwgKGVycj86IEFwaUVycm9yKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJldHVybiBjYihlcnIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fd3JpdGFibGUuY2htb2QocCwgaXNMY2htb2QsIG1vZGUsIGNiKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyBjaG1vZFN5bmMocDogc3RyaW5nLCBpc0xjaG1vZDogYm9vbGVhbiwgbW9kZTogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5jaGVja0luaXRpYWxpemVkKCk7XG4gICAgdGhpcy5vcGVyYXRlT25Xcml0YWJsZShwLCAoKSA9PiB7XG4gICAgICB0aGlzLl93cml0YWJsZS5jaG1vZFN5bmMocCwgaXNMY2htb2QsIG1vZGUpO1xuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIGNob3duKHA6IHN0cmluZywgaXNMY2htb2Q6IGJvb2xlYW4sIHVpZDogbnVtYmVyLCBnaWQ6IG51bWJlciwgY2I6IEJGU09uZUFyZ0NhbGxiYWNrKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLmNoZWNrSW5pdEFzeW5jKGNiKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLm9wZXJhdGVPbldyaXRhYmxlQXN5bmMocCwgKGVycj86IEFwaUVycm9yKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJldHVybiBjYihlcnIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fd3JpdGFibGUuY2hvd24ocCwgaXNMY2htb2QsIHVpZCwgZ2lkLCBjYik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBwdWJsaWMgY2hvd25TeW5jKHA6IHN0cmluZywgaXNMY2hvd246IGJvb2xlYW4sIHVpZDogbnVtYmVyLCBnaWQ6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMuY2hlY2tJbml0aWFsaXplZCgpO1xuICAgIHRoaXMub3BlcmF0ZU9uV3JpdGFibGUocCwgKCkgPT4ge1xuICAgICAgdGhpcy5fd3JpdGFibGUuY2hvd25TeW5jKHAsIGlzTGNob3duLCB1aWQsIGdpZCk7XG4gICAgfSk7XG4gIH1cblxuICBwdWJsaWMgdXRpbWVzKHA6IHN0cmluZywgYXRpbWU6IERhdGUsIG10aW1lOiBEYXRlLCBjYjogQkZTT25lQXJnQ2FsbGJhY2spOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuY2hlY2tJbml0QXN5bmMoY2IpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMub3BlcmF0ZU9uV3JpdGFibGVBc3luYyhwLCAoZXJyPzogQXBpRXJyb3IpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGNiKGVycik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl93cml0YWJsZS51dGltZXMocCwgYXRpbWUsIG10aW1lLCBjYik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBwdWJsaWMgdXRpbWVzU3luYyhwOiBzdHJpbmcsIGF0aW1lOiBEYXRlLCBtdGltZTogRGF0ZSk6IHZvaWQge1xuICAgIHRoaXMuY2hlY2tJbml0aWFsaXplZCgpO1xuICAgIHRoaXMub3BlcmF0ZU9uV3JpdGFibGUocCwgKCkgPT4ge1xuICAgICAgdGhpcy5fd3JpdGFibGUudXRpbWVzU3luYyhwLCBhdGltZSwgbXRpbWUpO1xuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBkZWxldGVQYXRoKHA6IHN0cmluZyk6IHZvaWQge1xuICAgIHRoaXMuX2RlbGV0ZWRGaWxlc1twXSA9IHRydWU7XG4gICAgdGhpcy51cGRhdGVMb2coYGQke3B9XFxuYCk7XG4gIH1cblxuICBwcml2YXRlIHVwZGF0ZUxvZyhhZGRpdGlvbjogc3RyaW5nKSB7XG4gICAgdGhpcy5fZGVsZXRlTG9nICs9IGFkZGl0aW9uO1xuICAgIGlmICh0aGlzLl9kZWxldGVMb2dVcGRhdGVQZW5kaW5nKSB7XG4gICAgICB0aGlzLl9kZWxldGVMb2dVcGRhdGVOZWVkZWQgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9kZWxldGVMb2dVcGRhdGVQZW5kaW5nID0gdHJ1ZTtcbiAgICAgIHRoaXMuX3dyaXRhYmxlLndyaXRlRmlsZShkZWxldGlvbkxvZ1BhdGgsIHRoaXMuX2RlbGV0ZUxvZywgJ3V0ZjgnLCBGaWxlRmxhZy5nZXRGaWxlRmxhZygndycpLCAwbzY0NCwgKGUpID0+IHtcbiAgICAgICAgdGhpcy5fZGVsZXRlTG9nVXBkYXRlUGVuZGluZyA9IGZhbHNlO1xuICAgICAgICBpZiAoZSkge1xuICAgICAgICAgIHRoaXMuX2RlbGV0ZUxvZ0Vycm9yID0gZTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9kZWxldGVMb2dVcGRhdGVOZWVkZWQpIHtcbiAgICAgICAgICB0aGlzLl9kZWxldGVMb2dVcGRhdGVOZWVkZWQgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLnVwZGF0ZUxvZygnJyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgX3JlcGFyc2VEZWxldGlvbkxvZygpOiB2b2lkIHtcbiAgICB0aGlzLl9kZWxldGVkRmlsZXMgPSB7fTtcbiAgICB0aGlzLl9kZWxldGVMb2cuc3BsaXQoJ1xcbicpLmZvckVhY2goKHBhdGg6IHN0cmluZykgPT4ge1xuICAgICAgLy8gSWYgdGhlIGxvZyBlbnRyeSBiZWdpbnMgdy8gJ2QnLCBpdCdzIGEgZGVsZXRpb24uXG4gICAgICB0aGlzLl9kZWxldGVkRmlsZXNbcGF0aC5zbGljZSgxKV0gPSBwYXRoLnNsaWNlKDAsIDEpID09PSAnZCc7XG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIGNoZWNrSW5pdGlhbGl6ZWQoKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLl9pc0luaXRpYWxpemVkKSB7XG4gICAgICB0aHJvdyBuZXcgQXBpRXJyb3IoRXJyb3JDb2RlLkVQRVJNLCBcIk92ZXJsYXlGUyBpcyBub3QgaW5pdGlhbGl6ZWQuIFBsZWFzZSBpbml0aWFsaXplIE92ZXJsYXlGUyB1c2luZyBpdHMgaW5pdGlhbGl6ZSgpIG1ldGhvZCBiZWZvcmUgdXNpbmcgaXQuXCIpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fZGVsZXRlTG9nRXJyb3IgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IGUgPSB0aGlzLl9kZWxldGVMb2dFcnJvcjtcbiAgICAgIHRoaXMuX2RlbGV0ZUxvZ0Vycm9yID0gbnVsbDtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBjaGVja0luaXRBc3luYyhjYjogQkZTT25lQXJnQ2FsbGJhY2spOiBib29sZWFuIHtcbiAgICBpZiAoIXRoaXMuX2lzSW5pdGlhbGl6ZWQpIHtcbiAgICAgIGNiKG5ldyBBcGlFcnJvcihFcnJvckNvZGUuRVBFUk0sIFwiT3ZlcmxheUZTIGlzIG5vdCBpbml0aWFsaXplZC4gUGxlYXNlIGluaXRpYWxpemUgT3ZlcmxheUZTIHVzaW5nIGl0cyBpbml0aWFsaXplKCkgbWV0aG9kIGJlZm9yZSB1c2luZyBpdC5cIikpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fZGVsZXRlTG9nRXJyb3IgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IGUgPSB0aGlzLl9kZWxldGVMb2dFcnJvcjtcbiAgICAgIHRoaXMuX2RlbGV0ZUxvZ0Vycm9yID0gbnVsbDtcbiAgICAgIGNiKGUpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHByaXZhdGUgY2hlY2tQYXRoKHA6IHN0cmluZyk6IHZvaWQge1xuICAgIGlmIChwID09PSBkZWxldGlvbkxvZ1BhdGgpIHtcbiAgICAgIHRocm93IEFwaUVycm9yLkVQRVJNKHApO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgY2hlY2tQYXRoQXN5bmMocDogc3RyaW5nLCBjYjogQkZTT25lQXJnQ2FsbGJhY2spOiBib29sZWFuIHtcbiAgICBpZiAocCA9PT0gZGVsZXRpb25Mb2dQYXRoKSB7XG4gICAgICBjYihBcGlFcnJvci5FUEVSTShwKSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcHJpdmF0ZSBjcmVhdGVQYXJlbnREaXJlY3Rvcmllc0FzeW5jKHA6IHN0cmluZywgY2I6IEJGU09uZUFyZ0NhbGxiYWNrKTogdm9pZCB7XG4gICAgbGV0IHBhcmVudCA9IHBhdGguZGlybmFtZShwKTtcbiAgICBjb25zdCB0b0NyZWF0ZTogc3RyaW5nW10gPSBbXTtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcblxuICAgIHRoaXMuX3dyaXRhYmxlLnN0YXQocGFyZW50LCBmYWxzZSwgc3RhdERvbmUpO1xuICAgIGZ1bmN0aW9uIHN0YXREb25lKGVycjogQXBpRXJyb3IsIHN0YXQ/OiBTdGF0cyk6IHZvaWQge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICB0b0NyZWF0ZS5wdXNoKHBhcmVudCk7XG4gICAgICAgIHBhcmVudCA9IHBhdGguZGlybmFtZShwYXJlbnQpO1xuICAgICAgICBzZWxmLl93cml0YWJsZS5zdGF0KHBhcmVudCwgZmFsc2UsIHN0YXREb25lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNyZWF0ZVBhcmVudHMoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVQYXJlbnRzKCk6IHZvaWQge1xuICAgICAgaWYgKCF0b0NyZWF0ZS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGNiKCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRpciA9IHRvQ3JlYXRlLnBvcCgpO1xuICAgICAgc2VsZi5fcmVhZGFibGUuc3RhdChkaXIhLCBmYWxzZSwgKGVycjogQXBpRXJyb3IsIHN0YXRzPzogU3RhdHMpID0+IHtcbiAgICAgICAgLy8gc3RvcCBpZiB3ZSBjb3VsZG4ndCByZWFkIHRoZSBkaXJcbiAgICAgICAgaWYgKCFzdGF0cykge1xuICAgICAgICAgIHJldHVybiBjYigpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi5fd3JpdGFibGUubWtkaXIoZGlyISwgc3RhdHMubW9kZSwgKGVycj86IEFwaUVycm9yKSA9PiB7XG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIGNiKGVycik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNyZWF0ZVBhcmVudHMoKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogV2l0aCB0aGUgZ2l2ZW4gcGF0aCwgY3JlYXRlIHRoZSBuZWVkZWQgcGFyZW50IGRpcmVjdG9yaWVzIG9uIHRoZSB3cml0YWJsZSBzdG9yYWdlXG4gICAqIHNob3VsZCB0aGV5IG5vdCBleGlzdC4gVXNlIG1vZGVzIGZyb20gdGhlIHJlYWQtb25seSBzdG9yYWdlLlxuICAgKi9cbiAgcHJpdmF0ZSBjcmVhdGVQYXJlbnREaXJlY3RvcmllcyhwOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBsZXQgcGFyZW50ID0gcGF0aC5kaXJuYW1lKHApLCB0b0NyZWF0ZTogc3RyaW5nW10gPSBbXTtcbiAgICB3aGlsZSAoIXRoaXMuX3dyaXRhYmxlLmV4aXN0c1N5bmMocGFyZW50KSkge1xuICAgICAgdG9DcmVhdGUucHVzaChwYXJlbnQpO1xuICAgICAgcGFyZW50ID0gcGF0aC5kaXJuYW1lKHBhcmVudCk7XG4gICAgfVxuICAgIHRvQ3JlYXRlID0gdG9DcmVhdGUucmV2ZXJzZSgpO1xuXG4gICAgdG9DcmVhdGUuZm9yRWFjaCgocDogc3RyaW5nKSA9PiB7XG4gICAgICB0aGlzLl93cml0YWJsZS5ta2RpclN5bmMocCwgdGhpcy5zdGF0U3luYyhwLCBmYWxzZSkubW9kZSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogSGVscGVyIGZ1bmN0aW9uOlxuICAgKiAtIEVuc3VyZXMgcCBpcyBvbiB3cml0YWJsZSBiZWZvcmUgcHJvY2VlZGluZy4gVGhyb3dzIGFuIGVycm9yIGlmIGl0IGRvZXNuJ3QgZXhpc3QuXG4gICAqIC0gQ2FsbHMgZiB0byBwZXJmb3JtIG9wZXJhdGlvbiBvbiB3cml0YWJsZS5cbiAgICovXG4gIHByaXZhdGUgb3BlcmF0ZU9uV3JpdGFibGUocDogc3RyaW5nLCBmOiAoKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuZXhpc3RzU3luYyhwKSkge1xuICAgICAgaWYgKCF0aGlzLl93cml0YWJsZS5leGlzdHNTeW5jKHApKSB7XG4gICAgICAgIC8vIEZpbGUgaXMgb24gcmVhZGFibGUgc3RvcmFnZS4gQ29weSB0byB3cml0YWJsZSBzdG9yYWdlIGJlZm9yZVxuICAgICAgICAvLyBjaGFuZ2luZyBpdHMgbW9kZS5cbiAgICAgICAgdGhpcy5jb3B5VG9Xcml0YWJsZShwKTtcbiAgICAgIH1cbiAgICAgIGYoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgQXBpRXJyb3IuRU5PRU5UKHApO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgb3BlcmF0ZU9uV3JpdGFibGVBc3luYyhwOiBzdHJpbmcsIGNiOiBCRlNPbmVBcmdDYWxsYmFjayk6IHZvaWQge1xuICAgIHRoaXMuZXhpc3RzKHAsIChleGlzdHM6IGJvb2xlYW4pID0+IHtcbiAgICAgIGlmICghZXhpc3RzKSB7XG4gICAgICAgIHJldHVybiBjYihBcGlFcnJvci5FTk9FTlQocCkpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl93cml0YWJsZS5leGlzdHMocCwgKGV4aXN0c1dyaXRhYmxlOiBib29sZWFuKSA9PiB7XG4gICAgICAgIGlmIChleGlzdHNXcml0YWJsZSkge1xuICAgICAgICAgIGNiKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29weVRvV3JpdGFibGVBc3luYyhwLCBjYik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENvcHkgZnJvbSByZWFkYWJsZSB0byB3cml0YWJsZSBzdG9yYWdlLlxuICAgKiBQUkVDT05ESVRJT046IEZpbGUgZG9lcyBub3QgZXhpc3Qgb24gd3JpdGFibGUgc3RvcmFnZS5cbiAgICovXG4gIHByaXZhdGUgY29weVRvV3JpdGFibGUocDogc3RyaW5nKTogdm9pZCB7XG4gICAgY29uc3QgcFN0YXRzID0gdGhpcy5zdGF0U3luYyhwLCBmYWxzZSk7XG4gICAgaWYgKHBTdGF0cy5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICB0aGlzLl93cml0YWJsZS5ta2RpclN5bmMocCwgcFN0YXRzLm1vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndyaXRlRmlsZVN5bmMocCxcbiAgICAgICAgdGhpcy5fcmVhZGFibGUucmVhZEZpbGVTeW5jKHAsIG51bGwsIGdldEZsYWcoJ3InKSksIG51bGwsXG4gICAgICAgIGdldEZsYWcoJ3cnKSwgdGhpcy5zdGF0U3luYyhwLCBmYWxzZSkubW9kZSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBjb3B5VG9Xcml0YWJsZUFzeW5jKHA6IHN0cmluZywgY2I6IEJGU09uZUFyZ0NhbGxiYWNrKTogdm9pZCB7XG4gICAgdGhpcy5zdGF0KHAsIGZhbHNlLCAoZXJyOiBBcGlFcnJvciwgcFN0YXRzPzogU3RhdHMpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGNiKGVycik7XG4gICAgICB9XG5cbiAgICAgIGlmIChwU3RhdHMhLmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlLm1rZGlyKHAsIHBTdGF0cyEubW9kZSwgY2IpO1xuICAgICAgfVxuXG4gICAgICAvLyBuZWVkIHRvIGNvcHkgZmlsZS5cbiAgICAgIHRoaXMuX3JlYWRhYmxlLnJlYWRGaWxlKHAsIG51bGwsIGdldEZsYWcoJ3InKSwgKGVycjogQXBpRXJyb3IsIGRhdGE/OiBCdWZmZXIpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJldHVybiBjYihlcnIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy53cml0ZUZpbGUocCwgZGF0YSwgbnVsbCwgZ2V0RmxhZygndycpLCBwU3RhdHMhLm1vZGUsIGNiKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvcHRpb25zIGZvciBPdmVybGF5RlMgaW5zdGFuY2VzLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIE92ZXJsYXlGU09wdGlvbnMge1xuICAvLyBUaGUgZmlsZSBzeXN0ZW0gdG8gd3JpdGUgbW9kaWZpZWQgZmlsZXMgdG8uXG4gIHdyaXRhYmxlOiBGaWxlU3lzdGVtO1xuICAvLyBUaGUgZmlsZSBzeXN0ZW0gdGhhdCBpbml0aWFsbHkgcG9wdWxhdGVzIHRoaXMgZmlsZSBzeXN0ZW0uXG4gIHJlYWRhYmxlOiBGaWxlU3lzdGVtO1xufVxuXG4vKipcbiAqIE92ZXJsYXlGUyBtYWtlcyBhIHJlYWQtb25seSBmaWxlc3lzdGVtIHdyaXRhYmxlIGJ5IHN0b3Jpbmcgd3JpdGVzIG9uIGEgc2Vjb25kLFxuICogd3JpdGFibGUgZmlsZSBzeXN0ZW0uIERlbGV0ZXMgYXJlIHBlcnNpc3RlZCB2aWEgbWV0YWRhdGEgc3RvcmVkIG9uIHRoZSB3cml0YWJsZVxuICogZmlsZSBzeXN0ZW0uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE92ZXJsYXlGUyBleHRlbmRzIExvY2tlZEZTPFVubG9ja2VkT3ZlcmxheUZTPiB7XG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgTmFtZSA9IFwiT3ZlcmxheUZTXCI7XG5cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBPcHRpb25zOiBGaWxlU3lzdGVtT3B0aW9ucyA9IHtcbiAgICB3cml0YWJsZToge1xuICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgIGRlc2NyaXB0aW9uOiBcIlRoZSBmaWxlIHN5c3RlbSB0byB3cml0ZSBtb2RpZmllZCBmaWxlcyB0by5cIlxuICAgIH0sXG4gICAgcmVhZGFibGU6IHtcbiAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICBkZXNjcmlwdGlvbjogXCJUaGUgZmlsZSBzeXN0ZW0gdGhhdCBpbml0aWFsbHkgcG9wdWxhdGVzIHRoaXMgZmlsZSBzeXN0ZW0uXCJcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYW5kIGluaXRpYWxpemVzIGFuIE92ZXJsYXlGUyBpbnN0YW5jZSB3aXRoIHRoZSBnaXZlbiBvcHRpb25zLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBDcmVhdGUob3B0czogT3ZlcmxheUZTT3B0aW9ucywgY2I6IEJGU0NhbGxiYWNrPE92ZXJsYXlGUz4pOiB2b2lkIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZnMgPSBuZXcgT3ZlcmxheUZTKG9wdHMud3JpdGFibGUsIG9wdHMucmVhZGFibGUsIGZhbHNlKTtcbiAgICAgIGZzLmluaXRpYWxpemUoKGU/KSA9PiB7XG4gICAgICAgIGNiKGUsIGZzKTtcbiAgICAgIH0sIGZhbHNlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjYihlKTtcbiAgICB9XG4gIH1cbiAgcHVibGljIHN0YXRpYyBpc0F2YWlsYWJsZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gVW5sb2NrZWRPdmVybGF5RlMuaXNBdmFpbGFibGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiAqKkRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgT3ZlcmxheUZTLkNyZWF0ZSgpIG1ldGhvZCBpbnN0ZWFkLioqXG4gICAqIEBwYXJhbSB3cml0YWJsZSBUaGUgZmlsZSBzeXN0ZW0gdG8gd3JpdGUgbW9kaWZpZWQgZmlsZXMgdG8uXG4gICAqIEBwYXJhbSByZWFkYWJsZSBUaGUgZmlsZSBzeXN0ZW0gdGhhdCBpbml0aWFsbHkgcG9wdWxhdGVzIHRoaXMgZmlsZSBzeXN0ZW0uXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih3cml0YWJsZTogRmlsZVN5c3RlbSwgcmVhZGFibGU6IEZpbGVTeXN0ZW0sIGRlcHJlY2F0ZU1zZyA9IHRydWUpIHtcbiAgICBzdXBlcihuZXcgVW5sb2NrZWRPdmVybGF5RlMod3JpdGFibGUsIHJlYWRhYmxlKSk7XG4gICAgZGVwcmVjYXRpb25NZXNzYWdlKGRlcHJlY2F0ZU1zZywgT3ZlcmxheUZTLk5hbWUsIHtyZWFkYWJsZTogXCJyZWFkYWJsZSBmaWxlIHN5c3RlbVwiLCB3cml0YWJsZTogXCJ3cml0YWJsZSBmaWxlIHN5c3RlbVwifSk7XG4gIH1cblxuICAvKipcbiAgICogKipEZXByZWNhdGVkLiBQbGVhc2UgdXNlIE92ZXJsYXlGUy5DcmVhdGUoKSB0byBjb25zdHJ1Y3QgYW5kIGluaXRpYWxpemUgT3ZlcmxheUZTIGluc3RhbmNlcy4qKlxuICAgKi9cbiAgcHVibGljIGluaXRpYWxpemUoY2I6IEJGU09uZUFyZ0NhbGxiYWNrLCBkZXByZWNhdGVNc2cgPSB0cnVlKTogdm9pZCB7XG4gICAgaWYgKGRlcHJlY2F0ZU1zZykge1xuICAgICAgY29uc29sZS53YXJuKGBbT3ZlcmxheUZTXSBPdmVybGF5RlMuaW5pdGlhbGl6ZSgpIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlLiBQbGVhc2UgdXNlICdPdmVybGF5RlMuQ3JlYXRlKHtyZWFkYWJsZTogcmVhZGFibGUgZmlsZSBzeXN0ZW0gaW5zdGFuY2UsIHdyaXRhYmxlOiB3cml0YWJsZSBmaWxlIHN5c3RlbSBpbnN0YW5jZX0sIGNiKScgdG8gY3JlYXRlIGFuZCBpbml0aWFsaXplIE92ZXJsYXlGUyBpbnN0YW5jZXMuYCk7XG4gICAgfVxuICAgIHN1cGVyLmluaXRpYWxpemUoY2IpO1xuICB9XG5cbiAgcHVibGljIGdldE92ZXJsYXllZEZpbGVTeXN0ZW1zKCk6IHsgcmVhZGFibGU6IEZpbGVTeXN0ZW07IHdyaXRhYmxlOiBGaWxlU3lzdGVtOyB9IHtcbiAgICByZXR1cm4gc3VwZXIuZ2V0RlNVbmxvY2tlZCgpLmdldE92ZXJsYXllZEZpbGVTeXN0ZW1zKCk7XG4gIH1cblxuICBwdWJsaWMgdW53cmFwKCk6IFVubG9ja2VkT3ZlcmxheUZTIHtcbiAgICByZXR1cm4gc3VwZXIuZ2V0RlNVbmxvY2tlZCgpO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vLi4vLi4vLi4vc3JjL2JhY2tlbmQvT3ZlcmxheUZTLnRzIiwiaW1wb3J0IHtCYXNlRmlsZVN5c3RlbSwgRmlsZVN5c3RlbSwgQkZTT25lQXJnQ2FsbGJhY2ssIEJGU0NhbGxiYWNrLCBGaWxlU3lzdGVtT3B0aW9uc30gZnJvbSAnLi4vY29yZS9maWxlX3N5c3RlbSc7XG5pbXBvcnQge0FwaUVycm9yLCBFcnJvckNvZGV9IGZyb20gJy4uL2NvcmUvYXBpX2Vycm9yJztcbmltcG9ydCB7RmlsZUZsYWd9IGZyb20gJy4uL2NvcmUvZmlsZV9mbGFnJztcbmltcG9ydCB7YnVmZmVyMkFycmF5QnVmZmVyLCBhcnJheUJ1ZmZlcjJCdWZmZXIsIGVtcHR5QnVmZmVyLCBkZXByZWNhdGlvbk1lc3NhZ2V9IGZyb20gJy4uL2NvcmUvdXRpbCc7XG5pbXBvcnQge0ZpbGUsIEJhc2VGaWxlfSBmcm9tICcuLi9jb3JlL2ZpbGUnO1xuaW1wb3J0IHtkZWZhdWx0IGFzIFN0YXRzfSBmcm9tICcuLi9jb3JlL25vZGVfZnNfc3RhdHMnO1xuaW1wb3J0IFByZWxvYWRGaWxlIGZyb20gJy4uL2dlbmVyaWMvcHJlbG9hZF9maWxlJztcbmltcG9ydCBnbG9iYWwgZnJvbSAnLi4vY29yZS9nbG9iYWwnO1xuaW1wb3J0IGZzIGZyb20gJy4uL2NvcmUvbm9kZV9mcyc7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5kZWNsYXJlIGNvbnN0IGltcG9ydFNjcmlwdHM6IEZ1bmN0aW9uO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuaW50ZXJmYWNlIElCcm93c2VyRlNNZXNzYWdlIHtcbiAgYnJvd3NlcmZzTWVzc2FnZTogYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmVudW0gU3BlY2lhbEFyZ1R5cGUge1xuICAvLyBDYWxsYmFja1xuICBDQixcbiAgLy8gRmlsZSBkZXNjcmlwdG9yXG4gIEZELFxuICAvLyBBUEkgZXJyb3JcbiAgQVBJX0VSUk9SLFxuICAvLyBTdGF0cyBvYmplY3RcbiAgU1RBVFMsXG4gIC8vIEluaXRpYWwgcHJvYmUgZm9yIGZpbGUgc3lzdGVtIGluZm9ybWF0aW9uLlxuICBQUk9CRSxcbiAgLy8gRmlsZUZsYWcgb2JqZWN0LlxuICBGSUxFRkxBRyxcbiAgLy8gQnVmZmVyIG9iamVjdC5cbiAgQlVGRkVSLFxuICAvLyBHZW5lcmljIEVycm9yIG9iamVjdC5cbiAgRVJST1Jcbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmludGVyZmFjZSBJU3BlY2lhbEFyZ3VtZW50IHtcbiAgdHlwZTogU3BlY2lhbEFyZ1R5cGU7XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5pbnRlcmZhY2UgSVByb2JlUmVzcG9uc2UgZXh0ZW5kcyBJU3BlY2lhbEFyZ3VtZW50IHtcbiAgaXNSZWFkT25seTogYm9vbGVhbjtcbiAgc3VwcG9ydHNMaW5rczogYm9vbGVhbjtcbiAgc3VwcG9ydHNQcm9wczogYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmludGVyZmFjZSBJQ2FsbGJhY2tBcmd1bWVudCBleHRlbmRzIElTcGVjaWFsQXJndW1lbnQge1xuICAvLyBUaGUgY2FsbGJhY2sgSUQuXG4gIGlkOiBudW1iZXI7XG59XG5cbi8qKlxuICogQ29udmVydHMgY2FsbGJhY2sgYXJndW1lbnRzIGludG8gSUNhbGxiYWNrQXJndW1lbnQgb2JqZWN0cywgYW5kIGJhY2tcbiAqIGFnYWluLlxuICogQGhpZGRlblxuICovXG5jbGFzcyBDYWxsYmFja0FyZ3VtZW50Q29udmVydGVyIHtcbiAgcHJpdmF0ZSBfY2FsbGJhY2tzOiB7IFtpZDogbnVtYmVyXTogRnVuY3Rpb24gfSA9IHt9O1xuICBwcml2YXRlIF9uZXh0SWQ6IG51bWJlciA9IDA7XG5cbiAgcHVibGljIHRvUmVtb3RlQXJnKGNiOiBGdW5jdGlvbik6IElDYWxsYmFja0FyZ3VtZW50IHtcbiAgICBjb25zdCBpZCA9IHRoaXMuX25leHRJZCsrO1xuICAgIHRoaXMuX2NhbGxiYWNrc1tpZF0gPSBjYjtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogU3BlY2lhbEFyZ1R5cGUuQ0IsXG4gICAgICBpZDogaWRcbiAgICB9O1xuICB9XG5cbiAgcHVibGljIHRvTG9jYWxBcmcoaWQ6IG51bWJlcik6IEZ1bmN0aW9uIHtcbiAgICBjb25zdCBjYiA9IHRoaXMuX2NhbGxiYWNrc1tpZF07XG4gICAgZGVsZXRlIHRoaXMuX2NhbGxiYWNrc1tpZF07XG4gICAgcmV0dXJuIGNiO1xuICB9XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5pbnRlcmZhY2UgSUZpbGVEZXNjcmlwdG9yQXJndW1lbnQgZXh0ZW5kcyBJU3BlY2lhbEFyZ3VtZW50IHtcbiAgLy8gVGhlIGZpbGUgZGVzY3JpcHRvcidzIGlkIG9uIHRoZSByZW1vdGUgc2lkZS5cbiAgaWQ6IG51bWJlcjtcbiAgLy8gVGhlIGVudGlyZSBmaWxlJ3MgZGF0YSwgYXMgYW4gYXJyYXkgYnVmZmVyLlxuICBkYXRhOiBBcnJheUJ1ZmZlcjtcbiAgLy8gVGhlIGZpbGUncyBzdGF0IG9iamVjdCwgYXMgYW4gYXJyYXkgYnVmZmVyLlxuICBzdGF0OiBBcnJheUJ1ZmZlcjtcbiAgLy8gVGhlIHBhdGggdG8gdGhlIGZpbGUuXG4gIHBhdGg6IHN0cmluZztcbiAgLy8gVGhlIGZsYWcgb2YgdGhlIG9wZW4gZmlsZSBkZXNjcmlwdG9yLlxuICBmbGFnOiBzdHJpbmc7XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBGaWxlRGVzY3JpcHRvckFyZ3VtZW50Q29udmVydGVyIHtcbiAgcHJpdmF0ZSBfZmlsZURlc2NyaXB0b3JzOiB7IFtpZDogbnVtYmVyXTogRmlsZSB9ID0ge307XG4gIHByaXZhdGUgX25leHRJZDogbnVtYmVyID0gMDtcblxuICBwdWJsaWMgdG9SZW1vdGVBcmcoZmQ6IEZpbGUsIHA6IHN0cmluZywgZmxhZzogRmlsZUZsYWcsIGNiOiBCRlNDYWxsYmFjazxJRmlsZURlc2NyaXB0b3JBcmd1bWVudD4pOiB2b2lkIHtcbiAgICBjb25zdCBpZCA9IHRoaXMuX25leHRJZCsrO1xuICAgIGxldCBkYXRhOiBBcnJheUJ1ZmZlcjtcbiAgICBsZXQgc3RhdDogQXJyYXlCdWZmZXI7XG4gICAgdGhpcy5fZmlsZURlc2NyaXB0b3JzW2lkXSA9IGZkO1xuXG4gICAgLy8gRXh0cmFjdCBuZWVkZWQgaW5mb3JtYXRpb24gYXN5bmNocm9ub3VzbHkuXG4gICAgZmQuc3RhdCgoZXJyLCBzdGF0cykgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBjYihlcnIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdCA9IGJ1ZmZlclRvVHJhbnNmZXJyYWJsZU9iamVjdChzdGF0cyEudG9CdWZmZXIoKSk7XG4gICAgICAgIC8vIElmIGl0J3MgYSByZWFkYWJsZSBmbGFnLCB3ZSBuZWVkIHRvIGdyYWIgY29udGVudHMuXG4gICAgICAgIGlmIChmbGFnLmlzUmVhZGFibGUoKSkge1xuICAgICAgICAgIGZkLnJlYWQoQnVmZmVyLmFsbG9jKHN0YXRzIS5zaXplKSwgMCwgc3RhdHMhLnNpemUsIDAsIChlcnI/OiBBcGlFcnJvciB8IG51bGwsIGJ5dGVzUmVhZD86IG51bWJlciwgYnVmZj86IEJ1ZmZlcikgPT4ge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICBjYihlcnIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZGF0YSA9IGJ1ZmZlclRvVHJhbnNmZXJyYWJsZU9iamVjdChidWZmISk7XG4gICAgICAgICAgICAgIGNiKG51bGwsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTcGVjaWFsQXJnVHlwZS5GRCxcbiAgICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgICAgICBzdGF0OiBzdGF0LFxuICAgICAgICAgICAgICAgIHBhdGg6IHAsXG4gICAgICAgICAgICAgICAgZmxhZzogZmxhZy5nZXRGbGFnU3RyaW5nKClcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gRmlsZSBpcyBub3QgcmVhZGFibGUsIHdoaWNoIG1lYW5zIHdyaXRpbmcgdG8gaXQgd2lsbCBhcHBlbmQgb3JcbiAgICAgICAgICAvLyB0cnVuY2F0ZS9yZXBsYWNlIGV4aXN0aW5nIGNvbnRlbnRzLiBSZXR1cm4gYW4gZW1wdHkgYXJyYXlidWZmZXIuXG4gICAgICAgICAgY2IobnVsbCwge1xuICAgICAgICAgICAgdHlwZTogU3BlY2lhbEFyZ1R5cGUuRkQsXG4gICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICBkYXRhOiBuZXcgQXJyYXlCdWZmZXIoMCksXG4gICAgICAgICAgICBzdGF0OiBzdGF0LFxuICAgICAgICAgICAgcGF0aDogcCxcbiAgICAgICAgICAgIGZsYWc6IGZsYWcuZ2V0RmxhZ1N0cmluZygpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyBhcHBseUZkQVBJUmVxdWVzdChyZXF1ZXN0OiBJQVBJUmVxdWVzdCwgY2I6IEJGU09uZUFyZ0NhbGxiYWNrKTogdm9pZCB7XG4gICAgY29uc3QgZmRBcmcgPSA8SUZpbGVEZXNjcmlwdG9yQXJndW1lbnQ+IHJlcXVlc3QuYXJnc1swXTtcbiAgICB0aGlzLl9hcHBseUZkQ2hhbmdlcyhmZEFyZywgKGVyciwgZmQ/KSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGNiKGVycik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBcHBseSBtZXRob2Qgb24gbm93LWNoYW5nZWQgZmlsZSBkZXNjcmlwdG9yLlxuICAgICAgICAoPGFueT4gZmQpW3JlcXVlc3QubWV0aG9kXSgoZT86IEFwaUVycm9yKSA9PiB7XG4gICAgICAgICAgaWYgKHJlcXVlc3QubWV0aG9kID09PSAnY2xvc2UnKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fZmlsZURlc2NyaXB0b3JzW2ZkQXJnLmlkXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2IoZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBfYXBwbHlGZENoYW5nZXMocmVtb3RlRmQ6IElGaWxlRGVzY3JpcHRvckFyZ3VtZW50LCBjYjogQkZTQ2FsbGJhY2s8RmlsZT4pOiB2b2lkIHtcbiAgICBjb25zdCBmZCA9IHRoaXMuX2ZpbGVEZXNjcmlwdG9yc1tyZW1vdGVGZC5pZF0sXG4gICAgICBkYXRhID0gdHJhbnNmZXJyYWJsZU9iamVjdFRvQnVmZmVyKHJlbW90ZUZkLmRhdGEpLFxuICAgICAgcmVtb3RlU3RhdHMgPSBTdGF0cy5mcm9tQnVmZmVyKHRyYW5zZmVycmFibGVPYmplY3RUb0J1ZmZlcihyZW1vdGVGZC5zdGF0KSk7XG5cbiAgICAvLyBXcml0ZSBkYXRhIGlmIHRoZSBmaWxlIGlzIHdyaXRhYmxlLlxuICAgIGNvbnN0IGZsYWcgPSBGaWxlRmxhZy5nZXRGaWxlRmxhZyhyZW1vdGVGZC5mbGFnKTtcbiAgICBpZiAoZmxhZy5pc1dyaXRlYWJsZSgpKSB7XG4gICAgICAvLyBBcHBlbmRhYmxlOiBXcml0ZSB0byBlbmQgb2YgZmlsZS5cbiAgICAgIC8vIFdyaXRlYWJsZTogUmVwbGFjZSBlbnRpcmUgY29udGVudHMgb2YgZmlsZS5cbiAgICAgIGZkLndyaXRlKGRhdGEsIDAsIGRhdGEubGVuZ3RoLCBmbGFnLmlzQXBwZW5kYWJsZSgpID8gZmQuZ2V0UG9zKCkhIDogMCwgKGU/OiBBcGlFcnJvciB8IG51bGwpID0+IHtcbiAgICAgICAgZnVuY3Rpb24gYXBwbHlTdGF0Q2hhbmdlcygpIHtcbiAgICAgICAgICAvLyBDaGVjayBpZiBtb2RlIGNoYW5nZWQuXG4gICAgICAgICAgZmQuc3RhdCgoZSwgc3RhdHM/KSA9PiB7XG4gICAgICAgICAgICBpZiAoZSkge1xuICAgICAgICAgICAgICBjYihlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChzdGF0cyEubW9kZSAhPT0gcmVtb3RlU3RhdHMubW9kZSkge1xuICAgICAgICAgICAgICAgIGZkLmNobW9kKHJlbW90ZVN0YXRzLm1vZGUsIChlOiBhbnkpID0+IHtcbiAgICAgICAgICAgICAgICAgIGNiKGUsIGZkKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYihlLCBmZCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZSkge1xuICAgICAgICAgIGNiKGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIElmIHdyaXRlYWJsZSAmIG5vdCBhcHBlbmRhYmxlLCB3ZSBuZWVkIHRvIGVuc3VyZSBmaWxlIGNvbnRlbnRzIGFyZVxuICAgICAgICAgIC8vIGlkZW50aWNhbCB0byB0aG9zZSBmcm9tIHRoZSByZW1vdGUgRkQuIFRodXMsIHdlIHRydW5jYXRlIHRvIHRoZVxuICAgICAgICAgIC8vIGxlbmd0aCBvZiB0aGUgcmVtb3RlIGZpbGUuXG4gICAgICAgICAgaWYgKCFmbGFnLmlzQXBwZW5kYWJsZSgpKSB7XG4gICAgICAgICAgICBmZC50cnVuY2F0ZShkYXRhLmxlbmd0aCwgKCkgPT4ge1xuICAgICAgICAgICAgICBhcHBseVN0YXRDaGFuZ2VzKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXBwbHlTdGF0Q2hhbmdlcygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNiKG51bGwsIGZkKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmludGVyZmFjZSBJQVBJRXJyb3JBcmd1bWVudCBleHRlbmRzIElTcGVjaWFsQXJndW1lbnQge1xuICAvLyBUaGUgZXJyb3Igb2JqZWN0LCBhcyBhbiBhcnJheSBidWZmZXIuXG4gIGVycm9yRGF0YTogQXJyYXlCdWZmZXI7XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5mdW5jdGlvbiBhcGlFcnJvckxvY2FsMlJlbW90ZShlOiBBcGlFcnJvcik6IElBUElFcnJvckFyZ3VtZW50IHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBTcGVjaWFsQXJnVHlwZS5BUElfRVJST1IsXG4gICAgZXJyb3JEYXRhOiBidWZmZXJUb1RyYW5zZmVycmFibGVPYmplY3QoZS53cml0ZVRvQnVmZmVyKCkpXG4gIH07XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5mdW5jdGlvbiBhcGlFcnJvclJlbW90ZTJMb2NhbChlOiBJQVBJRXJyb3JBcmd1bWVudCk6IEFwaUVycm9yIHtcbiAgcmV0dXJuIEFwaUVycm9yLmZyb21CdWZmZXIodHJhbnNmZXJyYWJsZU9iamVjdFRvQnVmZmVyKGUuZXJyb3JEYXRhKSk7XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5pbnRlcmZhY2UgSUVycm9yQXJndW1lbnQgZXh0ZW5kcyBJU3BlY2lhbEFyZ3VtZW50IHtcbiAgLy8gVGhlIG5hbWUgb2YgdGhlIGVycm9yIChlLmcuICdUeXBlRXJyb3InKS5cbiAgbmFtZTogc3RyaW5nO1xuICAvLyBUaGUgbWVzc2FnZSBhc3NvY2lhdGVkIHdpdGggdGhlIGVycm9yLlxuICBtZXNzYWdlOiBzdHJpbmc7XG4gIC8vIFRoZSBzdGFjayBhc3NvY2lhdGVkIHdpdGggdGhlIGVycm9yLlxuICBzdGFjazogc3RyaW5nO1xufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZnVuY3Rpb24gZXJyb3JMb2NhbDJSZW1vdGUoZTogRXJyb3IpOiBJRXJyb3JBcmd1bWVudCB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogU3BlY2lhbEFyZ1R5cGUuRVJST1IsXG4gICAgbmFtZTogZS5uYW1lLFxuICAgIG1lc3NhZ2U6IGUubWVzc2FnZSxcbiAgICBzdGFjazogZS5zdGFjayFcbiAgfTtcbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmZ1bmN0aW9uIGVycm9yUmVtb3RlMkxvY2FsKGU6IElFcnJvckFyZ3VtZW50KTogRXJyb3Ige1xuICBsZXQgY25zdHI6IHtcbiAgICBuZXcgKG1zZzogc3RyaW5nKTogRXJyb3I7XG4gIH0gPSBnbG9iYWxbZS5uYW1lXTtcbiAgaWYgKHR5cGVvZihjbnN0cikgIT09ICdmdW5jdGlvbicpIHtcbiAgICBjbnN0ciA9IEVycm9yO1xuICB9XG4gIGNvbnN0IGVyciA9IG5ldyBjbnN0cihlLm1lc3NhZ2UpO1xuICBlcnIuc3RhY2sgPSBlLnN0YWNrO1xuICByZXR1cm4gZXJyO1xufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuaW50ZXJmYWNlIElTdGF0c0FyZ3VtZW50IGV4dGVuZHMgSVNwZWNpYWxBcmd1bWVudCB7XG4gIC8vIFRoZSBzdGF0cyBvYmplY3QgYXMgYW4gYXJyYXkgYnVmZmVyLlxuICBzdGF0c0RhdGE6IEFycmF5QnVmZmVyO1xufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZnVuY3Rpb24gc3RhdHNMb2NhbDJSZW1vdGUoc3RhdHM6IFN0YXRzKTogSVN0YXRzQXJndW1lbnQge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFNwZWNpYWxBcmdUeXBlLlNUQVRTLFxuICAgIHN0YXRzRGF0YTogYnVmZmVyVG9UcmFuc2ZlcnJhYmxlT2JqZWN0KHN0YXRzLnRvQnVmZmVyKCkpXG4gIH07XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5mdW5jdGlvbiBzdGF0c1JlbW90ZTJMb2NhbChzdGF0czogSVN0YXRzQXJndW1lbnQpOiBTdGF0cyB7XG4gIHJldHVybiBTdGF0cy5mcm9tQnVmZmVyKHRyYW5zZmVycmFibGVPYmplY3RUb0J1ZmZlcihzdGF0cy5zdGF0c0RhdGEpKTtcbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmludGVyZmFjZSBJRmlsZUZsYWdBcmd1bWVudCBleHRlbmRzIElTcGVjaWFsQXJndW1lbnQge1xuICBmbGFnU3RyOiBzdHJpbmc7XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5mdW5jdGlvbiBmaWxlRmxhZ0xvY2FsMlJlbW90ZShmbGFnOiBGaWxlRmxhZyk6IElGaWxlRmxhZ0FyZ3VtZW50IHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBTcGVjaWFsQXJnVHlwZS5GSUxFRkxBRyxcbiAgICBmbGFnU3RyOiBmbGFnLmdldEZsYWdTdHJpbmcoKVxuICB9O1xufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZnVuY3Rpb24gZmlsZUZsYWdSZW1vdGUyTG9jYWwocmVtb3RlRmxhZzogSUZpbGVGbGFnQXJndW1lbnQpOiBGaWxlRmxhZyB7XG4gIHJldHVybiBGaWxlRmxhZy5nZXRGaWxlRmxhZyhyZW1vdGVGbGFnLmZsYWdTdHIpO1xufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuaW50ZXJmYWNlIElCdWZmZXJBcmd1bWVudCBleHRlbmRzIElTcGVjaWFsQXJndW1lbnQge1xuICBkYXRhOiBBcnJheUJ1ZmZlcjtcbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmZ1bmN0aW9uIGJ1ZmZlclRvVHJhbnNmZXJyYWJsZU9iamVjdChidWZmOiBCdWZmZXIpOiBBcnJheUJ1ZmZlciB7XG4gIHJldHVybiBidWZmZXIyQXJyYXlCdWZmZXIoYnVmZik7XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5mdW5jdGlvbiB0cmFuc2ZlcnJhYmxlT2JqZWN0VG9CdWZmZXIoYnVmZjogQXJyYXlCdWZmZXIpOiBCdWZmZXIge1xuICByZXR1cm4gYXJyYXlCdWZmZXIyQnVmZmVyKGJ1ZmYpO1xufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZnVuY3Rpb24gYnVmZmVyTG9jYWwyUmVtb3RlKGJ1ZmY6IEJ1ZmZlcik6IElCdWZmZXJBcmd1bWVudCB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogU3BlY2lhbEFyZ1R5cGUuQlVGRkVSLFxuICAgIGRhdGE6IGJ1ZmZlclRvVHJhbnNmZXJyYWJsZU9iamVjdChidWZmKVxuICB9O1xufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZnVuY3Rpb24gYnVmZmVyUmVtb3RlMkxvY2FsKGJ1ZmZBcmc6IElCdWZmZXJBcmd1bWVudCk6IEJ1ZmZlciB7XG4gIHJldHVybiB0cmFuc2ZlcnJhYmxlT2JqZWN0VG9CdWZmZXIoYnVmZkFyZy5kYXRhKTtcbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmludGVyZmFjZSBJQVBJUmVxdWVzdCBleHRlbmRzIElCcm93c2VyRlNNZXNzYWdlIHtcbiAgbWV0aG9kOiBzdHJpbmc7XG4gIGFyZ3M6IEFycmF5PG51bWJlciB8IHN0cmluZyB8IElTcGVjaWFsQXJndW1lbnQ+O1xufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZnVuY3Rpb24gaXNBUElSZXF1ZXN0KGRhdGE6IGFueSk6IGRhdGEgaXMgSUFQSVJlcXVlc3Qge1xuICByZXR1cm4gZGF0YSAmJiB0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcgJiYgZGF0YS5oYXNPd25Qcm9wZXJ0eSgnYnJvd3NlcmZzTWVzc2FnZScpICYmIGRhdGFbJ2Jyb3dzZXJmc01lc3NhZ2UnXTtcbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmludGVyZmFjZSBJQVBJUmVzcG9uc2UgZXh0ZW5kcyBJQnJvd3NlckZTTWVzc2FnZSB7XG4gIGNiSWQ6IG51bWJlcjtcbiAgYXJnczogQXJyYXk8bnVtYmVyIHwgc3RyaW5nIHwgSVNwZWNpYWxBcmd1bWVudD47XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5mdW5jdGlvbiBpc0FQSVJlc3BvbnNlKGRhdGE6IGFueSk6IGRhdGEgaXMgSUFQSVJlc3BvbnNlIHtcbiAgcmV0dXJuIGRhdGEgJiYgdHlwZW9mIGRhdGEgPT09ICdvYmplY3QnICYmIGRhdGEuaGFzT3duUHJvcGVydHkoJ2Jyb3dzZXJmc01lc3NhZ2UnKSAmJiBkYXRhWydicm93c2VyZnNNZXNzYWdlJ107XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIHJlbW90ZSBmaWxlIGluIGEgZGlmZmVyZW50IHdvcmtlci90aHJlYWQuXG4gKi9cbmNsYXNzIFdvcmtlckZpbGUgZXh0ZW5kcyBQcmVsb2FkRmlsZTxXb3JrZXJGUz4ge1xuICBwcml2YXRlIF9yZW1vdGVGZElkOiBudW1iZXI7XG5cbiAgY29uc3RydWN0b3IoX2ZzOiBXb3JrZXJGUywgX3BhdGg6IHN0cmluZywgX2ZsYWc6IEZpbGVGbGFnLCBfc3RhdDogU3RhdHMsIHJlbW90ZUZkSWQ6IG51bWJlciwgY29udGVudHM/OiBCdWZmZXIpIHtcbiAgICBzdXBlcihfZnMsIF9wYXRoLCBfZmxhZywgX3N0YXQsIGNvbnRlbnRzKTtcbiAgICB0aGlzLl9yZW1vdGVGZElkID0gcmVtb3RlRmRJZDtcbiAgfVxuXG4gIHB1YmxpYyBnZXRSZW1vdGVGZElkKCkge1xuICAgIHJldHVybiB0aGlzLl9yZW1vdGVGZElkO1xuICB9XG5cbiAgLyoqXG4gICAqIEBoaWRkZW5cbiAgICovXG4gIHB1YmxpYyB0b1JlbW90ZUFyZygpOiBJRmlsZURlc2NyaXB0b3JBcmd1bWVudCB7XG4gICAgcmV0dXJuIDxJRmlsZURlc2NyaXB0b3JBcmd1bWVudD4ge1xuICAgICAgdHlwZTogU3BlY2lhbEFyZ1R5cGUuRkQsXG4gICAgICBpZDogdGhpcy5fcmVtb3RlRmRJZCxcbiAgICAgIGRhdGE6IGJ1ZmZlclRvVHJhbnNmZXJyYWJsZU9iamVjdCh0aGlzLmdldEJ1ZmZlcigpKSxcbiAgICAgIHN0YXQ6IGJ1ZmZlclRvVHJhbnNmZXJyYWJsZU9iamVjdCh0aGlzLmdldFN0YXRzKCkudG9CdWZmZXIoKSksXG4gICAgICBwYXRoOiB0aGlzLmdldFBhdGgoKSxcbiAgICAgIGZsYWc6IHRoaXMuZ2V0RmxhZygpLmdldEZsYWdTdHJpbmcoKVxuICAgIH07XG4gIH1cblxuICBwdWJsaWMgc3luYyhjYjogQkZTT25lQXJnQ2FsbGJhY2spOiB2b2lkIHtcbiAgICB0aGlzLl9zeW5jQ2xvc2UoJ3N5bmMnLCBjYik7XG4gIH1cblxuICBwdWJsaWMgY2xvc2UoY2I6IEJGU09uZUFyZ0NhbGxiYWNrKTogdm9pZCB7XG4gICAgdGhpcy5fc3luY0Nsb3NlKCdjbG9zZScsIGNiKTtcbiAgfVxuXG4gIHByaXZhdGUgX3N5bmNDbG9zZSh0eXBlOiBzdHJpbmcsIGNiOiBCRlNPbmVBcmdDYWxsYmFjayk6IHZvaWQge1xuICAgIGlmICh0aGlzLmlzRGlydHkoKSkge1xuICAgICAgKDxXb3JrZXJGUz4gdGhpcy5fZnMpLnN5bmNDbG9zZSh0eXBlLCB0aGlzLCAoZT86IEFwaUVycm9yKSA9PiB7XG4gICAgICAgIGlmICghZSkge1xuICAgICAgICAgIHRoaXMucmVzZXREaXJ0eSgpO1xuICAgICAgICB9XG4gICAgICAgIGNiKGUpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNiKCk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgV29ya2VyRlNPcHRpb25zIHtcbiAgLy8gVGhlIHRhcmdldCB3b3JrZXIgdGhhdCB5b3Ugd2FudCB0byBjb25uZWN0IHRvLCBvciB0aGUgY3VycmVudCB3b3JrZXIgaWYgaW4gYSB3b3JrZXIgY29udGV4dC5cbiAgd29ya2VyOiBXb3JrZXI7XG59XG5cbi8qKlxuICogV29ya2VyRlMgbGV0cyB5b3UgYWNjZXNzIGEgQnJvd3NlckZTIGluc3RhbmNlIHRoYXQgaXMgcnVubmluZyBpbiBhIGRpZmZlcmVudFxuICogSmF2YVNjcmlwdCBjb250ZXh0IChlLmcuIGFjY2VzcyBCcm93c2VyRlMgaW4gb25lIG9mIHlvdXIgV2ViV29ya2Vycywgb3JcbiAqIGFjY2VzcyBCcm93c2VyRlMgcnVubmluZyBvbiB0aGUgbWFpbiBwYWdlIGZyb20gYSBXZWJXb3JrZXIpLlxuICpcbiAqIEZvciBleGFtcGxlLCB0byBoYXZlIGEgV2ViV29ya2VyIGFjY2VzcyBmaWxlcyBpbiB0aGUgbWFpbiBicm93c2VyIHRocmVhZCxcbiAqIGRvIHRoZSBmb2xsb3dpbmc6XG4gKlxuICogTUFJTiBCUk9XU0VSIFRIUkVBRDpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiAgIC8vIExpc3RlbiBmb3IgcmVtb3RlIGZpbGUgc3lzdGVtIHJlcXVlc3RzLlxuICogICBCcm93c2VyRlMuRmlsZVN5c3RlbS5Xb3JrZXJGUy5hdHRhY2hSZW1vdGVMaXN0ZW5lcih3ZWJXb3JrZXJPYmplY3QpO1xuICogYGBgXG4gKlxuICogV0VCV09SS0VSIFRIUkVBRDpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiAgIC8vIFNldCB0aGUgcmVtb3RlIGZpbGUgc3lzdGVtIGFzIHRoZSByb290IGZpbGUgc3lzdGVtLlxuICogICBCcm93c2VyRlMuY29uZmlndXJlKHsgZnM6IFwiV29ya2VyRlNcIiwgb3B0aW9uczogeyB3b3JrZXI6IHNlbGYgfX0sIGZ1bmN0aW9uKGUpIHtcbiAqICAgICAvLyBSZWFkeSFcbiAqICAgfSk7XG4gKiBgYGBcbiAqXG4gKiBOb3RlIHRoYXQgc3luY2hyb25vdXMgb3BlcmF0aW9ucyBhcmUgbm90IHBlcm1pdHRlZCBvbiB0aGUgV29ya2VyRlMsIHJlZ2FyZGxlc3NcbiAqIG9mIHRoZSBjb25maWd1cmF0aW9uIG9wdGlvbiBvZiB0aGUgcmVtb3RlIEZTLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXb3JrZXJGUyBleHRlbmRzIEJhc2VGaWxlU3lzdGVtIGltcGxlbWVudHMgRmlsZVN5c3RlbSB7XG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgTmFtZSA9IFwiV29ya2VyRlNcIjtcblxuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IE9wdGlvbnM6IEZpbGVTeXN0ZW1PcHRpb25zID0ge1xuICAgIHdvcmtlcjoge1xuICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgIGRlc2NyaXB0aW9uOiBcIlRoZSB0YXJnZXQgd29ya2VyIHRoYXQgeW91IHdhbnQgdG8gY29ubmVjdCB0bywgb3IgdGhlIGN1cnJlbnQgd29ya2VyIGlmIGluIGEgd29ya2VyIGNvbnRleHQuXCIsXG4gICAgICB2YWxpZGF0b3I6IGZ1bmN0aW9uKHY6IG9iamVjdCwgY2I6IEJGU09uZUFyZ0NhbGxiYWNrKTogdm9pZCB7XG4gICAgICAgIC8vIENoZWNrIGZvciBhIGBwb3N0TWVzc2FnZWAgZnVuY3Rpb24uXG4gICAgICAgIGlmICgoPGFueT4gdilbJ3Bvc3RNZXNzYWdlJ10pIHtcbiAgICAgICAgICBjYigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNiKG5ldyBBcGlFcnJvcihFcnJvckNvZGUuRUlOVkFMLCBgb3B0aW9uIG11c3QgYmUgYSBXZWIgV29ya2VyIGluc3RhbmNlLmApKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBwdWJsaWMgc3RhdGljIENyZWF0ZShvcHRzOiBXb3JrZXJGU09wdGlvbnMsIGNiOiBCRlNDYWxsYmFjazxXb3JrZXJGUz4pOiB2b2lkIHtcbiAgICBjb25zdCBmcyA9IG5ldyBXb3JrZXJGUyhvcHRzLndvcmtlciwgZmFsc2UpO1xuICAgIGZzLmluaXRpYWxpemUoKCkgPT4ge1xuICAgICAgY2IobnVsbCwgZnMpO1xuICAgIH0pO1xuICB9XG4gIHB1YmxpYyBzdGF0aWMgaXNBdmFpbGFibGUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHR5cGVvZihpbXBvcnRTY3JpcHRzKSAhPT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mKFdvcmtlcikgIT09ICd1bmRlZmluZWQnO1xuICB9XG5cbiAgLyoqXG4gICAqIEF0dGFjaGVzIGEgbGlzdGVuZXIgdG8gdGhlIHJlbW90ZSB3b3JrZXIgZm9yIGZpbGUgc3lzdGVtIHJlcXVlc3RzLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBhdHRhY2hSZW1vdGVMaXN0ZW5lcih3b3JrZXI6IFdvcmtlcikge1xuICAgIGNvbnN0IGZkQ29udmVydGVyID0gbmV3IEZpbGVEZXNjcmlwdG9yQXJndW1lbnRDb252ZXJ0ZXIoKTtcblxuICAgIGZ1bmN0aW9uIGFyZ0xvY2FsMlJlbW90ZShhcmc6IGFueSwgcmVxdWVzdEFyZ3M6IGFueVtdLCBjYjogQkZTQ2FsbGJhY2s8YW55Pik6IHZvaWQge1xuICAgICAgc3dpdGNoICh0eXBlb2YgYXJnKSB7XG4gICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgaWYgKGFyZyBpbnN0YW5jZW9mIFN0YXRzKSB7XG4gICAgICAgICAgICBjYihudWxsLCBzdGF0c0xvY2FsMlJlbW90ZShhcmcpKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGFyZyBpbnN0YW5jZW9mIEFwaUVycm9yKSB7XG4gICAgICAgICAgICBjYihudWxsLCBhcGlFcnJvckxvY2FsMlJlbW90ZShhcmcpKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGFyZyBpbnN0YW5jZW9mIEJhc2VGaWxlKSB7XG4gICAgICAgICAgICAvLyBQYXNzIGluIHAgYW5kIGZsYWdzIGZyb20gb3JpZ2luYWwgcmVxdWVzdC5cbiAgICAgICAgICAgIGNiKG51bGwsIGZkQ29udmVydGVyLnRvUmVtb3RlQXJnKDxGaWxlPiBhcmcsIHJlcXVlc3RBcmdzWzBdLCByZXF1ZXN0QXJnc1sxXSwgY2IpKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGFyZyBpbnN0YW5jZW9mIEZpbGVGbGFnKSB7XG4gICAgICAgICAgICBjYihudWxsLCBmaWxlRmxhZ0xvY2FsMlJlbW90ZShhcmcpKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGFyZyBpbnN0YW5jZW9mIEJ1ZmZlcikge1xuICAgICAgICAgICAgY2IobnVsbCwgYnVmZmVyTG9jYWwyUmVtb3RlKGFyZykpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoYXJnIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIGNiKG51bGwsIGVycm9yTG9jYWwyUmVtb3RlKGFyZykpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYihudWxsLCBhcmcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBjYihudWxsLCBhcmcpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFyZ1JlbW90ZTJMb2NhbChhcmc6IGFueSwgZml4ZWRSZXF1ZXN0QXJnczogYW55W10pOiBhbnkge1xuICAgICAgaWYgKCFhcmcpIHtcbiAgICAgICAgcmV0dXJuIGFyZztcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAodHlwZW9mIGFyZykge1xuICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgIGlmICh0eXBlb2YgYXJnWyd0eXBlJ10gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBjb25zdCBzcGVjaWFsQXJnID0gPElTcGVjaWFsQXJndW1lbnQ+IGFyZztcbiAgICAgICAgICAgIHN3aXRjaCAoc3BlY2lhbEFyZy50eXBlKSB7XG4gICAgICAgICAgICAgIGNhc2UgU3BlY2lhbEFyZ1R5cGUuQ0I6XG4gICAgICAgICAgICAgICAgY29uc3QgY2JJZCA9ICg8SUNhbGxiYWNrQXJndW1lbnQ+IGFyZykuaWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgbGV0IGk6IG51bWJlcjtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGZpeGVkQXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgIGxldCBtZXNzYWdlOiBJQVBJUmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZG93biA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGFib3J0QW5kU2VuZEVycm9yKGVycjogQXBpRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvdW50ZG93biA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICBjb3VudGRvd24gPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJvd3NlcmZzTWVzc2FnZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNiSWQ6IGNiSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBbYXBpRXJyb3JMb2NhbDJSZW1vdGUoZXJyKV1cbiAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgIHdvcmtlci5wb3N0TWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENhcHR1cmUgaSBhbmQgYXJndW1lbnQuXG4gICAgICAgICAgICAgICAgICAgICgoaTogbnVtYmVyLCBhcmc6IGFueSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgIGFyZ0xvY2FsMlJlbW90ZShhcmcsIGZpeGVkUmVxdWVzdEFyZ3MsIChlcnIsIGZpeGVkQXJnPykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZml4ZWRBcmdzW2ldID0gZml4ZWRBcmc7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGFib3J0QW5kU2VuZEVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKC0tY291bnRkb3duID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJvd3NlcmZzTWVzc2FnZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYklkOiBjYklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IGZpeGVkQXJnc1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICB3b3JrZXIucG9zdE1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pKGksIGFyZ3VtZW50c1tpXSk7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgYnJvd3NlcmZzTWVzc2FnZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICBjYklkOiBjYklkLFxuICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IGZpeGVkQXJnc1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB3b3JrZXIucG9zdE1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBjYXNlIFNwZWNpYWxBcmdUeXBlLkFQSV9FUlJPUjpcbiAgICAgICAgICAgICAgICByZXR1cm4gYXBpRXJyb3JSZW1vdGUyTG9jYWwoPElBUElFcnJvckFyZ3VtZW50PiBzcGVjaWFsQXJnKTtcbiAgICAgICAgICAgICAgY2FzZSBTcGVjaWFsQXJnVHlwZS5TVEFUUzpcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdHNSZW1vdGUyTG9jYWwoPElTdGF0c0FyZ3VtZW50PiBzcGVjaWFsQXJnKTtcbiAgICAgICAgICAgICAgY2FzZSBTcGVjaWFsQXJnVHlwZS5GSUxFRkxBRzpcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsZUZsYWdSZW1vdGUyTG9jYWwoPElGaWxlRmxhZ0FyZ3VtZW50PiBzcGVjaWFsQXJnKTtcbiAgICAgICAgICAgICAgY2FzZSBTcGVjaWFsQXJnVHlwZS5CVUZGRVI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlclJlbW90ZTJMb2NhbCg8SUJ1ZmZlckFyZ3VtZW50PiBzcGVjaWFsQXJnKTtcbiAgICAgICAgICAgICAgY2FzZSBTcGVjaWFsQXJnVHlwZS5FUlJPUjpcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3JSZW1vdGUyTG9jYWwoPElFcnJvckFyZ3VtZW50PiBzcGVjaWFsQXJnKTtcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAvLyBObyBpZGVhIHdoYXQgdGhpcyBpcy5cbiAgICAgICAgICAgICAgICByZXR1cm4gYXJnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYXJnO1xuICAgICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gYXJnO1xuICAgICAgfVxuICAgIH1cblxuICAgIHdvcmtlci5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgKGU6IE1lc3NhZ2VFdmVudCkgPT4ge1xuICAgICAgY29uc3QgcmVxdWVzdDogb2JqZWN0ID0gZS5kYXRhO1xuICAgICAgaWYgKGlzQVBJUmVxdWVzdChyZXF1ZXN0KSkge1xuICAgICAgICBjb25zdCBhcmdzID0gcmVxdWVzdC5hcmdzLFxuICAgICAgICAgIGZpeGVkQXJncyA9IG5ldyBBcnJheTxhbnk+KGFyZ3MubGVuZ3RoKTtcblxuICAgICAgICBzd2l0Y2ggKHJlcXVlc3QubWV0aG9kKSB7XG4gICAgICAgICAgY2FzZSAnY2xvc2UnOlxuICAgICAgICAgIGNhc2UgJ3N5bmMnOlxuICAgICAgICAgICAgKCgpID0+IHtcbiAgICAgICAgICAgICAgLy8gRmlsZSBkZXNjcmlwdG9yLXJlbGF0aXZlIG1ldGhvZHMuXG4gICAgICAgICAgICAgIGNvbnN0IHJlbW90ZUNiID0gPElDYWxsYmFja0FyZ3VtZW50PiBhcmdzWzFdO1xuICAgICAgICAgICAgICBmZENvbnZlcnRlci5hcHBseUZkQVBJUmVxdWVzdChyZXF1ZXN0LCAoZXJyPzogQXBpRXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBTZW5kIHJlc3BvbnNlLlxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlOiBJQVBJUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICBicm93c2VyZnNNZXNzYWdlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgY2JJZDogcmVtb3RlQ2IuaWQsXG4gICAgICAgICAgICAgICAgICBhcmdzOiBlcnIgPyBbYXBpRXJyb3JMb2NhbDJSZW1vdGUoZXJyKV0gOiBbXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgd29ya2VyLnBvc3RNZXNzYWdlKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAncHJvYmUnOlxuICAgICAgICAgICAgKCgpID0+IHtcbiAgICAgICAgICAgICAgY29uc3Qgcm9vdEZzID0gPEZpbGVTeXN0ZW0+IGZzLmdldFJvb3RGUygpLFxuICAgICAgICAgICAgICAgIHJlbW90ZUNiID0gPElDYWxsYmFja0FyZ3VtZW50PiBhcmdzWzFdLFxuICAgICAgICAgICAgICAgIHByb2JlUmVzcG9uc2U6IElQcm9iZVJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgdHlwZTogU3BlY2lhbEFyZ1R5cGUuUFJPQkUsXG4gICAgICAgICAgICAgICAgICBpc1JlYWRPbmx5OiByb290RnMuaXNSZWFkT25seSgpLFxuICAgICAgICAgICAgICAgICAgc3VwcG9ydHNMaW5rczogcm9vdEZzLnN1cHBvcnRzTGlua3MoKSxcbiAgICAgICAgICAgICAgICAgIHN1cHBvcnRzUHJvcHM6IHJvb3RGcy5zdXBwb3J0c1Byb3BzKClcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlOiBJQVBJUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICBicm93c2VyZnNNZXNzYWdlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgY2JJZDogcmVtb3RlQ2IuaWQsXG4gICAgICAgICAgICAgICAgICBhcmdzOiBbcHJvYmVSZXNwb25zZV1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgIHdvcmtlci5wb3N0TWVzc2FnZShyZXNwb25zZSk7XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIC8vIEZpbGUgc3lzdGVtIG1ldGhvZHMuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgZml4ZWRBcmdzW2ldID0gYXJnUmVtb3RlMkxvY2FsKGFyZ3NbaV0sIGZpeGVkQXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByb290RlMgPSBmcy5nZXRSb290RlMoKTtcbiAgICAgICAgICAgICg8RnVuY3Rpb24+ICg8YW55PiByb290RlMpW3JlcXVlc3QubWV0aG9kXSkuYXBwbHkocm9vdEZTLCBmaXhlZEFyZ3MpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgX3dvcmtlcjogV29ya2VyO1xuICBwcml2YXRlIF9jYWxsYmFja0NvbnZlcnRlciA9IG5ldyBDYWxsYmFja0FyZ3VtZW50Q29udmVydGVyKCk7XG5cbiAgcHJpdmF0ZSBfaXNJbml0aWFsaXplZDogYm9vbGVhbiA9IGZhbHNlO1xuICBwcml2YXRlIF9pc1JlYWRPbmx5OiBib29sZWFuID0gZmFsc2U7XG4gIHByaXZhdGUgX3N1cHBvcnRMaW5rczogYm9vbGVhbiA9IGZhbHNlO1xuICBwcml2YXRlIF9zdXBwb3J0UHJvcHM6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAvKipcbiAgICogKipEZXByZWNhdGVkLiBQbGVhc2UgdXNlIFdvcmtlckZTLkNyZWF0ZSgpIG1ldGhvZCBpbnN0ZWFkLioqXG4gICAqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgV29ya2VyRlMgaW5zdGFuY2UgdGhhdCBjb25uZWN0cyB3aXRoIEJyb3dzZXJGUyBydW5uaW5nIG9uXG4gICAqIHRoZSBzcGVjaWZpZWQgd29ya2VyLlxuICAgKi9cbiAgY29uc3RydWN0b3Iod29ya2VyOiBXb3JrZXIsIGRlcHJlY2F0ZU1zZyA9IHRydWUpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX3dvcmtlciA9IHdvcmtlcjtcbiAgICBkZXByZWNhdGlvbk1lc3NhZ2UoZGVwcmVjYXRlTXNnLCBXb3JrZXJGUy5OYW1lLCB7d29ya2VyOiBcIldlYiBXb3JrZXIgaW5zdGFuY2VcIn0pO1xuICAgIHRoaXMuX3dvcmtlci5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgKGU6IE1lc3NhZ2VFdmVudCkgPT4ge1xuICAgICAgY29uc3QgcmVzcDogb2JqZWN0ID0gZS5kYXRhO1xuICAgICAgaWYgKGlzQVBJUmVzcG9uc2UocmVzcCkpIHtcbiAgICAgICAgbGV0IGk6IG51bWJlcjtcbiAgICAgICAgY29uc3QgYXJncyA9IHJlc3AuYXJncztcbiAgICAgICAgY29uc3QgZml4ZWRBcmdzID0gbmV3IEFycmF5KGFyZ3MubGVuZ3RoKTtcbiAgICAgICAgLy8gRGlzcGF0Y2ggZXZlbnQgdG8gY29ycmVjdCBpZC5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGZpeGVkQXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGZpeGVkQXJnc1tpXSA9IHRoaXMuX2FyZ1JlbW90ZTJMb2NhbChhcmdzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jYWxsYmFja0NvbnZlcnRlci50b0xvY2FsQXJnKHJlc3AuY2JJZCkuYXBwbHkobnVsbCwgZml4ZWRBcmdzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyBnZXROYW1lKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIFdvcmtlckZTLk5hbWU7XG4gIH1cblxuICAvKipcbiAgICogKipEZXByZWNhdGVkLiBQbGVhc2UgdXNlIFdvcmtlckZTLkNyZWF0ZSgpIG1ldGhvZCB0byBjb25zdHJ1Y3QgYW5kIGluaXRpYWxpemUgV29ya2VyRlMgaW5zdGFuY2VzLioqXG4gICAqXG4gICAqIENhbGxlZCBvbmNlIGJvdGggbG9jYWwgYW5kIHJlbW90ZSBzaWRlcyBhcmUgc2V0IHVwLlxuICAgKi9cbiAgcHVibGljIGluaXRpYWxpemUoY2I6ICgpID0+IHZvaWQpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuX2lzSW5pdGlhbGl6ZWQpIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2U6IElBUElSZXF1ZXN0ID0ge1xuICAgICAgICBicm93c2VyZnNNZXNzYWdlOiB0cnVlLFxuICAgICAgICBtZXRob2Q6ICdwcm9iZScsXG4gICAgICAgIGFyZ3M6IFt0aGlzLl9hcmdMb2NhbDJSZW1vdGUoZW1wdHlCdWZmZXIoKSksIHRoaXMuX2NhbGxiYWNrQ29udmVydGVyLnRvUmVtb3RlQXJnKChwcm9iZVJlc3BvbnNlOiBJUHJvYmVSZXNwb25zZSkgPT4ge1xuICAgICAgICAgIHRoaXMuX2lzSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuX2lzUmVhZE9ubHkgPSBwcm9iZVJlc3BvbnNlLmlzUmVhZE9ubHk7XG4gICAgICAgICAgdGhpcy5fc3VwcG9ydExpbmtzID0gcHJvYmVSZXNwb25zZS5zdXBwb3J0c0xpbmtzO1xuICAgICAgICAgIHRoaXMuX3N1cHBvcnRQcm9wcyA9IHByb2JlUmVzcG9uc2Uuc3VwcG9ydHNQcm9wcztcbiAgICAgICAgICBjYigpO1xuICAgICAgICB9KV1cbiAgICAgIH07XG4gICAgICB0aGlzLl93b3JrZXIucG9zdE1lc3NhZ2UobWVzc2FnZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNiKCk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGlzUmVhZE9ubHkoKTogYm9vbGVhbiB7IHJldHVybiB0aGlzLl9pc1JlYWRPbmx5OyB9XG4gIHB1YmxpYyBzdXBwb3J0c1N5bmNoKCk6IGJvb2xlYW4geyByZXR1cm4gZmFsc2U7IH1cbiAgcHVibGljIHN1cHBvcnRzTGlua3MoKTogYm9vbGVhbiB7IHJldHVybiB0aGlzLl9zdXBwb3J0TGlua3M7IH1cbiAgcHVibGljIHN1cHBvcnRzUHJvcHMoKTogYm9vbGVhbiB7IHJldHVybiB0aGlzLl9zdXBwb3J0UHJvcHM7IH1cblxuICBwdWJsaWMgcmVuYW1lKG9sZFBhdGg6IHN0cmluZywgbmV3UGF0aDogc3RyaW5nLCBjYjogQkZTT25lQXJnQ2FsbGJhY2spOiB2b2lkIHtcbiAgICB0aGlzLl9ycGMoJ3JlbmFtZScsIGFyZ3VtZW50cyk7XG4gIH1cbiAgcHVibGljIHN0YXQocDogc3RyaW5nLCBpc0xzdGF0OiBib29sZWFuLCBjYjogQkZTQ2FsbGJhY2s8U3RhdHM+KTogdm9pZCB7XG4gICAgdGhpcy5fcnBjKCdzdGF0JywgYXJndW1lbnRzKTtcbiAgfVxuICBwdWJsaWMgb3BlbihwOiBzdHJpbmcsIGZsYWc6IEZpbGVGbGFnLCBtb2RlOiBudW1iZXIsIGNiOiBCRlNDYWxsYmFjazxGaWxlPik6IHZvaWQge1xuICAgIHRoaXMuX3JwYygnb3BlbicsIGFyZ3VtZW50cyk7XG4gIH1cbiAgcHVibGljIHVubGluayhwOiBzdHJpbmcsIGNiOiBGdW5jdGlvbik6IHZvaWQge1xuICAgIHRoaXMuX3JwYygndW5saW5rJywgYXJndW1lbnRzKTtcbiAgfVxuICBwdWJsaWMgcm1kaXIocDogc3RyaW5nLCBjYjogRnVuY3Rpb24pOiB2b2lkIHtcbiAgICB0aGlzLl9ycGMoJ3JtZGlyJywgYXJndW1lbnRzKTtcbiAgfVxuICBwdWJsaWMgbWtkaXIocDogc3RyaW5nLCBtb2RlOiBudW1iZXIsIGNiOiBGdW5jdGlvbik6IHZvaWQge1xuICAgIHRoaXMuX3JwYygnbWtkaXInLCBhcmd1bWVudHMpO1xuICB9XG4gIHB1YmxpYyByZWFkZGlyKHA6IHN0cmluZywgY2I6IEJGU0NhbGxiYWNrPHN0cmluZ1tdPik6IHZvaWQge1xuICAgIHRoaXMuX3JwYygncmVhZGRpcicsIGFyZ3VtZW50cyk7XG4gIH1cbiAgcHVibGljIGV4aXN0cyhwOiBzdHJpbmcsIGNiOiAoZXhpc3RzOiBib29sZWFuKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgdGhpcy5fcnBjKCdleGlzdHMnLCBhcmd1bWVudHMpO1xuICB9XG4gIHB1YmxpYyByZWFscGF0aChwOiBzdHJpbmcsIGNhY2hlOiB7IFtwYXRoOiBzdHJpbmddOiBzdHJpbmcgfSwgY2I6IEJGU0NhbGxiYWNrPHN0cmluZz4pOiB2b2lkIHtcbiAgICB0aGlzLl9ycGMoJ3JlYWxwYXRoJywgYXJndW1lbnRzKTtcbiAgfVxuICBwdWJsaWMgdHJ1bmNhdGUocDogc3RyaW5nLCBsZW46IG51bWJlciwgY2I6IEZ1bmN0aW9uKTogdm9pZCB7XG4gICAgdGhpcy5fcnBjKCd0cnVuY2F0ZScsIGFyZ3VtZW50cyk7XG4gIH1cbiAgcHVibGljIHJlYWRGaWxlKGZuYW1lOiBzdHJpbmcsIGVuY29kaW5nOiBzdHJpbmcsIGZsYWc6IEZpbGVGbGFnLCBjYjogQkZTQ2FsbGJhY2s8YW55Pik6IHZvaWQge1xuICAgIHRoaXMuX3JwYygncmVhZEZpbGUnLCBhcmd1bWVudHMpO1xuICB9XG4gIHB1YmxpYyB3cml0ZUZpbGUoZm5hbWU6IHN0cmluZywgZGF0YTogYW55LCBlbmNvZGluZzogc3RyaW5nLCBmbGFnOiBGaWxlRmxhZywgbW9kZTogbnVtYmVyLCBjYjogQkZTT25lQXJnQ2FsbGJhY2spOiB2b2lkIHtcbiAgICB0aGlzLl9ycGMoJ3dyaXRlRmlsZScsIGFyZ3VtZW50cyk7XG4gIH1cbiAgcHVibGljIGFwcGVuZEZpbGUoZm5hbWU6IHN0cmluZywgZGF0YTogYW55LCBlbmNvZGluZzogc3RyaW5nLCBmbGFnOiBGaWxlRmxhZywgbW9kZTogbnVtYmVyLCBjYjogQkZTT25lQXJnQ2FsbGJhY2spOiB2b2lkIHtcbiAgICB0aGlzLl9ycGMoJ2FwcGVuZEZpbGUnLCBhcmd1bWVudHMpO1xuICB9XG4gIHB1YmxpYyBjaG1vZChwOiBzdHJpbmcsIGlzTGNobW9kOiBib29sZWFuLCBtb2RlOiBudW1iZXIsIGNiOiBGdW5jdGlvbik6IHZvaWQge1xuICAgIHRoaXMuX3JwYygnY2htb2QnLCBhcmd1bWVudHMpO1xuICB9XG4gIHB1YmxpYyBjaG93bihwOiBzdHJpbmcsIGlzTGNob3duOiBib29sZWFuLCB1aWQ6IG51bWJlciwgZ2lkOiBudW1iZXIsIGNiOiBGdW5jdGlvbik6IHZvaWQge1xuICAgIHRoaXMuX3JwYygnY2hvd24nLCBhcmd1bWVudHMpO1xuICB9XG4gIHB1YmxpYyB1dGltZXMocDogc3RyaW5nLCBhdGltZTogRGF0ZSwgbXRpbWU6IERhdGUsIGNiOiBGdW5jdGlvbik6IHZvaWQge1xuICAgIHRoaXMuX3JwYygndXRpbWVzJywgYXJndW1lbnRzKTtcbiAgfVxuICBwdWJsaWMgbGluayhzcmNwYXRoOiBzdHJpbmcsIGRzdHBhdGg6IHN0cmluZywgY2I6IEZ1bmN0aW9uKTogdm9pZCB7XG4gICAgdGhpcy5fcnBjKCdsaW5rJywgYXJndW1lbnRzKTtcbiAgfVxuICBwdWJsaWMgc3ltbGluayhzcmNwYXRoOiBzdHJpbmcsIGRzdHBhdGg6IHN0cmluZywgdHlwZTogc3RyaW5nLCBjYjogRnVuY3Rpb24pOiB2b2lkIHtcbiAgICB0aGlzLl9ycGMoJ3N5bWxpbmsnLCBhcmd1bWVudHMpO1xuICB9XG4gIHB1YmxpYyByZWFkbGluayhwOiBzdHJpbmcsIGNiOiBGdW5jdGlvbik6IHZvaWQge1xuICAgIHRoaXMuX3JwYygncmVhZGxpbmsnLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcHVibGljIHN5bmNDbG9zZShtZXRob2Q6IHN0cmluZywgZmQ6IEZpbGUsIGNiOiBCRlNPbmVBcmdDYWxsYmFjayk6IHZvaWQge1xuICAgIHRoaXMuX3dvcmtlci5wb3N0TWVzc2FnZSg8SUFQSVJlcXVlc3Q+IHtcbiAgICAgIGJyb3dzZXJmc01lc3NhZ2U6IHRydWUsXG4gICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgIGFyZ3M6IFsoPFdvcmtlckZpbGU+IGZkKS50b1JlbW90ZUFyZygpLCB0aGlzLl9jYWxsYmFja0NvbnZlcnRlci50b1JlbW90ZUFyZyhjYildXG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIF9hcmdSZW1vdGUyTG9jYWwoYXJnOiBhbnkpOiBhbnkge1xuICAgIGlmICghYXJnKSB7XG4gICAgICByZXR1cm4gYXJnO1xuICAgIH1cbiAgICBzd2l0Y2ggKHR5cGVvZiBhcmcpIHtcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIGlmICh0eXBlb2YgYXJnWyd0eXBlJ10gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgY29uc3Qgc3BlY2lhbEFyZyA9IDxJU3BlY2lhbEFyZ3VtZW50PiBhcmc7XG4gICAgICAgICAgc3dpdGNoIChzcGVjaWFsQXJnLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgU3BlY2lhbEFyZ1R5cGUuQVBJX0VSUk9SOlxuICAgICAgICAgICAgICByZXR1cm4gYXBpRXJyb3JSZW1vdGUyTG9jYWwoPElBUElFcnJvckFyZ3VtZW50PiBzcGVjaWFsQXJnKTtcbiAgICAgICAgICAgIGNhc2UgU3BlY2lhbEFyZ1R5cGUuRkQ6XG4gICAgICAgICAgICAgIGNvbnN0IGZkQXJnID0gPElGaWxlRGVzY3JpcHRvckFyZ3VtZW50PiBzcGVjaWFsQXJnO1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IFdvcmtlckZpbGUodGhpcywgZmRBcmcucGF0aCwgRmlsZUZsYWcuZ2V0RmlsZUZsYWcoZmRBcmcuZmxhZyksIFN0YXRzLmZyb21CdWZmZXIodHJhbnNmZXJyYWJsZU9iamVjdFRvQnVmZmVyKGZkQXJnLnN0YXQpKSwgZmRBcmcuaWQsIHRyYW5zZmVycmFibGVPYmplY3RUb0J1ZmZlcihmZEFyZy5kYXRhKSk7XG4gICAgICAgICAgICBjYXNlIFNwZWNpYWxBcmdUeXBlLlNUQVRTOlxuICAgICAgICAgICAgICByZXR1cm4gc3RhdHNSZW1vdGUyTG9jYWwoPElTdGF0c0FyZ3VtZW50PiBzcGVjaWFsQXJnKTtcbiAgICAgICAgICAgIGNhc2UgU3BlY2lhbEFyZ1R5cGUuRklMRUZMQUc6XG4gICAgICAgICAgICAgIHJldHVybiBmaWxlRmxhZ1JlbW90ZTJMb2NhbCg8SUZpbGVGbGFnQXJndW1lbnQ+IHNwZWNpYWxBcmcpO1xuICAgICAgICAgICAgY2FzZSBTcGVjaWFsQXJnVHlwZS5CVUZGRVI6XG4gICAgICAgICAgICAgIHJldHVybiBidWZmZXJSZW1vdGUyTG9jYWwoPElCdWZmZXJBcmd1bWVudD4gc3BlY2lhbEFyZyk7XG4gICAgICAgICAgICBjYXNlIFNwZWNpYWxBcmdUeXBlLkVSUk9SOlxuICAgICAgICAgICAgICByZXR1cm4gZXJyb3JSZW1vdGUyTG9jYWwoPElFcnJvckFyZ3VtZW50PiBzcGVjaWFsQXJnKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHJldHVybiBhcmc7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBhcmc7XG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBhcmc7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBfcnBjKG1ldGhvZE5hbWU6IHN0cmluZywgYXJnczogSUFyZ3VtZW50cykge1xuICAgIGNvbnN0IGZpeGVkQXJncyA9IG5ldyBBcnJheShhcmdzLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBmaXhlZEFyZ3NbaV0gPSB0aGlzLl9hcmdMb2NhbDJSZW1vdGUoYXJnc1tpXSk7XG4gICAgfVxuICAgIGNvbnN0IG1lc3NhZ2U6IElBUElSZXF1ZXN0ID0ge1xuICAgICAgYnJvd3NlcmZzTWVzc2FnZTogdHJ1ZSxcbiAgICAgIG1ldGhvZDogbWV0aG9kTmFtZSxcbiAgICAgIGFyZ3M6IGZpeGVkQXJnc1xuICAgIH07XG4gICAgdGhpcy5fd29ya2VyLnBvc3RNZXNzYWdlKG1lc3NhZ2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGEgbG9jYWwgYXJndW1lbnQgaW50byBhIHJlbW90ZSBhcmd1bWVudC4gUHVibGljIHNvIFdvcmtlckZpbGUgb2JqZWN0cyBjYW4gY2FsbCBpdC5cbiAgICovXG4gIHByaXZhdGUgX2FyZ0xvY2FsMlJlbW90ZShhcmc6IGFueSk6IGFueSB7XG4gICAgaWYgKCFhcmcpIHtcbiAgICAgIHJldHVybiBhcmc7XG4gICAgfVxuICAgIHN3aXRjaCAodHlwZW9mIGFyZykge1xuICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICBpZiAoYXJnIGluc3RhbmNlb2YgU3RhdHMpIHtcbiAgICAgICAgICByZXR1cm4gc3RhdHNMb2NhbDJSZW1vdGUoYXJnKTtcbiAgICAgICAgfSBlbHNlIGlmIChhcmcgaW5zdGFuY2VvZiBBcGlFcnJvcikge1xuICAgICAgICAgIHJldHVybiBhcGlFcnJvckxvY2FsMlJlbW90ZShhcmcpO1xuICAgICAgICB9IGVsc2UgaWYgKGFyZyBpbnN0YW5jZW9mIFdvcmtlckZpbGUpIHtcbiAgICAgICAgICByZXR1cm4gKDxXb3JrZXJGaWxlPiBhcmcpLnRvUmVtb3RlQXJnKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoYXJnIGluc3RhbmNlb2YgRmlsZUZsYWcpIHtcbiAgICAgICAgICByZXR1cm4gZmlsZUZsYWdMb2NhbDJSZW1vdGUoYXJnKTtcbiAgICAgICAgfSBlbHNlIGlmIChhcmcgaW5zdGFuY2VvZiBCdWZmZXIpIHtcbiAgICAgICAgICByZXR1cm4gYnVmZmVyTG9jYWwyUmVtb3RlKGFyZyk7XG4gICAgICAgIH0gZWxzZSBpZiAoYXJnIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3JMb2NhbDJSZW1vdGUoYXJnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gXCJVbmtub3duIGFyZ3VtZW50XCI7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICByZXR1cm4gdGhpcy5fY2FsbGJhY2tDb252ZXJ0ZXIudG9SZW1vdGVBcmcoYXJnKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBhcmc7XG4gICAgfVxuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vLi4vLi4vLi4vc3JjL2JhY2tlbmQvV29ya2VyRlMudHMiLCIvKipcbiAqIENvbnRhaW5zIHV0aWxpdHkgbWV0aG9kcyBmb3IgcGVyZm9ybWluZyBhIHZhcmlldHkgb2YgdGFza3Mgd2l0aFxuICogWG1sSHR0cFJlcXVlc3QgYWNyb3NzIGJyb3dzZXJzLlxuICovXG5cbmltcG9ydCB7aXNJRSwgZW1wdHlCdWZmZXJ9IGZyb20gJy4uL2NvcmUvdXRpbCc7XG5pbXBvcnQge0FwaUVycm9yLCBFcnJvckNvZGV9IGZyb20gJy4uL2NvcmUvYXBpX2Vycm9yJztcbmltcG9ydCB7QkZTQ2FsbGJhY2t9IGZyb20gJy4uL2NvcmUvZmlsZV9zeXN0ZW0nO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZnVuY3Rpb24gYXN5bmNEb3dubG9hZEZpbGVNb2Rlcm4ocDogc3RyaW5nLCB0eXBlOiAnYnVmZmVyJywgY2I6IEJGU0NhbGxiYWNrPEJ1ZmZlcj4pOiB2b2lkO1xuZnVuY3Rpb24gYXN5bmNEb3dubG9hZEZpbGVNb2Rlcm4ocDogc3RyaW5nLCB0eXBlOiAnanNvbicsIGNiOiBCRlNDYWxsYmFjazxhbnk+KTogdm9pZDtcbmZ1bmN0aW9uIGFzeW5jRG93bmxvYWRGaWxlTW9kZXJuKHA6IHN0cmluZywgdHlwZTogc3RyaW5nLCBjYjogQkZTQ2FsbGJhY2s8YW55Pik6IHZvaWQ7XG5mdW5jdGlvbiBhc3luY0Rvd25sb2FkRmlsZU1vZGVybihwOiBzdHJpbmcsIHR5cGU6IHN0cmluZywgY2I6IEJGU0NhbGxiYWNrPGFueT4pOiB2b2lkIHtcbiAgY29uc3QgcmVxID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gIHJlcS5vcGVuKCdHRVQnLCBwLCB0cnVlKTtcbiAgbGV0IGpzb25TdXBwb3J0ZWQgPSB0cnVlO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdidWZmZXInOlxuICAgICAgcmVxLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdqc29uJzpcbiAgICAgLy8gU29tZSBicm93c2VycyBkb24ndCBzdXBwb3J0IHRoZSBKU09OIHJlc3BvbnNlIHR5cGUuXG4gICAgIC8vIFRoZXkgZWl0aGVyIHJlc2V0IHJlc3BvbnNlVHlwZSwgb3IgdGhyb3cgYW4gZXhjZXB0aW9uLlxuICAgICAvLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9Nb2Rlcm5penIvTW9kZXJuaXpyL2Jsb2IvbWFzdGVyL3NyYy90ZXN0WGhyVHlwZS5qc1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmVxLnJlc3BvbnNlVHlwZSA9ICdqc29uJztcbiAgICAgICAganNvblN1cHBvcnRlZCA9IHJlcS5yZXNwb25zZVR5cGUgPT09ICdqc29uJztcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAganNvblN1cHBvcnRlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBjYihuZXcgQXBpRXJyb3IoRXJyb3JDb2RlLkVJTlZBTCwgXCJJbnZhbGlkIGRvd25sb2FkIHR5cGU6IFwiICsgdHlwZSkpO1xuICB9XG4gIHJlcS5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbihlKSB7XG4gICAgaWYgKHJlcS5yZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICBpZiAocmVxLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgJ2J1ZmZlcic6XG4gICAgICAgICAgICAvLyBYWFg6IFdlYktpdC1iYXNlZCBicm93c2VycyByZXR1cm4gKm51bGwqIHdoZW4gWEhSaW5nIGFuIGVtcHR5IGZpbGUuXG4gICAgICAgICAgICByZXR1cm4gY2IobnVsbCwgcmVxLnJlc3BvbnNlID8gQnVmZmVyLmZyb20ocmVxLnJlc3BvbnNlKSA6IGVtcHR5QnVmZmVyKCkpO1xuICAgICAgICAgIGNhc2UgJ2pzb24nOlxuICAgICAgICAgICAgaWYgKGpzb25TdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNiKG51bGwsIHJlcS5yZXNwb25zZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gY2IobnVsbCwgSlNPTi5wYXJzZShyZXEucmVzcG9uc2VUZXh0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjYihuZXcgQXBpRXJyb3IocmVxLnN0YXR1cywgXCJYSFIgZXJyb3IuXCIpKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHJlcS5zZW5kKCk7XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5mdW5jdGlvbiBzeW5jRG93bmxvYWRGaWxlTW9kZXJuKHA6IHN0cmluZywgdHlwZTogJ2J1ZmZlcicpOiBCdWZmZXI7XG5mdW5jdGlvbiBzeW5jRG93bmxvYWRGaWxlTW9kZXJuKHA6IHN0cmluZywgdHlwZTogJ2pzb24nKTogYW55O1xuZnVuY3Rpb24gc3luY0Rvd25sb2FkRmlsZU1vZGVybihwOiBzdHJpbmcsIHR5cGU6IHN0cmluZyk6IGFueTtcbmZ1bmN0aW9uIHN5bmNEb3dubG9hZEZpbGVNb2Rlcm4ocDogc3RyaW5nLCB0eXBlOiBzdHJpbmcpOiBhbnkge1xuICBjb25zdCByZXEgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgcmVxLm9wZW4oJ0dFVCcsIHAsIGZhbHNlKTtcblxuICAvLyBPbiBtb3N0IHBsYXRmb3Jtcywgd2UgY2Fubm90IHNldCB0aGUgcmVzcG9uc2VUeXBlIG9mIHN5bmNocm9ub3VzIGRvd25sb2Fkcy5cbiAgLy8gQHRvZG8gVGVzdCBmb3IgdGhpczsgSUUxMCBhbGxvd3MgdGhpcywgYXMgZG8gb2xkZXIgdmVyc2lvbnMgb2YgQ2hyb21lL0ZGLlxuICBsZXQgZGF0YTogYW55ID0gbnVsbDtcbiAgbGV0IGVycjogYW55ID0gbnVsbDtcbiAgLy8gQ2xhc3NpYyBoYWNrIHRvIGRvd25sb2FkIGJpbmFyeSBkYXRhIGFzIGEgc3RyaW5nLlxuICByZXEub3ZlcnJpZGVNaW1lVHlwZSgndGV4dC9wbGFpbjsgY2hhcnNldD14LXVzZXItZGVmaW5lZCcpO1xuICByZXEub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oZSkge1xuICAgIGlmIChyZXEucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgaWYgKHJlcS5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlICdidWZmZXInOlxuICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgdGV4dCBpbnRvIGEgYnVmZmVyLlxuICAgICAgICAgICAgY29uc3QgdGV4dCA9IHJlcS5yZXNwb25zZVRleHQ7XG4gICAgICAgICAgICBkYXRhID0gQnVmZmVyLmFsbG9jKHRleHQubGVuZ3RoKTtcbiAgICAgICAgICAgIC8vIFRocm93IGF3YXkgdGhlIHVwcGVyIGJpdHMgb2YgZWFjaCBjaGFyYWN0ZXIuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRleHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgLy8gVGhpcyB3aWxsIGF1dG9tYXRpY2FsbHkgdGhyb3cgYXdheSB0aGUgdXBwZXIgYml0IG9mIGVhY2hcbiAgICAgICAgICAgICAgLy8gY2hhcmFjdGVyIGZvciB1cy5cbiAgICAgICAgICAgICAgZGF0YVtpXSA9IHRleHQuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBjYXNlICdqc29uJzpcbiAgICAgICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKHJlcS5yZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnIgPSBuZXcgQXBpRXJyb3IocmVxLnN0YXR1cywgXCJYSFIgZXJyb3IuXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9O1xuICByZXEuc2VuZCgpO1xuICBpZiAoZXJyKSB7XG4gICAgdGhyb3cgZXJyO1xuICB9XG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIElFMTAgYWxsb3dzIHVzIHRvIHBlcmZvcm0gc3luY2hyb25vdXMgYmluYXJ5IGZpbGUgZG93bmxvYWRzLlxuICogQHRvZG8gRmVhdHVyZSBkZXRlY3QgdGhpcywgYXMgb2xkZXIgdmVyc2lvbnMgb2YgRkYvQ2hyb21lIGRvIHRvbyFcbiAqIEBoaWRkZW5cbiAqL1xuZnVuY3Rpb24gc3luY0Rvd25sb2FkRmlsZUlFMTAocDogc3RyaW5nLCB0eXBlOiAnYnVmZmVyJyk6IEJ1ZmZlcjtcbmZ1bmN0aW9uIHN5bmNEb3dubG9hZEZpbGVJRTEwKHA6IHN0cmluZywgdHlwZTogJ2pzb24nKTogYW55O1xuZnVuY3Rpb24gc3luY0Rvd25sb2FkRmlsZUlFMTAocDogc3RyaW5nLCB0eXBlOiBzdHJpbmcpOiBhbnk7XG5mdW5jdGlvbiBzeW5jRG93bmxvYWRGaWxlSUUxMChwOiBzdHJpbmcsIHR5cGU6IHN0cmluZyk6IGFueSB7XG4gIGNvbnN0IHJlcSA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICByZXEub3BlbignR0VUJywgcCwgZmFsc2UpO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdidWZmZXInOlxuICAgICAgcmVxLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdqc29uJzpcbiAgICAgIC8vIElFMTAgZG9lcyBub3Qgc3VwcG9ydCB0aGUgSlNPTiB0eXBlLlxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBBcGlFcnJvcihFcnJvckNvZGUuRUlOVkFMLCBcIkludmFsaWQgZG93bmxvYWQgdHlwZTogXCIgKyB0eXBlKTtcbiAgfVxuICBsZXQgZGF0YTogYW55O1xuICBsZXQgZXJyOiBhbnk7XG4gIHJlcS5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbihlKSB7XG4gICAgaWYgKHJlcS5yZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICBpZiAocmVxLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgJ2J1ZmZlcic6XG4gICAgICAgICAgICBkYXRhID0gQnVmZmVyLmZyb20ocmVxLnJlc3BvbnNlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2pzb24nOlxuICAgICAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UocmVxLnJlc3BvbnNlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnIgPSBuZXcgQXBpRXJyb3IocmVxLnN0YXR1cywgXCJYSFIgZXJyb3IuXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgcmVxLnNlbmQoKTtcbiAgaWYgKGVycikge1xuICAgIHRocm93IGVycjtcbiAgfVxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmZ1bmN0aW9uIGdldEZpbGVTaXplKGFzeW5jOiBib29sZWFuLCBwOiBzdHJpbmcsIGNiOiBCRlNDYWxsYmFjazxudW1iZXI+KTogdm9pZCB7XG4gIGNvbnN0IHJlcSA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICByZXEub3BlbignSEVBRCcsIHAsIGFzeW5jKTtcbiAgcmVxLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICBpZiAocmVxLnJlYWR5U3RhdGUgPT09IDQpIHtcbiAgICAgIGlmIChyZXEuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gY2IobnVsbCwgcGFyc2VJbnQocmVxLmdldFJlc3BvbnNlSGVhZGVyKCdDb250ZW50LUxlbmd0aCcpIHx8ICctMScsIDEwKSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAvLyBJbiB0aGUgZXZlbnQgdGhhdCB0aGUgaGVhZGVyIGlzbid0IHByZXNlbnQgb3IgdGhlcmUgaXMgYW4gZXJyb3IuLi5cbiAgICAgICAgICByZXR1cm4gY2IobmV3IEFwaUVycm9yKEVycm9yQ29kZS5FSU8sIFwiWEhSIEhFQUQgZXJyb3I6IENvdWxkIG5vdCByZWFkIGNvbnRlbnQtbGVuZ3RoLlwiKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjYihuZXcgQXBpRXJyb3IocmVxLnN0YXR1cywgXCJYSFIgSEVBRCBlcnJvci5cIikpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgcmVxLnNlbmQoKTtcbn1cblxuLyoqXG4gKiBBc3luY2hyb25vdXNseSBkb3dubG9hZCBhIGZpbGUgYXMgYSBidWZmZXIgb3IgYSBKU09OIG9iamVjdC5cbiAqIE5vdGUgdGhhdCB0aGUgdGhpcmQgZnVuY3Rpb24gc2lnbmF0dXJlIHdpdGggYSBub24tc3BlY2lhbGl6ZWQgdHlwZSBpc1xuICogaW52YWxpZCwgYnV0IFR5cGVTY3JpcHQgcmVxdWlyZXMgaXQgd2hlbiB5b3Ugc3BlY2lhbGl6ZSBzdHJpbmcgYXJndW1lbnRzIHRvXG4gKiBjb25zdGFudHMuXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBsZXQgYXN5bmNEb3dubG9hZEZpbGU6IHtcbiAgKHA6IHN0cmluZywgdHlwZTogJ2J1ZmZlcicsIGNiOiBCRlNDYWxsYmFjazxCdWZmZXI+KTogdm9pZDtcbiAgKHA6IHN0cmluZywgdHlwZTogJ2pzb24nLCBjYjogQkZTQ2FsbGJhY2s8YW55Pik6IHZvaWQ7XG4gIChwOiBzdHJpbmcsIHR5cGU6IHN0cmluZywgY2I6IEJGU0NhbGxiYWNrPGFueT4pOiB2b2lkO1xufSA9IGFzeW5jRG93bmxvYWRGaWxlTW9kZXJuO1xuXG4vKipcbiAqIFN5bmNocm9ub3VzbHkgZG93bmxvYWQgYSBmaWxlIGFzIGEgYnVmZmVyIG9yIGEgSlNPTiBvYmplY3QuXG4gKiBOb3RlIHRoYXQgdGhlIHRoaXJkIGZ1bmN0aW9uIHNpZ25hdHVyZSB3aXRoIGEgbm9uLXNwZWNpYWxpemVkIHR5cGUgaXNcbiAqIGludmFsaWQsIGJ1dCBUeXBlU2NyaXB0IHJlcXVpcmVzIGl0IHdoZW4geW91IHNwZWNpYWxpemUgc3RyaW5nIGFyZ3VtZW50cyB0b1xuICogY29uc3RhbnRzLlxuICogQGhpZGRlblxuICovXG5leHBvcnQgbGV0IHN5bmNEb3dubG9hZEZpbGU6IHtcbiAgKHA6IHN0cmluZywgdHlwZTogJ2J1ZmZlcicpOiBCdWZmZXI7XG4gIChwOiBzdHJpbmcsIHR5cGU6ICdqc29uJyk6IGFueTtcbiAgKHA6IHN0cmluZywgdHlwZTogc3RyaW5nKTogYW55O1xufSA9IChpc0lFICYmIHR5cGVvZiBCbG9iICE9PSAndW5kZWZpbmVkJykgPyBzeW5jRG93bmxvYWRGaWxlSUUxMCA6IHN5bmNEb3dubG9hZEZpbGVNb2Rlcm47XG5cbi8qKlxuICogU3luY2hyb25vdXNseSByZXRyaWV2ZXMgdGhlIHNpemUgb2YgdGhlIGdpdmVuIGZpbGUgaW4gYnl0ZXMuXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRGaWxlU2l6ZVN5bmMocDogc3RyaW5nKTogbnVtYmVyIHtcbiAgbGV0IHJ2OiBudW1iZXIgPSAtMTtcbiAgZ2V0RmlsZVNpemUoZmFsc2UsIHAsIGZ1bmN0aW9uKGVycjogQXBpRXJyb3IsIHNpemU/OiBudW1iZXIpIHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICAgIHJ2ID0gc2l6ZSE7XG4gIH0pO1xuICByZXR1cm4gcnY7XG59XG5cbi8qKlxuICogQXN5bmNocm9ub3VzbHkgcmV0cmlldmVzIHRoZSBzaXplIG9mIHRoZSBnaXZlbiBmaWxlIGluIGJ5dGVzLlxuICogQGhpZGRlblxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RmlsZVNpemVBc3luYyhwOiBzdHJpbmcsIGNiOiAoZXJyOiBBcGlFcnJvciwgc2l6ZT86IG51bWJlcikgPT4gdm9pZCk6IHZvaWQge1xuICBnZXRGaWxlU2l6ZSh0cnVlLCBwLCBjYik7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vLi4vLi4vLi4vc3JjL2dlbmVyaWMveGhyLnRzIiwiaW1wb3J0IHtkZWZhdWx0IGFzIFN0YXRzLCBGaWxlVHlwZX0gZnJvbSAnLi4vY29yZS9ub2RlX2ZzX3N0YXRzJztcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5cbi8qKlxuICogQSBzaW1wbGUgY2xhc3MgZm9yIHN0b3JpbmcgYSBmaWxlc3lzdGVtIGluZGV4LiBBc3N1bWVzIHRoYXQgYWxsIHBhdGhzIHBhc3NlZFxuICogdG8gaXQgYXJlICphYnNvbHV0ZSogcGF0aHMuXG4gKlxuICogQ2FuIGJlIHVzZWQgYXMgYSBwYXJ0aWFsIG9yIGEgZnVsbCBpbmRleCwgYWx0aG91Z2ggY2FyZSBtdXN0IGJlIHRha2VuIGlmIHVzZWRcbiAqIGZvciB0aGUgZm9ybWVyIHB1cnBvc2UsIGVzcGVjaWFsbHkgd2hlbiBkaXJlY3RvcmllcyBhcmUgY29uY2VybmVkLlxuICovXG5leHBvcnQgY2xhc3MgRmlsZUluZGV4PFQ+IHtcbiAgLyoqXG4gICAqIFN0YXRpYyBtZXRob2QgZm9yIGNvbnN0cnVjdGluZyBpbmRpY2VzIGZyb20gYSBKU09OIGxpc3RpbmcuXG4gICAqIEBwYXJhbSBsaXN0aW5nIERpcmVjdG9yeSBsaXN0aW5nIGdlbmVyYXRlZCBieSB0b29scy9YSFJJbmRleGVyLmNvZmZlZVxuICAgKiBAcmV0dXJuIEEgbmV3IEZpbGVJbmRleCBvYmplY3QuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGZyb21MaXN0aW5nPFQ+KGxpc3Rpbmc6IGFueSk6IEZpbGVJbmRleDxUPiB7XG4gICAgY29uc3QgaWR4ID0gbmV3IEZpbGVJbmRleDxUPigpO1xuICAgIC8vIEFkZCBhIHJvb3QgRGlyTm9kZS5cbiAgICBjb25zdCByb290SW5vZGUgPSBuZXcgRGlySW5vZGU8VD4oKTtcbiAgICBpZHguX2luZGV4WycvJ10gPSByb290SW5vZGU7XG4gICAgY29uc3QgcXVldWUgPSBbWycnLCBsaXN0aW5nLCByb290SW5vZGVdXTtcbiAgICB3aGlsZSAocXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgbGV0IGlub2RlOiBJbm9kZTtcbiAgICAgIGNvbnN0IG5leHQgPSBxdWV1ZS5wb3AoKTtcbiAgICAgIGNvbnN0IHB3ZCA9IG5leHQhWzBdO1xuICAgICAgY29uc3QgdHJlZSA9IG5leHQhWzFdO1xuICAgICAgY29uc3QgcGFyZW50ID0gbmV4dCFbMl07XG4gICAgICBmb3IgKGNvbnN0IG5vZGUgaW4gdHJlZSkge1xuICAgICAgICBpZiAodHJlZS5oYXNPd25Qcm9wZXJ0eShub2RlKSkge1xuICAgICAgICAgIGNvbnN0IGNoaWxkcmVuID0gdHJlZVtub2RlXTtcbiAgICAgICAgICBjb25zdCBuYW1lID0gYCR7cHdkfS8ke25vZGV9YDtcbiAgICAgICAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGlkeC5faW5kZXhbbmFtZV0gPSBpbm9kZSA9IG5ldyBEaXJJbm9kZTxUPigpO1xuICAgICAgICAgICAgcXVldWUucHVzaChbbmFtZSwgY2hpbGRyZW4sIGlub2RlXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaW5vZGUgZG9lc24ndCBoYXZlIGNvcnJlY3Qgc2l6ZSBpbmZvcm1hdGlvbiwgbm90ZWQgd2l0aCAtMS5cbiAgICAgICAgICAgIGlub2RlID0gbmV3IEZpbGVJbm9kZTxTdGF0cz4obmV3IFN0YXRzKEZpbGVUeXBlLkZJTEUsIC0xLCAweDE2RCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICBwYXJlbnQuX2xzW25vZGVdID0gaW5vZGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpZHg7XG4gIH1cblxuICAvLyBNYXBzIGRpcmVjdG9yeSBwYXRocyB0byBkaXJlY3RvcnkgaW5vZGVzLCB3aGljaCBjb250YWluIGZpbGVzLlxuICBwcml2YXRlIF9pbmRleDoge1twYXRoOiBzdHJpbmddOiBEaXJJbm9kZTxUPiB9O1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IEZpbGVJbmRleC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIC8vIF9pbmRleCBpcyBhIHNpbmdsZS1sZXZlbCBrZXksdmFsdWUgc3RvcmUgdGhhdCBtYXBzICpkaXJlY3RvcnkqIHBhdGhzIHRvXG4gICAgLy8gRGlySW5vZGVzLiBGaWxlIGluZm9ybWF0aW9uIGlzIG9ubHkgY29udGFpbmVkIGluIERpcklub2RlcyB0aGVtc2VsdmVzLlxuICAgIHRoaXMuX2luZGV4ID0ge307XG4gICAgLy8gQ3JlYXRlIHRoZSByb290IGRpcmVjdG9yeS5cbiAgICB0aGlzLmFkZFBhdGgoJy8nLCBuZXcgRGlySW5vZGUoKSk7XG4gIH1cblxuICAvKipcbiAgICogUnVucyB0aGUgZ2l2ZW4gZnVuY3Rpb24gb3ZlciBhbGwgZmlsZXMgaW4gdGhlIGluZGV4LlxuICAgKi9cbiAgcHVibGljIGZpbGVJdGVyYXRvcjxUPihjYjogKGZpbGU6IFQgfCBudWxsKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgZm9yIChjb25zdCBwYXRoIGluIHRoaXMuX2luZGV4KSB7XG4gICAgICBpZiAodGhpcy5faW5kZXguaGFzT3duUHJvcGVydHkocGF0aCkpIHtcbiAgICAgICAgY29uc3QgZGlyID0gdGhpcy5faW5kZXhbcGF0aF07XG4gICAgICAgIGNvbnN0IGZpbGVzID0gZGlyLmdldExpc3RpbmcoKTtcbiAgICAgICAgZm9yIChjb25zdCBmaWxlIG9mIGZpbGVzKSB7XG4gICAgICAgICAgY29uc3QgaXRlbSA9IGRpci5nZXRJdGVtKGZpbGUpO1xuICAgICAgICAgIGlmIChpc0ZpbGVJbm9kZTxUPihpdGVtKSkge1xuICAgICAgICAgICAgY2IoaXRlbS5nZXREYXRhKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIHRoZSBnaXZlbiBhYnNvbHV0ZSBwYXRoIHRvIHRoZSBpbmRleCBpZiBpdCBpcyBub3QgYWxyZWFkeSBpbiB0aGUgaW5kZXguXG4gICAqIENyZWF0ZXMgYW55IG5lZWRlZCBwYXJlbnQgZGlyZWN0b3JpZXMuXG4gICAqIEBwYXJhbSBwYXRoIFRoZSBwYXRoIHRvIGFkZCB0byB0aGUgaW5kZXguXG4gICAqIEBwYXJhbSBpbm9kZSBUaGUgaW5vZGUgZm9yIHRoZVxuICAgKiAgIHBhdGggdG8gYWRkLlxuICAgKiBAcmV0dXJuICdUcnVlJyBpZiBpdCB3YXMgYWRkZWQgb3IgYWxyZWFkeSBleGlzdHMsICdmYWxzZScgaWYgdGhlcmVcbiAgICogICB3YXMgYW4gaXNzdWUgYWRkaW5nIGl0IChlLmcuIGl0ZW0gaW4gcGF0aCBpcyBhIGZpbGUsIGl0ZW0gZXhpc3RzIGJ1dCBpc1xuICAgKiAgIGRpZmZlcmVudCkuXG4gICAqIEB0b2RvIElmIGFkZGluZyBmYWlscyBhbmQgaW1wbGljaXRseSBjcmVhdGVzIGRpcmVjdG9yaWVzLCB3ZSBkbyBub3QgY2xlYW4gdXBcbiAgICogICB0aGUgbmV3IGVtcHR5IGRpcmVjdG9yaWVzLlxuICAgKi9cbiAgcHVibGljIGFkZFBhdGgocGF0aDogc3RyaW5nLCBpbm9kZTogSW5vZGUpOiBib29sZWFuIHtcbiAgICBpZiAoIWlub2RlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lub2RlIG11c3QgYmUgc3BlY2lmaWVkJyk7XG4gICAgfVxuICAgIGlmIChwYXRoWzBdICE9PSAnLycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUGF0aCBtdXN0IGJlIGFic29sdXRlLCBnb3Q6ICcgKyBwYXRoKTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiBpdCBhbHJlYWR5IGV4aXN0cy5cbiAgICBpZiAodGhpcy5faW5kZXguaGFzT3duUHJvcGVydHkocGF0aCkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pbmRleFtwYXRoXSA9PT0gaW5vZGU7XG4gICAgfVxuXG4gICAgY29uc3Qgc3BsaXRQYXRoID0gdGhpcy5fc3BsaXRfcGF0aChwYXRoKTtcbiAgICBjb25zdCBkaXJwYXRoID0gc3BsaXRQYXRoWzBdO1xuICAgIGNvbnN0IGl0ZW1uYW1lID0gc3BsaXRQYXRoWzFdO1xuICAgIC8vIFRyeSB0byBhZGQgdG8gaXRzIHBhcmVudCBkaXJlY3RvcnkgZmlyc3QuXG4gICAgbGV0IHBhcmVudCA9IHRoaXMuX2luZGV4W2RpcnBhdGhdO1xuICAgIGlmIChwYXJlbnQgPT09IHVuZGVmaW5lZCAmJiBwYXRoICE9PSAnLycpIHtcbiAgICAgIC8vIENyZWF0ZSBwYXJlbnQuXG4gICAgICBwYXJlbnQgPSBuZXcgRGlySW5vZGU8VD4oKTtcbiAgICAgIGlmICghdGhpcy5hZGRQYXRoKGRpcnBhdGgsIHBhcmVudCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBBZGQgbXlzZWxmIHRvIG15IHBhcmVudC5cbiAgICBpZiAocGF0aCAhPT0gJy8nKSB7XG4gICAgICBpZiAoIXBhcmVudC5hZGRJdGVtKGl0ZW1uYW1lLCBpbm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBJZiBJJ20gYSBkaXJlY3RvcnksIGFkZCBteXNlbGYgdG8gdGhlIGluZGV4LlxuICAgIGlmIChpc0Rpcklub2RlPFQ+KGlub2RlKSkge1xuICAgICAgdGhpcy5faW5kZXhbcGF0aF0gPSBpbm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyB0aGUgZ2l2ZW4gYWJzb2x1dGUgcGF0aCB0byB0aGUgaW5kZXggaWYgaXQgaXMgbm90IGFscmVhZHkgaW4gdGhlIGluZGV4LlxuICAgKiBUaGUgcGF0aCBpcyBhZGRlZCB3aXRob3V0IHNwZWNpYWwgdHJlYXRtZW50IChubyBqb2luaW5nIG9mIGFkamFjZW50IHNlcGFyYXRvcnMsIGV0YykuXG4gICAqIENyZWF0ZXMgYW55IG5lZWRlZCBwYXJlbnQgZGlyZWN0b3JpZXMuXG4gICAqIEBwYXJhbSBwYXRoIFRoZSBwYXRoIHRvIGFkZCB0byB0aGUgaW5kZXguXG4gICAqIEBwYXJhbSBpbm9kZSBUaGUgaW5vZGUgZm9yIHRoZVxuICAgKiAgIHBhdGggdG8gYWRkLlxuICAgKiBAcmV0dXJuICdUcnVlJyBpZiBpdCB3YXMgYWRkZWQgb3IgYWxyZWFkeSBleGlzdHMsICdmYWxzZScgaWYgdGhlcmVcbiAgICogICB3YXMgYW4gaXNzdWUgYWRkaW5nIGl0IChlLmcuIGl0ZW0gaW4gcGF0aCBpcyBhIGZpbGUsIGl0ZW0gZXhpc3RzIGJ1dCBpc1xuICAgKiAgIGRpZmZlcmVudCkuXG4gICAqIEB0b2RvIElmIGFkZGluZyBmYWlscyBhbmQgaW1wbGljaXRseSBjcmVhdGVzIGRpcmVjdG9yaWVzLCB3ZSBkbyBub3QgY2xlYW4gdXBcbiAgICogICB0aGUgbmV3IGVtcHR5IGRpcmVjdG9yaWVzLlxuICAgKi9cbiAgcHVibGljIGFkZFBhdGhGYXN0KHBhdGg6IHN0cmluZywgaW5vZGU6IElub2RlKTogYm9vbGVhbiB7XG4gICAgY29uc3QgaXRlbU5hbWVNYXJrID0gcGF0aC5sYXN0SW5kZXhPZignLycpO1xuICAgIGNvbnN0IHBhcmVudFBhdGggPSBpdGVtTmFtZU1hcmsgPT09IDAgPyBcIi9cIiA6IHBhdGguc3Vic3RyaW5nKDAsIGl0ZW1OYW1lTWFyayk7XG4gICAgY29uc3QgaXRlbU5hbWUgPSBwYXRoLnN1YnN0cmluZyhpdGVtTmFtZU1hcmsgKyAxKTtcblxuICAgIC8vIFRyeSB0byBhZGQgdG8gaXRzIHBhcmVudCBkaXJlY3RvcnkgZmlyc3QuXG4gICAgbGV0IHBhcmVudCA9IHRoaXMuX2luZGV4W3BhcmVudFBhdGhdO1xuICAgIGlmIChwYXJlbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gQ3JlYXRlIHBhcmVudC5cbiAgICAgIHBhcmVudCA9IG5ldyBEaXJJbm9kZTxUPigpO1xuICAgICAgdGhpcy5hZGRQYXRoRmFzdChwYXJlbnRQYXRoLCBwYXJlbnQpO1xuICAgIH1cblxuICAgIGlmICghcGFyZW50LmFkZEl0ZW0oaXRlbU5hbWUsIGlub2RlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIElmIGFkZGluZyBhIGRpcmVjdG9yeSwgYWRkIHRvIHRoZSBpbmRleCBhcyB3ZWxsLlxuICAgIGlmIChpbm9kZS5pc0RpcigpKSB7XG4gICAgICB0aGlzLl9pbmRleFtwYXRoXSA9IDxEaXJJbm9kZTxUPj4gaW5vZGU7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgdGhlIGdpdmVuIHBhdGguIENhbiBiZSBhIGZpbGUgb3IgYSBkaXJlY3RvcnkuXG4gICAqIEByZXR1cm4gVGhlIHJlbW92ZWQgaXRlbSxcbiAgICogICBvciBudWxsIGlmIGl0IGRpZCBub3QgZXhpc3QuXG4gICAqL1xuICBwdWJsaWMgcmVtb3ZlUGF0aChwYXRoOiBzdHJpbmcpOiBJbm9kZSB8IG51bGwge1xuICAgIGNvbnN0IHNwbGl0UGF0aCA9IHRoaXMuX3NwbGl0X3BhdGgocGF0aCk7XG4gICAgY29uc3QgZGlycGF0aCA9IHNwbGl0UGF0aFswXTtcbiAgICBjb25zdCBpdGVtbmFtZSA9IHNwbGl0UGF0aFsxXTtcblxuICAgIC8vIFRyeSB0byByZW1vdmUgaXQgZnJvbSBpdHMgcGFyZW50IGRpcmVjdG9yeSBmaXJzdC5cbiAgICBjb25zdCBwYXJlbnQgPSB0aGlzLl9pbmRleFtkaXJwYXRoXTtcbiAgICBpZiAocGFyZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBSZW1vdmUgbXlzZWxmIGZyb20gbXkgcGFyZW50LlxuICAgIGNvbnN0IGlub2RlID0gcGFyZW50LnJlbUl0ZW0oaXRlbW5hbWUpO1xuICAgIGlmIChpbm9kZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIElmIEknbSBhIGRpcmVjdG9yeSwgcmVtb3ZlIG15c2VsZiBmcm9tIHRoZSBpbmRleCwgYW5kIHJlbW92ZSBteSBjaGlsZHJlbi5cbiAgICBpZiAoaXNEaXJJbm9kZShpbm9kZSkpIHtcbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gaW5vZGUuZ2V0TGlzdGluZygpO1xuICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBjaGlsZHJlbikge1xuICAgICAgICB0aGlzLnJlbW92ZVBhdGgocGF0aCArICcvJyArIGNoaWxkKTtcbiAgICAgIH1cblxuICAgICAgLy8gUmVtb3ZlIHRoZSBkaXJlY3RvcnkgZnJvbSB0aGUgaW5kZXgsIHVubGVzcyBpdCdzIHRoZSByb290LlxuICAgICAgaWYgKHBhdGggIT09ICcvJykge1xuICAgICAgICBkZWxldGUgdGhpcy5faW5kZXhbcGF0aF07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpbm9kZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIGRpcmVjdG9yeSBsaXN0aW5nIG9mIHRoZSBnaXZlbiBwYXRoLlxuICAgKiBAcmV0dXJuIEFuIGFycmF5IG9mIGZpbGVzIGluIHRoZSBnaXZlbiBwYXRoLCBvciAnbnVsbCcgaWYgaXQgZG9lcyBub3QgZXhpc3QuXG4gICAqL1xuICBwdWJsaWMgbHMocGF0aDogc3RyaW5nKTogc3RyaW5nW10gfCBudWxsIHtcbiAgICBjb25zdCBpdGVtID0gdGhpcy5faW5kZXhbcGF0aF07XG4gICAgaWYgKGl0ZW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBpdGVtLmdldExpc3RpbmcoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpbm9kZSBvZiB0aGUgZ2l2ZW4gaXRlbS5cbiAgICogQHJldHVybiBSZXR1cm5zIG51bGwgaWYgdGhlIGl0ZW0gZG9lcyBub3QgZXhpc3QuXG4gICAqL1xuICBwdWJsaWMgZ2V0SW5vZGUocGF0aDogc3RyaW5nKTogSW5vZGUgfCBudWxsIHtcbiAgICBjb25zdCBzcGxpdFBhdGggPSB0aGlzLl9zcGxpdF9wYXRoKHBhdGgpO1xuICAgIGNvbnN0IGRpcnBhdGggPSBzcGxpdFBhdGhbMF07XG4gICAgY29uc3QgaXRlbW5hbWUgPSBzcGxpdFBhdGhbMV07XG4gICAgLy8gUmV0cmlldmUgZnJvbSBpdHMgcGFyZW50IGRpcmVjdG9yeS5cbiAgICBjb25zdCBwYXJlbnQgPSB0aGlzLl9pbmRleFtkaXJwYXRoXTtcbiAgICBpZiAocGFyZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBSb290IGNhc2VcbiAgICBpZiAoZGlycGF0aCA9PT0gcGF0aCkge1xuICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICB9XG4gICAgcmV0dXJuIHBhcmVudC5nZXRJdGVtKGl0ZW1uYW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTcGxpdCBpbnRvIGEgKGRpcmVjdG9yeSBwYXRoLCBpdGVtIG5hbWUpIHBhaXJcbiAgICovXG4gIHByaXZhdGUgX3NwbGl0X3BhdGgocDogc3RyaW5nKTogc3RyaW5nW10ge1xuICAgIGNvbnN0IGRpcnBhdGggPSBwYXRoLmRpcm5hbWUocCk7XG4gICAgY29uc3QgaXRlbW5hbWUgPSBwLnN1YnN0cihkaXJwYXRoLmxlbmd0aCArIChkaXJwYXRoID09PSBcIi9cIiA/IDAgOiAxKSk7XG4gICAgcmV0dXJuIFtkaXJwYXRoLCBpdGVtbmFtZV07XG4gIH1cbn1cblxuLyoqXG4gKiBHZW5lcmljIGludGVyZmFjZSBmb3IgZmlsZS9kaXJlY3RvcnkgaW5vZGVzLlxuICogTm90ZSB0aGF0IFN0YXRzIG9iamVjdHMgYXJlIHdoYXQgd2UgdXNlIGZvciBmaWxlIGlub2Rlcy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJbm9kZSB7XG4gIC8vIElzIHRoaXMgYW4gaW5vZGUgZm9yIGEgZmlsZT9cbiAgaXNGaWxlKCk6IGJvb2xlYW47XG4gIC8vIElzIHRoaXMgYW4gaW5vZGUgZm9yIGEgZGlyZWN0b3J5P1xuICBpc0RpcigpOiBib29sZWFuO1xufVxuXG4vKipcbiAqIElub2RlIGZvciBhIGZpbGUuIFN0b3JlcyBhbiBhcmJpdHJhcnkgKGZpbGVzeXN0ZW0tc3BlY2lmaWMpIGRhdGEgcGF5bG9hZC5cbiAqL1xuZXhwb3J0IGNsYXNzIEZpbGVJbm9kZTxUPiBpbXBsZW1lbnRzIElub2RlIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBkYXRhOiBUKSB7IH1cbiAgcHVibGljIGlzRmlsZSgpOiBib29sZWFuIHsgcmV0dXJuIHRydWU7IH1cbiAgcHVibGljIGlzRGlyKCk6IGJvb2xlYW4geyByZXR1cm4gZmFsc2U7IH1cbiAgcHVibGljIGdldERhdGEoKTogVCB7IHJldHVybiB0aGlzLmRhdGE7IH1cbiAgcHVibGljIHNldERhdGEoZGF0YTogVCk6IHZvaWQgeyB0aGlzLmRhdGEgPSBkYXRhOyB9XG59XG5cbi8qKlxuICogSW5vZGUgZm9yIGEgZGlyZWN0b3J5LiBDdXJyZW50bHkgb25seSBjb250YWlucyB0aGUgZGlyZWN0b3J5IGxpc3RpbmcuXG4gKi9cbmV4cG9ydCBjbGFzcyBEaXJJbm9kZTxUPiBpbXBsZW1lbnRzIElub2RlIHtcbiAgcHJpdmF0ZSBfbHM6IHtbcGF0aDogc3RyaW5nXTogSW5vZGV9ID0ge307XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGFuIGlub2RlIGZvciBhIGRpcmVjdG9yeS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgZGF0YTogVCB8IG51bGwgPSBudWxsKSB7fVxuICBwdWJsaWMgaXNGaWxlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBwdWJsaWMgaXNEaXIoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcHVibGljIGdldERhdGEoKTogVCB8IG51bGwgeyByZXR1cm4gdGhpcy5kYXRhOyB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhIFN0YXRzIG9iamVjdCBmb3IgdGhpcyBpbm9kZS5cbiAgICogQHRvZG8gU2hvdWxkIHByb2JhYmx5IHJlbW92ZSB0aGlzIGF0IHNvbWUgcG9pbnQuIFRoaXMgaXNuJ3QgdGhlXG4gICAqICAgICAgIHJlc3BvbnNpYmlsaXR5IG9mIHRoZSBGaWxlSW5kZXguXG4gICAqL1xuICBwdWJsaWMgZ2V0U3RhdHMoKTogU3RhdHMge1xuICAgIHJldHVybiBuZXcgU3RhdHMoRmlsZVR5cGUuRElSRUNUT1JZLCA0MDk2LCAweDE2RCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGRpcmVjdG9yeSBsaXN0aW5nIGZvciB0aGlzIGRpcmVjdG9yeS4gUGF0aHMgaW4gdGhlIGRpcmVjdG9yeSBhcmVcbiAgICogcmVsYXRpdmUgdG8gdGhlIGRpcmVjdG9yeSdzIHBhdGguXG4gICAqIEByZXR1cm4gVGhlIGRpcmVjdG9yeSBsaXN0aW5nIGZvciB0aGlzIGRpcmVjdG9yeS5cbiAgICovXG4gIHB1YmxpYyBnZXRMaXN0aW5nKCk6IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5fbHMpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpbm9kZSBmb3IgdGhlIGluZGljYXRlZCBpdGVtLCBvciBudWxsIGlmIGl0IGRvZXMgbm90IGV4aXN0LlxuICAgKiBAcGFyYW0gcCBOYW1lIG9mIGl0ZW0gaW4gdGhpcyBkaXJlY3RvcnkuXG4gICAqL1xuICBwdWJsaWMgZ2V0SXRlbShwOiBzdHJpbmcpOiBJbm9kZSB8IG51bGwge1xuICAgIGNvbnN0IGl0ZW0gPSB0aGlzLl9sc1twXTtcbiAgICByZXR1cm4gaXRlbSA/IGl0ZW0gOiBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBBZGQgdGhlIGdpdmVuIGl0ZW0gdG8gdGhlIGRpcmVjdG9yeSBsaXN0aW5nLiBOb3RlIHRoYXQgdGhlIGdpdmVuIGlub2RlIGlzXG4gICAqIG5vdCBjb3BpZWQsIGFuZCB3aWxsIGJlIG11dGF0ZWQgYnkgdGhlIERpcklub2RlIGlmIGl0IGlzIGEgRGlySW5vZGUuXG4gICAqIEBwYXJhbSBwIEl0ZW0gbmFtZSB0byBhZGQgdG8gdGhlIGRpcmVjdG9yeSBsaXN0aW5nLlxuICAgKiBAcGFyYW0gaW5vZGUgVGhlIGlub2RlIGZvciB0aGVcbiAgICogICBpdGVtIHRvIGFkZCB0byB0aGUgZGlyZWN0b3J5IGlub2RlLlxuICAgKiBAcmV0dXJuIFRydWUgaWYgaXQgd2FzIGFkZGVkLCBmYWxzZSBpZiBpdCBhbHJlYWR5IGV4aXN0ZWQuXG4gICAqL1xuICBwdWJsaWMgYWRkSXRlbShwOiBzdHJpbmcsIGlub2RlOiBJbm9kZSk6IGJvb2xlYW4ge1xuICAgIGlmIChwIGluIHRoaXMuX2xzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuX2xzW3BdID0gaW5vZGU7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgdGhlIGdpdmVuIGl0ZW0gZnJvbSB0aGUgZGlyZWN0b3J5IGxpc3RpbmcuXG4gICAqIEBwYXJhbSBwIE5hbWUgb2YgaXRlbSB0byByZW1vdmUgZnJvbSB0aGUgZGlyZWN0b3J5IGxpc3RpbmcuXG4gICAqIEByZXR1cm4gUmV0dXJucyB0aGUgaXRlbVxuICAgKiAgIHJlbW92ZWQsIG9yIG51bGwgaWYgdGhlIGl0ZW0gZGlkIG5vdCBleGlzdC5cbiAgICovXG4gIHB1YmxpYyByZW1JdGVtKHA6IHN0cmluZyk6IElub2RlIHwgbnVsbCB7XG4gICAgY29uc3QgaXRlbSA9IHRoaXMuX2xzW3BdO1xuICAgIGlmIChpdGVtID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBkZWxldGUgdGhpcy5fbHNbcF07XG4gICAgcmV0dXJuIGl0ZW07XG4gIH1cbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0ZpbGVJbm9kZTxUPihpbm9kZTogSW5vZGUgfCBudWxsKTogaW5vZGUgaXMgRmlsZUlub2RlPFQ+IHtcbiAgcmV0dXJuICEhaW5vZGUgJiYgaW5vZGUuaXNGaWxlKCk7XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNEaXJJbm9kZTxUPihpbm9kZTogSW5vZGUgfCBudWxsKTogaW5vZGUgaXMgRGlySW5vZGU8VD4ge1xuICByZXR1cm4gISFpbm9kZSAmJiBpbm9kZS5pc0RpcigpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uLy4uLy4uLy4uL3NyYy9nZW5lcmljL2ZpbGVfaW5kZXgudHMiLCJpbXBvcnQge0Jhc2VGaWxlU3lzdGVtLCBGaWxlU3lzdGVtLCBCRlNDYWxsYmFjaywgRmlsZVN5c3RlbU9wdGlvbnN9IGZyb20gJy4uL2NvcmUvZmlsZV9zeXN0ZW0nO1xuaW1wb3J0IHtBcGlFcnJvciwgRXJyb3JDb2RlfSBmcm9tICcuLi9jb3JlL2FwaV9lcnJvcic7XG5pbXBvcnQge0ZpbGVGbGFnLCBBY3Rpb25UeXBlfSBmcm9tICcuLi9jb3JlL2ZpbGVfZmxhZyc7XG5pbXBvcnQge2NvcHlpbmdTbGljZSwgZGVwcmVjYXRpb25NZXNzYWdlfSBmcm9tICcuLi9jb3JlL3V0aWwnO1xuaW1wb3J0IHtGaWxlfSBmcm9tICcuLi9jb3JlL2ZpbGUnO1xuaW1wb3J0IFN0YXRzIGZyb20gJy4uL2NvcmUvbm9kZV9mc19zdGF0cyc7XG5pbXBvcnQge05vU3luY0ZpbGV9IGZyb20gJy4uL2dlbmVyaWMvcHJlbG9hZF9maWxlJztcbmltcG9ydCB7YXN5bmNEb3dubG9hZEZpbGUsIHN5bmNEb3dubG9hZEZpbGUsIGdldEZpbGVTaXplQXN5bmMsIGdldEZpbGVTaXplU3luY30gZnJvbSAnLi4vZ2VuZXJpYy94aHInO1xuaW1wb3J0IHtGaWxlSW5kZXgsIGlzRmlsZUlub2RlLCBpc0Rpcklub2RlfSBmcm9tICcuLi9nZW5lcmljL2ZpbGVfaW5kZXgnO1xuXG4vKipcbiAqIFRyeSB0byBjb252ZXJ0IHRoZSBnaXZlbiBidWZmZXIgaW50byBhIHN0cmluZywgYW5kIHBhc3MgaXQgdG8gdGhlIGNhbGxiYWNrLlxuICogT3B0aW1pemF0aW9uIHRoYXQgcmVtb3ZlcyB0aGUgbmVlZGVkIHRyeS9jYXRjaCBpbnRvIGEgaGVscGVyIGZ1bmN0aW9uLCBhc1xuICogdGhpcyBpcyBhbiB1bmNvbW1vbiBjYXNlLlxuICogQGhpZGRlblxuICovXG5mdW5jdGlvbiB0cnlUb1N0cmluZyhidWZmOiBCdWZmZXIsIGVuY29kaW5nOiBzdHJpbmcsIGNiOiBCRlNDYWxsYmFjazxzdHJpbmc+KSB7XG4gIHRyeSB7XG4gICAgY2IobnVsbCwgYnVmZi50b1N0cmluZyhlbmNvZGluZykpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgY2IoZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIGFuIFhtbEh0dHBSZXF1ZXN0IGZpbGUgc3lzdGVtLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFhtbEh0dHBSZXF1ZXN0T3B0aW9ucyB7XG4gIC8vIFVSTCB0byBhIGZpbGUgaW5kZXggYXMgYSBKU09OIGZpbGUgb3IgdGhlIGZpbGUgaW5kZXggb2JqZWN0IGl0c2VsZiwgZ2VuZXJhdGVkIHdpdGggdGhlIG1ha2VfeGhyZnNfaW5kZXggc2NyaXB0LlxuICAvLyBEZWZhdWx0cyB0byBgaW5kZXguanNvbmAuXG4gIGluZGV4Pzogc3RyaW5nIHwgb2JqZWN0O1xuICAvLyBVc2VkIGFzIHRoZSBVUkwgcHJlZml4IGZvciBmZXRjaGVkIGZpbGVzLlxuICAvLyBEZWZhdWx0OiBGZXRjaCBmaWxlcyByZWxhdGl2ZSB0byB0aGUgaW5kZXguXG4gIGJhc2VVcmw/OiBzdHJpbmc7XG59XG5cbi8qKlxuICogQSBzaW1wbGUgZmlsZXN5c3RlbSBiYWNrZWQgYnkgWE1MSHR0cFJlcXVlc3RzLiBZb3UgbXVzdCBjcmVhdGUgYSBkaXJlY3RvcnkgbGlzdGluZyB1c2luZyB0aGVcbiAqIGBtYWtlX3hocmZzX2luZGV4YCB0b29sIHByb3ZpZGVkIGJ5IEJyb3dzZXJGUy5cbiAqXG4gKiBJZiB5b3UgaW5zdGFsbCBCcm93c2VyRlMgZ2xvYmFsbHkgd2l0aCBgbnBtIGkgLWcgYnJvd3NlcmZzYCwgeW91IGNhbiBnZW5lcmF0ZSBhIGxpc3RpbmcgYnlcbiAqIHJ1bm5pbmcgYG1ha2VfeGhyZnNfaW5kZXhgIGluIHlvdXIgdGVybWluYWwgaW4gdGhlIGRpcmVjdG9yeSB5b3Ugd291bGQgbGlrZSB0byBpbmRleDpcbiAqXG4gKiBgYGBcbiAqIG1ha2VfeGhyZnNfaW5kZXggPiBpbmRleC5qc29uXG4gKiBgYGBcbiAqXG4gKiBMaXN0aW5ncyBvYmplY3RzIGxvb2sgbGlrZSB0aGUgZm9sbG93aW5nOlxuICpcbiAqIGBgYGpzb25cbiAqIHtcbiAqICAgXCJob21lXCI6IHtcbiAqICAgICBcImp2aWxrXCI6IHtcbiAqICAgICAgIFwic29tZUZpbGUudHh0XCI6IG51bGwsXG4gKiAgICAgICBcInNvbWVEaXJcIjoge1xuICogICAgICAgICAvLyBFbXB0eSBkaXJlY3RvcnlcbiAqICAgICAgIH1cbiAqICAgICB9XG4gKiAgIH1cbiAqIH1cbiAqIGBgYFxuICpcbiAqICpUaGlzIGV4YW1wbGUgaGFzIHRoZSBmb2xkZXIgYC9ob21lL2p2aWxrYCB3aXRoIHN1YmZpbGUgYHNvbWVGaWxlLnR4dGAgYW5kIHN1YmZvbGRlciBgc29tZURpcmAuKlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBYbWxIdHRwUmVxdWVzdCBleHRlbmRzIEJhc2VGaWxlU3lzdGVtIGltcGxlbWVudHMgRmlsZVN5c3RlbSB7XG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgTmFtZSA9IFwiWG1sSHR0cFJlcXVlc3RcIjtcblxuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IE9wdGlvbnM6IEZpbGVTeXN0ZW1PcHRpb25zID0ge1xuICAgIGluZGV4OiB7XG4gICAgICB0eXBlOiBbXCJzdHJpbmdcIiwgXCJvYmplY3RcIl0sXG4gICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgIGRlc2NyaXB0aW9uOiBcIlVSTCB0byBhIGZpbGUgaW5kZXggYXMgYSBKU09OIGZpbGUgb3IgdGhlIGZpbGUgaW5kZXggb2JqZWN0IGl0c2VsZiwgZ2VuZXJhdGVkIHdpdGggdGhlIG1ha2VfeGhyZnNfaW5kZXggc2NyaXB0LiBEZWZhdWx0cyB0byBgaW5kZXguanNvbmAuXCJcbiAgICB9LFxuICAgIGJhc2VVcmw6IHtcbiAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgIGRlc2NyaXB0aW9uOiBcIlVzZWQgYXMgdGhlIFVSTCBwcmVmaXggZm9yIGZldGNoZWQgZmlsZXMuIERlZmF1bHQ6IEZldGNoIGZpbGVzIHJlbGF0aXZlIHRvIHRoZSBpbmRleC5cIlxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ29uc3RydWN0IGFuIFhtbEh0dHBSZXF1ZXN0IGZpbGUgc3lzdGVtIGJhY2tlbmQgd2l0aCB0aGUgZ2l2ZW4gb3B0aW9ucy5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgQ3JlYXRlKG9wdHM6IFhtbEh0dHBSZXF1ZXN0T3B0aW9ucywgY2I6IEJGU0NhbGxiYWNrPFhtbEh0dHBSZXF1ZXN0Pik6IHZvaWQge1xuICAgIGlmIChvcHRzLmluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG9wdHMuaW5kZXggPSBgaW5kZXguanNvbmA7XG4gICAgfVxuICAgIGlmICh0eXBlb2Yob3B0cy5pbmRleCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIFhtbEh0dHBSZXF1ZXN0LkZyb21VUkwob3B0cy5pbmRleCwgY2IsIG9wdHMuYmFzZVVybCwgZmFsc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYihudWxsLCBuZXcgWG1sSHR0cFJlcXVlc3Qob3B0cy5pbmRleCwgb3B0cy5iYXNlVXJsLCBmYWxzZSkpO1xuICAgIH1cbiAgfVxuICBwdWJsaWMgc3RhdGljIGlzQXZhaWxhYmxlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0eXBlb2YoWE1MSHR0cFJlcXVlc3QpICE9PSBcInVuZGVmaW5lZFwiICYmIFhNTEh0dHBSZXF1ZXN0ICE9PSBudWxsO1xuICB9XG4gIC8qKlxuICAgKiAqKkRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgWG1sSHR0cFJlcXVlc3QuQ3JlYXRlKCkgbWV0aG9kIGluc3RlYWQgdG8gY29uc3RydWN0IFhtbEh0dHBSZXF1ZXN0IG9iamVjdHMuKipcbiAgICpcbiAgICogQ29uc3RydWN0cyBhbiBYbWxIdHRwUmVxdWVzdCBvYmplY3QgdXNpbmcgdGhlIGRpcmVjdG9yeSBsaXN0aW5nIGF0IHRoZSBnaXZlbiBVUkwuXG4gICAqIFVzZXMgdGhlIGJhc2UgVVJMIGFzIHRoZSBVUkwgcHJlZml4IGZvciBmZXRjaGVkIGZpbGVzLlxuICAgKiBAcGFyYW0gY2IgQ2FsbGVkIHdoZW4gdGhlIGZpbGUgc3lzdGVtIGhhcyBiZWVuIGluc3RhbnRpYXRlZCwgb3IgaWYgYW4gZXJyb3Igb2NjdXJzLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBGcm9tVVJMKHVybDogc3RyaW5nLCBjYjogQkZTQ2FsbGJhY2s8WG1sSHR0cFJlcXVlc3Q+LCBiYXNlVXJsID0gdXJsLnNsaWNlKDAsIHVybC5sYXN0SW5kZXhPZignLycpICsgMSksIGRlcHJlY2F0ZU1zZyA9IHRydWUpOiB2b2lkIHtcbiAgICBpZiAoZGVwcmVjYXRlTXNnKSB7XG4gICAgICBjb25zb2xlLndhcm4oYFtYbWxIdHRwUmVxdWVzdF0gWG1sSHR0cFJlcXVlc3QuRnJvbVVSTCgpIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlLiBQbGVhc2UgdXNlICdYbWxIdHRwUmVxdWVzdC5DcmVhdGUoeyBpbmRleDogXCIke3VybH1cIiwgYmFzZVVybDogXCIke2Jhc2VVcmx9XCIgfSwgY2IpJyBpbnN0ZWFkLmApO1xuICAgIH1cbiAgICBhc3luY0Rvd25sb2FkRmlsZSh1cmwsIFwianNvblwiLCAoZSwgZGF0YT8pID0+IHtcbiAgICAgIGlmIChlKSB7XG4gICAgICAgIGNiKGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2IobnVsbCwgbmV3IFhtbEh0dHBSZXF1ZXN0KGRhdGEsIGJhc2VVcmwsIGZhbHNlKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBwdWJsaWMgcmVhZG9ubHkgcHJlZml4VXJsOiBzdHJpbmc7XG4gIHByaXZhdGUgX2luZGV4OiBGaWxlSW5kZXg8e30+O1xuICAvKipcbiAgICogKipEZXByZWNhdGVkLiBQbGVhc2UgdXNlIFhtbEh0dHBSZXF1ZXN0LkNyZWF0ZSgpIG1ldGhvZCBpbnN0ZWFkIHRvIGNvbnN0cnVjdCBYbWxIdHRwUmVxdWVzdCBvYmplY3RzLioqXG4gICAqXG4gICAqIENvbnN0cnVjdHMgdGhlIGZpbGUgc3lzdGVtLiBZb3UgbXVzdCBwcm92aWRlIHRoZSBkaXJlY3RvcnkgbGlzdGluZyBhcyBhIEpTT04gb2JqZWN0XG4gICAqIHByb2R1Y2VkIGJ5IHRoZSBgbWFrZV94aHJmc19pbmRleGAgc2NyaXB0LlxuICAgKlxuICAgKiAqKkRFUFJFQ0FURUQ6KiogWW91IG1heSBwYXNzIGEgVVJMIHRvIHRoZSBmaWxlIGluZGV4IHRvIHRoZSBjb25zdHJ1Y3Rvciwgd2hpY2ggd2lsbCBmZXRjaCB0aGUgZmlsZSBpbmRleFxuICAgKiAqc3luY2hyb25vdXNseSogYW5kIG1heSBmcmVlemUgdXAgdGhlIHdlYiBwYWdlLiBUaGlzIGJlaGF2aW9yIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uXG4gICAqIG9mIEJyb3dzZXJGUy5cbiAgICpcbiAgICogQHBhcmFtIGxpc3RpbmdVcmxPck9iaiBpbmRleCBvYmplY3Qgb3IgdGhlIHBhdGggdG8gdGhlIEpTT04gZmlsZSBpbmRleCBnZW5lcmF0ZWQgYnlcbiAgICogICBgbWFrZV94aHJmc19pbmRleGAuXG4gICAqIEBwYXJhbSBwcmVmaXhVcmwgVVJMIHRoYXQgaXMgcHJlcGVuZGVkIHRvIGFueSBmaWxlIGxvY2F0aW9ucyBpbiB0aGUgZmlsZSBpbmRleC4gZS5nLiBpZiBgcHJlZml4VXJsID0gJ2RhdGEvYCwgYW5kIHRoZSB1c2VyIHdhbnRzIHRvIG9wZW4gdGhlIGZpbGUgYC9mb28udHh0YCxcbiAgICogdGhlIGZpbGUgc3lzdGVtIHdpbGwgZmV0Y2ggZmlsZSBgZGF0YS9mb28udHh0YC4gVGhlIGJyb3dzZXIgd2lsbCBhY2Nlc3MgdGhlIGZpbGUgcmVsYXRpdmUgdG8gdGhlIGN1cnJyZW50IHdlYnBhZ2VcbiAgICogVVJMLlxuICAgKi9cbiAgY29uc3RydWN0b3IobGlzdGluZ1VybE9yT2JqOiBzdHJpbmcgfCBvYmplY3QsIHByZWZpeFVybDogc3RyaW5nID0gJycsIGRlcHJlY2F0ZU1zZyA9IHRydWUpIHtcbiAgICBzdXBlcigpO1xuICAgIGlmICghbGlzdGluZ1VybE9yT2JqKSB7XG4gICAgICBsaXN0aW5nVXJsT3JPYmogPSAnaW5kZXguanNvbic7XG4gICAgfVxuICAgIC8vIHByZWZpeF91cmwgbXVzdCBlbmQgaW4gYSBkaXJlY3Rvcnkgc2VwYXJhdG9yLlxuICAgIGlmIChwcmVmaXhVcmwubGVuZ3RoID4gMCAmJiBwcmVmaXhVcmwuY2hhckF0KHByZWZpeFVybC5sZW5ndGggLSAxKSAhPT0gJy8nKSB7XG4gICAgICBwcmVmaXhVcmwgPSBwcmVmaXhVcmwgKyAnLyc7XG4gICAgfVxuICAgIHRoaXMucHJlZml4VXJsID0gcHJlZml4VXJsO1xuXG4gICAgbGV0IGxpc3Rpbmc6IG9iamVjdCB8IG51bGwgPSBudWxsO1xuICAgIGlmICh0eXBlb2YobGlzdGluZ1VybE9yT2JqKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgbGlzdGluZyA9IHRoaXMuX3JlcXVlc3RGaWxlU3luYyg8c3RyaW5nPiBsaXN0aW5nVXJsT3JPYmosICdqc29uJyk7XG4gICAgICBpZiAoIWxpc3RpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGZpbmQgbGlzdGluZyBhdCBVUkw6ICR7bGlzdGluZ1VybE9yT2JqfVwiKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGlzdGluZyA9IGxpc3RpbmdVcmxPck9iajtcbiAgICB9XG4gICAgZGVwcmVjYXRpb25NZXNzYWdlKGRlcHJlY2F0ZU1zZywgWG1sSHR0cFJlcXVlc3QuTmFtZSwgeyBpbmRleDogdHlwZW9mKGxpc3RpbmdVcmxPck9iaikgPT09IFwic3RyaW5nXCIgPyBsaXN0aW5nVXJsT3JPYmogOiBcImZpbGUgaW5kZXggYXMgYW4gb2JqZWN0XCIsIGJhc2VVcmw6IHByZWZpeFVybH0pO1xuXG4gICAgdGhpcy5faW5kZXggPSBGaWxlSW5kZXguZnJvbUxpc3RpbmcobGlzdGluZyk7XG4gIH1cblxuICBwdWJsaWMgZW1wdHkoKTogdm9pZCB7XG4gICAgdGhpcy5faW5kZXguZmlsZUl0ZXJhdG9yKGZ1bmN0aW9uKGZpbGU6IFN0YXRzKSB7XG4gICAgICBmaWxlLmZpbGVEYXRhID0gbnVsbDtcbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyBnZXROYW1lKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIFhtbEh0dHBSZXF1ZXN0Lk5hbWU7XG4gIH1cblxuICBwdWJsaWMgZGlza1NwYWNlKHBhdGg6IHN0cmluZywgY2I6ICh0b3RhbDogbnVtYmVyLCBmcmVlOiBudW1iZXIpID0+IHZvaWQpOiB2b2lkIHtcbiAgICAvLyBSZWFkLW9ubHkgZmlsZSBzeXN0ZW0uIFdlIGNvdWxkIGNhbGN1bGF0ZSB0aGUgdG90YWwgc3BhY2UsIGJ1dCB0aGF0J3Mgbm90XG4gICAgLy8gaW1wb3J0YW50IHJpZ2h0IG5vdy5cbiAgICBjYigwLCAwKTtcbiAgfVxuXG4gIHB1YmxpYyBpc1JlYWRPbmx5KCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcHVibGljIHN1cHBvcnRzTGlua3MoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcHVibGljIHN1cHBvcnRzUHJvcHMoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcHVibGljIHN1cHBvcnRzU3luY2goKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogU3BlY2lhbCBYSFIgZnVuY3Rpb246IFByZWxvYWQgdGhlIGdpdmVuIGZpbGUgaW50byB0aGUgaW5kZXguXG4gICAqIEBwYXJhbSBbU3RyaW5nXSBwYXRoXG4gICAqIEBwYXJhbSBbQnJvd3NlckZTLkJ1ZmZlcl0gYnVmZmVyXG4gICAqL1xuICBwdWJsaWMgcHJlbG9hZEZpbGUocGF0aDogc3RyaW5nLCBidWZmZXI6IEJ1ZmZlcik6IHZvaWQge1xuICAgIGNvbnN0IGlub2RlID0gdGhpcy5faW5kZXguZ2V0SW5vZGUocGF0aCk7XG4gICAgaWYgKGlzRmlsZUlub2RlPFN0YXRzPihpbm9kZSkpIHtcbiAgICAgIGlmIChpbm9kZSA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBBcGlFcnJvci5FTk9FTlQocGF0aCk7XG4gICAgICB9XG4gICAgICBjb25zdCBzdGF0cyA9IGlub2RlLmdldERhdGEoKTtcbiAgICAgIHN0YXRzLnNpemUgPSBidWZmZXIubGVuZ3RoO1xuICAgICAgc3RhdHMuZmlsZURhdGEgPSBidWZmZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IEFwaUVycm9yLkVJU0RJUihwYXRoKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgc3RhdChwYXRoOiBzdHJpbmcsIGlzTHN0YXQ6IGJvb2xlYW4sIGNiOiBCRlNDYWxsYmFjazxTdGF0cz4pOiB2b2lkIHtcbiAgICBjb25zdCBpbm9kZSA9IHRoaXMuX2luZGV4LmdldElub2RlKHBhdGgpO1xuICAgIGlmIChpbm9kZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGNiKEFwaUVycm9yLkVOT0VOVChwYXRoKSk7XG4gICAgfVxuICAgIGxldCBzdGF0czogU3RhdHM7XG4gICAgaWYgKGlzRmlsZUlub2RlPFN0YXRzPihpbm9kZSkpIHtcbiAgICAgIHN0YXRzID0gaW5vZGUuZ2V0RGF0YSgpO1xuICAgICAgLy8gQXQgdGhpcyBwb2ludCwgYSBub24tb3BlbmVkIGZpbGUgd2lsbCBzdGlsbCBoYXZlIGRlZmF1bHQgc3RhdHMgZnJvbSB0aGUgbGlzdGluZy5cbiAgICAgIGlmIChzdGF0cy5zaXplIDwgMCkge1xuICAgICAgICB0aGlzLl9yZXF1ZXN0RmlsZVNpemVBc3luYyhwYXRoLCBmdW5jdGlvbihlOiBBcGlFcnJvciwgc2l6ZT86IG51bWJlcikge1xuICAgICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gY2IoZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0YXRzLnNpemUgPSBzaXplITtcbiAgICAgICAgICBjYihudWxsLCBzdGF0cy5jbG9uZSgpKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYihudWxsLCBzdGF0cy5jbG9uZSgpKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzRGlySW5vZGUoaW5vZGUpKSB7XG4gICAgICBzdGF0cyA9IGlub2RlLmdldFN0YXRzKCk7XG4gICAgICBjYihudWxsLCBzdGF0cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNiKEFwaUVycm9yLkZpbGVFcnJvcihFcnJvckNvZGUuRUlOVkFMLCBwYXRoKSk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHN0YXRTeW5jKHBhdGg6IHN0cmluZywgaXNMc3RhdDogYm9vbGVhbik6IFN0YXRzIHtcbiAgICBjb25zdCBpbm9kZSA9IHRoaXMuX2luZGV4LmdldElub2RlKHBhdGgpO1xuICAgIGlmIChpbm9kZSA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgQXBpRXJyb3IuRU5PRU5UKHBhdGgpO1xuICAgIH1cbiAgICBsZXQgc3RhdHM6IFN0YXRzO1xuICAgIGlmIChpc0ZpbGVJbm9kZTxTdGF0cz4oaW5vZGUpKSB7XG4gICAgICBzdGF0cyA9IGlub2RlLmdldERhdGEoKTtcbiAgICAgIC8vIEF0IHRoaXMgcG9pbnQsIGEgbm9uLW9wZW5lZCBmaWxlIHdpbGwgc3RpbGwgaGF2ZSBkZWZhdWx0IHN0YXRzIGZyb20gdGhlIGxpc3RpbmcuXG4gICAgICBpZiAoc3RhdHMuc2l6ZSA8IDApIHtcbiAgICAgICAgc3RhdHMuc2l6ZSA9IHRoaXMuX3JlcXVlc3RGaWxlU2l6ZVN5bmMocGF0aCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc0Rpcklub2RlKGlub2RlKSkge1xuICAgICAgc3RhdHMgPSBpbm9kZS5nZXRTdGF0cygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBBcGlFcnJvci5GaWxlRXJyb3IoRXJyb3JDb2RlLkVJTlZBTCwgcGF0aCk7XG4gICAgfVxuICAgIHJldHVybiBzdGF0cztcbiAgfVxuXG4gIHB1YmxpYyBvcGVuKHBhdGg6IHN0cmluZywgZmxhZ3M6IEZpbGVGbGFnLCBtb2RlOiBudW1iZXIsIGNiOiBCRlNDYWxsYmFjazxGaWxlPik6IHZvaWQge1xuICAgIC8vIElOVkFSSUFOVDogWW91IGNhbid0IHdyaXRlIHRvIGZpbGVzIG9uIHRoaXMgZmlsZSBzeXN0ZW0uXG4gICAgaWYgKGZsYWdzLmlzV3JpdGVhYmxlKCkpIHtcbiAgICAgIHJldHVybiBjYihuZXcgQXBpRXJyb3IoRXJyb3JDb2RlLkVQRVJNLCBwYXRoKSk7XG4gICAgfVxuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIC8vIENoZWNrIGlmIHRoZSBwYXRoIGV4aXN0cywgYW5kIGlzIGEgZmlsZS5cbiAgICBjb25zdCBpbm9kZSA9IHRoaXMuX2luZGV4LmdldElub2RlKHBhdGgpO1xuICAgIGlmIChpbm9kZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGNiKEFwaUVycm9yLkVOT0VOVChwYXRoKSk7XG4gICAgfVxuICAgIGlmIChpc0ZpbGVJbm9kZTxTdGF0cz4oaW5vZGUpKSB7XG4gICAgICBjb25zdCBzdGF0cyA9IGlub2RlLmdldERhdGEoKTtcbiAgICAgIHN3aXRjaCAoZmxhZ3MucGF0aEV4aXN0c0FjdGlvbigpKSB7XG4gICAgICAgIGNhc2UgQWN0aW9uVHlwZS5USFJPV19FWENFUFRJT046XG4gICAgICAgIGNhc2UgQWN0aW9uVHlwZS5UUlVOQ0FURV9GSUxFOlxuICAgICAgICAgIHJldHVybiBjYihBcGlFcnJvci5FRVhJU1QocGF0aCkpO1xuICAgICAgICBjYXNlIEFjdGlvblR5cGUuTk9QOlxuICAgICAgICAgIC8vIFVzZSBleGlzdGluZyBmaWxlIGNvbnRlbnRzLlxuICAgICAgICAgIC8vIFhYWDogVWgsIHRoaXMgbWFpbnRhaW5zIHRoZSBwcmV2aW91c2x5LXVzZWQgZmxhZy5cbiAgICAgICAgICBpZiAoc3RhdHMuZmlsZURhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBjYihudWxsLCBuZXcgTm9TeW5jRmlsZShzZWxmLCBwYXRoLCBmbGFncywgc3RhdHMuY2xvbmUoKSwgc3RhdHMuZmlsZURhdGEpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gQHRvZG8gYmUgbGF6aWVyIGFib3V0IGFjdHVhbGx5IHJlcXVlc3RpbmcgdGhlIGZpbGVcbiAgICAgICAgICB0aGlzLl9yZXF1ZXN0RmlsZUFzeW5jKHBhdGgsICdidWZmZXInLCBmdW5jdGlvbihlcnI6IEFwaUVycm9yLCBidWZmZXI/OiBCdWZmZXIpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNiKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB3ZSBkb24ndCBpbml0aWFsbHkgaGF2ZSBmaWxlIHNpemVzXG4gICAgICAgICAgICBzdGF0cy5zaXplID0gYnVmZmVyIS5sZW5ndGg7XG4gICAgICAgICAgICBzdGF0cy5maWxlRGF0YSA9IGJ1ZmZlciE7XG4gICAgICAgICAgICByZXR1cm4gY2IobnVsbCwgbmV3IE5vU3luY0ZpbGUoc2VsZiwgcGF0aCwgZmxhZ3MsIHN0YXRzLmNsb25lKCksIGJ1ZmZlcikpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBjYihuZXcgQXBpRXJyb3IoRXJyb3JDb2RlLkVJTlZBTCwgJ0ludmFsaWQgRmlsZU1vZGUgb2JqZWN0LicpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGNiKEFwaUVycm9yLkVJU0RJUihwYXRoKSk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIG9wZW5TeW5jKHBhdGg6IHN0cmluZywgZmxhZ3M6IEZpbGVGbGFnLCBtb2RlOiBudW1iZXIpOiBGaWxlIHtcbiAgICAvLyBJTlZBUklBTlQ6IFlvdSBjYW4ndCB3cml0ZSB0byBmaWxlcyBvbiB0aGlzIGZpbGUgc3lzdGVtLlxuICAgIGlmIChmbGFncy5pc1dyaXRlYWJsZSgpKSB7XG4gICAgICB0aHJvdyBuZXcgQXBpRXJyb3IoRXJyb3JDb2RlLkVQRVJNLCBwYXRoKTtcbiAgICB9XG4gICAgLy8gQ2hlY2sgaWYgdGhlIHBhdGggZXhpc3RzLCBhbmQgaXMgYSBmaWxlLlxuICAgIGNvbnN0IGlub2RlID0gdGhpcy5faW5kZXguZ2V0SW5vZGUocGF0aCk7XG4gICAgaWYgKGlub2RlID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBBcGlFcnJvci5FTk9FTlQocGF0aCk7XG4gICAgfVxuICAgIGlmIChpc0ZpbGVJbm9kZTxTdGF0cz4oaW5vZGUpKSB7XG4gICAgICBjb25zdCBzdGF0cyA9IGlub2RlLmdldERhdGEoKTtcbiAgICAgIHN3aXRjaCAoZmxhZ3MucGF0aEV4aXN0c0FjdGlvbigpKSB7XG4gICAgICAgIGNhc2UgQWN0aW9uVHlwZS5USFJPV19FWENFUFRJT046XG4gICAgICAgIGNhc2UgQWN0aW9uVHlwZS5UUlVOQ0FURV9GSUxFOlxuICAgICAgICAgIHRocm93IEFwaUVycm9yLkVFWElTVChwYXRoKTtcbiAgICAgICAgY2FzZSBBY3Rpb25UeXBlLk5PUDpcbiAgICAgICAgICAvLyBVc2UgZXhpc3RpbmcgZmlsZSBjb250ZW50cy5cbiAgICAgICAgICAvLyBYWFg6IFVoLCB0aGlzIG1haW50YWlucyB0aGUgcHJldmlvdXNseS11c2VkIGZsYWcuXG4gICAgICAgICAgaWYgKHN0YXRzLmZpbGVEYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE5vU3luY0ZpbGUodGhpcywgcGF0aCwgZmxhZ3MsIHN0YXRzLmNsb25lKCksIHN0YXRzLmZpbGVEYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gQHRvZG8gYmUgbGF6aWVyIGFib3V0IGFjdHVhbGx5IHJlcXVlc3RpbmcgdGhlIGZpbGVcbiAgICAgICAgICBjb25zdCBidWZmZXIgPSB0aGlzLl9yZXF1ZXN0RmlsZVN5bmMocGF0aCwgJ2J1ZmZlcicpO1xuICAgICAgICAgIC8vIHdlIGRvbid0IGluaXRpYWxseSBoYXZlIGZpbGUgc2l6ZXNcbiAgICAgICAgICBzdGF0cy5zaXplID0gYnVmZmVyLmxlbmd0aDtcbiAgICAgICAgICBzdGF0cy5maWxlRGF0YSA9IGJ1ZmZlcjtcbiAgICAgICAgICByZXR1cm4gbmV3IE5vU3luY0ZpbGUodGhpcywgcGF0aCwgZmxhZ3MsIHN0YXRzLmNsb25lKCksIGJ1ZmZlcik7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEFwaUVycm9yKEVycm9yQ29kZS5FSU5WQUwsICdJbnZhbGlkIEZpbGVNb2RlIG9iamVjdC4nKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgQXBpRXJyb3IuRUlTRElSKHBhdGgpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyByZWFkZGlyKHBhdGg6IHN0cmluZywgY2I6IEJGU0NhbGxiYWNrPHN0cmluZ1tdPik6IHZvaWQge1xuICAgIHRyeSB7XG4gICAgICBjYihudWxsLCB0aGlzLnJlYWRkaXJTeW5jKHBhdGgpKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjYihlKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgcmVhZGRpclN5bmMocGF0aDogc3RyaW5nKTogc3RyaW5nW10ge1xuICAgIC8vIENoZWNrIGlmIGl0IGV4aXN0cy5cbiAgICBjb25zdCBpbm9kZSA9IHRoaXMuX2luZGV4LmdldElub2RlKHBhdGgpO1xuICAgIGlmIChpbm9kZSA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgQXBpRXJyb3IuRU5PRU5UKHBhdGgpO1xuICAgIH0gZWxzZSBpZiAoaXNEaXJJbm9kZShpbm9kZSkpIHtcbiAgICAgIHJldHVybiBpbm9kZS5nZXRMaXN0aW5nKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IEFwaUVycm9yLkVOT1RESVIocGF0aCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFdlIGhhdmUgdGhlIGVudGlyZSBmaWxlIGFzIGEgYnVmZmVyOyBvcHRpbWl6ZSByZWFkRmlsZS5cbiAgICovXG4gIHB1YmxpYyByZWFkRmlsZShmbmFtZTogc3RyaW5nLCBlbmNvZGluZzogc3RyaW5nLCBmbGFnOiBGaWxlRmxhZywgY2I6IEJGU0NhbGxiYWNrPHN0cmluZyB8IEJ1ZmZlcj4pOiB2b2lkIHtcbiAgICAvLyBXcmFwIGNiIGluIGZpbGUgY2xvc2luZyBjb2RlLlxuICAgIGNvbnN0IG9sZENiID0gY2I7XG4gICAgLy8gR2V0IGZpbGUuXG4gICAgdGhpcy5vcGVuKGZuYW1lLCBmbGFnLCAweDFhNCwgZnVuY3Rpb24oZXJyOiBBcGlFcnJvciwgZmQ/OiBGaWxlKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJldHVybiBjYihlcnIpO1xuICAgICAgfVxuICAgICAgY2IgPSBmdW5jdGlvbihlcnI6IEFwaUVycm9yLCBhcmc/OiBCdWZmZXIpIHtcbiAgICAgICAgZmQhLmNsb3NlKGZ1bmN0aW9uKGVycjI6IGFueSkge1xuICAgICAgICAgIGlmICghZXJyKSB7XG4gICAgICAgICAgICBlcnIgPSBlcnIyO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gb2xkQ2IoZXJyLCBhcmcpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBjb25zdCBmZENhc3QgPSA8Tm9TeW5jRmlsZTxYbWxIdHRwUmVxdWVzdD4+IGZkO1xuICAgICAgY29uc3QgZmRCdWZmID0gPEJ1ZmZlcj4gZmRDYXN0LmdldEJ1ZmZlcigpO1xuICAgICAgaWYgKGVuY29kaW5nID09PSBudWxsKSB7XG4gICAgICAgIGNiKGVyciwgY29weWluZ1NsaWNlKGZkQnVmZikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5VG9TdHJpbmcoZmRCdWZmLCBlbmNvZGluZywgY2IpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNwZWNpYWxseS1vcHRpbWl6ZWQgcmVhZGZpbGUuXG4gICAqL1xuICBwdWJsaWMgcmVhZEZpbGVTeW5jKGZuYW1lOiBzdHJpbmcsIGVuY29kaW5nOiBzdHJpbmcsIGZsYWc6IEZpbGVGbGFnKTogYW55IHtcbiAgICAvLyBHZXQgZmlsZS5cbiAgICBjb25zdCBmZCA9IHRoaXMub3BlblN5bmMoZm5hbWUsIGZsYWcsIDB4MWE0KTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZmRDYXN0ID0gPE5vU3luY0ZpbGU8WG1sSHR0cFJlcXVlc3Q+PiBmZDtcbiAgICAgIGNvbnN0IGZkQnVmZiA9IDxCdWZmZXI+IGZkQ2FzdC5nZXRCdWZmZXIoKTtcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gY29weWluZ1NsaWNlKGZkQnVmZik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmRCdWZmLnRvU3RyaW5nKGVuY29kaW5nKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgZmQuY2xvc2VTeW5jKCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBnZXRYaHJQYXRoKGZpbGVQYXRoOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGlmIChmaWxlUGF0aC5jaGFyQXQoMCkgPT09ICcvJykge1xuICAgICAgZmlsZVBhdGggPSBmaWxlUGF0aC5zbGljZSgxKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucHJlZml4VXJsICsgZmlsZVBhdGg7XG4gIH1cblxuICAvKipcbiAgICogQXN5bmNocm9ub3VzbHkgZG93bmxvYWQgdGhlIGdpdmVuIGZpbGUuXG4gICAqL1xuICBwcml2YXRlIF9yZXF1ZXN0RmlsZUFzeW5jKHA6IHN0cmluZywgdHlwZTogJ2J1ZmZlcicsIGNiOiBCRlNDYWxsYmFjazxCdWZmZXI+KTogdm9pZDtcbiAgcHJpdmF0ZSBfcmVxdWVzdEZpbGVBc3luYyhwOiBzdHJpbmcsIHR5cGU6ICdqc29uJywgY2I6IEJGU0NhbGxiYWNrPGFueT4pOiB2b2lkO1xuICBwcml2YXRlIF9yZXF1ZXN0RmlsZUFzeW5jKHA6IHN0cmluZywgdHlwZTogc3RyaW5nLCBjYjogQkZTQ2FsbGJhY2s8YW55Pik6IHZvaWQ7XG4gIHByaXZhdGUgX3JlcXVlc3RGaWxlQXN5bmMocDogc3RyaW5nLCB0eXBlOiBzdHJpbmcsIGNiOiBCRlNDYWxsYmFjazxhbnk+KTogdm9pZCB7XG4gICAgYXN5bmNEb3dubG9hZEZpbGUodGhpcy5nZXRYaHJQYXRoKHApLCB0eXBlLCBjYik7XG4gIH1cblxuICAvKipcbiAgICogU3luY2hyb25vdXNseSBkb3dubG9hZCB0aGUgZ2l2ZW4gZmlsZS5cbiAgICovXG4gIHByaXZhdGUgX3JlcXVlc3RGaWxlU3luYyhwOiBzdHJpbmcsIHR5cGU6ICdidWZmZXInKTogQnVmZmVyO1xuICBwcml2YXRlIF9yZXF1ZXN0RmlsZVN5bmMocDogc3RyaW5nLCB0eXBlOiAnanNvbicpOiBhbnk7XG4gIHByaXZhdGUgX3JlcXVlc3RGaWxlU3luYyhwOiBzdHJpbmcsIHR5cGU6IHN0cmluZyk6IGFueTtcbiAgcHJpdmF0ZSBfcmVxdWVzdEZpbGVTeW5jKHA6IHN0cmluZywgdHlwZTogc3RyaW5nKTogYW55IHtcbiAgICByZXR1cm4gc3luY0Rvd25sb2FkRmlsZSh0aGlzLmdldFhoclBhdGgocCksIHR5cGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIE9ubHkgcmVxdWVzdHMgdGhlIEhFQUQgY29udGVudCwgZm9yIHRoZSBmaWxlIHNpemUuXG4gICAqL1xuICBwcml2YXRlIF9yZXF1ZXN0RmlsZVNpemVBc3luYyhwYXRoOiBzdHJpbmcsIGNiOiBCRlNDYWxsYmFjazxudW1iZXI+KTogdm9pZCB7XG4gICAgZ2V0RmlsZVNpemVBc3luYyh0aGlzLmdldFhoclBhdGgocGF0aCksIGNiKTtcbiAgfVxuICBwcml2YXRlIF9yZXF1ZXN0RmlsZVNpemVTeW5jKHBhdGg6IHN0cmluZyk6IG51bWJlciB7XG4gICAgcmV0dXJuIGdldEZpbGVTaXplU3luYyh0aGlzLmdldFhoclBhdGgocGF0aCkpO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vLi4vLi4vLi4vc3JjL2JhY2tlbmQvWG1sSHR0cFJlcXVlc3QudHMiLCIvKipcbiAqIChOb25zdGFuZGFyZCkgU3RyaW5nIHV0aWxpdHkgZnVuY3Rpb24gZm9yIDgtYml0IEFTQ0lJIHdpdGggdGhlIGV4dGVuZGVkXG4gKiBjaGFyYWN0ZXIgc2V0LiBVbmxpa2UgdGhlIEFTQ0lJIGFib3ZlLCB3ZSBkbyBub3QgbWFzayB0aGUgaGlnaCBiaXRzLlxuICpcbiAqIFBsYWNlZCBpbnRvIGEgc2VwYXJhdGUgZmlsZSBzbyBpdCBjYW4gYmUgdXNlZCB3aXRoIG90aGVyIEJ1ZmZlciBpbXBsZW1lbnRhdGlvbnMuXG4gKiBAc2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRXh0ZW5kZWRfQVNDSUlcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRXh0ZW5kZWRBU0NJSSB7XG4gIHByaXZhdGUgc3RhdGljIGV4dGVuZGVkQ2hhcnMgPSBbICdcXHUwMEM3JywgJ1xcdTAwRkMnLCAnXFx1MDBFOScsICdcXHUwMEUyJywgJ1xcdTAwRTQnLFxuICAgICdcXHUwMEUwJywgJ1xcdTAwRTUnLCAnXFx1MDBFNycsICdcXHUwMEVBJywgJ1xcdTAwRUInLCAnXFx1MDBFOCcsICdcXHUwMEVGJyxcbiAgICAnXFx1MDBFRScsICdcXHUwMEVDJywgJ1xcdTAwQzQnLCAnXFx1MDBDNScsICdcXHUwMEM5JywgJ1xcdTAwRTYnLCAnXFx1MDBDNicsXG4gICAgJ1xcdTAwRjQnLCAnXFx1MDBGNicsICdcXHUwMEYyJywgJ1xcdTAwRkInLCAnXFx1MDBGOScsICdcXHUwMEZGJywgJ1xcdTAwRDYnLFxuICAgICdcXHUwMERDJywgJ1xcdTAwRjgnLCAnXFx1MDBBMycsICdcXHUwMEQ4JywgJ1xcdTAwRDcnLCAnXFx1MDE5MicsICdcXHUwMEUxJyxcbiAgICAnXFx1MDBFRCcsICdcXHUwMEYzJywgJ1xcdTAwRkEnLCAnXFx1MDBGMScsICdcXHUwMEQxJywgJ1xcdTAwQUEnLCAnXFx1MDBCQScsXG4gICAgJ1xcdTAwQkYnLCAnXFx1MDBBRScsICdcXHUwMEFDJywgJ1xcdTAwQkQnLCAnXFx1MDBCQycsICdcXHUwMEExJywgJ1xcdTAwQUInLFxuICAgICdcXHUwMEJCJywgJ18nLCAnXycsICdfJywgJ1xcdTAwQTYnLCAnXFx1MDBBNicsICdcXHUwMEMxJywgJ1xcdTAwQzInLCAnXFx1MDBDMCcsXG4gICAgJ1xcdTAwQTknLCAnXFx1MDBBNicsICdcXHUwMEE2JywgJysnLCAnKycsICdcXHUwMEEyJywgJ1xcdTAwQTUnLCAnKycsICcrJywgJy0nLFxuICAgICctJywgJysnLCAnLScsICcrJywgJ1xcdTAwRTMnLCAnXFx1MDBDMycsICcrJywgJysnLCAnLScsICctJywgJ1xcdTAwQTYnLCAnLScsXG4gICAgJysnLCAnXFx1MDBBNCcsICdcXHUwMEYwJywgJ1xcdTAwRDAnLCAnXFx1MDBDQScsICdcXHUwMENCJywgJ1xcdTAwQzgnLCAnaScsXG4gICAgJ1xcdTAwQ0QnLCAnXFx1MDBDRScsICdcXHUwMENGJywgJysnLCAnKycsICdfJywgJ18nLCAnXFx1MDBBNicsICdcXHUwMENDJywgJ18nLFxuICAgICdcXHUwMEQzJywgJ1xcdTAwREYnLCAnXFx1MDBENCcsICdcXHUwMEQyJywgJ1xcdTAwRjUnLCAnXFx1MDBENScsICdcXHUwMEI1JyxcbiAgICAnXFx1MDBGRScsICdcXHUwMERFJywgJ1xcdTAwREEnLCAnXFx1MDBEQicsICdcXHUwMEQ5JywgJ1xcdTAwRkQnLCAnXFx1MDBERCcsXG4gICAgJ1xcdTAwQUYnLCAnXFx1MDBCNCcsICdcXHUwMEFEJywgJ1xcdTAwQjEnLCAnXycsICdcXHUwMEJFJywgJ1xcdTAwQjYnLCAnXFx1MDBBNycsXG4gICAgJ1xcdTAwRjcnLCAnXFx1MDBCOCcsICdcXHUwMEIwJywgJ1xcdTAwQTgnLCAnXFx1MDBCNycsICdcXHUwMEI5JywgJ1xcdTAwQjMnLFxuICAgICdcXHUwMEIyJywgJ18nLCAnICcgXTtcblxuICBwdWJsaWMgc3RhdGljIHN0cjJieXRlKHN0cjogc3RyaW5nLCBidWY6IEJ1ZmZlcik6IG51bWJlciB7XG4gICAgY29uc3QgbGVuZ3RoID0gc3RyLmxlbmd0aCA+IGJ1Zi5sZW5ndGggPyBidWYubGVuZ3RoIDogc3RyLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgY2hhckNvZGUgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgIGlmIChjaGFyQ29kZSA+IDB4N0YpIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgZXh0ZW5kZWQgQVNDSUkuXG4gICAgICAgIGNvbnN0IGNoYXJJZHggPSBFeHRlbmRlZEFTQ0lJLmV4dGVuZGVkQ2hhcnMuaW5kZXhPZihzdHIuY2hhckF0KGkpKTtcbiAgICAgICAgaWYgKGNoYXJJZHggPiAtMSkge1xuICAgICAgICAgIGNoYXJDb2RlID0gY2hhcklkeCArIDB4ODA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBrZWVwIGl0IGFzLWlzLlxuICAgICAgfVxuICAgICAgYnVmW2NoYXJDb2RlXSA9IGk7XG4gICAgfVxuICAgIHJldHVybiBsZW5ndGg7XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIGJ5dGUyc3RyKGJ1ZmY6IEJ1ZmZlcik6IHN0cmluZyB7XG4gICAgY29uc3QgY2hhcnMgPSBuZXcgQXJyYXkoYnVmZi5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmZi5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgY2hhckNvZGUgPSBidWZmW2ldO1xuICAgICAgaWYgKGNoYXJDb2RlID4gMHg3Rikge1xuICAgICAgICBjaGFyc1tpXSA9IEV4dGVuZGVkQVNDSUkuZXh0ZW5kZWRDaGFyc1tjaGFyQ29kZSAtIDEyOF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaGFyc1tpXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2hhcnMuam9pbignJyk7XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIGJ5dGVMZW5ndGgoc3RyOiBzdHJpbmcpOiBudW1iZXIgeyByZXR1cm4gc3RyLmxlbmd0aDsgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uLy4uLy4uLy4uL3NyYy9nZW5lcmljL2V4dGVuZGVkX2FzY2lpLnRzIiwiaW1wb3J0IHtBcGlFcnJvciwgRXJyb3JDb2RlfSBmcm9tICcuLi9jb3JlL2FwaV9lcnJvcic7XG5pbXBvcnQge2RlZmF1bHQgYXMgU3RhdHMsIEZpbGVUeXBlfSBmcm9tICcuLi9jb3JlL25vZGVfZnNfc3RhdHMnO1xuaW1wb3J0IHtTeW5jaHJvbm91c0ZpbGVTeXN0ZW0sIEZpbGVTeXN0ZW0sIEJGU0NhbGxiYWNrLCBGaWxlU3lzdGVtT3B0aW9uc30gZnJvbSAnLi4vY29yZS9maWxlX3N5c3RlbSc7XG5pbXBvcnQge0ZpbGV9IGZyb20gJy4uL2NvcmUvZmlsZSc7XG5pbXBvcnQge0ZpbGVGbGFnLCBBY3Rpb25UeXBlfSBmcm9tICcuLi9jb3JlL2ZpbGVfZmxhZyc7XG5pbXBvcnQge05vU3luY0ZpbGV9IGZyb20gJy4uL2dlbmVyaWMvcHJlbG9hZF9maWxlJztcbmltcG9ydCB7QXJyYXlpc2gsIGFycmF5aXNoMkJ1ZmZlciwgY29weWluZ1NsaWNlLCBkZXByZWNhdGlvbk1lc3NhZ2UsIGJ1ZmZlclZhbGlkYXRvcn0gZnJvbSAnLi4vY29yZS91dGlsJztcbmltcG9ydCBFeHRlbmRlZEFTQ0lJIGZyb20gJy4uL2dlbmVyaWMvZXh0ZW5kZWRfYXNjaWknO1xuaW1wb3J0IHNldEltbWVkaWF0ZSBmcm9tICcuLi9nZW5lcmljL3NldEltbWVkaWF0ZSc7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgaW5mbGF0ZVJhdzpcbiAgKGRhdGE6IEFycmF5aXNoPG51bWJlcj4sIG9wdGlvbnM/OiB7XG4gICAgY2h1bmtTaXplOiBudW1iZXI7XG4gIH0pID0+IEFycmF5aXNoPG51bWJlcj4gPSByZXF1aXJlKCdwYWtvL2xpYi9pbmZsYXRlJykuaW5mbGF0ZVJhdztcbmltcG9ydCB7RmlsZUluZGV4LCBEaXJJbm9kZSwgRmlsZUlub2RlLCBpc0Rpcklub2RlLCBpc0ZpbGVJbm9kZX0gZnJvbSAnLi4vZ2VuZXJpYy9maWxlX2luZGV4JztcblxuLyoqXG4gKiBNYXBzIENvbXByZXNzaW9uTWV0aG9kID0+IGZ1bmN0aW9uIHRoYXQgZGVjb21wcmVzc2VzLlxuICogQGhpZGRlblxuICovXG5jb25zdCBkZWNvbXByZXNzaW9uTWV0aG9kczoge1ttZXRob2Q6IG51bWJlcl06IChkYXRhOiBCdWZmZXIsIGNvbXByZXNzZWRTaXplOiBudW1iZXIsIHVuY29tcHJlc3NlZFNpemU6IG51bWJlciwgZmxhZ3M6IG51bWJlcikgPT4gQnVmZmVyfSA9IHt9O1xuXG4vKipcbiAqIDQuNC4yLjI6IEluZGljYXRlcyB0aGUgY29tcGF0aWJpbHRpeSBvZiBhIGZpbGUncyBleHRlcm5hbCBhdHRyaWJ1dGVzLlxuICovXG5leHBvcnQgZW51bSBFeHRlcm5hbEZpbGVBdHRyaWJ1dGVUeXBlIHtcbiAgTVNET1MgPSAwLCBBTUlHQSA9IDEsIE9QRU5WTVMgPSAyLCBVTklYID0gMywgVk1fQ01TID0gNCwgQVRBUklfU1QgPSA1LFxuICBPUzJfSFBGUyA9IDYsIE1BQyA9IDcsIFpfU1lTVEVNID0gOCwgQ1BfTSA9IDksIE5URlMgPSAxMCwgTVZTID0gMTEsIFZTRSA9IDEyLFxuICBBQ09STl9SSVNDID0gMTMsIFZGQVQgPSAxNCwgQUxUX01WUyA9IDE1LCBCRU9TID0gMTYsIFRBTkRFTSA9IDE3LCBPU180MDAgPSAxOCxcbiAgT1NYID0gMTlcbn1cblxuLyoqXG4gKiA0LjQuNVxuICovXG5leHBvcnQgZW51bSBDb21wcmVzc2lvbk1ldGhvZCB7XG4gIFNUT1JFRCA9IDAsICAgICAvLyBUaGUgZmlsZSBpcyBzdG9yZWQgKG5vIGNvbXByZXNzaW9uKVxuICBTSFJVTksgPSAxLCAgICAgLy8gVGhlIGZpbGUgaXMgU2hydW5rXG4gIFJFRFVDRURfMSA9IDIsICAvLyBUaGUgZmlsZSBpcyBSZWR1Y2VkIHdpdGggY29tcHJlc3Npb24gZmFjdG9yIDFcbiAgUkVEVUNFRF8yID0gMywgIC8vIFRoZSBmaWxlIGlzIFJlZHVjZWQgd2l0aCBjb21wcmVzc2lvbiBmYWN0b3IgMlxuICBSRURVQ0VEXzMgPSA0LCAgLy8gVGhlIGZpbGUgaXMgUmVkdWNlZCB3aXRoIGNvbXByZXNzaW9uIGZhY3RvciAzXG4gIFJFRFVDRURfNCA9IDUsICAvLyBUaGUgZmlsZSBpcyBSZWR1Y2VkIHdpdGggY29tcHJlc3Npb24gZmFjdG9yIDRcbiAgSU1QTE9ERSA9IDYsICAgIC8vIFRoZSBmaWxlIGlzIEltcGxvZGVkXG4gIERFRkxBVEUgPSA4LCAgICAvLyBUaGUgZmlsZSBpcyBEZWZsYXRlZFxuICBERUZMQVRFNjQgPSA5LCAgLy8gRW5oYW5jZWQgRGVmbGF0aW5nIHVzaW5nIERlZmxhdGU2NCh0bSlcbiAgVEVSU0VfT0xEID0gMTAsIC8vIFBLV0FSRSBEYXRhIENvbXByZXNzaW9uIExpYnJhcnkgSW1wbG9kaW5nIChvbGQgSUJNIFRFUlNFKVxuICBCWklQMiA9IDEyLCAgICAgLy8gRmlsZSBpcyBjb21wcmVzc2VkIHVzaW5nIEJaSVAyIGFsZ29yaXRobVxuICBMWk1BID0gMTQsICAgICAgLy8gTFpNQSAoRUZTKVxuICBURVJTRV9ORVcgPSAxOCwgLy8gRmlsZSBpcyBjb21wcmVzc2VkIHVzaW5nIElCTSBURVJTRSAobmV3KVxuICBMWjc3ID0gMTksICAgICAgLy8gSUJNIExaNzcgeiBBcmNoaXRlY3R1cmUgKFBGUylcbiAgV0FWUEFDSyA9IDk3LCAgIC8vIFdhdlBhY2sgY29tcHJlc3NlZCBkYXRhXG4gIFBQTUQgPSA5OCAgICAgICAvLyBQUE1kIHZlcnNpb24gSSwgUmV2IDFcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgaW5wdXQgdGltZSBhbmQgZGF0ZSBpbiBNUy1ET1MgZm9ybWF0IGludG8gYSBKYXZhU2NyaXB0IERhdGVcbiAqIG9iamVjdC5cbiAqIEBoaWRkZW5cbiAqL1xuZnVuY3Rpb24gbXNkb3MyZGF0ZSh0aW1lOiBudW1iZXIsIGRhdGU6IG51bWJlcik6IERhdGUge1xuICAvLyBNUy1ET1MgRGF0ZVxuICAvLyB8MCAwIDAgMCAgMHwwIDAgMCAgMHwwIDAgMCAgMCAwIDAgMFxuICAvLyAgIEQgKDEtMzEpICBNICgxLTIzKSAgWSAoZnJvbSAxOTgwKVxuICBjb25zdCBkYXkgPSBkYXRlICYgMHgxRjtcbiAgLy8gSlMgZGF0ZSBpcyAwLWluZGV4ZWQsIERPUyBpcyAxLWluZGV4ZWQuXG4gIGNvbnN0IG1vbnRoID0gKChkYXRlID4+IDUpICYgMHhGKSAtIDE7XG4gIGNvbnN0IHllYXIgPSAoZGF0ZSA+PiA5KSArIDE5ODA7XG4gIC8vIE1TIERPUyBUaW1lXG4gIC8vIHwwIDAgMCAwICAwfDAgMCAwICAwIDAgMHwwICAwIDAgMCAwXG4gIC8vICAgIFNlY29uZCAgICAgIE1pbnV0ZSAgICAgICBIb3VyXG4gIGNvbnN0IHNlY29uZCA9IHRpbWUgJiAweDFGO1xuICBjb25zdCBtaW51dGUgPSAodGltZSA+PiA1KSAmIDB4M0Y7XG4gIGNvbnN0IGhvdXIgPSB0aW1lID4+IDExO1xuICByZXR1cm4gbmV3IERhdGUoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQpO1xufVxuXG4vKipcbiAqIFNhZmVseSByZXR1cm5zIHRoZSBzdHJpbmcgZnJvbSB0aGUgYnVmZmVyLCBldmVuIGlmIGl0IGlzIDAgYnl0ZXMgbG9uZy5cbiAqIChOb3JtYWxseSwgY2FsbGluZyB0b1N0cmluZygpIG9uIGEgYnVmZmVyIHdpdGggc3RhcnQgPT09IGVuZCBjYXVzZXMgYW5cbiAqIGV4Y2VwdGlvbikuXG4gKiBAaGlkZGVuXG4gKi9cbmZ1bmN0aW9uIHNhZmVUb1N0cmluZyhidWZmOiBCdWZmZXIsIHVzZVVURjg6IGJvb2xlYW4sIHN0YXJ0OiBudW1iZXIsIGxlbmd0aDogbnVtYmVyKTogc3RyaW5nIHtcbiAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBcIlwiO1xuICB9IGVsc2UgaWYgKHVzZVVURjgpIHtcbiAgICByZXR1cm4gYnVmZi50b1N0cmluZygndXRmOCcsIHN0YXJ0LCBzdGFydCArIGxlbmd0aCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIEV4dGVuZGVkQVNDSUkuYnl0ZTJzdHIoYnVmZi5zbGljZShzdGFydCwgc3RhcnQgKyBsZW5ndGgpKTtcbiAgfVxufVxuXG4vKlxuICAgNC4zLjYgT3ZlcmFsbCAuWklQIGZpbGUgZm9ybWF0OlxuXG4gICAgICBbbG9jYWwgZmlsZSBoZWFkZXIgMV1cbiAgICAgIFtlbmNyeXB0aW9uIGhlYWRlciAxXVxuICAgICAgW2ZpbGUgZGF0YSAxXVxuICAgICAgW2RhdGEgZGVzY3JpcHRvciAxXVxuICAgICAgLlxuICAgICAgLlxuICAgICAgLlxuICAgICAgW2xvY2FsIGZpbGUgaGVhZGVyIG5dXG4gICAgICBbZW5jcnlwdGlvbiBoZWFkZXIgbl1cbiAgICAgIFtmaWxlIGRhdGEgbl1cbiAgICAgIFtkYXRhIGRlc2NyaXB0b3Igbl1cbiAgICAgIFthcmNoaXZlIGRlY3J5cHRpb24gaGVhZGVyXVxuICAgICAgW2FyY2hpdmUgZXh0cmEgZGF0YSByZWNvcmRdXG4gICAgICBbY2VudHJhbCBkaXJlY3RvcnkgaGVhZGVyIDFdXG4gICAgICAuXG4gICAgICAuXG4gICAgICAuXG4gICAgICBbY2VudHJhbCBkaXJlY3RvcnkgaGVhZGVyIG5dXG4gICAgICBbemlwNjQgZW5kIG9mIGNlbnRyYWwgZGlyZWN0b3J5IHJlY29yZF1cbiAgICAgIFt6aXA2NCBlbmQgb2YgY2VudHJhbCBkaXJlY3RvcnkgbG9jYXRvcl1cbiAgICAgIFtlbmQgb2YgY2VudHJhbCBkaXJlY3RvcnkgcmVjb3JkXVxuKi9cblxuLyoqXG4gKiA0LjMuNyAgTG9jYWwgZmlsZSBoZWFkZXI6XG4gKlxuICogICAgIGxvY2FsIGZpbGUgaGVhZGVyIHNpZ25hdHVyZSAgICAgNCBieXRlcyAgKDB4MDQwMzRiNTApXG4gKiAgICAgdmVyc2lvbiBuZWVkZWQgdG8gZXh0cmFjdCAgICAgICAyIGJ5dGVzXG4gKiAgICAgZ2VuZXJhbCBwdXJwb3NlIGJpdCBmbGFnICAgICAgICAyIGJ5dGVzXG4gKiAgICAgY29tcHJlc3Npb24gbWV0aG9kICAgICAgICAgICAgICAyIGJ5dGVzXG4gKiAgICBsYXN0IG1vZCBmaWxlIHRpbWUgICAgICAgICAgICAgIDIgYnl0ZXNcbiAqICAgIGxhc3QgbW9kIGZpbGUgZGF0ZSAgICAgICAgICAgICAgMiBieXRlc1xuICogICAgY3JjLTMyICAgICAgICAgICAgICAgICAgICAgICAgICA0IGJ5dGVzXG4gKiAgICBjb21wcmVzc2VkIHNpemUgICAgICAgICAgICAgICAgIDQgYnl0ZXNcbiAqICAgIHVuY29tcHJlc3NlZCBzaXplICAgICAgICAgICAgICAgNCBieXRlc1xuICogICAgZmlsZSBuYW1lIGxlbmd0aCAgICAgICAgICAgICAgICAyIGJ5dGVzXG4gKiAgICBleHRyYSBmaWVsZCBsZW5ndGggICAgICAgICAgICAgIDIgYnl0ZXNcbiAqXG4gKiAgICBmaWxlIG5hbWUgKHZhcmlhYmxlIHNpemUpXG4gKiAgICBleHRyYSBmaWVsZCAodmFyaWFibGUgc2l6ZSlcbiAqL1xuZXhwb3J0IGNsYXNzIEZpbGVIZWFkZXIge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGRhdGE6IEJ1ZmZlcikge1xuICAgIGlmIChkYXRhLnJlYWRVSW50MzJMRSgwKSAhPT0gMHgwNDAzNGI1MCkge1xuICAgICAgdGhyb3cgbmV3IEFwaUVycm9yKEVycm9yQ29kZS5FSU5WQUwsIFwiSW52YWxpZCBaaXAgZmlsZTogTG9jYWwgZmlsZSBoZWFkZXIgaGFzIGludmFsaWQgc2lnbmF0dXJlOiBcIiArIHRoaXMuZGF0YS5yZWFkVUludDMyTEUoMCkpO1xuICAgIH1cbiAgfVxuICBwdWJsaWMgdmVyc2lvbk5lZWRlZCgpOiBudW1iZXIgeyByZXR1cm4gdGhpcy5kYXRhLnJlYWRVSW50MTZMRSg0KTsgfVxuICBwdWJsaWMgZmxhZ3MoKTogbnVtYmVyIHsgcmV0dXJuIHRoaXMuZGF0YS5yZWFkVUludDE2TEUoNik7IH1cbiAgcHVibGljIGNvbXByZXNzaW9uTWV0aG9kKCk6IENvbXByZXNzaW9uTWV0aG9kIHsgcmV0dXJuIHRoaXMuZGF0YS5yZWFkVUludDE2TEUoOCk7IH1cbiAgcHVibGljIGxhc3RNb2RGaWxlVGltZSgpOiBEYXRlIHtcbiAgICAvLyBUaW1lIGFuZCBkYXRlIGlzIGluIE1TLURPUyBmb3JtYXQuXG4gICAgcmV0dXJuIG1zZG9zMmRhdGUodGhpcy5kYXRhLnJlYWRVSW50MTZMRSgxMCksIHRoaXMuZGF0YS5yZWFkVUludDE2TEUoMTIpKTtcbiAgfVxuICBwdWJsaWMgcmF3TGFzdE1vZEZpbGVUaW1lKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5yZWFkVUludDMyTEUoMTApO1xuICB9XG4gIHB1YmxpYyBjcmMzMigpOiBudW1iZXIgeyByZXR1cm4gdGhpcy5kYXRhLnJlYWRVSW50MzJMRSgxNCk7IH1cbiAgLyoqXG4gICAqIFRoZXNlIHR3byB2YWx1ZXMgYXJlIENPTVBMRVRFTFkgVVNFTEVTUy5cbiAgICpcbiAgICogU2VjdGlvbiA0LjQuOTpcbiAgICogICBJZiBiaXQgMyBvZiB0aGUgZ2VuZXJhbCBwdXJwb3NlIGJpdCBmbGFnIGlzIHNldCxcbiAgICogICB0aGVzZSBmaWVsZHMgYXJlIHNldCB0byB6ZXJvIGluIHRoZSBsb2NhbCBoZWFkZXIgYW5kIHRoZVxuICAgKiAgIGNvcnJlY3QgdmFsdWVzIGFyZSBwdXQgaW4gdGhlIGRhdGEgZGVzY3JpcHRvciBhbmRcbiAgICogICBpbiB0aGUgY2VudHJhbCBkaXJlY3RvcnkuXG4gICAqXG4gICAqIFNvIHdlJ2xsIGp1c3QgdXNlIHRoZSBjZW50cmFsIGRpcmVjdG9yeSdzIHZhbHVlcy5cbiAgICovXG4gIC8vIHB1YmxpYyBjb21wcmVzc2VkU2l6ZSgpOiBudW1iZXIgeyByZXR1cm4gdGhpcy5kYXRhLnJlYWRVSW50MzJMRSgxOCk7IH1cbiAgLy8gcHVibGljIHVuY29tcHJlc3NlZFNpemUoKTogbnVtYmVyIHsgcmV0dXJuIHRoaXMuZGF0YS5yZWFkVUludDMyTEUoMjIpOyB9XG4gIHB1YmxpYyBmaWxlTmFtZUxlbmd0aCgpOiBudW1iZXIgeyByZXR1cm4gdGhpcy5kYXRhLnJlYWRVSW50MTZMRSgyNik7IH1cbiAgcHVibGljIGV4dHJhRmllbGRMZW5ndGgoKTogbnVtYmVyIHsgcmV0dXJuIHRoaXMuZGF0YS5yZWFkVUludDE2TEUoMjgpOyB9XG4gIHB1YmxpYyBmaWxlTmFtZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiBzYWZlVG9TdHJpbmcodGhpcy5kYXRhLCB0aGlzLnVzZVVURjgoKSwgMzAsIHRoaXMuZmlsZU5hbWVMZW5ndGgoKSk7XG4gIH1cbiAgcHVibGljIGV4dHJhRmllbGQoKTogQnVmZmVyIHtcbiAgICBjb25zdCBzdGFydCA9IDMwICsgdGhpcy5maWxlTmFtZUxlbmd0aCgpO1xuICAgIHJldHVybiB0aGlzLmRhdGEuc2xpY2Uoc3RhcnQsIHN0YXJ0ICsgdGhpcy5leHRyYUZpZWxkTGVuZ3RoKCkpO1xuICB9XG4gIHB1YmxpYyB0b3RhbFNpemUoKTogbnVtYmVyIHsgcmV0dXJuIDMwICsgdGhpcy5maWxlTmFtZUxlbmd0aCgpICsgdGhpcy5leHRyYUZpZWxkTGVuZ3RoKCk7IH1cbiAgcHVibGljIHVzZVVURjgoKTogYm9vbGVhbiB7IHJldHVybiAodGhpcy5mbGFncygpICYgMHg4MDApID09PSAweDgwMDsgfVxufVxuXG4vKipcbiAqIDQuMy44ICBGaWxlIGRhdGFcbiAqXG4gKiAgIEltbWVkaWF0ZWx5IGZvbGxvd2luZyB0aGUgbG9jYWwgaGVhZGVyIGZvciBhIGZpbGVcbiAqICAgU0hPVUxEIGJlIHBsYWNlZCB0aGUgY29tcHJlc3NlZCBvciBzdG9yZWQgZGF0YSBmb3IgdGhlIGZpbGUuXG4gKiAgIElmIHRoZSBmaWxlIGlzIGVuY3J5cHRlZCwgdGhlIGVuY3J5cHRpb24gaGVhZGVyIGZvciB0aGUgZmlsZVxuICogICBTSE9VTEQgYmUgcGxhY2VkIGFmdGVyIHRoZSBsb2NhbCBoZWFkZXIgYW5kIGJlZm9yZSB0aGUgZmlsZVxuICogICBkYXRhLiBUaGUgc2VyaWVzIG9mIFtsb2NhbCBmaWxlIGhlYWRlcl1bZW5jcnlwdGlvbiBoZWFkZXJdXG4gKiAgIFtmaWxlIGRhdGFdW2RhdGEgZGVzY3JpcHRvcl0gcmVwZWF0cyBmb3IgZWFjaCBmaWxlIGluIHRoZVxuICogICAuWklQIGFyY2hpdmUuXG4gKlxuICogICBaZXJvLWJ5dGUgZmlsZXMsIGRpcmVjdG9yaWVzLCBhbmQgb3RoZXIgZmlsZSB0eXBlcyB0aGF0XG4gKiAgIGNvbnRhaW4gbm8gY29udGVudCBNVVNUIG5vdCBpbmNsdWRlIGZpbGUgZGF0YS5cbiAqL1xuZXhwb3J0IGNsYXNzIEZpbGVEYXRhIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBoZWFkZXI6IEZpbGVIZWFkZXIsIHByaXZhdGUgcmVjb3JkOiBDZW50cmFsRGlyZWN0b3J5LCBwcml2YXRlIGRhdGE6IEJ1ZmZlcikge31cbiAgcHVibGljIGRlY29tcHJlc3MoKTogQnVmZmVyIHtcbiAgICAvLyBDaGVjayB0aGUgY29tcHJlc3Npb25cbiAgICBjb25zdCBjb21wcmVzc2lvbk1ldGhvZDogQ29tcHJlc3Npb25NZXRob2QgPSB0aGlzLmhlYWRlci5jb21wcmVzc2lvbk1ldGhvZCgpO1xuICAgIGNvbnN0IGZjbiA9IGRlY29tcHJlc3Npb25NZXRob2RzW2NvbXByZXNzaW9uTWV0aG9kXTtcbiAgICBpZiAoZmNuKSB7XG4gICAgICByZXR1cm4gZmNuKHRoaXMuZGF0YSwgdGhpcy5yZWNvcmQuY29tcHJlc3NlZFNpemUoKSwgdGhpcy5yZWNvcmQudW5jb21wcmVzc2VkU2l6ZSgpLCB0aGlzLnJlY29yZC5mbGFnKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgbmFtZTogc3RyaW5nID0gQ29tcHJlc3Npb25NZXRob2RbY29tcHJlc3Npb25NZXRob2RdO1xuICAgICAgaWYgKCFuYW1lKSB7XG4gICAgICAgIG5hbWUgPSBgVW5rbm93bjogJHtjb21wcmVzc2lvbk1ldGhvZH1gO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEFwaUVycm9yKEVycm9yQ29kZS5FSU5WQUwsIGBJbnZhbGlkIGNvbXByZXNzaW9uIG1ldGhvZCBvbiBmaWxlICcke3RoaXMuaGVhZGVyLmZpbGVOYW1lKCl9JzogJHtuYW1lfWApO1xuICAgIH1cbiAgfVxuICBwdWJsaWMgZ2V0SGVhZGVyKCk6IEZpbGVIZWFkZXIge1xuICAgIHJldHVybiB0aGlzLmhlYWRlcjtcbiAgfVxuICBwdWJsaWMgZ2V0UmVjb3JkKCk6IENlbnRyYWxEaXJlY3Rvcnkge1xuICAgIHJldHVybiB0aGlzLnJlY29yZDtcbiAgfVxuICBwdWJsaWMgZ2V0UmF3RGF0YSgpOiBCdWZmZXIge1xuICAgIHJldHVybiB0aGlzLmRhdGE7XG4gIH1cbn1cblxuLyoqXG4gKiA0LjMuOSAgRGF0YSBkZXNjcmlwdG9yOlxuICpcbiAqICAgIGNyYy0zMiAgICAgICAgICAgICAgICAgICAgICAgICAgNCBieXRlc1xuICogICAgY29tcHJlc3NlZCBzaXplICAgICAgICAgICAgICAgICA0IGJ5dGVzXG4gKiAgICB1bmNvbXByZXNzZWQgc2l6ZSAgICAgICAgICAgICAgIDQgYnl0ZXNcbiAqL1xuZXhwb3J0IGNsYXNzIERhdGFEZXNjcmlwdG9yIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBkYXRhOiBCdWZmZXIpIHt9XG4gIHB1YmxpYyBjcmMzMigpOiBudW1iZXIgeyByZXR1cm4gdGhpcy5kYXRhLnJlYWRVSW50MzJMRSgwKTsgfVxuICBwdWJsaWMgY29tcHJlc3NlZFNpemUoKTogbnVtYmVyIHsgcmV0dXJuIHRoaXMuZGF0YS5yZWFkVUludDMyTEUoNCk7IH1cbiAgcHVibGljIHVuY29tcHJlc3NlZFNpemUoKTogbnVtYmVyIHsgcmV0dXJuIHRoaXMuZGF0YS5yZWFkVUludDMyTEUoOCk7IH1cbn1cblxuLypcbmAgNC4zLjEwICBBcmNoaXZlIGRlY3J5cHRpb24gaGVhZGVyOlxuXG4gICAgICA0LjMuMTAuMSBUaGUgQXJjaGl2ZSBEZWNyeXB0aW9uIEhlYWRlciBpcyBpbnRyb2R1Y2VkIGluIHZlcnNpb24gNi4yXG4gICAgICBvZiB0aGUgWklQIGZvcm1hdCBzcGVjaWZpY2F0aW9uLiAgVGhpcyByZWNvcmQgZXhpc3RzIGluIHN1cHBvcnRcbiAgICAgIG9mIHRoZSBDZW50cmFsIERpcmVjdG9yeSBFbmNyeXB0aW9uIEZlYXR1cmUgaW1wbGVtZW50ZWQgYXMgcGFydCBvZlxuICAgICAgdGhlIFN0cm9uZyBFbmNyeXB0aW9uIFNwZWNpZmljYXRpb24gYXMgZGVzY3JpYmVkIGluIHRoaXMgZG9jdW1lbnQuXG4gICAgICBXaGVuIHRoZSBDZW50cmFsIERpcmVjdG9yeSBTdHJ1Y3R1cmUgaXMgZW5jcnlwdGVkLCB0aGlzIGRlY3J5cHRpb25cbiAgICAgIGhlYWRlciBNVVNUIHByZWNlZGUgdGhlIGVuY3J5cHRlZCBkYXRhIHNlZ21lbnQuXG4gKi9cbi8qKlxuICogNC4zLjExICBBcmNoaXZlIGV4dHJhIGRhdGEgcmVjb3JkOlxuICpcbiAqICAgICAgYXJjaGl2ZSBleHRyYSBkYXRhIHNpZ25hdHVyZSAgICA0IGJ5dGVzICAoMHgwODA2NGI1MClcbiAqICAgICAgZXh0cmEgZmllbGQgbGVuZ3RoICAgICAgICAgICAgICA0IGJ5dGVzXG4gKiAgICAgIGV4dHJhIGZpZWxkIGRhdGEgICAgICAgICAgICAgICAgKHZhcmlhYmxlIHNpemUpXG4gKlxuICogICAgNC4zLjExLjEgVGhlIEFyY2hpdmUgRXh0cmEgRGF0YSBSZWNvcmQgaXMgaW50cm9kdWNlZCBpbiB2ZXJzaW9uIDYuMlxuICogICAgb2YgdGhlIFpJUCBmb3JtYXQgc3BlY2lmaWNhdGlvbi4gIFRoaXMgcmVjb3JkIE1BWSBiZSB1c2VkIGluIHN1cHBvcnRcbiAqICAgIG9mIHRoZSBDZW50cmFsIERpcmVjdG9yeSBFbmNyeXB0aW9uIEZlYXR1cmUgaW1wbGVtZW50ZWQgYXMgcGFydCBvZlxuICogICAgdGhlIFN0cm9uZyBFbmNyeXB0aW9uIFNwZWNpZmljYXRpb24gYXMgZGVzY3JpYmVkIGluIHRoaXMgZG9jdW1lbnQuXG4gKiAgICBXaGVuIHByZXNlbnQsIHRoaXMgcmVjb3JkIE1VU1QgaW1tZWRpYXRlbHkgcHJlY2VkZSB0aGUgY2VudHJhbFxuICogICAgZGlyZWN0b3J5IGRhdGEgc3RydWN0dXJlLlxuICovXG5leHBvcnQgY2xhc3MgQXJjaGl2ZUV4dHJhRGF0YVJlY29yZCB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgZGF0YTogQnVmZmVyKSB7XG4gICAgaWYgKHRoaXMuZGF0YS5yZWFkVUludDMyTEUoMCkgIT09IDB4MDgwNjRiNTApIHtcbiAgICAgIHRocm93IG5ldyBBcGlFcnJvcihFcnJvckNvZGUuRUlOVkFMLCBcIkludmFsaWQgYXJjaGl2ZSBleHRyYSBkYXRhIHJlY29yZCBzaWduYXR1cmU6IFwiICsgdGhpcy5kYXRhLnJlYWRVSW50MzJMRSgwKSk7XG4gICAgfVxuICB9XG4gIHB1YmxpYyBsZW5ndGgoKTogbnVtYmVyIHsgcmV0dXJuIHRoaXMuZGF0YS5yZWFkVUludDMyTEUoNCk7IH1cbiAgcHVibGljIGV4dHJhRmllbGREYXRhKCk6IEJ1ZmZlciB7IHJldHVybiB0aGlzLmRhdGEuc2xpY2UoOCwgOCArIHRoaXMubGVuZ3RoKCkpOyB9XG59XG5cbi8qKlxuICogNC4zLjEzIERpZ2l0YWwgc2lnbmF0dXJlOlxuICpcbiAqICAgICAgaGVhZGVyIHNpZ25hdHVyZSAgICAgICAgICAgICAgICA0IGJ5dGVzICAoMHgwNTA1NGI1MClcbiAqICAgICAgc2l6ZSBvZiBkYXRhICAgICAgICAgICAgICAgICAgICAyIGJ5dGVzXG4gKiAgICAgIHNpZ25hdHVyZSBkYXRhICh2YXJpYWJsZSBzaXplKVxuICpcbiAqICAgIFdpdGggdGhlIGludHJvZHVjdGlvbiBvZiB0aGUgQ2VudHJhbCBEaXJlY3RvcnkgRW5jcnlwdGlvblxuICogICAgZmVhdHVyZSBpbiB2ZXJzaW9uIDYuMiBvZiB0aGlzIHNwZWNpZmljYXRpb24sIHRoZSBDZW50cmFsXG4gKiAgICBEaXJlY3RvcnkgU3RydWN0dXJlIE1BWSBiZSBzdG9yZWQgYm90aCBjb21wcmVzc2VkIGFuZCBlbmNyeXB0ZWQuXG4gKiAgICBBbHRob3VnaCBub3QgcmVxdWlyZWQsIGl0IGlzIGFzc3VtZWQgd2hlbiBlbmNyeXB0aW5nIHRoZVxuICogICAgQ2VudHJhbCBEaXJlY3RvcnkgU3RydWN0dXJlLCB0aGF0IGl0IHdpbGwgYmUgY29tcHJlc3NlZFxuICogICAgZm9yIGdyZWF0ZXIgc3RvcmFnZSBlZmZpY2llbmN5LiAgSW5mb3JtYXRpb24gb24gdGhlXG4gKiAgICBDZW50cmFsIERpcmVjdG9yeSBFbmNyeXB0aW9uIGZlYXR1cmUgY2FuIGJlIGZvdW5kIGluIHRoZSBzZWN0aW9uXG4gKiAgICBkZXNjcmliaW5nIHRoZSBTdHJvbmcgRW5jcnlwdGlvbiBTcGVjaWZpY2F0aW9uLiBUaGUgRGlnaXRhbFxuICogICAgU2lnbmF0dXJlIHJlY29yZCB3aWxsIGJlIG5laXRoZXIgY29tcHJlc3NlZCBub3IgZW5jcnlwdGVkLlxuICovXG5leHBvcnQgY2xhc3MgRGlnaXRhbFNpZ25hdHVyZSB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgZGF0YTogQnVmZmVyKSB7XG4gICAgaWYgKHRoaXMuZGF0YS5yZWFkVUludDMyTEUoMCkgIT09IDB4MDUwNTRiNTApIHtcbiAgICAgIHRocm93IG5ldyBBcGlFcnJvcihFcnJvckNvZGUuRUlOVkFMLCBcIkludmFsaWQgZGlnaXRhbCBzaWduYXR1cmUgc2lnbmF0dXJlOiBcIiArIHRoaXMuZGF0YS5yZWFkVUludDMyTEUoMCkpO1xuICAgIH1cbiAgfVxuICBwdWJsaWMgc2l6ZSgpOiBudW1iZXIgeyByZXR1cm4gdGhpcy5kYXRhLnJlYWRVSW50MTZMRSg0KTsgfVxuICBwdWJsaWMgc2lnbmF0dXJlRGF0YSgpOiBCdWZmZXIgeyByZXR1cm4gdGhpcy5kYXRhLnNsaWNlKDYsIDYgKyB0aGlzLnNpemUoKSk7IH1cbn1cblxuLyoqXG4gKiA0LjMuMTIgIENlbnRyYWwgZGlyZWN0b3J5IHN0cnVjdHVyZTpcbiAqXG4gKiAgY2VudHJhbCBmaWxlIGhlYWRlciBzaWduYXR1cmUgICA0IGJ5dGVzICAoMHgwMjAxNGI1MClcbiAqICB2ZXJzaW9uIG1hZGUgYnkgICAgICAgICAgICAgICAgIDIgYnl0ZXNcbiAqICB2ZXJzaW9uIG5lZWRlZCB0byBleHRyYWN0ICAgICAgIDIgYnl0ZXNcbiAqICBnZW5lcmFsIHB1cnBvc2UgYml0IGZsYWcgICAgICAgIDIgYnl0ZXNcbiAqICBjb21wcmVzc2lvbiBtZXRob2QgICAgICAgICAgICAgIDIgYnl0ZXNcbiAqICBsYXN0IG1vZCBmaWxlIHRpbWUgICAgICAgICAgICAgIDIgYnl0ZXNcbiAqICBsYXN0IG1vZCBmaWxlIGRhdGUgICAgICAgICAgICAgIDIgYnl0ZXNcbiAqICBjcmMtMzIgICAgICAgICAgICAgICAgICAgICAgICAgIDQgYnl0ZXNcbiAqICBjb21wcmVzc2VkIHNpemUgICAgICAgICAgICAgICAgIDQgYnl0ZXNcbiAqICB1bmNvbXByZXNzZWQgc2l6ZSAgICAgICAgICAgICAgIDQgYnl0ZXNcbiAqICBmaWxlIG5hbWUgbGVuZ3RoICAgICAgICAgICAgICAgIDIgYnl0ZXNcbiAqICBleHRyYSBmaWVsZCBsZW5ndGggICAgICAgICAgICAgIDIgYnl0ZXNcbiAqICBmaWxlIGNvbW1lbnQgbGVuZ3RoICAgICAgICAgICAgIDIgYnl0ZXNcbiAqICBkaXNrIG51bWJlciBzdGFydCAgICAgICAgICAgICAgIDIgYnl0ZXNcbiAqICBpbnRlcm5hbCBmaWxlIGF0dHJpYnV0ZXMgICAgICAgIDIgYnl0ZXNcbiAqICBleHRlcm5hbCBmaWxlIGF0dHJpYnV0ZXMgICAgICAgIDQgYnl0ZXNcbiAqICByZWxhdGl2ZSBvZmZzZXQgb2YgbG9jYWwgaGVhZGVyIDQgYnl0ZXNcbiAqXG4gKiAgZmlsZSBuYW1lICh2YXJpYWJsZSBzaXplKVxuICogIGV4dHJhIGZpZWxkICh2YXJpYWJsZSBzaXplKVxuICogIGZpbGUgY29tbWVudCAodmFyaWFibGUgc2l6ZSlcbiAqL1xuZXhwb3J0IGNsYXNzIENlbnRyYWxEaXJlY3Rvcnkge1xuICAvLyBPcHRpbWl6YXRpb246IFRoZSBmaWxlbmFtZSBpcyBmcmVxdWVudGx5IHJlYWQsIHNvIHN0YXNoIGl0IGhlcmUuXG4gIHByaXZhdGUgX2ZpbGVuYW1lOiBzdHJpbmc7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgemlwRGF0YTogQnVmZmVyLCBwcml2YXRlIGRhdGE6IEJ1ZmZlcikge1xuICAgIC8vIFNhbml0eSBjaGVjay5cbiAgICBpZiAodGhpcy5kYXRhLnJlYWRVSW50MzJMRSgwKSAhPT0gMHgwMjAxNGI1MCkge1xuICAgICAgdGhyb3cgbmV3IEFwaUVycm9yKEVycm9yQ29kZS5FSU5WQUwsIGBJbnZhbGlkIFppcCBmaWxlOiBDZW50cmFsIGRpcmVjdG9yeSByZWNvcmQgaGFzIGludmFsaWQgc2lnbmF0dXJlOiAke3RoaXMuZGF0YS5yZWFkVUludDMyTEUoMCl9YCk7XG4gICAgfVxuICAgIHRoaXMuX2ZpbGVuYW1lID0gdGhpcy5wcm9kdWNlRmlsZW5hbWUoKTtcbiAgfVxuICBwdWJsaWMgdmVyc2lvbk1hZGVCeSgpOiBudW1iZXIgeyByZXR1cm4gdGhpcy5kYXRhLnJlYWRVSW50MTZMRSg0KTsgfVxuICBwdWJsaWMgdmVyc2lvbk5lZWRlZCgpOiBudW1iZXIgeyByZXR1cm4gdGhpcy5kYXRhLnJlYWRVSW50MTZMRSg2KTsgfVxuICBwdWJsaWMgZmxhZygpOiBudW1iZXIgeyByZXR1cm4gdGhpcy5kYXRhLnJlYWRVSW50MTZMRSg4KTsgfVxuICBwdWJsaWMgY29tcHJlc3Npb25NZXRob2QoKTogQ29tcHJlc3Npb25NZXRob2QgeyByZXR1cm4gdGhpcy5kYXRhLnJlYWRVSW50MTZMRSgxMCk7IH1cbiAgcHVibGljIGxhc3RNb2RGaWxlVGltZSgpOiBEYXRlIHtcbiAgICAvLyBUaW1lIGFuZCBkYXRlIGlzIGluIE1TLURPUyBmb3JtYXQuXG4gICAgcmV0dXJuIG1zZG9zMmRhdGUodGhpcy5kYXRhLnJlYWRVSW50MTZMRSgxMiksIHRoaXMuZGF0YS5yZWFkVUludDE2TEUoMTQpKTtcbiAgfVxuICBwdWJsaWMgcmF3TGFzdE1vZEZpbGVUaW1lKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5yZWFkVUludDMyTEUoMTIpO1xuICB9XG4gIHB1YmxpYyBjcmMzMigpOiBudW1iZXIgeyByZXR1cm4gdGhpcy5kYXRhLnJlYWRVSW50MzJMRSgxNik7IH1cbiAgcHVibGljIGNvbXByZXNzZWRTaXplKCk6IG51bWJlciB7IHJldHVybiB0aGlzLmRhdGEucmVhZFVJbnQzMkxFKDIwKTsgfVxuICBwdWJsaWMgdW5jb21wcmVzc2VkU2l6ZSgpOiBudW1iZXIgeyByZXR1cm4gdGhpcy5kYXRhLnJlYWRVSW50MzJMRSgyNCk7IH1cbiAgcHVibGljIGZpbGVOYW1lTGVuZ3RoKCk6IG51bWJlciB7IHJldHVybiB0aGlzLmRhdGEucmVhZFVJbnQxNkxFKDI4KTsgfVxuICBwdWJsaWMgZXh0cmFGaWVsZExlbmd0aCgpOiBudW1iZXIgeyByZXR1cm4gdGhpcy5kYXRhLnJlYWRVSW50MTZMRSgzMCk7IH1cbiAgcHVibGljIGZpbGVDb21tZW50TGVuZ3RoKCk6IG51bWJlciB7IHJldHVybiB0aGlzLmRhdGEucmVhZFVJbnQxNkxFKDMyKTsgfVxuICBwdWJsaWMgZGlza051bWJlclN0YXJ0KCk6IG51bWJlciB7IHJldHVybiB0aGlzLmRhdGEucmVhZFVJbnQxNkxFKDM0KTsgfVxuICBwdWJsaWMgaW50ZXJuYWxBdHRyaWJ1dGVzKCk6IG51bWJlciB7IHJldHVybiB0aGlzLmRhdGEucmVhZFVJbnQxNkxFKDM2KTsgfVxuICBwdWJsaWMgZXh0ZXJuYWxBdHRyaWJ1dGVzKCk6IG51bWJlciB7IHJldHVybiB0aGlzLmRhdGEucmVhZFVJbnQzMkxFKDM4KTsgfVxuICBwdWJsaWMgaGVhZGVyUmVsYXRpdmVPZmZzZXQoKTogbnVtYmVyIHsgcmV0dXJuIHRoaXMuZGF0YS5yZWFkVUludDMyTEUoNDIpOyB9XG4gIHB1YmxpYyBwcm9kdWNlRmlsZW5hbWUoKTogc3RyaW5nIHtcbiAgICAvKlxuICAgICAgNC40LjE3LjEgY2xhaW1zOlxuICAgICAgKiBBbGwgc2xhc2hlcyBhcmUgZm9yd2FyZCAoJy8nKSBzbGFzaGVzLlxuICAgICAgKiBGaWxlbmFtZSBkb2Vzbid0IGJlZ2luIHdpdGggYSBzbGFzaC5cbiAgICAgICogTm8gZHJpdmUgbGV0dGVycyBvciBhbnkgbm9uc2Vuc2UgbGlrZSB0aGF0LlxuICAgICAgKiBJZiBmaWxlbmFtZSBpcyBtaXNzaW5nLCB0aGUgaW5wdXQgY2FtZSBmcm9tIHN0YW5kYXJkIGlucHV0LlxuXG4gICAgICBVbmZvcnR1bmF0ZWx5LCB0aGlzIGlzbid0IHRydWUgaW4gcHJhY3RpY2UuIFNvbWUgV2luZG93cyB6aXAgdXRpbGl0aWVzIHVzZVxuICAgICAgYSBiYWNrc2xhc2ggaGVyZSwgYnV0IHRoZSBjb3JyZWN0IFVuaXgtc3R5bGUgcGF0aCBpbiBmaWxlIGhlYWRlcnMuXG5cbiAgICAgIFRvIGF2b2lkIHNlZWtpbmcgYWxsIG92ZXIgdGhlIGZpbGUgdG8gcmVjb3ZlciB0aGUga25vd24tZ29vZCBmaWxlbmFtZXNcbiAgICAgIGZyb20gZmlsZSBoZWFkZXJzLCB3ZSBzaW1wbHkgY29udmVydCAnLycgdG8gJ1xcJyBoZXJlLlxuICAgICovXG4gICAgY29uc3QgZmlsZU5hbWU6IHN0cmluZyA9IHNhZmVUb1N0cmluZyh0aGlzLmRhdGEsIHRoaXMudXNlVVRGOCgpLCA0NiwgdGhpcy5maWxlTmFtZUxlbmd0aCgpKTtcbiAgICByZXR1cm4gZmlsZU5hbWUucmVwbGFjZSgvXFxcXC9nLCBcIi9cIik7XG4gIH1cbiAgcHVibGljIGZpbGVOYW1lKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbGVuYW1lO1xuICB9XG4gIHB1YmxpYyByYXdGaWxlTmFtZSgpOiBCdWZmZXIge1xuICAgIHJldHVybiB0aGlzLmRhdGEuc2xpY2UoNDYsIDQ2ICsgdGhpcy5maWxlTmFtZUxlbmd0aCgpKTtcbiAgfVxuICBwdWJsaWMgZXh0cmFGaWVsZCgpOiBCdWZmZXIge1xuICAgIGNvbnN0IHN0YXJ0ID0gNDQgKyB0aGlzLmZpbGVOYW1lTGVuZ3RoKCk7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5zbGljZShzdGFydCwgc3RhcnQgKyB0aGlzLmV4dHJhRmllbGRMZW5ndGgoKSk7XG4gIH1cbiAgcHVibGljIGZpbGVDb21tZW50KCk6IHN0cmluZyB7XG4gICAgY29uc3Qgc3RhcnQgPSA0NiArIHRoaXMuZmlsZU5hbWVMZW5ndGgoKSArIHRoaXMuZXh0cmFGaWVsZExlbmd0aCgpO1xuICAgIHJldHVybiBzYWZlVG9TdHJpbmcodGhpcy5kYXRhLCB0aGlzLnVzZVVURjgoKSwgc3RhcnQsIHRoaXMuZmlsZUNvbW1lbnRMZW5ndGgoKSk7XG4gIH1cbiAgcHVibGljIHJhd0ZpbGVDb21tZW50KCk6IEJ1ZmZlciB7XG4gICAgY29uc3Qgc3RhcnQgPSA0NiArIHRoaXMuZmlsZU5hbWVMZW5ndGgoKSArIHRoaXMuZXh0cmFGaWVsZExlbmd0aCgpO1xuICAgIHJldHVybiB0aGlzLmRhdGEuc2xpY2Uoc3RhcnQsIHN0YXJ0ICsgdGhpcy5maWxlQ29tbWVudExlbmd0aCgpKTtcbiAgfVxuICBwdWJsaWMgdG90YWxTaXplKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIDQ2ICsgdGhpcy5maWxlTmFtZUxlbmd0aCgpICsgdGhpcy5leHRyYUZpZWxkTGVuZ3RoKCkgKyB0aGlzLmZpbGVDb21tZW50TGVuZ3RoKCk7XG4gIH1cbiAgcHVibGljIGlzRGlyZWN0b3J5KCk6IGJvb2xlYW4ge1xuICAgIC8vIE5PVEU6IFRoaXMgYXNzdW1lcyB0aGF0IHRoZSB6aXAgZmlsZSBpbXBsZW1lbnRhdGlvbiB1c2VzIHRoZSBsb3dlciBieXRlXG4gICAgLy8gICAgICAgb2YgZXh0ZXJuYWwgYXR0cmlidXRlcyBmb3IgRE9TIGF0dHJpYnV0ZXMgZm9yXG4gICAgLy8gICAgICAgYmFja3dhcmRzLWNvbXBhdGliaWxpdHkuIFRoaXMgaXMgbm90IG1hbmRhdGVkLCBidXQgYXBwZWFycyB0byBiZVxuICAgIC8vICAgICAgIGNvbW1vbnBsYWNlLlxuICAgIC8vICAgICAgIEFjY29yZGluZyB0byB0aGUgc3BlYywgdGhlIGxheW91dCBvZiBleHRlcm5hbCBhdHRyaWJ1dGVzIGlzXG4gICAgLy8gICAgICAgcGxhdGZvcm0tZGVwZW5kZW50LlxuICAgIC8vICAgICAgIElmIHRoYXQgZmFpbHMsIHdlIGFsc28gY2hlY2sgaWYgdGhlIG5hbWUgb2YgdGhlIGZpbGUgZW5kcyBpbiAnLycsXG4gICAgLy8gICAgICAgd2hpY2ggaXMgd2hhdCBKYXZhJ3MgWmlwRmlsZSBpbXBsZW1lbnRhdGlvbiBkb2VzLlxuICAgIGNvbnN0IGZpbGVOYW1lID0gdGhpcy5maWxlTmFtZSgpO1xuICAgIHJldHVybiAodGhpcy5leHRlcm5hbEF0dHJpYnV0ZXMoKSAmIDB4MTAgPyB0cnVlIDogZmFsc2UpIHx8IChmaWxlTmFtZS5jaGFyQXQoZmlsZU5hbWUubGVuZ3RoIC0gMSkgPT09ICcvJyk7XG4gIH1cbiAgcHVibGljIGlzRmlsZSgpOiBib29sZWFuIHsgcmV0dXJuICF0aGlzLmlzRGlyZWN0b3J5KCk7IH1cbiAgcHVibGljIHVzZVVURjgoKTogYm9vbGVhbiB7IHJldHVybiAodGhpcy5mbGFnKCkgJiAweDgwMCkgPT09IDB4ODAwOyB9XG4gIHB1YmxpYyBpc0VuY3J5cHRlZCgpOiBib29sZWFuIHsgcmV0dXJuICh0aGlzLmZsYWcoKSAmIDB4MSkgPT09IDB4MTsgfVxuICBwdWJsaWMgZ2V0RmlsZURhdGEoKTogRmlsZURhdGEge1xuICAgIC8vIE5lZWQgdG8gZ3JhYiB0aGUgaGVhZGVyIGJlZm9yZSB3ZSBjYW4gZmlndXJlIG91dCB3aGVyZSB0aGUgYWN0dWFsXG4gICAgLy8gY29tcHJlc3NlZCBkYXRhIHN0YXJ0cy5cbiAgICBjb25zdCBzdGFydCA9IHRoaXMuaGVhZGVyUmVsYXRpdmVPZmZzZXQoKTtcbiAgICBjb25zdCBoZWFkZXIgPSBuZXcgRmlsZUhlYWRlcih0aGlzLnppcERhdGEuc2xpY2Uoc3RhcnQpKTtcbiAgICByZXR1cm4gbmV3IEZpbGVEYXRhKGhlYWRlciwgdGhpcywgdGhpcy56aXBEYXRhLnNsaWNlKHN0YXJ0ICsgaGVhZGVyLnRvdGFsU2l6ZSgpKSk7XG4gIH1cbiAgcHVibGljIGdldERhdGEoKTogQnVmZmVyIHtcbiAgICByZXR1cm4gdGhpcy5nZXRGaWxlRGF0YSgpLmRlY29tcHJlc3MoKTtcbiAgfVxuICBwdWJsaWMgZ2V0UmF3RGF0YSgpOiBCdWZmZXIge1xuICAgIHJldHVybiB0aGlzLmdldEZpbGVEYXRhKCkuZ2V0UmF3RGF0YSgpO1xuICB9XG4gIHB1YmxpYyBnZXRTdGF0cygpOiBTdGF0cyB7XG4gICAgcmV0dXJuIG5ldyBTdGF0cyhGaWxlVHlwZS5GSUxFLCB0aGlzLnVuY29tcHJlc3NlZFNpemUoKSwgMHgxNkQsIG5ldyBEYXRlKCksIHRoaXMubGFzdE1vZEZpbGVUaW1lKCkpO1xuICB9XG59XG5cbi8qKlxuICogNC4zLjE2OiBlbmQgb2YgY2VudHJhbCBkaXJlY3RvcnkgcmVjb3JkXG4gKiAgZW5kIG9mIGNlbnRyYWwgZGlyIHNpZ25hdHVyZSAgICA0IGJ5dGVzICAoMHgwNjA1NGI1MClcbiAqICBudW1iZXIgb2YgdGhpcyBkaXNrICAgICAgICAgICAgIDIgYnl0ZXNcbiAqICBudW1iZXIgb2YgdGhlIGRpc2sgd2l0aCB0aGVcbiAqICBzdGFydCBvZiB0aGUgY2VudHJhbCBkaXJlY3RvcnkgIDIgYnl0ZXNcbiAqICB0b3RhbCBudW1iZXIgb2YgZW50cmllcyBpbiB0aGVcbiAqICBjZW50cmFsIGRpcmVjdG9yeSBvbiB0aGlzIGRpc2sgIDIgYnl0ZXNcbiAqICB0b3RhbCBudW1iZXIgb2YgZW50cmllcyBpblxuICogIHRoZSBjZW50cmFsIGRpcmVjdG9yeSAgICAgICAgICAgMiBieXRlc1xuICogIHNpemUgb2YgdGhlIGNlbnRyYWwgZGlyZWN0b3J5ICAgNCBieXRlc1xuICogIG9mZnNldCBvZiBzdGFydCBvZiBjZW50cmFsXG4gKiAgZGlyZWN0b3J5IHdpdGggcmVzcGVjdCB0b1xuICogIHRoZSBzdGFydGluZyBkaXNrIG51bWJlciAgICAgICAgNCBieXRlc1xuICogIC5aSVAgZmlsZSBjb21tZW50IGxlbmd0aCAgICAgICAgMiBieXRlc1xuICogIC5aSVAgZmlsZSBjb21tZW50ICAgICAgICh2YXJpYWJsZSBzaXplKVxuICovXG5leHBvcnQgY2xhc3MgRW5kT2ZDZW50cmFsRGlyZWN0b3J5IHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBkYXRhOiBCdWZmZXIpIHtcbiAgICBpZiAodGhpcy5kYXRhLnJlYWRVSW50MzJMRSgwKSAhPT0gMHgwNjA1NGI1MCkge1xuICAgICAgdGhyb3cgbmV3IEFwaUVycm9yKEVycm9yQ29kZS5FSU5WQUwsIGBJbnZhbGlkIFppcCBmaWxlOiBFbmQgb2YgY2VudHJhbCBkaXJlY3RvcnkgcmVjb3JkIGhhcyBpbnZhbGlkIHNpZ25hdHVyZTogJHt0aGlzLmRhdGEucmVhZFVJbnQzMkxFKDApfWApO1xuICAgIH1cbiAgfVxuICBwdWJsaWMgZGlza051bWJlcigpOiBudW1iZXIgeyByZXR1cm4gdGhpcy5kYXRhLnJlYWRVSW50MTZMRSg0KTsgfVxuICBwdWJsaWMgY2REaXNrTnVtYmVyKCk6IG51bWJlciB7IHJldHVybiB0aGlzLmRhdGEucmVhZFVJbnQxNkxFKDYpOyB9XG4gIHB1YmxpYyBjZERpc2tFbnRyeUNvdW50KCk6IG51bWJlciB7IHJldHVybiB0aGlzLmRhdGEucmVhZFVJbnQxNkxFKDgpOyB9XG4gIHB1YmxpYyBjZFRvdGFsRW50cnlDb3VudCgpOiBudW1iZXIgeyByZXR1cm4gdGhpcy5kYXRhLnJlYWRVSW50MTZMRSgxMCk7IH1cbiAgcHVibGljIGNkU2l6ZSgpOiBudW1iZXIgeyByZXR1cm4gdGhpcy5kYXRhLnJlYWRVSW50MzJMRSgxMik7IH1cbiAgcHVibGljIGNkT2Zmc2V0KCk6IG51bWJlciB7IHJldHVybiB0aGlzLmRhdGEucmVhZFVJbnQzMkxFKDE2KTsgfVxuICBwdWJsaWMgY2RaaXBDb21tZW50TGVuZ3RoKCk6IG51bWJlciB7IHJldHVybiB0aGlzLmRhdGEucmVhZFVJbnQxNkxFKDIwKTsgfVxuICBwdWJsaWMgY2RaaXBDb21tZW50KCk6IHN0cmluZyB7XG4gICAgLy8gQXNzdW1pbmcgVVRGLTguIFRoZSBzcGVjaWZpY2F0aW9uIGRvZXNuJ3Qgc3BlY2lmeS5cbiAgICByZXR1cm4gc2FmZVRvU3RyaW5nKHRoaXMuZGF0YSwgdHJ1ZSwgMjIsIHRoaXMuY2RaaXBDb21tZW50TGVuZ3RoKCkpO1xuICB9XG4gIHB1YmxpYyByYXdDZFppcENvbW1lbnQoKTogQnVmZmVyIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLnNsaWNlKDIyLCAyMiArIHRoaXMuY2RaaXBDb21tZW50TGVuZ3RoKCkpO1xuICB9XG59XG5cbi8qKlxuICogQ29udGFpbnMgdGhlIHRhYmxlIG9mIGNvbnRlbnRzIG9mIGEgWmlwIGZpbGUuXG4gKi9cbmV4cG9ydCBjbGFzcyBaaXBUT0Mge1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgaW5kZXg6IEZpbGVJbmRleDxDZW50cmFsRGlyZWN0b3J5PiwgcHVibGljIGRpcmVjdG9yeUVudHJpZXM6IENlbnRyYWxEaXJlY3RvcnlbXSwgcHVibGljIGVvY2Q6IEVuZE9mQ2VudHJhbERpcmVjdG9yeSwgcHVibGljIGRhdGE6IEJ1ZmZlcikge1xuICB9XG59XG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvcHRpb25zIGZvciBhIFppcEZTIGZpbGUgc3lzdGVtLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFppcEZTT3B0aW9ucyB7XG4gIC8vIFRoZSB6aXAgZmlsZSBhcyBhIGJpbmFyeSBidWZmZXIuXG4gIHppcERhdGE6IEJ1ZmZlcjtcbiAgLy8gVGhlIG5hbWUgb2YgdGhlIHppcCBmaWxlIChvcHRpb25hbCkuXG4gIG5hbWU/OiBzdHJpbmc7XG59XG5cbi8qKlxuICogWmlwIGZpbGUtYmFja2VkIGZpbGVzeXN0ZW1cbiAqIEltcGxlbWVudGVkIGFjY29yZGluZyB0byB0aGUgc3RhbmRhcmQ6XG4gKiBodHRwOi8vd3d3LnBrd2FyZS5jb20vZG9jdW1lbnRzL2Nhc2VzdHVkaWVzL0FQUE5PVEUuVFhUXG4gKlxuICogV2hpbGUgdGhlcmUgYXJlIGEgZmV3IHppcCBsaWJyYXJpZXMgZm9yIEphdmFTY3JpcHQgKGUuZy4gSlNaaXAgYW5kIHppcC5qcyksXG4gKiB0aGV5IGFyZSBub3QgYSBnb29kIG1hdGNoIGZvciBCcm93c2VyRlMuIEluIHBhcnRpY3VsYXIsIHRoZXNlIGxpYnJhcmllc1xuICogcGVyZm9ybSBhIGxvdCBvZiB1bm5lZWRlZCBkYXRhIGNvcHlpbmcsIGFuZCBlYWdlcmx5IGRlY29tcHJlc3MgZXZlcnkgZmlsZVxuICogaW4gdGhlIHppcCBmaWxlIHVwb24gbG9hZGluZyB0byBjaGVjayB0aGUgQ1JDMzIuIFRoZXkgYWxzbyBlYWdlcmx5IGRlY29kZVxuICogc3RyaW5ncy4gRnVydGhlcm1vcmUsIHRoZXNlIGxpYnJhcmllcyBkdXBsaWNhdGUgZnVuY3Rpb25hbGl0eSBhbHJlYWR5IHByZXNlbnRcbiAqIGluIEJyb3dzZXJGUyAoZS5nLiBVVEYtOCBkZWNvZGluZyBhbmQgYmluYXJ5IGRhdGEgbWFuaXB1bGF0aW9uKS5cbiAqXG4gKiBUaGlzIGZpbGVzeXN0ZW0gdGFrZXMgYWR2YW50YWdlIG9mIEJyb3dzZXJGUydzIEJ1ZmZlciBpbXBsZW1lbnRhdGlvbiwgd2hpY2hcbiAqIGVmZmljaWVudGx5IHJlcHJlc2VudHMgdGhlIHppcCBmaWxlIGluIG1lbW9yeSAoaW4gYm90aCBBcnJheUJ1ZmZlci1lbmFibGVkXG4gKiBicm93c2VycyAqYW5kKiBub24tQXJyYXlCdWZmZXIgYnJvd3NlcnMpLCBhbmQgd2hpY2ggY2FuIG5lYXRseSBiZSAnc2xpY2VkJ1xuICogd2l0aG91dCBjb3B5aW5nIGRhdGEuIEVhY2ggc3RydWN0IGRlZmluZWQgaW4gdGhlIHN0YW5kYXJkIGlzIHJlcHJlc2VudGVkIHdpdGhcbiAqIGEgYnVmZmVyIHNsaWNlIHBvaW50aW5nIHRvIGFuIG9mZnNldCBpbiB0aGUgemlwIGZpbGUsIGFuZCBoYXMgZ2V0dGVycyBmb3JcbiAqIGVhY2ggZmllbGQuIEFzIHdlIGFudGljaXBhdGUgdGhhdCB0aGlzIGRhdGEgd2lsbCBub3QgYmUgcmVhZCBvZnRlbiwgd2UgY2hvb3NlXG4gKiBub3QgdG8gc3RvcmUgZWFjaCBzdHJ1Y3QgZmllbGQgaW4gdGhlIEphdmFTY3JpcHQgb2JqZWN0OyBpbnN0ZWFkLCB0byByZWR1Y2VcbiAqIG1lbW9yeSBjb25zdW1wdGlvbiwgd2UgcmV0cmlldmUgaXQgZGlyZWN0bHkgZnJvbSB0aGUgYmluYXJ5IGRhdGEgZWFjaCB0aW1lIGl0XG4gKiBpcyByZXF1ZXN0ZWQuXG4gKlxuICogV2hlbiB0aGUgZmlsZXN5c3RlbSBpcyBpbnN0YW50aWF0ZWQsIHdlIGRldGVybWluZSB0aGUgZGlyZWN0b3J5IHN0cnVjdHVyZVxuICogb2YgdGhlIHppcCBmaWxlIGFzIHF1aWNrbHkgYXMgcG9zc2libGUuIFdlIGxhemlseSBkZWNvbXByZXNzIGFuZCBjaGVjayB0aGVcbiAqIENSQzMyIG9mIGZpbGVzLiBXZSBkbyBub3QgY2FjaGUgZGVjb21wcmVzc2VkIGZpbGVzOyBpZiB0aGlzIGlzIGEgZGVzaXJlZFxuICogZmVhdHVyZSwgaXQgaXMgYmVzdCBpbXBsZW1lbnRlZCBhcyBhIGdlbmVyaWMgZmlsZSBzeXN0ZW0gd3JhcHBlciB0aGF0IGNhblxuICogY2FjaGUgZGF0YSBmcm9tIGFyYml0cmFyeSBmaWxlIHN5c3RlbXMuXG4gKlxuICogRm9yIGluZmxhdGlvbiwgd2UgdXNlIGBwYWtvYCdzIGltcGxlbWVudGF0aW9uOlxuICogaHR0cHM6Ly9naXRodWIuY29tL25vZGVjYS9wYWtvXG4gKlxuICogQ3VycmVudCBsaW1pdGF0aW9uczpcbiAqICogTm8gZW5jcnlwdGlvbi5cbiAqICogTm8gWklQNjQgc3VwcG9ydC5cbiAqICogUmVhZC1vbmx5LlxuICogICBXcml0ZSBzdXBwb3J0IHdvdWxkIHJlcXVpcmUgdGhhdCB3ZTpcbiAqICAgLSBLZWVwIHRyYWNrIG9mIGNoYW5nZWQvbmV3IGZpbGVzLlxuICogICAtIENvbXByZXNzIGNoYW5nZWQgZmlsZXMsIGFuZCBnZW5lcmF0ZSBhcHByb3ByaWF0ZSBtZXRhZGF0YSBmb3IgZWFjaC5cbiAqICAgLSBVcGRhdGUgZmlsZSBvZmZzZXRzIGZvciBvdGhlciBmaWxlcyBpbiB0aGUgemlwIGZpbGUuXG4gKiAgIC0gU3RyZWFtIGl0IG91dCB0byBhIGxvY2F0aW9uLlxuICogICBUaGlzIGlzbid0IHRoYXQgYmFkLCBzbyB3ZSBtaWdodCBkbyB0aGlzIGF0IGEgbGF0ZXIgZGF0ZS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgWmlwRlMgZXh0ZW5kcyBTeW5jaHJvbm91c0ZpbGVTeXN0ZW0gaW1wbGVtZW50cyBGaWxlU3lzdGVtIHtcbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBOYW1lID0gXCJaaXBGU1wiO1xuXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgT3B0aW9uczogRmlsZVN5c3RlbU9wdGlvbnMgPSB7XG4gICAgemlwRGF0YToge1xuICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgIGRlc2NyaXB0aW9uOiBcIlRoZSB6aXAgZmlsZSBhcyBhIEJ1ZmZlciBvYmplY3QuXCIsXG4gICAgICB2YWxpZGF0b3I6IGJ1ZmZlclZhbGlkYXRvclxuICAgIH0sXG4gICAgbmFtZToge1xuICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgZGVzY3JpcHRpb246IFwiVGhlIG5hbWUgb2YgdGhlIHppcCBmaWxlIChvcHRpb25hbCkuXCJcbiAgICB9XG4gIH07XG5cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBDb21wcmVzc2lvbk1ldGhvZCA9IENvbXByZXNzaW9uTWV0aG9kO1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgWmlwRlMgaW5zdGFuY2Ugd2l0aCB0aGUgZ2l2ZW4gb3B0aW9ucy5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgQ3JlYXRlKG9wdHM6IFppcEZTT3B0aW9ucywgY2I6IEJGU0NhbGxiYWNrPFppcEZTPik6IHZvaWQge1xuICAgIHRyeSB7XG4gICAgICBaaXBGUy5jb21wdXRlSW5kZXgob3B0cy56aXBEYXRhLCAoemlwVE9DKSA9PiB7XG4gICAgICAgIGNvbnN0IGZzID0gbmV3IFppcEZTKHppcFRPQywgb3B0cy5uYW1lLCBmYWxzZSk7XG4gICAgICAgIGNiKG51bGwsIGZzKTtcbiAgICAgIH0sIGZhbHNlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjYihlKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIGlzQXZhaWxhYmxlKCk6IGJvb2xlYW4geyByZXR1cm4gdHJ1ZTsgfVxuXG4gIHB1YmxpYyBzdGF0aWMgUmVnaXN0ZXJEZWNvbXByZXNzaW9uTWV0aG9kKG06IENvbXByZXNzaW9uTWV0aG9kLCBmY246IChkYXRhOiBCdWZmZXIsIGNvbXByZXNzZWRTaXplOiBudW1iZXIsIHVuY29tcHJlc3NlZFNpemU6IG51bWJlciwgZmxhZ3M6IG51bWJlcikgPT4gQnVmZmVyKTogdm9pZCB7XG4gICAgZGVjb21wcmVzc2lvbk1ldGhvZHNbbV0gPSBmY247XG4gIH1cblxuICAvKipcbiAgICogKipEZXByZWNhdGVkLiBQbGVhc2UgdXNlIFppcEZTLkNyZWF0ZSgpIG1ldGhvZCBpbnN0ZWFkLioqXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGNvbXB1dGVJbmRleChkYXRhOiBCdWZmZXIsIGNiOiAoemlwVE9DOiBaaXBUT0MpID0+IHZvaWQsIGRlcHJlY2F0ZU1zZyA9IHRydWUpIHtcbiAgICAvLyBUT0RPOiBSZWZhY3RvciB0byBwbHVtYiBlcnJvcnMgdGhyb3VnaC4gUmlnaHQgbm93LCB0aGV5IHRocm93LlxuICAgIGlmIChkZXByZWNhdGVNc2cpIHtcbiAgICAgIGNvbnNvbGUud2FybihgW1ppcEZTXSBaaXBGUy5jb21wdXRlSW5kZXggaXMgbm93IGRlcHJlY2F0ZWQsIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZS4gUGxlYXNlIHVwZGF0ZSB5b3VyIGNvZGUgdG8gdXNlICdaaXBGUy5DcmVhdGUoeyB6aXBEYXRhOiB6aXAgZmlsZSBhcyBhIEJ1ZmZlcn0sIGNiKScgaW5zdGVhZC5gKTtcbiAgICB9XG4gICAgY29uc3QgaW5kZXg6IEZpbGVJbmRleDxDZW50cmFsRGlyZWN0b3J5PiA9IG5ldyBGaWxlSW5kZXg8Q2VudHJhbERpcmVjdG9yeT4oKTtcbiAgICBjb25zdCBlb2NkOiBFbmRPZkNlbnRyYWxEaXJlY3RvcnkgPSBaaXBGUy5nZXRFT0NEKGRhdGEpO1xuICAgIGlmIChlb2NkLmRpc2tOdW1iZXIoKSAhPT0gZW9jZC5jZERpc2tOdW1iZXIoKSkge1xuICAgICAgdGhyb3cgbmV3IEFwaUVycm9yKEVycm9yQ29kZS5FSU5WQUwsIFwiWmlwRlMgZG9lcyBub3Qgc3VwcG9ydCBzcGFubmVkIHppcCBmaWxlcy5cIik7XG4gICAgfVxuXG4gICAgY29uc3QgY2RQdHIgPSBlb2NkLmNkT2Zmc2V0KCk7XG4gICAgaWYgKGNkUHRyID09PSAweEZGRkZGRkZGKSB7XG4gICAgICB0aHJvdyBuZXcgQXBpRXJyb3IoRXJyb3JDb2RlLkVJTlZBTCwgXCJaaXBGUyBkb2VzIG5vdCBzdXBwb3J0IFppcDY0LlwiKTtcbiAgICB9XG4gICAgY29uc3QgY2RFbmQgPSBjZFB0ciArIGVvY2QuY2RTaXplKCk7XG4gICAgWmlwRlMuY29tcHV0ZUluZGV4UmVzcG9uc2l2ZShkYXRhLCBpbmRleCwgY2RQdHIsIGNkRW5kLCBjYiwgW10sIGVvY2QpO1xuICB9XG5cbiAgLyoqXG4gICAqIExvY2F0ZXMgdGhlIGVuZCBvZiBjZW50cmFsIGRpcmVjdG9yeSByZWNvcmQgYXQgdGhlIGVuZCBvZiB0aGUgZmlsZS5cbiAgICogVGhyb3dzIGFuIGV4Y2VwdGlvbiBpZiBpdCBjYW5ub3QgYmUgZm91bmQuXG4gICAqL1xuICBwcml2YXRlIHN0YXRpYyBnZXRFT0NEKGRhdGE6IEJ1ZmZlcik6IEVuZE9mQ2VudHJhbERpcmVjdG9yeSB7XG4gICAgLy8gVW5mb3J0dW5hdGVseSwgdGhlIGNvbW1lbnQgaXMgdmFyaWFibGUgc2l6ZSBhbmQgdXAgdG8gNjRLIGluIHNpemUuXG4gICAgLy8gV2UgYXNzdW1lIHRoYXQgdGhlIG1hZ2ljIHNpZ25hdHVyZSBkb2VzIG5vdCBhcHBlYXIgaW4gdGhlIGNvbW1lbnQsIGFuZFxuICAgIC8vIGluIHRoZSBieXRlcyBiZXR3ZWVuIHRoZSBjb21tZW50IGFuZCB0aGUgc2lnbmF0dXJlLiBPdGhlciBaSVBcbiAgICAvLyBpbXBsZW1lbnRhdGlvbnMgbWFrZSB0aGlzIHNhbWUgYXNzdW1wdGlvbiwgc2luY2UgdGhlIGFsdGVybmF0aXZlIGlzIHRvXG4gICAgLy8gcmVhZCB0aHJlYWQgZXZlcnkgZW50cnkgaW4gdGhlIGZpbGUgdG8gZ2V0IHRvIGl0LiA6KFxuICAgIC8vIFRoZXNlIGFyZSAqbmVnYXRpdmUqIG9mZnNldHMgZnJvbSB0aGUgZW5kIG9mIHRoZSBmaWxlLlxuICAgIGNvbnN0IHN0YXJ0T2Zmc2V0ID0gMjI7XG4gICAgY29uc3QgZW5kT2Zmc2V0ID0gTWF0aC5taW4oc3RhcnRPZmZzZXQgKyAweEZGRkYsIGRhdGEubGVuZ3RoIC0gMSk7XG4gICAgLy8gVGhlcmUncyBub3QgZXZlbiBhIGJ5dGUgYWxpZ25tZW50IGd1YXJhbnRlZSBvbiB0aGUgY29tbWVudCBzbyB3ZSBuZWVkIHRvXG4gICAgLy8gc2VhcmNoIGJ5dGUgYnkgYnl0ZS4gKmdydW1ibGUgZ3J1bWJsZSpcbiAgICBmb3IgKGxldCBpID0gc3RhcnRPZmZzZXQ7IGkgPCBlbmRPZmZzZXQ7IGkrKykge1xuICAgICAgLy8gTWFnaWMgbnVtYmVyOiBFT0NEIFNpZ25hdHVyZVxuICAgICAgaWYgKGRhdGEucmVhZFVJbnQzMkxFKGRhdGEubGVuZ3RoIC0gaSkgPT09IDB4MDYwNTRiNTApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFbmRPZkNlbnRyYWxEaXJlY3RvcnkoZGF0YS5zbGljZShkYXRhLmxlbmd0aCAtIGkpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IEFwaUVycm9yKEVycm9yQ29kZS5FSU5WQUwsIFwiSW52YWxpZCBaSVAgZmlsZTogQ291bGQgbm90IGxvY2F0ZSBFbmQgb2YgQ2VudHJhbCBEaXJlY3Rvcnkgc2lnbmF0dXJlLlwiKTtcbiAgfVxuXG4gIHByaXZhdGUgc3RhdGljIGFkZFRvSW5kZXgoY2Q6IENlbnRyYWxEaXJlY3RvcnksIGluZGV4OiBGaWxlSW5kZXg8Q2VudHJhbERpcmVjdG9yeT4pIHtcbiAgICAvLyBQYXRocyBtdXN0IGJlIGFic29sdXRlLCB5ZXQgemlwIGZpbGUgcGF0aHMgYXJlIGFsd2F5cyByZWxhdGl2ZSB0byB0aGVcbiAgICAvLyB6aXAgcm9vdC4gU28gd2UgYXBwZW5kICcvJyBhbmQgY2FsbCBpdCBhIGRheS5cbiAgICBsZXQgZmlsZW5hbWUgPSBjZC5maWxlTmFtZSgpO1xuICAgIGlmIChmaWxlbmFtZS5jaGFyQXQoMCkgPT09ICcvJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV0hZIElTIFRISVMgQUJTT0xVVEVcIik7XG4gICAgfVxuICAgIC8vIFhYWDogRm9yIHRoZSBmaWxlIGluZGV4LCBzdHJpcCB0aGUgdHJhaWxpbmcgJy8nLlxuICAgIGlmIChmaWxlbmFtZS5jaGFyQXQoZmlsZW5hbWUubGVuZ3RoIC0gMSkgPT09ICcvJykge1xuICAgICAgZmlsZW5hbWUgPSBmaWxlbmFtZS5zdWJzdHIoMCwgZmlsZW5hbWUubGVuZ3RoIC0gMSk7XG4gICAgfVxuXG4gICAgaWYgKGNkLmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgIGluZGV4LmFkZFBhdGhGYXN0KCcvJyArIGZpbGVuYW1lLCBuZXcgRGlySW5vZGU8Q2VudHJhbERpcmVjdG9yeT4oY2QpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5kZXguYWRkUGF0aEZhc3QoJy8nICsgZmlsZW5hbWUsIG5ldyBGaWxlSW5vZGU8Q2VudHJhbERpcmVjdG9yeT4oY2QpKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHN0YXRpYyBjb21wdXRlSW5kZXhSZXNwb25zaXZlKGRhdGE6IEJ1ZmZlciwgaW5kZXg6IEZpbGVJbmRleDxDZW50cmFsRGlyZWN0b3J5PiwgY2RQdHI6IG51bWJlciwgY2RFbmQ6IG51bWJlciwgY2I6ICh6aXBUT0M6IFppcFRPQykgPT4gdm9pZCwgY2RFbnRyaWVzOiBDZW50cmFsRGlyZWN0b3J5W10sIGVvY2Q6IEVuZE9mQ2VudHJhbERpcmVjdG9yeSkge1xuICAgIGlmIChjZFB0ciA8IGNkRW5kKSB7XG4gICAgICBsZXQgY291bnQgPSAwO1xuICAgICAgd2hpbGUgKGNvdW50KysgPCAyMDAgJiYgY2RQdHIgPCBjZEVuZCkge1xuICAgICAgICBjb25zdCBjZDogQ2VudHJhbERpcmVjdG9yeSA9IG5ldyBDZW50cmFsRGlyZWN0b3J5KGRhdGEsIGRhdGEuc2xpY2UoY2RQdHIpKTtcbiAgICAgICAgWmlwRlMuYWRkVG9JbmRleChjZCwgaW5kZXgpO1xuICAgICAgICBjZFB0ciArPSBjZC50b3RhbFNpemUoKTtcbiAgICAgICAgY2RFbnRyaWVzLnB1c2goY2QpO1xuICAgICAgfVxuICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICAgICAgWmlwRlMuY29tcHV0ZUluZGV4UmVzcG9uc2l2ZShkYXRhLCBpbmRleCwgY2RQdHIsIGNkRW5kLCBjYiwgY2RFbnRyaWVzLCBlb2NkKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYihuZXcgWmlwVE9DKGluZGV4LCBjZEVudHJpZXMsIGVvY2QsIGRhdGEpKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIF9pbmRleDogRmlsZUluZGV4PENlbnRyYWxEaXJlY3Rvcnk+ID0gbmV3IEZpbGVJbmRleDxDZW50cmFsRGlyZWN0b3J5PigpO1xuICBwcml2YXRlIF9kaXJlY3RvcnlFbnRyaWVzOiBDZW50cmFsRGlyZWN0b3J5W10gPSBbXTtcbiAgcHJpdmF0ZSBfZW9jZDogRW5kT2ZDZW50cmFsRGlyZWN0b3J5IHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgZGF0YTogQnVmZmVyO1xuXG4gIC8qKlxuICAgKiAqKkRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgWmlwRlMuQ3JlYXRlKCkgbWV0aG9kIHRvIGNvbnN0cnVjdCBaaXBGUyBvYmplY3RzLioqXG4gICAqL1xuICBjb25zdHJ1Y3RvcihpbnB1dDogQnVmZmVyIHwgWmlwVE9DLCBwcml2YXRlIG5hbWU6IHN0cmluZyA9ICcnLCBkZXByZWNhdGVNc2cgPSB0cnVlKSB7XG4gICAgc3VwZXIoKTtcbiAgICBkZXByZWNhdGlvbk1lc3NhZ2UoZGVwcmVjYXRlTXNnLCBaaXBGUy5OYW1lLCB7emlwRGF0YTogXCJ6aXAgZGF0YSBhcyBhIEJ1ZmZlclwiLCBuYW1lOiBuYW1lfSk7XG4gICAgaWYgKGlucHV0IGluc3RhbmNlb2YgWmlwVE9DKSB7XG4gICAgICB0aGlzLl9pbmRleCA9IGlucHV0LmluZGV4O1xuICAgICAgdGhpcy5fZGlyZWN0b3J5RW50cmllcyA9IGlucHV0LmRpcmVjdG9yeUVudHJpZXM7XG4gICAgICB0aGlzLl9lb2NkID0gaW5wdXQuZW9jZDtcbiAgICAgIHRoaXMuZGF0YSA9IGlucHV0LmRhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGF0YSA9IGlucHV0IGFzIEJ1ZmZlcjtcbiAgICAgIHRoaXMucG9wdWxhdGVJbmRleCgpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBnZXROYW1lKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIFppcEZTLk5hbWUgKyAodGhpcy5uYW1lICE9PSAnJyA/IGAgJHt0aGlzLm5hbWV9YCA6ICcnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIENlbnRyYWxEaXJlY3Rvcnkgb2JqZWN0IGZvciB0aGUgZ2l2ZW4gcGF0aC5cbiAgICovXG4gIHB1YmxpYyBnZXRDZW50cmFsRGlyZWN0b3J5RW50cnkocGF0aDogc3RyaW5nKTogQ2VudHJhbERpcmVjdG9yeSB7XG4gICAgY29uc3QgaW5vZGUgPSB0aGlzLl9pbmRleC5nZXRJbm9kZShwYXRoKTtcbiAgICBpZiAoaW5vZGUgPT09IG51bGwpIHtcbiAgICAgIHRocm93IEFwaUVycm9yLkVOT0VOVChwYXRoKTtcbiAgICB9XG4gICAgaWYgKGlzRmlsZUlub2RlPENlbnRyYWxEaXJlY3Rvcnk+KGlub2RlKSkge1xuICAgICAgcmV0dXJuIGlub2RlLmdldERhdGEoKTtcbiAgICB9IGVsc2UgaWYgKGlzRGlySW5vZGU8Q2VudHJhbERpcmVjdG9yeT4oaW5vZGUpKSB7XG4gICAgICByZXR1cm4gaW5vZGUuZ2V0RGF0YSgpITtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU2hvdWxkIG5ldmVyIG9jY3VyLlxuICAgICAgdGhyb3cgQXBpRXJyb3IuRVBFUk0oYEludmFsaWQgaW5vZGU6ICR7aW5vZGV9YCk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGdldENlbnRyYWxEaXJlY3RvcnlFbnRyeUF0KGluZGV4OiBudW1iZXIpOiBDZW50cmFsRGlyZWN0b3J5IHtcbiAgICBjb25zdCBkaXJFbnRyeSA9IHRoaXMuX2RpcmVjdG9yeUVudHJpZXNbaW5kZXhdO1xuICAgIGlmICghZGlyRW50cnkpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBJbnZhbGlkIGRpcmVjdG9yeSBpbmRleDogJHtpbmRleH0uYCk7XG4gICAgfVxuICAgIHJldHVybiBkaXJFbnRyeTtcbiAgfVxuXG4gIHB1YmxpYyBnZXROdW1iZXJPZkNlbnRyYWxEaXJlY3RvcnlFbnRyaWVzKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX2RpcmVjdG9yeUVudHJpZXMubGVuZ3RoO1xuICB9XG5cbiAgcHVibGljIGdldEVuZE9mQ2VudHJhbERpcmVjdG9yeSgpOiBFbmRPZkNlbnRyYWxEaXJlY3RvcnkgfCBudWxsIHtcbiAgICByZXR1cm4gdGhpcy5fZW9jZDtcbiAgfVxuXG4gIHB1YmxpYyBkaXNrU3BhY2UocGF0aDogc3RyaW5nLCBjYjogKHRvdGFsOiBudW1iZXIsIGZyZWU6IG51bWJlcikgPT4gdm9pZCk6IHZvaWQge1xuICAgIC8vIFJlYWQtb25seSBmaWxlIHN5c3RlbS5cbiAgICBjYih0aGlzLmRhdGEubGVuZ3RoLCAwKTtcbiAgfVxuXG4gIHB1YmxpYyBpc1JlYWRPbmx5KCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcHVibGljIHN1cHBvcnRzTGlua3MoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcHVibGljIHN1cHBvcnRzUHJvcHMoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcHVibGljIHN1cHBvcnRzU3luY2goKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBwdWJsaWMgc3RhdFN5bmMocGF0aDogc3RyaW5nLCBpc0xzdGF0OiBib29sZWFuKTogU3RhdHMge1xuICAgIGNvbnN0IGlub2RlID0gdGhpcy5faW5kZXguZ2V0SW5vZGUocGF0aCk7XG4gICAgaWYgKGlub2RlID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBBcGlFcnJvci5FTk9FTlQocGF0aCk7XG4gICAgfVxuICAgIGxldCBzdGF0czogU3RhdHM7XG4gICAgaWYgKGlzRmlsZUlub2RlPENlbnRyYWxEaXJlY3Rvcnk+KGlub2RlKSkge1xuICAgICAgc3RhdHMgPSBpbm9kZS5nZXREYXRhKCkuZ2V0U3RhdHMoKTtcbiAgICB9IGVsc2UgaWYgKGlzRGlySW5vZGUoaW5vZGUpKSB7XG4gICAgICBzdGF0cyA9IGlub2RlLmdldFN0YXRzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBBcGlFcnJvcihFcnJvckNvZGUuRUlOVkFMLCBcIkludmFsaWQgaW5vZGUuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gc3RhdHM7XG4gIH1cblxuICBwdWJsaWMgb3BlblN5bmMocGF0aDogc3RyaW5nLCBmbGFnczogRmlsZUZsYWcsIG1vZGU6IG51bWJlcik6IEZpbGUge1xuICAgIC8vIElOVkFSSUFOVDogQ2Fubm90IHdyaXRlIHRvIFJPIGZpbGUgc3lzdGVtcy5cbiAgICBpZiAoZmxhZ3MuaXNXcml0ZWFibGUoKSkge1xuICAgICAgdGhyb3cgbmV3IEFwaUVycm9yKEVycm9yQ29kZS5FUEVSTSwgcGF0aCk7XG4gICAgfVxuICAgIC8vIENoZWNrIGlmIHRoZSBwYXRoIGV4aXN0cywgYW5kIGlzIGEgZmlsZS5cbiAgICBjb25zdCBpbm9kZSA9IHRoaXMuX2luZGV4LmdldElub2RlKHBhdGgpO1xuICAgIGlmICghaW5vZGUpIHtcbiAgICAgIHRocm93IEFwaUVycm9yLkVOT0VOVChwYXRoKTtcbiAgICB9IGVsc2UgaWYgKGlzRmlsZUlub2RlPENlbnRyYWxEaXJlY3Rvcnk+KGlub2RlKSkge1xuICAgICAgY29uc3QgY2RSZWNvcmQgPSBpbm9kZS5nZXREYXRhKCk7XG4gICAgICBjb25zdCBzdGF0cyA9IGNkUmVjb3JkLmdldFN0YXRzKCk7XG4gICAgICBzd2l0Y2ggKGZsYWdzLnBhdGhFeGlzdHNBY3Rpb24oKSkge1xuICAgICAgICBjYXNlIEFjdGlvblR5cGUuVEhST1dfRVhDRVBUSU9OOlxuICAgICAgICBjYXNlIEFjdGlvblR5cGUuVFJVTkNBVEVfRklMRTpcbiAgICAgICAgICB0aHJvdyBBcGlFcnJvci5FRVhJU1QocGF0aCk7XG4gICAgICAgIGNhc2UgQWN0aW9uVHlwZS5OT1A6XG4gICAgICAgICAgcmV0dXJuIG5ldyBOb1N5bmNGaWxlKHRoaXMsIHBhdGgsIGZsYWdzLCBzdGF0cywgY2RSZWNvcmQuZ2V0RGF0YSgpKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgQXBpRXJyb3IoRXJyb3JDb2RlLkVJTlZBTCwgJ0ludmFsaWQgRmlsZU1vZGUgb2JqZWN0LicpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBBcGlFcnJvci5FSVNESVIocGF0aCk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHJlYWRkaXJTeW5jKHBhdGg6IHN0cmluZyk6IHN0cmluZ1tdIHtcbiAgICAvLyBDaGVjayBpZiBpdCBleGlzdHMuXG4gICAgY29uc3QgaW5vZGUgPSB0aGlzLl9pbmRleC5nZXRJbm9kZShwYXRoKTtcbiAgICBpZiAoIWlub2RlKSB7XG4gICAgICB0aHJvdyBBcGlFcnJvci5FTk9FTlQocGF0aCk7XG4gICAgfSBlbHNlIGlmIChpc0Rpcklub2RlKGlub2RlKSkge1xuICAgICAgcmV0dXJuIGlub2RlLmdldExpc3RpbmcoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgQXBpRXJyb3IuRU5PVERJUihwYXRoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3BlY2lhbGx5LW9wdGltaXplZCByZWFkZmlsZS5cbiAgICovXG4gIHB1YmxpYyByZWFkRmlsZVN5bmMoZm5hbWU6IHN0cmluZywgZW5jb2Rpbmc6IHN0cmluZywgZmxhZzogRmlsZUZsYWcpOiBhbnkge1xuICAgIC8vIEdldCBmaWxlLlxuICAgIGNvbnN0IGZkID0gdGhpcy5vcGVuU3luYyhmbmFtZSwgZmxhZywgMHgxYTQpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBmZENhc3QgPSA8Tm9TeW5jRmlsZTxaaXBGUz4+IGZkO1xuICAgICAgY29uc3QgZmRCdWZmID0gPEJ1ZmZlcj4gZmRDYXN0LmdldEJ1ZmZlcigpO1xuICAgICAgaWYgKGVuY29kaW5nID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBjb3B5aW5nU2xpY2UoZmRCdWZmKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmZEJ1ZmYudG9TdHJpbmcoZW5jb2RpbmcpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBmZC5jbG9zZVN5bmMoKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHBvcHVsYXRlSW5kZXgoKSB7XG4gICAgY29uc3QgZW9jZDogRW5kT2ZDZW50cmFsRGlyZWN0b3J5ID0gdGhpcy5fZW9jZCA9IFppcEZTLmdldEVPQ0QodGhpcy5kYXRhKTtcbiAgICBpZiAoZW9jZC5kaXNrTnVtYmVyKCkgIT09IGVvY2QuY2REaXNrTnVtYmVyKCkpIHtcbiAgICAgIHRocm93IG5ldyBBcGlFcnJvcihFcnJvckNvZGUuRUlOVkFMLCBcIlppcEZTIGRvZXMgbm90IHN1cHBvcnQgc3Bhbm5lZCB6aXAgZmlsZXMuXCIpO1xuICAgIH1cblxuICAgIGxldCBjZFB0ciA9IGVvY2QuY2RPZmZzZXQoKTtcbiAgICBpZiAoY2RQdHIgPT09IDB4RkZGRkZGRkYpIHtcbiAgICAgIHRocm93IG5ldyBBcGlFcnJvcihFcnJvckNvZGUuRUlOVkFMLCBcIlppcEZTIGRvZXMgbm90IHN1cHBvcnQgWmlwNjQuXCIpO1xuICAgIH1cbiAgICBjb25zdCBjZEVuZCA9IGNkUHRyICsgZW9jZC5jZFNpemUoKTtcbiAgICB3aGlsZSAoY2RQdHIgPCBjZEVuZCkge1xuICAgICAgY29uc3QgY2Q6IENlbnRyYWxEaXJlY3RvcnkgPSBuZXcgQ2VudHJhbERpcmVjdG9yeSh0aGlzLmRhdGEsIHRoaXMuZGF0YS5zbGljZShjZFB0cikpO1xuICAgICAgY2RQdHIgKz0gY2QudG90YWxTaXplKCk7XG4gICAgICBaaXBGUy5hZGRUb0luZGV4KGNkLCB0aGlzLl9pbmRleCk7XG4gICAgICB0aGlzLl9kaXJlY3RvcnlFbnRyaWVzLnB1c2goY2QpO1xuICAgIH1cbiAgfVxufVxuXG5aaXBGUy5SZWdpc3RlckRlY29tcHJlc3Npb25NZXRob2QoQ29tcHJlc3Npb25NZXRob2QuREVGTEFURSwgKGRhdGEsIGNvbXByZXNzZWRTaXplLCB1bmNvbXByZXNzZWRTaXplKSA9PiB7XG4gIHJldHVybiBhcnJheWlzaDJCdWZmZXIoaW5mbGF0ZVJhdyhcbiAgICBkYXRhLnNsaWNlKDAsIGNvbXByZXNzZWRTaXplKSxcbiAgICB7IGNodW5rU2l6ZTogdW5jb21wcmVzc2VkU2l6ZSB9XG4gICkpO1xufSk7XG5cblppcEZTLlJlZ2lzdGVyRGVjb21wcmVzc2lvbk1ldGhvZChDb21wcmVzc2lvbk1ldGhvZC5TVE9SRUQsIChkYXRhLCBjb21wcmVzc2VkU2l6ZSwgdW5jb21wcmVzc2VkU2l6ZSkgPT4ge1xuICByZXR1cm4gY29weWluZ1NsaWNlKGRhdGEsIDAsIHVuY29tcHJlc3NlZFNpemUpO1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vLi4vLi4vLi4vc3JjL2JhY2tlbmQvWmlwRlMudHMiLCJpbXBvcnQge0FwaUVycm9yLCBFcnJvckNvZGV9IGZyb20gJy4uL2NvcmUvYXBpX2Vycm9yJztcbmltcG9ydCB7ZGVmYXVsdCBhcyBTdGF0cywgRmlsZVR5cGV9IGZyb20gJy4uL2NvcmUvbm9kZV9mc19zdGF0cyc7XG5pbXBvcnQge1N5bmNocm9ub3VzRmlsZVN5c3RlbSwgRmlsZVN5c3RlbSwgQkZTQ2FsbGJhY2ssIEZpbGVTeXN0ZW1PcHRpb25zfSBmcm9tICcuLi9jb3JlL2ZpbGVfc3lzdGVtJztcbmltcG9ydCB7RmlsZX0gZnJvbSAnLi4vY29yZS9maWxlJztcbmltcG9ydCB7RmlsZUZsYWcsIEFjdGlvblR5cGV9IGZyb20gJy4uL2NvcmUvZmlsZV9mbGFnJztcbmltcG9ydCB7Tm9TeW5jRmlsZX0gZnJvbSAnLi4vZ2VuZXJpYy9wcmVsb2FkX2ZpbGUnO1xuaW1wb3J0IHtjb3B5aW5nU2xpY2UsIGRlcHJlY2F0aW9uTWVzc2FnZSwgYnVmZmVyVmFsaWRhdG9yfSBmcm9tICcuLi9jb3JlL3V0aWwnO1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IHJvY2tSaWRnZUlkZW50aWZpZXIgPSBcIklFRUVfUDEyODJcIjtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBlbnVtIFZvbHVtZURlc2NyaXB0b3JUeXBlQ29kZSB7XG4gIEJvb3RSZWNvcmQgPSAwLFxuICBQcmltYXJ5Vm9sdW1lRGVzY3JpcHRvciA9IDEsXG4gIFN1cHBsZW1lbnRhcnlWb2x1bWVEZXNjcmlwdG9yID0gMixcbiAgVm9sdW1lUGFydGl0aW9uRGVzY3JpcHRvciA9IDMsXG4gIFZvbHVtZURlc2NyaXB0b3JTZXRUZXJtaW5hdG9yID0gMjU1XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG50eXBlIFRHZXRTdHJpbmcgPSAoZDogQnVmZmVyLCBpOiBudW1iZXIsIGxlbjogbnVtYmVyKSA9PiBzdHJpbmc7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5mdW5jdGlvbiBnZXRBU0NJSVN0cmluZyhkYXRhOiBCdWZmZXIsIHN0YXJ0SW5kZXg6IG51bWJlciwgbGVuZ3RoOiBudW1iZXIpIHtcbiAgcmV0dXJuIGRhdGEudG9TdHJpbmcoJ2FzY2lpJywgc3RhcnRJbmRleCwgc3RhcnRJbmRleCArIGxlbmd0aCkudHJpbSgpO1xufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZnVuY3Rpb24gZ2V0Sm9saWV0U3RyaW5nKGRhdGE6IEJ1ZmZlciwgc3RhcnRJbmRleDogbnVtYmVyLCBsZW5ndGg6IG51bWJlcik6IHN0cmluZyB7XG4gIGlmIChsZW5ndGggPT09IDEpIHtcbiAgICAvLyBTcGVjaWFsOiBSb290LCBwYXJlbnQsIGN1cnJlbnQgZGlyZWN0b3J5IGFyZSBzdGlsbCBhIHNpbmdsZSBieXRlLlxuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGRhdGFbc3RhcnRJbmRleF0pO1xuICB9XG4gIC8vIFVURjE2LUJFLCB3aGljaCBpc24ndCBuYXRpdmVseSBzdXBwb3J0ZWQgYnkgTm9kZUpTIEJ1ZmZlcnMuXG4gIC8vIExlbmd0aCBzaG91bGQgYmUgZXZlbiwgYnV0IHBlc3NpbWlzdGljYWxseSBmbG9vciBqdXN0IGluIGNhc2UuXG4gIGNvbnN0IHBhaXJzID0gTWF0aC5mbG9vcihsZW5ndGggLyAyKTtcbiAgY29uc3QgY2hhcnMgPSBuZXcgQXJyYXkocGFpcnMpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHBhaXJzOyBpKyspIHtcbiAgICBjb25zdCBwb3MgPSBzdGFydEluZGV4ICsgKGkgPDwgMSk7XG4gICAgY2hhcnNbaV0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGRhdGFbcG9zICsgMV0gfCAoZGF0YVtwb3NdIDw8IDgpKTtcbiAgfVxuICByZXR1cm4gY2hhcnMuam9pbignJyk7XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5mdW5jdGlvbiBnZXREYXRlKGRhdGE6IEJ1ZmZlciwgc3RhcnRJbmRleDogbnVtYmVyKTogRGF0ZSB7XG4gIGNvbnN0IHllYXIgPSBwYXJzZUludChnZXRBU0NJSVN0cmluZyhkYXRhLCBzdGFydEluZGV4LCA0KSwgMTApO1xuICBjb25zdCBtb24gPSBwYXJzZUludChnZXRBU0NJSVN0cmluZyhkYXRhLCBzdGFydEluZGV4ICsgNCwgMiksIDEwKTtcbiAgY29uc3QgZGF5ID0gcGFyc2VJbnQoZ2V0QVNDSUlTdHJpbmcoZGF0YSwgc3RhcnRJbmRleCArIDYsIDIpLCAxMCk7XG4gIGNvbnN0IGhvdXIgPSBwYXJzZUludChnZXRBU0NJSVN0cmluZyhkYXRhLCBzdGFydEluZGV4ICsgOCwgMiksIDEwKTtcbiAgY29uc3QgbWluID0gcGFyc2VJbnQoZ2V0QVNDSUlTdHJpbmcoZGF0YSwgc3RhcnRJbmRleCArIDEwLCAyKSwgMTApO1xuICBjb25zdCBzZWMgPSBwYXJzZUludChnZXRBU0NJSVN0cmluZyhkYXRhLCBzdGFydEluZGV4ICsgMTIsIDIpLCAxMCk7XG4gIGNvbnN0IGh1bmRyZXRoc1NlYyA9IHBhcnNlSW50KGdldEFTQ0lJU3RyaW5nKGRhdGEsIHN0YXJ0SW5kZXggKyAxNCwgMiksIDEwKTtcbiAgLy8gTGFzdCBpcyBhIHRpbWUtem9uZSBvZmZzZXQsIGJ1dCBKYXZhU2NyaXB0IGRhdGVzIGRvbid0IHN1cHBvcnQgdGltZSB6b25lcyB3ZWxsLlxuICByZXR1cm4gbmV3IERhdGUoeWVhciwgbW9uLCBkYXksIGhvdXIsIG1pbiwgc2VjLCBodW5kcmV0aHNTZWMgKiAxMDApO1xufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZnVuY3Rpb24gZ2V0U2hvcnRGb3JtRGF0ZShkYXRhOiBCdWZmZXIsIHN0YXJ0SW5kZXg6IG51bWJlcik6IERhdGUge1xuICBjb25zdCB5ZWFyc1NpbmNlMTkwMCA9IGRhdGFbc3RhcnRJbmRleF07XG4gIGNvbnN0IG1vbnRoID0gZGF0YVtzdGFydEluZGV4ICsgMV07XG4gIGNvbnN0IGRheSA9IGRhdGFbc3RhcnRJbmRleCArIDJdO1xuICBjb25zdCBob3VyID0gZGF0YVtzdGFydEluZGV4ICsgM107XG4gIGNvbnN0IG1pbnV0ZSA9IGRhdGFbc3RhcnRJbmRleCArIDRdO1xuICBjb25zdCBzZWNvbmQgPSBkYXRhW3N0YXJ0SW5kZXggKyA1XTtcbiAgLy8gSmF2YVNjcmlwdCdzIERhdGUgc3VwcG9ydCBpc24ndCBzbyBncmVhdDsgaWdub3JlIHRpbWV6b25lLlxuICAvLyBjb25zdCBvZmZzZXRGcm9tR01UID0gdGhpcy5fZGF0YVsyNF07XG4gIHJldHVybiBuZXcgRGF0ZSh5ZWFyc1NpbmNlMTkwMCwgbW9udGggLSAxLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kKTtcbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmZ1bmN0aW9uIGNvbnN0cnVjdFN5c3RlbVVzZUVudHJ5KGJpZ0RhdGE6IEJ1ZmZlciwgaTogbnVtYmVyKTogU3lzdGVtVXNlRW50cnkge1xuICBjb25zdCBkYXRhID0gYmlnRGF0YS5zbGljZShpKTtcbiAgY29uc3Qgc3VlID0gbmV3IFN5c3RlbVVzZUVudHJ5KGRhdGEpO1xuICBzd2l0Y2ggKHN1ZS5zaWduYXR1cmVXb3JkKCkpIHtcbiAgICBjYXNlIFN5c3RlbVVzZUVudHJ5U2lnbmF0dXJlcy5DRTpcbiAgICAgIHJldHVybiBuZXcgQ0VFbnRyeShkYXRhKTtcbiAgICBjYXNlIFN5c3RlbVVzZUVudHJ5U2lnbmF0dXJlcy5QRDpcbiAgICAgIHJldHVybiBuZXcgIFBERW50cnkoZGF0YSk7XG4gICAgY2FzZSBTeXN0ZW1Vc2VFbnRyeVNpZ25hdHVyZXMuU1A6XG4gICAgICByZXR1cm4gbmV3IFNQRW50cnkoZGF0YSk7XG4gICAgY2FzZSBTeXN0ZW1Vc2VFbnRyeVNpZ25hdHVyZXMuU1Q6XG4gICAgICByZXR1cm4gbmV3IFNURW50cnkoZGF0YSk7XG4gICAgY2FzZSBTeXN0ZW1Vc2VFbnRyeVNpZ25hdHVyZXMuRVI6XG4gICAgICByZXR1cm4gbmV3IEVSRW50cnkoZGF0YSk7XG4gICAgY2FzZSBTeXN0ZW1Vc2VFbnRyeVNpZ25hdHVyZXMuRVM6XG4gICAgICByZXR1cm4gbmV3IEVTRW50cnkoZGF0YSk7XG4gICAgY2FzZSBTeXN0ZW1Vc2VFbnRyeVNpZ25hdHVyZXMuUFg6XG4gICAgICByZXR1cm4gbmV3IFBYRW50cnkoZGF0YSk7XG4gICAgY2FzZSBTeXN0ZW1Vc2VFbnRyeVNpZ25hdHVyZXMuUE46XG4gICAgICByZXR1cm4gbmV3IFBORW50cnkoZGF0YSk7XG4gICAgY2FzZSBTeXN0ZW1Vc2VFbnRyeVNpZ25hdHVyZXMuU0w6XG4gICAgICByZXR1cm4gbmV3IFNMRW50cnkoZGF0YSk7XG4gICAgY2FzZSBTeXN0ZW1Vc2VFbnRyeVNpZ25hdHVyZXMuTk06XG4gICAgICByZXR1cm4gbmV3IE5NRW50cnkoZGF0YSk7XG4gICAgY2FzZSBTeXN0ZW1Vc2VFbnRyeVNpZ25hdHVyZXMuQ0w6XG4gICAgICByZXR1cm4gbmV3IENMRW50cnkoZGF0YSk7XG4gICAgY2FzZSBTeXN0ZW1Vc2VFbnRyeVNpZ25hdHVyZXMuUEw6XG4gICAgICByZXR1cm4gbmV3IFBMRW50cnkoZGF0YSk7XG4gICAgY2FzZSBTeXN0ZW1Vc2VFbnRyeVNpZ25hdHVyZXMuUkU6XG4gICAgICByZXR1cm4gbmV3IFJFRW50cnkoZGF0YSk7XG4gICAgY2FzZSBTeXN0ZW1Vc2VFbnRyeVNpZ25hdHVyZXMuVEY6XG4gICAgICByZXR1cm4gbmV3IFRGRW50cnkoZGF0YSk7XG4gICAgY2FzZSBTeXN0ZW1Vc2VFbnRyeVNpZ25hdHVyZXMuU0Y6XG4gICAgICByZXR1cm4gbmV3IFNGRW50cnkoZGF0YSk7XG4gICAgY2FzZSBTeXN0ZW1Vc2VFbnRyeVNpZ25hdHVyZXMuUlI6XG4gICAgICByZXR1cm4gbmV3IFJSRW50cnkoZGF0YSk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBzdWU7XG4gIH1cbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmZ1bmN0aW9uIGNvbnN0cnVjdFN5c3RlbVVzZUVudHJpZXMoZGF0YTogQnVmZmVyLCBpOiBudW1iZXIsIGxlbjogbnVtYmVyLCBpc29EYXRhOiBCdWZmZXIpOiBTeXN0ZW1Vc2VFbnRyeVtdIHtcbiAgLy8gSWYgdGhlIHJlbWFpbmluZyBhbGxvY2F0ZWQgc3BhY2UgZm9sbG93aW5nIHRoZSBsYXN0IHJlY29yZGVkIFN5c3RlbSBVc2UgRW50cnkgaW4gYSBTeXN0ZW1cbiAgLy8gVXNlIGZpZWxkIG9yIENvbnRpbnVhdGlvbiBBcmVhIGlzIGxlc3MgdGhhbiBmb3VyIGJ5dGVzIGxvbmcsIGl0IGNhbm5vdCBjb250YWluIGEgU3lzdGVtXG4gIC8vIFVzZSBFbnRyeSBhbmQgc2hhbGwgYmUgaWdub3JlZFxuICBsZW4gPSBsZW4gLSA0O1xuICBsZXQgZW50cmllcyA9IG5ldyBBcnJheTxTeXN0ZW1Vc2VFbnRyeT4oKTtcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICBjb25zdCBlbnRyeSA9IGNvbnN0cnVjdFN5c3RlbVVzZUVudHJ5KGRhdGEsIGkpO1xuICAgIGNvbnN0IGxlbmd0aCA9IGVudHJ5Lmxlbmd0aCgpO1xuICAgIGlmIChsZW5ndGggPT09IDApIHtcbiAgICAgIC8vIEludmFsaWQgU1Ugc2VjdGlvbjsgcHJldmVudCBpbmZpbml0ZSBsb29wLlxuICAgICAgcmV0dXJuIGVudHJpZXM7XG4gICAgfVxuICAgIGkgKz0gbGVuZ3RoO1xuICAgIGlmIChlbnRyeSBpbnN0YW5jZW9mIFNURW50cnkpIHtcbiAgICAgIC8vIFNUIGluZGljYXRlcyB0aGUgZW5kIG9mIGVudHJpZXMuXG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKGVudHJ5IGluc3RhbmNlb2YgQ0VFbnRyeSkge1xuICAgICAgZW50cmllcyA9IGVudHJpZXMuY29uY2F0KGVudHJ5LmdldEVudHJpZXMoaXNvRGF0YSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbnRyaWVzLnB1c2goZW50cnkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZW50cmllcztcbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIFZvbHVtZURlc2NyaXB0b3Ige1xuICBwcm90ZWN0ZWQgX2RhdGE6IEJ1ZmZlcjtcbiAgY29uc3RydWN0b3IoZGF0YTogQnVmZmVyKSB7XG4gICAgdGhpcy5fZGF0YSA9IGRhdGE7XG4gIH1cbiAgcHVibGljIHR5cGUoKTogVm9sdW1lRGVzY3JpcHRvclR5cGVDb2RlIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YVswXTtcbiAgfVxuICBwdWJsaWMgc3RhbmRhcmRJZGVudGlmaWVyKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGdldEFTQ0lJU3RyaW5nKHRoaXMuX2RhdGEsIDEsIDUpO1xuICB9XG4gIHB1YmxpYyB2ZXJzaW9uKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGFbNl07XG4gIH1cbiAgcHVibGljIGRhdGEoKTogQnVmZmVyIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YS5zbGljZSg3LCAyMDQ4KTtcbiAgfVxufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuYWJzdHJhY3QgY2xhc3MgUHJpbWFyeU9yU3VwcGxlbWVudGFyeVZvbHVtZURlc2NyaXB0b3IgZXh0ZW5kcyBWb2x1bWVEZXNjcmlwdG9yIHtcbiAgcHJpdmF0ZSBfcm9vdDogRGlyZWN0b3J5UmVjb3JkIHwgbnVsbCA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKGRhdGE6IEJ1ZmZlcikge1xuICAgIHN1cGVyKGRhdGEpO1xuICB9XG4gIHB1YmxpYyBzeXN0ZW1JZGVudGlmaWVyKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFN0cmluZzMyKDgpO1xuICB9XG4gIHB1YmxpYyB2b2x1bWVJZGVudGlmaWVyKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFN0cmluZzMyKDQwKTtcbiAgfVxuICBwdWJsaWMgdm9sdW1lU3BhY2VTaXplKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGEucmVhZFVJbnQzMkxFKDgwKTtcbiAgfVxuICBwdWJsaWMgdm9sdW1lU2V0U2l6ZSgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLl9kYXRhLnJlYWRVSW50MTZMRSgxMjApO1xuICB9XG4gIHB1YmxpYyB2b2x1bWVTZXF1ZW5jZU51bWJlcigpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLl9kYXRhLnJlYWRVSW50MTZMRSgxMjQpO1xuICB9XG4gIHB1YmxpYyBsb2dpY2FsQmxvY2tTaXplKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGEucmVhZFVJbnQxNkxFKDEyOCk7XG4gIH1cbiAgcHVibGljIHBhdGhUYWJsZVNpemUoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YS5yZWFkVUludDMyTEUoMTMyKTtcbiAgfVxuICBwdWJsaWMgbG9jYXRpb25PZlR5cGVMUGF0aFRhYmxlKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGEucmVhZFVJbnQzMkxFKDE0MCk7XG4gIH1cbiAgcHVibGljIGxvY2F0aW9uT2ZPcHRpb25hbFR5cGVMUGF0aFRhYmxlKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGEucmVhZFVJbnQzMkxFKDE0NCk7XG4gIH1cbiAgcHVibGljIGxvY2F0aW9uT2ZUeXBlTVBhdGhUYWJsZSgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLl9kYXRhLnJlYWRVSW50MzJCRSgxNDgpO1xuICB9XG4gIHB1YmxpYyBsb2NhdGlvbk9mT3B0aW9uYWxUeXBlTVBhdGhUYWJsZSgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLl9kYXRhLnJlYWRVSW50MzJCRSgxNTIpO1xuICB9XG4gIHB1YmxpYyByb290RGlyZWN0b3J5RW50cnkoaXNvRGF0YTogQnVmZmVyKTogRGlyZWN0b3J5UmVjb3JkIHtcbiAgICBpZiAodGhpcy5fcm9vdCA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5fcm9vdCA9IHRoaXMuX2NvbnN0cnVjdFJvb3REaXJlY3RvcnlSZWNvcmQodGhpcy5fZGF0YS5zbGljZSgxNTYpKTtcbiAgICAgIHRoaXMuX3Jvb3Qucm9vdENoZWNrRm9yUm9ja1JpZGdlKGlzb0RhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcm9vdDtcbiAgfVxuICBwdWJsaWMgdm9sdW1lU2V0SWRlbnRpZmllcigpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl9nZXRTdHJpbmcoMTkwLCAxMjgpO1xuICB9XG4gIHB1YmxpYyBwdWJsaXNoZXJJZGVudGlmaWVyKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFN0cmluZygzMTgsIDEyOCk7XG4gIH1cbiAgcHVibGljIGRhdGFQcmVwYXJlcklkZW50aWZpZXIoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0U3RyaW5nKDQ0NiwgMTI4KTtcbiAgfVxuICBwdWJsaWMgYXBwbGljYXRpb25JZGVudGlmaWVyKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFN0cmluZyg1NzQsIDEyOCk7XG4gIH1cbiAgcHVibGljIGNvcHlyaWdodEZpbGVJZGVudGlmaWVyKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFN0cmluZyg3MDIsIDM4KTtcbiAgfVxuICBwdWJsaWMgYWJzdHJhY3RGaWxlSWRlbnRpZmllcigpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl9nZXRTdHJpbmcoNzQwLCAzNik7XG4gIH1cbiAgcHVibGljIGJpYmxpb2dyYXBoaWNGaWxlSWRlbnRpZmllcigpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl9nZXRTdHJpbmcoNzc2LCAzNyk7XG4gIH1cbiAgcHVibGljIHZvbHVtZUNyZWF0aW9uRGF0ZSgpOiBEYXRlIHtcbiAgICByZXR1cm4gZ2V0RGF0ZSh0aGlzLl9kYXRhLCA4MTMpO1xuICB9XG4gIHB1YmxpYyB2b2x1bWVNb2RpZmljYXRpb25EYXRlKCk6IERhdGUge1xuICAgIHJldHVybiBnZXREYXRlKHRoaXMuX2RhdGEsIDgzMCk7XG4gIH1cbiAgcHVibGljIHZvbHVtZUV4cGlyYXRpb25EYXRlKCk6IERhdGUge1xuICAgIHJldHVybiBnZXREYXRlKHRoaXMuX2RhdGEsIDg0Nyk7XG4gIH1cbiAgcHVibGljIHZvbHVtZUVmZmVjdGl2ZURhdGUoKTogRGF0ZSB7XG4gICAgcmV0dXJuIGdldERhdGUodGhpcy5fZGF0YSwgODY0KTtcbiAgfVxuICBwdWJsaWMgZmlsZVN0cnVjdHVyZVZlcnNpb24oKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YVs4ODFdO1xuICB9XG4gIHB1YmxpYyBhcHBsaWNhdGlvblVzZWQoKTogQnVmZmVyIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YS5zbGljZSg4ODMsIDg4MyArIDUxMik7XG4gIH1cbiAgcHVibGljIHJlc2VydmVkKCk6IEJ1ZmZlciB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGEuc2xpY2UoMTM5NSwgMTM5NSArIDY1Myk7XG4gIH1cbiAgcHVibGljIGFic3RyYWN0IG5hbWUoKTogc3RyaW5nO1xuICBwcm90ZWN0ZWQgYWJzdHJhY3QgX2NvbnN0cnVjdFJvb3REaXJlY3RvcnlSZWNvcmQoZGF0YTogQnVmZmVyKTogRGlyZWN0b3J5UmVjb3JkO1xuICBwcm90ZWN0ZWQgYWJzdHJhY3QgX2dldFN0cmluZyhpZHg6IG51bWJlciwgbGVuOiBudW1iZXIpOiBzdHJpbmc7XG4gIHByb3RlY3RlZCBfZ2V0U3RyaW5nMzIoaWR4OiBudW1iZXIpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl9nZXRTdHJpbmcoaWR4LCAzMik7XG4gIH1cbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIFByaW1hcnlWb2x1bWVEZXNjcmlwdG9yIGV4dGVuZHMgUHJpbWFyeU9yU3VwcGxlbWVudGFyeVZvbHVtZURlc2NyaXB0b3Ige1xuICBjb25zdHJ1Y3RvcihkYXRhOiBCdWZmZXIpIHtcbiAgICBzdXBlcihkYXRhKTtcbiAgICBpZiAodGhpcy50eXBlKCkgIT09IFZvbHVtZURlc2NyaXB0b3JUeXBlQ29kZS5QcmltYXJ5Vm9sdW1lRGVzY3JpcHRvcikge1xuICAgICAgdGhyb3cgbmV3IEFwaUVycm9yKEVycm9yQ29kZS5FSU8sIGBJbnZhbGlkIHByaW1hcnkgdm9sdW1lIGRlc2NyaXB0b3IuYCk7XG4gICAgfVxuICB9XG4gIHB1YmxpYyBuYW1lKCkge1xuICAgIHJldHVybiBcIklTTzk2NjBcIjtcbiAgfVxuICBwcm90ZWN0ZWQgX2NvbnN0cnVjdFJvb3REaXJlY3RvcnlSZWNvcmQoZGF0YTogQnVmZmVyKTogRGlyZWN0b3J5UmVjb3JkIHtcbiAgICByZXR1cm4gbmV3IElTT0RpcmVjdG9yeVJlY29yZChkYXRhLCAtMSk7XG4gIH1cbiAgcHJvdGVjdGVkIF9nZXRTdHJpbmcoaWR4OiBudW1iZXIsIGxlbjogbnVtYmVyKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0U3RyaW5nKGlkeCwgbGVuKTtcbiAgfVxufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgU3VwcGxlbWVudGFyeVZvbHVtZURlc2NyaXB0b3IgZXh0ZW5kcyBQcmltYXJ5T3JTdXBwbGVtZW50YXJ5Vm9sdW1lRGVzY3JpcHRvciB7XG4gIGNvbnN0cnVjdG9yKGRhdGE6IEJ1ZmZlcikge1xuICAgIHN1cGVyKGRhdGEpO1xuICAgIGlmICh0aGlzLnR5cGUoKSAhPT0gVm9sdW1lRGVzY3JpcHRvclR5cGVDb2RlLlN1cHBsZW1lbnRhcnlWb2x1bWVEZXNjcmlwdG9yKSB7XG4gICAgICB0aHJvdyBuZXcgQXBpRXJyb3IoRXJyb3JDb2RlLkVJTywgYEludmFsaWQgc3VwcGxlbWVudGFyeSB2b2x1bWUgZGVzY3JpcHRvci5gKTtcbiAgICB9XG4gICAgY29uc3QgZXNjYXBlU2VxdWVuY2UgPSB0aGlzLmVzY2FwZVNlcXVlbmNlKCk7XG4gICAgY29uc3QgdGhpcmQgPSBlc2NhcGVTZXF1ZW5jZVsyXTtcbiAgICAvLyBUaGlyZCBjaGFyYWN0ZXIgaWRlbnRpZmllcyB3aGF0ICdsZXZlbCcgb2YgdGhlIFVDUyBzcGVjaWZpY2F0aW9uIHRvIGZvbGxvdy5cbiAgICAvLyBXZSBpZ25vcmUgaXQuXG4gICAgaWYgKGVzY2FwZVNlcXVlbmNlWzBdICE9PSAweDI1IHx8IGVzY2FwZVNlcXVlbmNlWzFdICE9PSAweDJGIHx8XG4gICAgICAgKHRoaXJkICE9PSAweDQwICYmIHRoaXJkICE9PSAweDQzICYmIHRoaXJkICE9PSAweDQ1KSkge1xuICAgICAgdGhyb3cgbmV3IEFwaUVycm9yKEVycm9yQ29kZS5FSU8sIGBVbnJlY29nbml6ZWQgZXNjYXBlIHNlcXVlbmNlIGZvciBTdXBwbGVtZW50YXJ5Vm9sdW1lRGVzY3JpcHRvcjogJHtlc2NhcGVTZXF1ZW5jZS50b1N0cmluZygpfWApO1xuICAgIH1cbiAgfVxuICBwdWJsaWMgbmFtZSgpIHtcbiAgICByZXR1cm4gXCJKb2xpZXRcIjtcbiAgfVxuICBwdWJsaWMgZXNjYXBlU2VxdWVuY2UoKTogQnVmZmVyIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YS5zbGljZSg4OCwgMTIwKTtcbiAgfVxuICBwcm90ZWN0ZWQgX2NvbnN0cnVjdFJvb3REaXJlY3RvcnlSZWNvcmQoZGF0YTogQnVmZmVyKTogRGlyZWN0b3J5UmVjb3JkIHtcbiAgICByZXR1cm4gbmV3IEpvbGlldERpcmVjdG9yeVJlY29yZChkYXRhLCAtMSk7XG4gIH1cbiAgcHJvdGVjdGVkIF9nZXRTdHJpbmcoaWR4OiBudW1iZXIsIGxlbjogbnVtYmVyKTogc3RyaW5nIHtcbiAgICByZXR1cm4gZ2V0Sm9saWV0U3RyaW5nKHRoaXMuX2RhdGEsIGlkeCwgbGVuKTtcbiAgfVxufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgZW51bSBGaWxlRmxhZ3Mge1xuICBIaWRkZW4gPSAxLFxuICBEaXJlY3RvcnkgPSAxIDw8IDEsXG4gIEFzc29jaWF0ZWRGaWxlID0gMSA8PCAyLFxuICBFQVJDb250YWluc0luZm8gPSAxIDw8IDMsXG4gIEVBUkNvbnRhaW5zUGVybXMgPSAxIDw8IDQsXG4gIEZpbmFsRGlyZWN0b3J5UmVjb3JkRm9yRmlsZSA9IDEgPDwgNVxufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuYWJzdHJhY3QgY2xhc3MgRGlyZWN0b3J5UmVjb3JkIHtcbiAgcHJvdGVjdGVkIF9kYXRhOiBCdWZmZXI7XG4gIC8vIE9mZnNldCBhdCB3aGljaCBzeXN0ZW0gdXNlIGVudHJpZXMgYmVnaW4uIFNldCB0byAtMSBpZiBub3QgZW5hYmxlZC5cbiAgcHJvdGVjdGVkIF9yb2NrUmlkZ2VPZmZzZXQ6IG51bWJlcjtcbiAgcHJvdGVjdGVkIF9zdUVudHJpZXM6IFN5c3RlbVVzZUVudHJ5W10gfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBfZmlsZU9yRGlyOiBCdWZmZXIgfCBEaXJlY3Rvcnk8RGlyZWN0b3J5UmVjb3JkPiB8IG51bGwgPSBudWxsO1xuICBjb25zdHJ1Y3RvcihkYXRhOiBCdWZmZXIsIHJvY2tSaWRnZU9mZnNldDogbnVtYmVyKSB7XG4gICAgdGhpcy5fZGF0YSA9IGRhdGE7XG4gICAgdGhpcy5fcm9ja1JpZGdlT2Zmc2V0ID0gcm9ja1JpZGdlT2Zmc2V0O1xuICB9XG4gIHB1YmxpYyBoYXNSb2NrUmlkZ2UoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX3JvY2tSaWRnZU9mZnNldCA+IC0xO1xuICB9XG4gIHB1YmxpYyBnZXRSb2NrUmlkZ2VPZmZzZXQoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fcm9ja1JpZGdlT2Zmc2V0O1xuICB9XG4gIC8qKlxuICAgKiAhIU9OTFkgVkFMSUQgT04gUk9PVCBOT0RFISFcbiAgICogQ2hlY2tzIGlmIFJvY2sgUmlkZ2UgaXMgZW5hYmxlZCwgYW5kIHNldHMgdGhlIG9mZnNldC5cbiAgICovXG4gIHB1YmxpYyByb290Q2hlY2tGb3JSb2NrUmlkZ2UoaXNvRGF0YTogQnVmZmVyKTogdm9pZCB7XG4gICAgY29uc3QgZGlyID0gdGhpcy5nZXREaXJlY3RvcnkoaXNvRGF0YSk7XG4gICAgdGhpcy5fcm9ja1JpZGdlT2Zmc2V0ID0gZGlyLmdldERvdEVudHJ5KGlzb0RhdGEpLl9nZXRSb2NrUmlkZ2VPZmZzZXQoaXNvRGF0YSk7XG4gICAgaWYgKHRoaXMuX3JvY2tSaWRnZU9mZnNldCA+IC0xKSB7XG4gICAgICAvLyBXaXBlIG91dCBkaXJlY3RvcnkuIFN0YXJ0IG92ZXIgd2l0aCBSUiBrbm93bGVkZ2UuXG4gICAgICB0aGlzLl9maWxlT3JEaXIgPSBudWxsO1xuICAgIH1cbiAgfVxuICBwdWJsaWMgbGVuZ3RoKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGFbMF07XG4gIH1cbiAgcHVibGljIGV4dGVuZGVkQXR0cmlidXRlUmVjb3JkTGVuZ3RoKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGFbMV07XG4gIH1cbiAgcHVibGljIGxiYSgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLl9kYXRhLnJlYWRVSW50MzJMRSgyKSAqIDIwNDg7XG4gIH1cbiAgcHVibGljIGRhdGFMZW5ndGgoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YS5yZWFkVUludDMyTEUoMTApO1xuICB9XG4gIHB1YmxpYyByZWNvcmRpbmdEYXRlKCk6IERhdGUge1xuICAgIHJldHVybiBnZXRTaG9ydEZvcm1EYXRlKHRoaXMuX2RhdGEsIDE4KTtcbiAgfVxuICBwdWJsaWMgZmlsZUZsYWdzKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGFbMjVdO1xuICB9XG4gIHB1YmxpYyBmaWxlVW5pdFNpemUoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YVsyNl07XG4gIH1cbiAgcHVibGljIGludGVybGVhdmVHYXBTaXplKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGFbMjddO1xuICB9XG4gIHB1YmxpYyB2b2x1bWVTZXF1ZW5jZU51bWJlcigpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLl9kYXRhLnJlYWRVSW50MTZMRSgyOCk7XG4gIH1cbiAgcHVibGljIGlkZW50aWZpZXIoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0U3RyaW5nKDMzLCB0aGlzLl9kYXRhWzMyXSk7XG4gIH1cbiAgcHVibGljIGZpbGVOYW1lKGlzb0RhdGE6IEJ1ZmZlcik6IHN0cmluZyB7XG4gICAgaWYgKHRoaXMuaGFzUm9ja1JpZGdlKCkpIHtcbiAgICAgIGNvbnN0IGZuID0gdGhpcy5fcm9ja1JpZGdlRmlsZW5hbWUoaXNvRGF0YSk7XG4gICAgICBpZiAoZm4gIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZuO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBpZGVudCA9IHRoaXMuaWRlbnRpZmllcigpO1xuICAgIGlmICh0aGlzLmlzRGlyZWN0b3J5KGlzb0RhdGEpKSB7XG4gICAgICByZXR1cm4gaWRlbnQ7XG4gICAgfVxuICAgIC8vIEZpbGVzOlxuICAgIC8vIC0gTVVTVCBoYXZlIDB4MkUgKC4pIHNlcGFyYXRpbmcgdGhlIG5hbWUgZnJvbSB0aGUgZXh0ZW5zaW9uXG4gICAgLy8gLSBNVVNUIGhhdmUgMHgzQiAoOykgc2VwYXJhdGluZyB0aGUgZmlsZSBuYW1lIGFuZCBleHRlbnNpb24gZnJvbSB0aGUgdmVyc2lvblxuICAgIC8vIEdldHMgZXhwYW5kZWQgdG8gdHdvLWJ5dGUgY2hhciBpbiBVbmljb2RlIGRpcmVjdG9yeSByZWNvcmRzLlxuICAgIGNvbnN0IHZlcnNpb25TZXBhcmF0b3IgPSBpZGVudC5pbmRleE9mKCc7Jyk7XG4gICAgaWYgKHZlcnNpb25TZXBhcmF0b3IgPT09IC0xKSB7XG4gICAgICAvLyBTb21lIEpvbGlldCBmaWxlbmFtZXMgbGFjayB0aGUgdmVyc2lvbiBzZXBhcmF0b3IsIGRlc3BpdGUgdGhlIHN0YW5kYXJkXG4gICAgICAvLyBzcGVjaWZ5aW5nIHRoYXQgaXQgc2hvdWxkIGJlIHRoZXJlLlxuICAgICAgcmV0dXJuIGlkZW50O1xuICAgIH0gZWxzZSBpZiAoaWRlbnRbdmVyc2lvblNlcGFyYXRvciAtIDFdID09PSAnLicpIHtcbiAgICAgIC8vIEVtcHR5IGV4dGVuc2lvbi4gRG8gbm90IGluY2x1ZGUgJy4nIGluIHRoZSBmaWxlbmFtZS5cbiAgICAgIHJldHVybiBpZGVudC5zbGljZSgwLCB2ZXJzaW9uU2VwYXJhdG9yIC0gMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEluY2x1ZGUgdXAgdG8gdmVyc2lvbiBzZXBhcmF0b3IuXG4gICAgICByZXR1cm4gaWRlbnQuc2xpY2UoMCwgdmVyc2lvblNlcGFyYXRvcik7XG4gICAgfVxuICB9XG4gIHB1YmxpYyBpc0RpcmVjdG9yeShpc29EYXRhOiBCdWZmZXIpOiBib29sZWFuIHtcbiAgICBsZXQgcnYgPSAhISh0aGlzLmZpbGVGbGFncygpICYgRmlsZUZsYWdzLkRpcmVjdG9yeSk7XG4gICAgLy8gSWYgaXQgbGFja3MgdGhlIERpcmVjdG9yeSBmbGFnLCBpdCBtYXkgc3RpbGwgYmUgYSBkaXJlY3RvcnkgaWYgd2UndmUgZXhjZWVkZWQgdGhlIGRpcmVjdG9yeVxuICAgIC8vIGRlcHRoIGxpbWl0LiBSb2NrIFJpZGdlIG1hcmtzIHRoZXNlIGFzIGZpbGVzIGFuZCBhZGRzIGEgc3BlY2lhbCBhdHRyaWJ1dGUuXG4gICAgaWYgKCFydiAmJiB0aGlzLmhhc1JvY2tSaWRnZSgpKSB7XG4gICAgICBydiA9IHRoaXMuZ2V0U1VFbnRyaWVzKGlzb0RhdGEpLmZpbHRlcigoZSkgPT4gZSBpbnN0YW5jZW9mIENMRW50cnkpLmxlbmd0aCA+IDA7XG4gICAgfVxuICAgIHJldHVybiBydjtcbiAgfVxuICBwdWJsaWMgaXNTeW1saW5rKGlzb0RhdGE6IEJ1ZmZlcik6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmhhc1JvY2tSaWRnZSgpICYmIHRoaXMuZ2V0U1VFbnRyaWVzKGlzb0RhdGEpLmZpbHRlcigoZSkgPT4gZSBpbnN0YW5jZW9mIFNMRW50cnkpLmxlbmd0aCA+IDA7XG4gIH1cbiAgcHVibGljIGdldFN5bWxpbmtQYXRoKGlzb0RhdGE6IEJ1ZmZlcik6IHN0cmluZyB7XG4gICAgbGV0IHAgPSBcIlwiO1xuICAgIGNvbnN0IGVudHJpZXMgPSB0aGlzLmdldFNVRW50cmllcyhpc29EYXRhKTtcbiAgICBjb25zdCBnZXRTdHIgPSB0aGlzLl9nZXRHZXRTdHJpbmcoKTtcbiAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJpZXMpIHtcbiAgICAgIGlmIChlbnRyeSBpbnN0YW5jZW9mIFNMRW50cnkpIHtcbiAgICAgICAgY29uc3QgY29tcG9uZW50cyA9IGVudHJ5LmNvbXBvbmVudFJlY29yZHMoKTtcbiAgICAgICAgZm9yIChjb25zdCBjb21wb25lbnQgb2YgY29tcG9uZW50cykge1xuICAgICAgICAgIGNvbnN0IGZsYWdzID0gY29tcG9uZW50LmZsYWdzKCk7XG4gICAgICAgICAgaWYgKGZsYWdzICYgU0xDb21wb25lbnRGbGFncy5DVVJSRU5UKSB7XG4gICAgICAgICAgICBwICs9IFwiLi9cIjtcbiAgICAgICAgICB9IGVsc2UgaWYgKGZsYWdzICYgU0xDb21wb25lbnRGbGFncy5QQVJFTlQpIHtcbiAgICAgICAgICAgIHAgKz0gXCIuLi9cIjtcbiAgICAgICAgICB9IGVsc2UgaWYgKGZsYWdzICYgU0xDb21wb25lbnRGbGFncy5ST09UKSB7XG4gICAgICAgICAgICBwICs9IFwiL1wiO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwICs9IGNvbXBvbmVudC5jb250ZW50KGdldFN0cik7XG4gICAgICAgICAgICBpZiAoIShmbGFncyAmIFNMQ29tcG9uZW50RmxhZ3MuQ09OVElOVUUpKSB7XG4gICAgICAgICAgICAgIHAgKz0gJy8nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWVudHJ5LmNvbnRpbnVlRmxhZygpKSB7XG4gICAgICAgICAgLy8gV2UgYXJlIGRvbmUgd2l0aCB0aGlzIGxpbmsuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHAubGVuZ3RoID4gMSAmJiBwW3AubGVuZ3RoIC0gMV0gPT09ICcvJykge1xuICAgICAgLy8gVHJpbSB0cmFpbGluZyAnLycuXG4gICAgICByZXR1cm4gcC5zbGljZSgwLCBwLmxlbmd0aCAtIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcDtcbiAgICB9XG4gIH1cbiAgcHVibGljIGdldEZpbGUoaXNvRGF0YTogQnVmZmVyKTogQnVmZmVyIHtcbiAgICBpZiAodGhpcy5pc0RpcmVjdG9yeShpc29EYXRhKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUcmllZCB0byBnZXQgYSBGaWxlIGZyb20gYSBkaXJlY3RvcnkuYCk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9maWxlT3JEaXIgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuX2ZpbGVPckRpciA9IGlzb0RhdGEuc2xpY2UodGhpcy5sYmEoKSwgdGhpcy5sYmEoKSArIHRoaXMuZGF0YUxlbmd0aCgpKTtcbiAgICB9XG4gICAgcmV0dXJuIDxCdWZmZXI+IHRoaXMuX2ZpbGVPckRpcjtcbiAgfVxuICBwdWJsaWMgZ2V0RGlyZWN0b3J5KGlzb0RhdGE6IEJ1ZmZlcik6IERpcmVjdG9yeTxEaXJlY3RvcnlSZWNvcmQ+IHtcbiAgICBpZiAoIXRoaXMuaXNEaXJlY3RvcnkoaXNvRGF0YSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVHJpZWQgdG8gZ2V0IGEgRGlyZWN0b3J5IGZyb20gYSBmaWxlLmApO1xuICAgIH1cbiAgICBpZiAodGhpcy5fZmlsZU9yRGlyID09PSBudWxsKSB7XG4gICAgICB0aGlzLl9maWxlT3JEaXIgPSB0aGlzLl9jb25zdHJ1Y3REaXJlY3RvcnkoaXNvRGF0YSk7XG4gICAgfVxuICAgIHJldHVybiA8RGlyZWN0b3J5PHRoaXM+PiB0aGlzLl9maWxlT3JEaXI7XG4gIH1cbiAgcHVibGljIGdldFNVRW50cmllcyhpc29EYXRhOiBCdWZmZXIpOiBTeXN0ZW1Vc2VFbnRyeVtdIHtcbiAgICBpZiAoIXRoaXMuX3N1RW50cmllcykge1xuICAgICAgdGhpcy5fY29uc3RydWN0U1VFbnRyaWVzKGlzb0RhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fc3VFbnRyaWVzITtcbiAgfVxuICBwcm90ZWN0ZWQgYWJzdHJhY3QgX2dldFN0cmluZyhpOiBudW1iZXIsIGxlbjogbnVtYmVyKTogc3RyaW5nO1xuICBwcm90ZWN0ZWQgYWJzdHJhY3QgX2dldEdldFN0cmluZygpOiBUR2V0U3RyaW5nO1xuICBwcm90ZWN0ZWQgYWJzdHJhY3QgX2NvbnN0cnVjdERpcmVjdG9yeShpc29EYXRhOiBCdWZmZXIpOiBEaXJlY3Rvcnk8RGlyZWN0b3J5UmVjb3JkPjtcbiAgcHJvdGVjdGVkIF9yb2NrUmlkZ2VGaWxlbmFtZShpc29EYXRhOiBCdWZmZXIpOiBzdHJpbmcgfCBudWxsIHtcbiAgICBjb25zdCBubUVudHJpZXMgPSA8Tk1FbnRyeVtdPiB0aGlzLmdldFNVRW50cmllcyhpc29EYXRhKS5maWx0ZXIoKGUpID0+IGUgaW5zdGFuY2VvZiBOTUVudHJ5KTtcbiAgICBpZiAobm1FbnRyaWVzLmxlbmd0aCA9PT0gMCB8fCBubUVudHJpZXNbMF0uZmxhZ3MoKSAmIChOTUZsYWdzLkNVUlJFTlQgfCBOTUZsYWdzLlBBUkVOVCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBsZXQgc3RyID0gJyc7XG4gICAgY29uc3QgZ2V0U3RyaW5nID0gdGhpcy5fZ2V0R2V0U3RyaW5nKCk7XG4gICAgZm9yIChjb25zdCBlIG9mIG5tRW50cmllcykge1xuICAgICAgc3RyICs9IGUubmFtZShnZXRTdHJpbmcpO1xuICAgICAgaWYgKCEoZS5mbGFncygpICYgTk1GbGFncy5DT05USU5VRSkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG4gIH1cbiAgcHJpdmF0ZSBfY29uc3RydWN0U1VFbnRyaWVzKGlzb0RhdGE6IEJ1ZmZlcik6IHZvaWQge1xuICAgIGxldCBpID0gMzMgKyB0aGlzLl9kYXRhWzMyXTtcbiAgICBpZiAoaSAlIDIgPT09IDEpIHtcbiAgICAgIC8vIFNraXAgcGFkZGluZyBmaWVsZC5cbiAgICAgIGkrKztcbiAgICB9XG4gICAgaSArPSB0aGlzLl9yb2NrUmlkZ2VPZmZzZXQ7XG4gICAgdGhpcy5fc3VFbnRyaWVzID0gY29uc3RydWN0U3lzdGVtVXNlRW50cmllcyh0aGlzLl9kYXRhLCBpLCB0aGlzLmxlbmd0aCgpLCBpc29EYXRhKTtcbiAgfVxuICAvKipcbiAgICogISFPTkxZIFZBTElEIE9OIEZJUlNUIEVOVFJZIE9GIFJPT1QgRElSRUNUT1JZISFcbiAgICogUmV0dXJucyAtMSBpZiByb2NrIHJpZGdlIGlzIG5vdCBlbmFibGVkLiBPdGhlcndpc2UsIHJldHVybnMgdGhlIG9mZnNldFxuICAgKiBhdCB3aGljaCBzeXN0ZW0gdXNlIGZpZWxkcyBiZWdpbi5cbiAgICovXG4gIHByaXZhdGUgX2dldFJvY2tSaWRnZU9mZnNldChpc29EYXRhOiBCdWZmZXIpOiBudW1iZXIge1xuICAgIC8vIEluIHRoZSB3b3JzdCBjYXNlLCB3ZSBnZXQgc29tZSBnYXJiYWdlIFNVIGVudHJpZXMuXG4gICAgLy8gRnVkZ2Ugb2Zmc2V0IHRvIDAgYmVmb3JlIHByb2NlZWRpbmcuXG4gICAgdGhpcy5fcm9ja1JpZGdlT2Zmc2V0ID0gMDtcbiAgICBjb25zdCBzdUVudHJpZXMgPSB0aGlzLmdldFNVRW50cmllcyhpc29EYXRhKTtcbiAgICBpZiAoc3VFbnRyaWVzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHNwRW50cnkgPSBzdUVudHJpZXNbMF07XG4gICAgICBpZiAoc3BFbnRyeSBpbnN0YW5jZW9mIFNQRW50cnkgJiYgc3BFbnRyeS5jaGVja0J5dGVzUGFzcygpKSB7XG4gICAgICAgIC8vIFNVU1AgaXMgaW4gdXNlLlxuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHN1RW50cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGVudHJ5ID0gc3VFbnRyaWVzW2ldO1xuICAgICAgICAgIGlmIChlbnRyeSBpbnN0YW5jZW9mIFJSRW50cnkgfHwgKGVudHJ5IGluc3RhbmNlb2YgRVJFbnRyeSAmJiBlbnRyeS5leHRlbnNpb25JZGVudGlmaWVyKCkgPT09IHJvY2tSaWRnZUlkZW50aWZpZXIpKSB7XG4gICAgICAgICAgICAvLyBSb2NrIFJpZGdlIGlzIGluIHVzZSFcbiAgICAgICAgICAgIHJldHVybiBzcEVudHJ5LmJ5dGVzU2tpcHBlZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBGYWlsZWQuXG4gICAgdGhpcy5fcm9ja1JpZGdlT2Zmc2V0ID0gLTE7XG4gICAgcmV0dXJuIC0xO1xuICB9XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBJU09EaXJlY3RvcnlSZWNvcmQgZXh0ZW5kcyBEaXJlY3RvcnlSZWNvcmQge1xuICBjb25zdHJ1Y3RvcihkYXRhOiBCdWZmZXIsIHJvY2tSaWRnZU9mZnNldDogbnVtYmVyKSB7XG4gICAgc3VwZXIoZGF0YSwgcm9ja1JpZGdlT2Zmc2V0KTtcbiAgfVxuICBwcm90ZWN0ZWQgX2dldFN0cmluZyhpOiBudW1iZXIsIGxlbjogbnVtYmVyKTogc3RyaW5nIHtcbiAgICByZXR1cm4gZ2V0QVNDSUlTdHJpbmcodGhpcy5fZGF0YSwgaSwgbGVuKTtcbiAgfVxuICBwcm90ZWN0ZWQgX2NvbnN0cnVjdERpcmVjdG9yeShpc29EYXRhOiBCdWZmZXIpOiBEaXJlY3Rvcnk8RGlyZWN0b3J5UmVjb3JkPiB7XG4gICAgcmV0dXJuIG5ldyBJU09EaXJlY3RvcnkodGhpcywgaXNvRGF0YSk7XG4gIH1cbiAgcHJvdGVjdGVkIF9nZXRHZXRTdHJpbmcoKTogVEdldFN0cmluZyB7XG4gICAgcmV0dXJuIGdldEFTQ0lJU3RyaW5nO1xuICB9XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBKb2xpZXREaXJlY3RvcnlSZWNvcmQgZXh0ZW5kcyBEaXJlY3RvcnlSZWNvcmQge1xuICBjb25zdHJ1Y3RvcihkYXRhOiBCdWZmZXIsIHJvY2tSaWRnZU9mZnNldDogbnVtYmVyKSB7XG4gICAgc3VwZXIoZGF0YSwgcm9ja1JpZGdlT2Zmc2V0KTtcbiAgfVxuICBwcm90ZWN0ZWQgX2dldFN0cmluZyhpOiBudW1iZXIsIGxlbjogbnVtYmVyKTogc3RyaW5nIHtcbiAgICByZXR1cm4gZ2V0Sm9saWV0U3RyaW5nKHRoaXMuX2RhdGEsIGksIGxlbik7XG4gIH1cbiAgcHJvdGVjdGVkIF9jb25zdHJ1Y3REaXJlY3RvcnkoaXNvRGF0YTogQnVmZmVyKTogRGlyZWN0b3J5PERpcmVjdG9yeVJlY29yZD4ge1xuICAgIHJldHVybiBuZXcgSm9saWV0RGlyZWN0b3J5KHRoaXMsIGlzb0RhdGEpO1xuICB9XG4gIHByb3RlY3RlZCBfZ2V0R2V0U3RyaW5nKCk6IFRHZXRTdHJpbmcge1xuICAgIHJldHVybiBnZXRKb2xpZXRTdHJpbmc7XG4gIH1cbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGVudW0gU3lzdGVtVXNlRW50cnlTaWduYXR1cmVzIHtcbiAgQ0UgPSAweDQzNDUsXG4gIFBEID0gMHg1MDQ0LFxuICBTUCA9IDB4NTM1MCxcbiAgU1QgPSAweDUzNTQsXG4gIEVSID0gMHg0NTUyLFxuICBFUyA9IDB4NDU1MyxcbiAgUFggPSAweDUwNTgsXG4gIFBOID0gMHg1MDRFLFxuICBTTCA9IDB4NTM0QyxcbiAgTk0gPSAweDRFNEQsXG4gIENMID0gMHg0MzRDLFxuICBQTCA9IDB4NTA0QyxcbiAgUkUgPSAweDUyNDUsXG4gIFRGID0gMHg1NDQ2LFxuICBTRiA9IDB4NTM0NixcbiAgUlIgPSAweDUyNTJcbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIFN5c3RlbVVzZUVudHJ5IHtcbiAgcHJvdGVjdGVkIF9kYXRhOiBCdWZmZXI7XG4gIGNvbnN0cnVjdG9yKGRhdGE6IEJ1ZmZlcikge1xuICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xuICB9XG4gIHB1YmxpYyBzaWduYXR1cmVXb3JkKCk6IFN5c3RlbVVzZUVudHJ5U2lnbmF0dXJlcyB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGEucmVhZFVJbnQxNkJFKDApO1xuICB9XG4gIHB1YmxpYyBzaWduYXR1cmVXb3JkU3RyaW5nKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGdldEFTQ0lJU3RyaW5nKHRoaXMuX2RhdGEsIDAsIDIpO1xuICB9XG4gIHB1YmxpYyBsZW5ndGgoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YVsyXTtcbiAgfVxuICBwdWJsaWMgc3VWZXJzaW9uKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGFbM107XG4gIH1cbn1cblxuLyoqXG4gKiBDb250aW51YXRpb24gZW50cnkuXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIENFRW50cnkgZXh0ZW5kcyBTeXN0ZW1Vc2VFbnRyeSB7XG4gIHByaXZhdGUgX2VudHJpZXM6IFN5c3RlbVVzZUVudHJ5W10gfCBudWxsID0gbnVsbDtcbiAgY29uc3RydWN0b3IoZGF0YTogQnVmZmVyKSB7XG4gICAgc3VwZXIoZGF0YSk7XG4gIH1cbiAgLyoqXG4gICAqIExvZ2ljYWwgYmxvY2sgYWRkcmVzcyBvZiB0aGUgY29udGludWF0aW9uIGFyZWEuXG4gICAqL1xuICBwdWJsaWMgY29udGludWF0aW9uTGJhKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGEucmVhZFVJbnQzMkxFKDQpO1xuICB9XG4gIC8qKlxuICAgKiBPZmZzZXQgaW50byB0aGUgbG9naWNhbCBibG9jay5cbiAgICovXG4gIHB1YmxpYyBjb250aW51YXRpb25MYmFPZmZzZXQoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YS5yZWFkVUludDMyTEUoMTIpO1xuICB9XG4gIC8qKlxuICAgKiBMZW5ndGggb2YgdGhlIGNvbnRpbnVhdGlvbiBhcmVhLlxuICAgKi9cbiAgcHVibGljIGNvbnRpbnVhdGlvbkxlbmd0aCgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLl9kYXRhLnJlYWRVSW50MzJMRSgyMCk7XG4gIH1cbiAgcHVibGljIGdldEVudHJpZXMoaXNvRGF0YTogQnVmZmVyKTogU3lzdGVtVXNlRW50cnlbXSB7XG4gICAgaWYgKCF0aGlzLl9lbnRyaWVzKSB7XG4gICAgICBjb25zdCBzdGFydCA9IHRoaXMuY29udGludWF0aW9uTGJhKCkgKiAyMDQ4ICsgdGhpcy5jb250aW51YXRpb25MYmFPZmZzZXQoKTtcbiAgICAgIHRoaXMuX2VudHJpZXMgPSBjb25zdHJ1Y3RTeXN0ZW1Vc2VFbnRyaWVzKGlzb0RhdGEsIHN0YXJ0LCB0aGlzLmNvbnRpbnVhdGlvbkxlbmd0aCgpLCBpc29EYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2VudHJpZXM7XG4gIH1cbn1cblxuLyoqXG4gKiBQYWRkaW5nIGVudHJ5LlxuICogQGhpZGRlblxuICovXG5jbGFzcyBQREVudHJ5IGV4dGVuZHMgU3lzdGVtVXNlRW50cnkge1xuICBjb25zdHJ1Y3RvcihkYXRhOiBCdWZmZXIpIHtcbiAgICBzdXBlcihkYXRhKTtcbiAgfVxufVxuXG4vKipcbiAqIElkZW50aWZpZXMgdGhhdCBTVVNQIGlzIGluLXVzZS5cbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgU1BFbnRyeSBleHRlbmRzIFN5c3RlbVVzZUVudHJ5IHtcbiAgY29uc3RydWN0b3IoZGF0YTogQnVmZmVyKSB7XG4gICAgc3VwZXIoZGF0YSk7XG4gIH1cbiAgcHVibGljIGNoZWNrQnl0ZXNQYXNzKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9kYXRhWzRdID09PSAweEJFICYmIHRoaXMuX2RhdGFbNV0gPT09IDB4RUY7XG4gIH1cbiAgcHVibGljIGJ5dGVzU2tpcHBlZCgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLl9kYXRhWzZdO1xuICB9XG59XG5cbi8qKlxuICogSWRlbnRpZmllcyB0aGUgZW5kIG9mIHRoZSBTVVNQIGVudHJpZXMuXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIFNURW50cnkgZXh0ZW5kcyBTeXN0ZW1Vc2VFbnRyeSB7XG4gIGNvbnN0cnVjdG9yKGRhdGE6IEJ1ZmZlcikge1xuICAgIHN1cGVyKGRhdGEpO1xuICB9XG59XG5cbi8qKlxuICogU3BlY2lmaWVzIHN5c3RlbS1zcGVjaWZpYyBleHRlbnNpb25zIHRvIFNVU1AuXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIEVSRW50cnkgZXh0ZW5kcyBTeXN0ZW1Vc2VFbnRyeSB7XG4gIGNvbnN0cnVjdG9yKGRhdGE6IEJ1ZmZlcikge1xuICAgIHN1cGVyKGRhdGEpO1xuICB9XG4gIHB1YmxpYyBpZGVudGlmaWVyTGVuZ3RoKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGFbNF07XG4gIH1cbiAgcHVibGljIGRlc2NyaXB0b3JMZW5ndGgoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YVs1XTtcbiAgfVxuICBwdWJsaWMgc291cmNlTGVuZ3RoKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGFbNl07XG4gIH1cbiAgcHVibGljIGV4dGVuc2lvblZlcnNpb24oKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YVs3XTtcbiAgfVxuICBwdWJsaWMgZXh0ZW5zaW9uSWRlbnRpZmllcigpOiBzdHJpbmcge1xuICAgIHJldHVybiBnZXRBU0NJSVN0cmluZyh0aGlzLl9kYXRhLCA4LCB0aGlzLmlkZW50aWZpZXJMZW5ndGgoKSk7XG4gIH1cbiAgcHVibGljIGV4dGVuc2lvbkRlc2NyaXB0b3IoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gZ2V0QVNDSUlTdHJpbmcodGhpcy5fZGF0YSwgOCArIHRoaXMuaWRlbnRpZmllckxlbmd0aCgpLCB0aGlzLmRlc2NyaXB0b3JMZW5ndGgoKSk7XG4gIH1cbiAgcHVibGljIGV4dGVuc2lvblNvdXJjZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiBnZXRBU0NJSVN0cmluZyh0aGlzLl9kYXRhLCA4ICsgdGhpcy5pZGVudGlmaWVyTGVuZ3RoKCkgKyB0aGlzLmRlc2NyaXB0b3JMZW5ndGgoKSwgdGhpcy5zb3VyY2VMZW5ndGgoKSk7XG4gIH1cbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIEVTRW50cnkgZXh0ZW5kcyBTeXN0ZW1Vc2VFbnRyeSB7XG4gIGNvbnN0cnVjdG9yKGRhdGE6IEJ1ZmZlcikge1xuICAgIHN1cGVyKGRhdGEpO1xuICB9XG4gIHB1YmxpYyBleHRlbnNpb25TZXF1ZW5jZSgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLl9kYXRhWzRdO1xuICB9XG59XG5cbi8qKlxuICogUm9ja1JpZGdlOiBNYXJrcyB0aGF0IFJvY2tSaWRnZSBpcyBpbiB1c2UgW2RlcHJlY2F0ZWRdXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIFJSRW50cnkgZXh0ZW5kcyBTeXN0ZW1Vc2VFbnRyeSB7XG4gIGNvbnN0cnVjdG9yKGRhdGE6IEJ1ZmZlcikge1xuICAgIHN1cGVyKGRhdGEpO1xuICB9XG59XG5cbi8qKlxuICogUm9ja1JpZGdlOiBSZWNvcmRzIFBPU0lYIGZpbGUgYXR0cmlidXRlcy5cbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgUFhFbnRyeSBleHRlbmRzIFN5c3RlbVVzZUVudHJ5IHtcbiAgY29uc3RydWN0b3IoZGF0YTogQnVmZmVyKSB7XG4gICAgc3VwZXIoZGF0YSk7XG4gIH1cbiAgcHVibGljIG1vZGUoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YS5yZWFkVUludDMyTEUoNCk7XG4gIH1cbiAgcHVibGljIGZpbGVMaW5rcygpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLl9kYXRhLnJlYWRVSW50MzJMRSgxMik7XG4gIH1cbiAgcHVibGljIHVpZCgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLl9kYXRhLnJlYWRVSW50MzJMRSgyMCk7XG4gIH1cbiAgcHVibGljIGdpZCgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLl9kYXRhLnJlYWRVSW50MzJMRSgyOCk7XG4gIH1cbiAgcHVibGljIGlub2RlKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGEucmVhZFVJbnQzMkxFKDM2KTtcbiAgfVxufVxuXG4vKipcbiAqIFJvY2tSaWRnZTogUmVjb3JkcyBQT1NJWCBkZXZpY2UgbnVtYmVyLlxuICogQGhpZGRlblxuICovXG5jbGFzcyBQTkVudHJ5IGV4dGVuZHMgU3lzdGVtVXNlRW50cnkge1xuICBjb25zdHJ1Y3RvcihkYXRhOiBCdWZmZXIpIHtcbiAgICBzdXBlcihkYXRhKTtcbiAgfVxuICBwdWJsaWMgZGV2VEhpZ2goKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YS5yZWFkVUludDMyTEUoNCk7XG4gIH1cbiAgcHVibGljIGRldlRMb3coKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YS5yZWFkVUludDMyTEUoMTIpO1xuICB9XG59XG5cbi8qKlxuICogUm9ja1JpZGdlOiBSZWNvcmRzIHN5bWJvbGljIGxpbmtcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgU0xFbnRyeSBleHRlbmRzIFN5c3RlbVVzZUVudHJ5IHtcbiAgY29uc3RydWN0b3IoZGF0YTogQnVmZmVyKSB7XG4gICAgc3VwZXIoZGF0YSk7XG4gIH1cbiAgcHVibGljIGZsYWdzKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGFbNF07XG4gIH1cbiAgcHVibGljIGNvbnRpbnVlRmxhZygpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmZsYWdzKCkgJiAweDE7XG4gIH1cbiAgcHVibGljIGNvbXBvbmVudFJlY29yZHMoKTogU0xDb21wb25lbnRSZWNvcmRbXSB7XG4gICAgY29uc3QgcmVjb3JkcyA9IG5ldyBBcnJheTxTTENvbXBvbmVudFJlY29yZD4oKTtcbiAgICBsZXQgaSA9IDU7XG4gICAgd2hpbGUgKGkgPCB0aGlzLmxlbmd0aCgpKSB7XG4gICAgICBjb25zdCByZWNvcmQgPSBuZXcgU0xDb21wb25lbnRSZWNvcmQodGhpcy5fZGF0YS5zbGljZShpKSk7XG4gICAgICByZWNvcmRzLnB1c2gocmVjb3JkKTtcbiAgICAgIGkgKz0gcmVjb3JkLmxlbmd0aCgpO1xuICAgIH1cbiAgICByZXR1cm4gcmVjb3JkcztcbiAgfVxufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgZW51bSBTTENvbXBvbmVudEZsYWdzIHtcbiAgQ09OVElOVUUgPSAxLFxuICBDVVJSRU5UID0gMSA8PCAxLFxuICBQQVJFTlQgPSAxIDw8IDIsXG4gIFJPT1QgPSAxIDw8IDNcbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIFNMQ29tcG9uZW50UmVjb3JkIHtcbiAgcHJpdmF0ZSBfZGF0YTogQnVmZmVyO1xuICBjb25zdHJ1Y3RvcihkYXRhOiBCdWZmZXIpIHtcbiAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgfVxuICBwdWJsaWMgZmxhZ3MoKTogU0xDb21wb25lbnRGbGFncyB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGFbMF07XG4gIH1cbiAgcHVibGljIGxlbmd0aCgpOiBudW1iZXIge1xuICAgIHJldHVybiAyICsgdGhpcy5jb21wb25lbnRMZW5ndGgoKTtcbiAgfVxuICBwdWJsaWMgY29tcG9uZW50TGVuZ3RoKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGFbMV07XG4gIH1cbiAgcHVibGljIGNvbnRlbnQoZ2V0U3RyaW5nOiBUR2V0U3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gZ2V0U3RyaW5nKHRoaXMuX2RhdGEsIDIsIHRoaXMuY29tcG9uZW50TGVuZ3RoKCkpO1xuICB9XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBlbnVtIE5NRmxhZ3Mge1xuICBDT05USU5VRSA9IDEsXG4gIENVUlJFTlQgPSAxIDw8IDEsXG4gIFBBUkVOVCA9IDEgPDwgMlxufVxuXG4vKipcbiAqIFJvY2tSaWRnZTogUmVjb3JkcyBhbHRlcm5hdGUgZmlsZSBuYW1lXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIE5NRW50cnkgZXh0ZW5kcyBTeXN0ZW1Vc2VFbnRyeSB7XG4gIGNvbnN0cnVjdG9yKGRhdGE6IEJ1ZmZlcikge1xuICAgIHN1cGVyKGRhdGEpO1xuICB9XG4gIHB1YmxpYyBmbGFncygpOiBOTUZsYWdzIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YVs0XTtcbiAgfVxuICBwdWJsaWMgbmFtZShnZXRTdHJpbmc6IFRHZXRTdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiBnZXRTdHJpbmcodGhpcy5fZGF0YSwgNSwgdGhpcy5sZW5ndGgoKSAtIDUpO1xuICB9XG59XG5cbi8qKlxuICogUm9ja1JpZGdlOiBSZWNvcmRzIGNoaWxkIGxpbmtcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgQ0xFbnRyeSBleHRlbmRzIFN5c3RlbVVzZUVudHJ5IHtcbiAgY29uc3RydWN0b3IoZGF0YTogQnVmZmVyKSB7XG4gICAgc3VwZXIoZGF0YSk7XG4gIH1cbiAgcHVibGljIGNoaWxkRGlyZWN0b3J5TGJhKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGEucmVhZFVJbnQzMkxFKDQpO1xuICB9XG59XG5cbi8qKlxuICogUm9ja1JpZGdlOiBSZWNvcmRzIHBhcmVudCBsaW5rLlxuICogQGhpZGRlblxuICovXG5jbGFzcyBQTEVudHJ5IGV4dGVuZHMgU3lzdGVtVXNlRW50cnkge1xuICBjb25zdHJ1Y3RvcihkYXRhOiBCdWZmZXIpIHtcbiAgICBzdXBlcihkYXRhKTtcbiAgfVxuICBwdWJsaWMgcGFyZW50RGlyZWN0b3J5TGJhKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGEucmVhZFVJbnQzMkxFKDQpO1xuICB9XG59XG5cbi8qKlxuICogUm9ja1JpZGdlOiBSZWNvcmRzIHJlbG9jYXRlZCBkaXJlY3RvcnkuXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIFJFRW50cnkgZXh0ZW5kcyBTeXN0ZW1Vc2VFbnRyeSB7XG4gIGNvbnN0cnVjdG9yKGRhdGE6IEJ1ZmZlcikge1xuICAgIHN1cGVyKGRhdGEpO1xuICB9XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBlbnVtIFRGRmxhZ3Mge1xuICBDUkVBVElPTiA9IDEsXG4gIE1PRElGWSA9IDEgPDwgMSxcbiAgQUNDRVNTID0gMSA8PCAyLFxuICBBVFRSSUJVVEVTID0gMSA8PCAzLFxuICBCQUNLVVAgPSAxIDw8IDQsXG4gIEVYUElSQVRJT04gPSAxIDw8IDUsXG4gIEVGRkVDVElWRSA9IDEgPDwgNixcbiAgTE9OR19GT1JNID0gMSA8PCA3XG59XG5cbi8qKlxuICogUm9ja1JpZGdlOiBSZWNvcmRzIGZpbGUgdGltZXN0YW1wc1xuICogQGhpZGRlblxuICovXG5jbGFzcyBURkVudHJ5IGV4dGVuZHMgU3lzdGVtVXNlRW50cnkge1xuICBjb25zdHJ1Y3RvcihkYXRhOiBCdWZmZXIpIHtcbiAgICBzdXBlcihkYXRhKTtcbiAgfVxuICBwdWJsaWMgZmxhZ3MoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YVs0XTtcbiAgfVxuICBwdWJsaWMgY3JlYXRpb24oKTogRGF0ZSB8IG51bGwge1xuICAgIGlmICh0aGlzLmZsYWdzKCkgJiBURkZsYWdzLkNSRUFUSU9OKSB7XG4gICAgICBpZiAodGhpcy5fbG9uZ0Zvcm1EYXRlcygpKSB7XG4gICAgICAgIHJldHVybiBnZXREYXRlKHRoaXMuX2RhdGEsIDUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGdldFNob3J0Rm9ybURhdGUodGhpcy5fZGF0YSwgNSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICBwdWJsaWMgbW9kaWZ5KCk6IERhdGUgfCBudWxsIHtcbiAgICBpZiAodGhpcy5mbGFncygpICYgVEZGbGFncy5NT0RJRlkpIHtcbiAgICAgIGNvbnN0IHByZXZpb3VzRGF0ZXMgPSAodGhpcy5mbGFncygpICYgVEZGbGFncy5DUkVBVElPTikgPyAxIDogMDtcbiAgICAgIGlmICh0aGlzLl9sb25nRm9ybURhdGVzKSB7XG4gICAgICAgIHJldHVybiBnZXREYXRlKHRoaXMuX2RhdGEsIDUgKyAocHJldmlvdXNEYXRlcyAqIDE3KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZ2V0U2hvcnRGb3JtRGF0ZSh0aGlzLl9kYXRhLCA1ICsgKHByZXZpb3VzRGF0ZXMgKiA3KSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICBwdWJsaWMgYWNjZXNzKCk6IERhdGUgfCBudWxsIHtcbiAgICBpZiAodGhpcy5mbGFncygpICYgVEZGbGFncy5BQ0NFU1MpIHtcbiAgICAgIGxldCBwcmV2aW91c0RhdGVzID0gKHRoaXMuZmxhZ3MoKSAmIFRGRmxhZ3MuQ1JFQVRJT04pID8gMSA6IDA7XG4gICAgICBwcmV2aW91c0RhdGVzICs9ICh0aGlzLmZsYWdzKCkgJiBURkZsYWdzLk1PRElGWSkgPyAxIDogMDtcbiAgICAgIGlmICh0aGlzLl9sb25nRm9ybURhdGVzKSB7XG4gICAgICAgIHJldHVybiBnZXREYXRlKHRoaXMuX2RhdGEsIDUgKyAocHJldmlvdXNEYXRlcyAqIDE3KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZ2V0U2hvcnRGb3JtRGF0ZSh0aGlzLl9kYXRhLCA1ICsgKHByZXZpb3VzRGF0ZXMgKiA3KSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICBwdWJsaWMgYmFja3VwKCk6IERhdGUgfCBudWxsIHtcbiAgICBpZiAodGhpcy5mbGFncygpICYgVEZGbGFncy5CQUNLVVApIHtcbiAgICAgIGxldCBwcmV2aW91c0RhdGVzID0gKHRoaXMuZmxhZ3MoKSAmIFRGRmxhZ3MuQ1JFQVRJT04pID8gMSA6IDA7XG4gICAgICBwcmV2aW91c0RhdGVzICs9ICh0aGlzLmZsYWdzKCkgJiBURkZsYWdzLk1PRElGWSkgPyAxIDogMDtcbiAgICAgIHByZXZpb3VzRGF0ZXMgKz0gKHRoaXMuZmxhZ3MoKSAmIFRGRmxhZ3MuQUNDRVNTKSA/IDEgOiAwO1xuICAgICAgaWYgKHRoaXMuX2xvbmdGb3JtRGF0ZXMpIHtcbiAgICAgICAgcmV0dXJuIGdldERhdGUodGhpcy5fZGF0YSwgNSArIChwcmV2aW91c0RhdGVzICogMTcpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBnZXRTaG9ydEZvcm1EYXRlKHRoaXMuX2RhdGEsIDUgKyAocHJldmlvdXNEYXRlcyAqIDcpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIHB1YmxpYyBleHBpcmF0aW9uKCk6IERhdGUgfCBudWxsIHtcbiAgICBpZiAodGhpcy5mbGFncygpICYgVEZGbGFncy5FWFBJUkFUSU9OKSB7XG4gICAgICBsZXQgcHJldmlvdXNEYXRlcyA9ICh0aGlzLmZsYWdzKCkgJiBURkZsYWdzLkNSRUFUSU9OKSA/IDEgOiAwO1xuICAgICAgcHJldmlvdXNEYXRlcyArPSAodGhpcy5mbGFncygpICYgVEZGbGFncy5NT0RJRlkpID8gMSA6IDA7XG4gICAgICBwcmV2aW91c0RhdGVzICs9ICh0aGlzLmZsYWdzKCkgJiBURkZsYWdzLkFDQ0VTUykgPyAxIDogMDtcbiAgICAgIHByZXZpb3VzRGF0ZXMgKz0gKHRoaXMuZmxhZ3MoKSAmIFRGRmxhZ3MuQkFDS1VQKSA/IDEgOiAwO1xuICAgICAgaWYgKHRoaXMuX2xvbmdGb3JtRGF0ZXMpIHtcbiAgICAgICAgcmV0dXJuIGdldERhdGUodGhpcy5fZGF0YSwgNSArIChwcmV2aW91c0RhdGVzICogMTcpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBnZXRTaG9ydEZvcm1EYXRlKHRoaXMuX2RhdGEsIDUgKyAocHJldmlvdXNEYXRlcyAqIDcpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIHB1YmxpYyBlZmZlY3RpdmUoKTogRGF0ZSB8IG51bGwge1xuICAgIGlmICh0aGlzLmZsYWdzKCkgJiBURkZsYWdzLkVGRkVDVElWRSkge1xuICAgICAgbGV0IHByZXZpb3VzRGF0ZXMgPSAodGhpcy5mbGFncygpICYgVEZGbGFncy5DUkVBVElPTikgPyAxIDogMDtcbiAgICAgIHByZXZpb3VzRGF0ZXMgKz0gKHRoaXMuZmxhZ3MoKSAmIFRGRmxhZ3MuTU9ESUZZKSA/IDEgOiAwO1xuICAgICAgcHJldmlvdXNEYXRlcyArPSAodGhpcy5mbGFncygpICYgVEZGbGFncy5BQ0NFU1MpID8gMSA6IDA7XG4gICAgICBwcmV2aW91c0RhdGVzICs9ICh0aGlzLmZsYWdzKCkgJiBURkZsYWdzLkJBQ0tVUCkgPyAxIDogMDtcbiAgICAgIHByZXZpb3VzRGF0ZXMgKz0gKHRoaXMuZmxhZ3MoKSAmIFRGRmxhZ3MuRVhQSVJBVElPTikgPyAxIDogMDtcbiAgICAgIGlmICh0aGlzLl9sb25nRm9ybURhdGVzKSB7XG4gICAgICAgIHJldHVybiBnZXREYXRlKHRoaXMuX2RhdGEsIDUgKyAocHJldmlvdXNEYXRlcyAqIDE3KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZ2V0U2hvcnRGb3JtRGF0ZSh0aGlzLl9kYXRhLCA1ICsgKHByZXZpb3VzRGF0ZXMgKiA3KSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICBwcml2YXRlIF9sb25nRm9ybURhdGVzKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAhISh0aGlzLmZsYWdzKCkgJiYgVEZGbGFncy5MT05HX0ZPUk0pO1xuICB9XG59XG5cbi8qKlxuICogUm9ja1JpZGdlOiBGaWxlIGRhdGEgaW4gc3BhcnNlIGZvcm1hdC5cbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgU0ZFbnRyeSBleHRlbmRzIFN5c3RlbVVzZUVudHJ5IHtcbiAgY29uc3RydWN0b3IoZGF0YTogQnVmZmVyKSB7XG4gICAgc3VwZXIoZGF0YSk7XG4gIH1cbiAgcHVibGljIHZpcnR1YWxTaXplSGlnaCgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLl9kYXRhLnJlYWRVSW50MzJMRSg0KTtcbiAgfVxuICBwdWJsaWMgdmlydHVhbFNpemVMb3coKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YS5yZWFkVUludDMyTEUoMTIpO1xuICB9XG4gIHB1YmxpYyB0YWJsZURlcHRoKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGFbMjBdO1xuICB9XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5hYnN0cmFjdCBjbGFzcyBEaXJlY3Rvcnk8VCBleHRlbmRzIERpcmVjdG9yeVJlY29yZD4ge1xuICBwcm90ZWN0ZWQgX3JlY29yZDogVDtcbiAgcHJpdmF0ZSBfZmlsZUxpc3Q6IHN0cmluZ1tdID0gW107XG4gIHByaXZhdGUgX2ZpbGVNYXA6IHtbbmFtZTogc3RyaW5nXTogVH0gPSB7fTtcbiAgY29uc3RydWN0b3IocmVjb3JkOiBULCBpc29EYXRhOiBCdWZmZXIpIHtcbiAgICB0aGlzLl9yZWNvcmQgPSByZWNvcmQ7XG4gICAgbGV0IGkgPSByZWNvcmQubGJhKCk7XG4gICAgbGV0IGlMaW1pdCA9IGkgKyByZWNvcmQuZGF0YUxlbmd0aCgpO1xuICAgIGlmICghKHJlY29yZC5maWxlRmxhZ3MoKSAmIEZpbGVGbGFncy5EaXJlY3RvcnkpKSB7XG4gICAgICAvLyBNdXN0IGhhdmUgYSBDTCBlbnRyeS5cbiAgICAgIGNvbnN0IGNsID0gPENMRW50cnk+IHJlY29yZC5nZXRTVUVudHJpZXMoaXNvRGF0YSkuZmlsdGVyKChlKSA9PiBlIGluc3RhbmNlb2YgQ0xFbnRyeSlbMF07XG4gICAgICBpID0gY2wuY2hpbGREaXJlY3RvcnlMYmEoKSAqIDIwNDg7XG4gICAgICBpTGltaXQgPSBJbmZpbml0eTtcbiAgICB9XG5cbiAgICB3aGlsZSAoaSA8IGlMaW1pdCkge1xuICAgICAgY29uc3QgbGVuID0gaXNvRGF0YVtpXTtcbiAgICAgIC8vIFplcm8tcGFkZGluZyBiZXR3ZWVuIHNlY3RvcnMuXG4gICAgICAvLyBUT0RPOiBDb3VsZCBvcHRpbWl6ZSB0aGlzIHRvIHNlZWsgdG8gbmVhcmVzdC1zZWN0b3IgdXBvblxuICAgICAgLy8gc2VlaW5nIGEgMC5cbiAgICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgICAgaSsrO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHIgPSB0aGlzLl9jb25zdHJ1Y3REaXJlY3RvcnlSZWNvcmQoaXNvRGF0YS5zbGljZShpKSk7XG4gICAgICBjb25zdCBmbmFtZSA9IHIuZmlsZU5hbWUoaXNvRGF0YSk7XG4gICAgICAvLyBTa2lwICcuJyBhbmQgJy4uJyBlbnRyaWVzLlxuICAgICAgaWYgKGZuYW1lICE9PSAnXFx1MDAwMCcgJiYgZm5hbWUgIT09ICdcXHUwMDAxJykge1xuICAgICAgICAvLyBTa2lwIHJlbG9jYXRlZCBlbnRyaWVzLlxuICAgICAgICBpZiAoIXIuaGFzUm9ja1JpZGdlKCkgfHwgci5nZXRTVUVudHJpZXMoaXNvRGF0YSkuZmlsdGVyKChlKSA9PiBlIGluc3RhbmNlb2YgUkVFbnRyeSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5fZmlsZU1hcFtmbmFtZV0gPSByO1xuICAgICAgICAgIHRoaXMuX2ZpbGVMaXN0LnB1c2goZm5hbWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlMaW1pdCA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgLy8gRmlyc3QgZW50cnkgY29udGFpbnMgbmVlZGVkIGRhdGEuXG4gICAgICAgIGlMaW1pdCA9IGkgKyByLmRhdGFMZW5ndGgoKTtcbiAgICAgIH1cbiAgICAgIGkgKz0gci5sZW5ndGgoKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgcmVjb3JkIHdpdGggdGhlIGdpdmVuIG5hbWUuXG4gICAqIFJldHVybnMgdW5kZWZpbmVkIGlmIG5vdCBwcmVzZW50LlxuICAgKi9cbiAgcHVibGljIGdldFJlY29yZChuYW1lOiBzdHJpbmcpOiBEaXJlY3RvcnlSZWNvcmQge1xuICAgIHJldHVybiB0aGlzLl9maWxlTWFwW25hbWVdO1xuICB9XG4gIHB1YmxpYyBnZXRGaWxlTGlzdCgpOiBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbGVMaXN0O1xuICB9XG4gIHB1YmxpYyBnZXREb3RFbnRyeShpc29EYXRhOiBCdWZmZXIpOiBUIHtcbiAgICByZXR1cm4gdGhpcy5fY29uc3RydWN0RGlyZWN0b3J5UmVjb3JkKGlzb0RhdGEuc2xpY2UodGhpcy5fcmVjb3JkLmxiYSgpKSk7XG4gIH1cbiAgcHJvdGVjdGVkIGFic3RyYWN0IF9jb25zdHJ1Y3REaXJlY3RvcnlSZWNvcmQoZGF0YTogQnVmZmVyKTogVDtcbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIElTT0RpcmVjdG9yeSBleHRlbmRzIERpcmVjdG9yeTxJU09EaXJlY3RvcnlSZWNvcmQ+IHtcbiAgY29uc3RydWN0b3IocmVjb3JkOiBJU09EaXJlY3RvcnlSZWNvcmQsIGlzb0RhdGE6IEJ1ZmZlcikge1xuICAgIHN1cGVyKHJlY29yZCwgaXNvRGF0YSk7XG4gIH1cbiAgcHJvdGVjdGVkIF9jb25zdHJ1Y3REaXJlY3RvcnlSZWNvcmQoZGF0YTogQnVmZmVyKTogSVNPRGlyZWN0b3J5UmVjb3JkIHtcbiAgICByZXR1cm4gbmV3IElTT0RpcmVjdG9yeVJlY29yZChkYXRhLCB0aGlzLl9yZWNvcmQuZ2V0Um9ja1JpZGdlT2Zmc2V0KCkpO1xuICB9XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBKb2xpZXREaXJlY3RvcnkgZXh0ZW5kcyBEaXJlY3Rvcnk8Sm9saWV0RGlyZWN0b3J5UmVjb3JkPiB7XG4gIGNvbnN0cnVjdG9yKHJlY29yZDogSm9saWV0RGlyZWN0b3J5UmVjb3JkLCBpc29EYXRhOiBCdWZmZXIpIHtcbiAgICBzdXBlcihyZWNvcmQsIGlzb0RhdGEpO1xuICB9XG4gIHByb3RlY3RlZCBfY29uc3RydWN0RGlyZWN0b3J5UmVjb3JkKGRhdGE6IEJ1ZmZlcik6IEpvbGlldERpcmVjdG9yeVJlY29yZCB7XG4gICAgcmV0dXJuIG5ldyBKb2xpZXREaXJlY3RvcnlSZWNvcmQoZGF0YSwgdGhpcy5fcmVjb3JkLmdldFJvY2tSaWRnZU9mZnNldCgpKTtcbiAgfVxufVxuXG4vKipcbiAqIE9wdGlvbnMgZm9yIElzb0ZTIGZpbGUgc3lzdGVtIGluc3RhbmNlcy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJc29GU09wdGlvbnMge1xuICAvLyBUaGUgSVNPIGZpbGUgaW4gYSBidWZmZXIuXG4gIGRhdGE6IEJ1ZmZlcjtcbiAgLy8gVGhlIG5hbWUgb2YgdGhlIElTTyAob3B0aW9uYWw7IHVzZWQgZm9yIGRlYnVnIG1lc3NhZ2VzIC8gaWRlbnRpZmljYXRpb24gdmlhIGdldE5hbWUoKSkuXG4gIG5hbWU/OiBzdHJpbmc7XG59XG5cbi8qKlxuICogTW91bnRzIGFuIElTTyBmaWxlIGFzIGEgcmVhZC1vbmx5IGZpbGUgc3lzdGVtLlxuICpcbiAqIFN1cHBvcnRzOlxuICogKiBWYW5pbGxhIElTTzk2NjAgSVNPc1xuICogKiBNaWNyb3NvZnQgSm9saWV0IGFuZCBSb2NrIFJpZGdlIGV4dGVuc2lvbnMgdG8gdGhlIElTTzk2NjAgc3RhbmRhcmRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSXNvRlMgZXh0ZW5kcyBTeW5jaHJvbm91c0ZpbGVTeXN0ZW0gaW1wbGVtZW50cyBGaWxlU3lzdGVtIHtcbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBOYW1lID0gXCJJc29GU1wiO1xuXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgT3B0aW9uczogRmlsZVN5c3RlbU9wdGlvbnMgPSB7XG4gICAgZGF0YToge1xuICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgIGRlc2NyaXB0aW9uOiBcIlRoZSBJU08gZmlsZSBpbiBhIGJ1ZmZlclwiLFxuICAgICAgdmFsaWRhdG9yOiBidWZmZXJWYWxpZGF0b3JcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gSXNvRlMgaW5zdGFuY2Ugd2l0aCB0aGUgZ2l2ZW4gb3B0aW9ucy5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgQ3JlYXRlKG9wdHM6IElzb0ZTT3B0aW9ucywgY2I6IEJGU0NhbGxiYWNrPElzb0ZTPik6IHZvaWQge1xuICAgIGxldCBmczogSXNvRlMgfCB1bmRlZmluZWQ7XG4gICAgbGV0IGU6IEFwaUVycm9yIHwgdW5kZWZpbmVkO1xuICAgIHRyeSB7XG4gICAgICBmcyA9IG5ldyBJc29GUyhvcHRzLmRhdGEsIG9wdHMubmFtZSwgZmFsc2UpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGUgPSBlO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBjYihlLCBmcyk7XG4gICAgfVxuICB9XG4gIHB1YmxpYyBzdGF0aWMgaXNBdmFpbGFibGUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBwcml2YXRlIF9kYXRhOiBCdWZmZXI7XG4gIHByaXZhdGUgX3B2ZDogUHJpbWFyeU9yU3VwcGxlbWVudGFyeVZvbHVtZURlc2NyaXB0b3I7XG4gIHByaXZhdGUgX3Jvb3Q6IERpcmVjdG9yeVJlY29yZDtcbiAgcHJpdmF0ZSBfbmFtZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiAqKkRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgSXNvRlMuQ3JlYXRlKCkgbWV0aG9kIGluc3RlYWQuKipcbiAgICpcbiAgICogQ29uc3RydWN0cyBhIHJlYWQtb25seSBmaWxlIHN5c3RlbSBmcm9tIHRoZSBnaXZlbiBJU08uXG4gICAqIEBwYXJhbSBkYXRhIFRoZSBJU08gZmlsZSBpbiBhIGJ1ZmZlci5cbiAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIElTTyAob3B0aW9uYWw7IHVzZWQgZm9yIGRlYnVnIG1lc3NhZ2VzIC8gaWRlbnRpZmljYXRpb24gdmlhIGdldE5hbWUoKSkuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihkYXRhOiBCdWZmZXIsIG5hbWU6IHN0cmluZyA9IFwiXCIsIGRlcHJlY2F0ZU1zZyA9IHRydWUpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xuICAgIGRlcHJlY2F0aW9uTWVzc2FnZShkZXByZWNhdGVNc2csIElzb0ZTLk5hbWUsIHtkYXRhOiBcIklTTyBkYXRhIGFzIGEgQnVmZmVyXCIsIG5hbWU6IG5hbWV9KTtcbiAgICAvLyBTa2lwIGZpcnN0IDE2IHNlY3RvcnMuXG4gICAgbGV0IHZkVGVybWluYXRvckZvdW5kID0gZmFsc2U7XG4gICAgbGV0IGkgPSAxNiAqIDIwNDg7XG4gICAgY29uc3QgY2FuZGlkYXRlVkRzID0gbmV3IEFycmF5PFByaW1hcnlPclN1cHBsZW1lbnRhcnlWb2x1bWVEZXNjcmlwdG9yPigpO1xuICAgIHdoaWxlICghdmRUZXJtaW5hdG9yRm91bmQpIHtcbiAgICAgIGNvbnN0IHNsaWNlID0gZGF0YS5zbGljZShpKTtcbiAgICAgIGNvbnN0IHZkID0gbmV3IFZvbHVtZURlc2NyaXB0b3Ioc2xpY2UpO1xuICAgICAgc3dpdGNoICh2ZC50eXBlKCkpIHtcbiAgICAgICAgY2FzZSBWb2x1bWVEZXNjcmlwdG9yVHlwZUNvZGUuUHJpbWFyeVZvbHVtZURlc2NyaXB0b3I6XG4gICAgICAgICAgY2FuZGlkYXRlVkRzLnB1c2gobmV3IFByaW1hcnlWb2x1bWVEZXNjcmlwdG9yKHNsaWNlKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgVm9sdW1lRGVzY3JpcHRvclR5cGVDb2RlLlN1cHBsZW1lbnRhcnlWb2x1bWVEZXNjcmlwdG9yOlxuICAgICAgICAgIGNhbmRpZGF0ZVZEcy5wdXNoKG5ldyBTdXBwbGVtZW50YXJ5Vm9sdW1lRGVzY3JpcHRvcihzbGljZSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFZvbHVtZURlc2NyaXB0b3JUeXBlQ29kZS5Wb2x1bWVEZXNjcmlwdG9yU2V0VGVybWluYXRvcjpcbiAgICAgICAgICB2ZFRlcm1pbmF0b3JGb3VuZCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpICs9IDIwNDg7XG4gICAgfVxuICAgIGlmIChjYW5kaWRhdGVWRHMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgQXBpRXJyb3IoRXJyb3JDb2RlLkVJTywgYFVuYWJsZSB0byBmaW5kIGEgc3VpdGFibGUgdm9sdW1lIGRlc2NyaXB0b3IuYCk7XG4gICAgfVxuICAgIGNhbmRpZGF0ZVZEcy5mb3JFYWNoKCh2KSA9PiB7XG4gICAgICAvLyBUYWtlIGFuIFNWRCBvdmVyIGEgUFZELlxuICAgICAgaWYgKCF0aGlzLl9wdmQgfHwgdGhpcy5fcHZkLnR5cGUoKSAhPT0gVm9sdW1lRGVzY3JpcHRvclR5cGVDb2RlLlN1cHBsZW1lbnRhcnlWb2x1bWVEZXNjcmlwdG9yKSB7XG4gICAgICAgIHRoaXMuX3B2ZCA9IHY7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5fcm9vdCA9IHRoaXMuX3B2ZC5yb290RGlyZWN0b3J5RW50cnkoZGF0YSk7XG4gICAgdGhpcy5fbmFtZSA9IG5hbWU7XG4gIH1cblxuICBwdWJsaWMgZ2V0TmFtZSgpOiBzdHJpbmcge1xuICAgIGxldCBuYW1lID0gYElzb0ZTJHt0aGlzLl9uYW1lfSR7dGhpcy5fcHZkID8gYC0ke3RoaXMuX3B2ZC5uYW1lKCl9YCA6ICcnfWA7XG4gICAgaWYgKHRoaXMuX3Jvb3QgJiYgdGhpcy5fcm9vdC5oYXNSb2NrUmlkZ2UoKSkge1xuICAgICAgbmFtZSArPSBgLVJvY2tSaWRnZWA7XG4gICAgfVxuICAgIHJldHVybiBuYW1lO1xuICB9XG5cbiAgcHVibGljIGRpc2tTcGFjZShwYXRoOiBzdHJpbmcsIGNiOiAodG90YWw6IG51bWJlciwgZnJlZTogbnVtYmVyKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgLy8gUmVhZC1vbmx5IGZpbGUgc3lzdGVtLlxuICAgIGNiKHRoaXMuX2RhdGEubGVuZ3RoLCAwKTtcbiAgfVxuXG4gIHB1YmxpYyBpc1JlYWRPbmx5KCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcHVibGljIHN1cHBvcnRzTGlua3MoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcHVibGljIHN1cHBvcnRzUHJvcHMoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcHVibGljIHN1cHBvcnRzU3luY2goKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBwdWJsaWMgc3RhdFN5bmMocDogc3RyaW5nLCBpc0xzdGF0OiBib29sZWFuKTogU3RhdHMge1xuICAgIGNvbnN0IHJlY29yZCA9IHRoaXMuX2dldERpcmVjdG9yeVJlY29yZChwKTtcbiAgICBpZiAocmVjb3JkID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBBcGlFcnJvci5FTk9FTlQocCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9nZXRTdGF0cyhwLCByZWNvcmQpITtcbiAgfVxuXG4gIHB1YmxpYyBvcGVuU3luYyhwOiBzdHJpbmcsIGZsYWdzOiBGaWxlRmxhZywgbW9kZTogbnVtYmVyKTogRmlsZSB7XG4gICAgLy8gSU5WQVJJQU5UOiBDYW5ub3Qgd3JpdGUgdG8gUk8gZmlsZSBzeXN0ZW1zLlxuICAgIGlmIChmbGFncy5pc1dyaXRlYWJsZSgpKSB7XG4gICAgICB0aHJvdyBuZXcgQXBpRXJyb3IoRXJyb3JDb2RlLkVQRVJNLCBwKTtcbiAgICB9XG4gICAgLy8gQ2hlY2sgaWYgdGhlIHBhdGggZXhpc3RzLCBhbmQgaXMgYSBmaWxlLlxuICAgIGNvbnN0IHJlY29yZCA9IHRoaXMuX2dldERpcmVjdG9yeVJlY29yZChwKTtcbiAgICBpZiAoIXJlY29yZCkge1xuICAgICAgdGhyb3cgQXBpRXJyb3IuRU5PRU5UKHApO1xuICAgIH0gZWxzZSBpZiAocmVjb3JkLmlzU3ltbGluayh0aGlzLl9kYXRhKSkge1xuICAgICAgcmV0dXJuIHRoaXMub3BlblN5bmMocGF0aC5yZXNvbHZlKHAsIHJlY29yZC5nZXRTeW1saW5rUGF0aCh0aGlzLl9kYXRhKSksIGZsYWdzLCBtb2RlKTtcbiAgICB9IGVsc2UgaWYgKCFyZWNvcmQuaXNEaXJlY3RvcnkodGhpcy5fZGF0YSkpIHtcbiAgICAgIGNvbnN0IGRhdGEgPSByZWNvcmQuZ2V0RmlsZSh0aGlzLl9kYXRhKTtcbiAgICAgIGNvbnN0IHN0YXRzID0gdGhpcy5fZ2V0U3RhdHMocCwgcmVjb3JkKSE7XG4gICAgICBzd2l0Y2ggKGZsYWdzLnBhdGhFeGlzdHNBY3Rpb24oKSkge1xuICAgICAgICBjYXNlIEFjdGlvblR5cGUuVEhST1dfRVhDRVBUSU9OOlxuICAgICAgICBjYXNlIEFjdGlvblR5cGUuVFJVTkNBVEVfRklMRTpcbiAgICAgICAgICB0aHJvdyBBcGlFcnJvci5FRVhJU1QocCk7XG4gICAgICAgIGNhc2UgQWN0aW9uVHlwZS5OT1A6XG4gICAgICAgICAgcmV0dXJuIG5ldyBOb1N5bmNGaWxlKHRoaXMsIHAsIGZsYWdzLCBzdGF0cywgZGF0YSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEFwaUVycm9yKEVycm9yQ29kZS5FSU5WQUwsICdJbnZhbGlkIEZpbGVNb2RlIG9iamVjdC4nKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgQXBpRXJyb3IuRUlTRElSKHApO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyByZWFkZGlyU3luYyhwYXRoOiBzdHJpbmcpOiBzdHJpbmdbXSB7XG4gICAgLy8gQ2hlY2sgaWYgaXQgZXhpc3RzLlxuICAgIGNvbnN0IHJlY29yZCA9IHRoaXMuX2dldERpcmVjdG9yeVJlY29yZChwYXRoKTtcbiAgICBpZiAoIXJlY29yZCkge1xuICAgICAgdGhyb3cgQXBpRXJyb3IuRU5PRU5UKHBhdGgpO1xuICAgIH0gZWxzZSBpZiAocmVjb3JkLmlzRGlyZWN0b3J5KHRoaXMuX2RhdGEpKSB7XG4gICAgICByZXR1cm4gcmVjb3JkLmdldERpcmVjdG9yeSh0aGlzLl9kYXRhKS5nZXRGaWxlTGlzdCgpLnNsaWNlKDApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBBcGlFcnJvci5FTk9URElSKHBhdGgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTcGVjaWFsbHktb3B0aW1pemVkIHJlYWRmaWxlLlxuICAgKi9cbiAgcHVibGljIHJlYWRGaWxlU3luYyhmbmFtZTogc3RyaW5nLCBlbmNvZGluZzogc3RyaW5nLCBmbGFnOiBGaWxlRmxhZyk6IGFueSB7XG4gICAgLy8gR2V0IGZpbGUuXG4gICAgY29uc3QgZmQgPSB0aGlzLm9wZW5TeW5jKGZuYW1lLCBmbGFnLCAweDFhNCk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGZkQ2FzdCA9IDxOb1N5bmNGaWxlPElzb0ZTPj4gZmQ7XG4gICAgICBjb25zdCBmZEJ1ZmYgPSA8QnVmZmVyPiBmZENhc3QuZ2V0QnVmZmVyKCk7XG4gICAgICBpZiAoZW5jb2RpbmcgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGNvcHlpbmdTbGljZShmZEJ1ZmYpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZkQnVmZi50b1N0cmluZyhlbmNvZGluZyk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGZkLmNsb3NlU3luYygpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgX2dldERpcmVjdG9yeVJlY29yZChwYXRoOiBzdHJpbmcpOiBEaXJlY3RvcnlSZWNvcmQgfCBudWxsIHtcbiAgICAvLyBTcGVjaWFsIGNhc2UuXG4gICAgaWYgKHBhdGggPT09ICcvJykge1xuICAgICAgcmV0dXJuIHRoaXMuX3Jvb3Q7XG4gICAgfVxuICAgIGNvbnN0IGNvbXBvbmVudHMgPSBwYXRoLnNwbGl0KCcvJykuc2xpY2UoMSk7XG4gICAgbGV0IGRpciA9IHRoaXMuX3Jvb3Q7XG4gICAgZm9yIChjb25zdCBjb21wb25lbnQgb2YgY29tcG9uZW50cykge1xuICAgICAgaWYgKGRpci5pc0RpcmVjdG9yeSh0aGlzLl9kYXRhKSkge1xuICAgICAgICBkaXIgPSBkaXIuZ2V0RGlyZWN0b3J5KHRoaXMuX2RhdGEpLmdldFJlY29yZChjb21wb25lbnQpO1xuICAgICAgICBpZiAoIWRpcikge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRpcjtcbiAgfVxuXG4gIHByaXZhdGUgX2dldFN0YXRzKHA6IHN0cmluZywgcmVjb3JkOiBEaXJlY3RvcnlSZWNvcmQpOiBTdGF0cyB8IG51bGwge1xuICAgIGlmIChyZWNvcmQuaXNTeW1saW5rKHRoaXMuX2RhdGEpKSB7XG4gICAgICBjb25zdCBuZXdQID0gcGF0aC5yZXNvbHZlKHAsIHJlY29yZC5nZXRTeW1saW5rUGF0aCh0aGlzLl9kYXRhKSk7XG4gICAgICBjb25zdCBkaXJSZWMgPSB0aGlzLl9nZXREaXJlY3RvcnlSZWNvcmQobmV3UCk7XG4gICAgICBpZiAoIWRpclJlYykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9nZXRTdGF0cyhuZXdQLCBkaXJSZWMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBsZW4gPSByZWNvcmQuZGF0YUxlbmd0aCgpO1xuICAgICAgbGV0IG1vZGUgPSAweDE2RDtcbiAgICAgIGNvbnN0IGRhdGUgPSByZWNvcmQucmVjb3JkaW5nRGF0ZSgpO1xuICAgICAgbGV0IGF0aW1lID0gZGF0ZTtcbiAgICAgIGxldCBtdGltZSA9IGRhdGU7XG4gICAgICBsZXQgY3RpbWUgPSBkYXRlO1xuICAgICAgaWYgKHJlY29yZC5oYXNSb2NrUmlkZ2UoKSkge1xuICAgICAgICBjb25zdCBlbnRyaWVzID0gcmVjb3JkLmdldFNVRW50cmllcyh0aGlzLl9kYXRhKTtcbiAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiBlbnRyaWVzKSB7XG4gICAgICAgICAgaWYgKGVudHJ5IGluc3RhbmNlb2YgUFhFbnRyeSkge1xuICAgICAgICAgICAgbW9kZSA9IGVudHJ5Lm1vZGUoKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGVudHJ5IGluc3RhbmNlb2YgVEZFbnRyeSkge1xuICAgICAgICAgICAgY29uc3QgZmxhZ3MgPSBlbnRyeS5mbGFncygpO1xuICAgICAgICAgICAgaWYgKGZsYWdzICYgVEZGbGFncy5BQ0NFU1MpIHtcbiAgICAgICAgICAgICAgYXRpbWUgPSBlbnRyeS5hY2Nlc3MoKSE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmxhZ3MgJiBURkZsYWdzLk1PRElGWSkge1xuICAgICAgICAgICAgICBtdGltZSA9IGVudHJ5Lm1vZGlmeSgpITtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmbGFncyAmIFRGRmxhZ3MuQ1JFQVRJT04pIHtcbiAgICAgICAgICAgICAgY3RpbWUgPSBlbnRyeS5jcmVhdGlvbigpITtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIE1hc2sgb3V0IHdyaXRlYWJsZSBmbGFncy4gVGhpcyBpcyBhIFJPIGZpbGUgc3lzdGVtLlxuICAgICAgbW9kZSA9IG1vZGUgJiAweDE2RDtcbiAgICAgIHJldHVybiBuZXcgU3RhdHMocmVjb3JkLmlzRGlyZWN0b3J5KHRoaXMuX2RhdGEpID8gRmlsZVR5cGUuRElSRUNUT1JZIDogRmlsZVR5cGUuRklMRSwgbGVuLCBtb2RlLCBhdGltZSwgbXRpbWUsIGN0aW1lKTtcbiAgICB9XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi8uLi8uLi8uLi9zcmMvYmFja2VuZC9Jc29GUy50cyIsImltcG9ydCB7RmlsZVN5c3RlbUNvbnN0cnVjdG9yLCBCRlNDYWxsYmFjaywgRmlsZVN5c3RlbX0gZnJvbSAnLi9maWxlX3N5c3RlbSc7XG5pbXBvcnQge0FwaUVycm9yfSBmcm9tICcuL2FwaV9lcnJvcic7XG5pbXBvcnQge2NoZWNrT3B0aW9uc30gZnJvbSAnLi91dGlsJztcbmltcG9ydCBBc3luY01pcnJvciBmcm9tICcuLi9iYWNrZW5kL0FzeW5jTWlycm9yJztcbmltcG9ydCBEcm9wYm94IGZyb20gJy4uL2JhY2tlbmQvRHJvcGJveCc7XG5pbXBvcnQgRW1zY3JpcHRlbiBmcm9tICcuLi9iYWNrZW5kL0Vtc2NyaXB0ZW4nO1xuaW1wb3J0IEZvbGRlckFkYXB0ZXIgZnJvbSAnLi4vYmFja2VuZC9Gb2xkZXJBZGFwdGVyJztcbmltcG9ydCBIVE1MNUZTIGZyb20gJy4uL2JhY2tlbmQvSFRNTDVGUyc7XG5pbXBvcnQgSW5NZW1vcnkgZnJvbSAnLi4vYmFja2VuZC9Jbk1lbW9yeSc7XG5pbXBvcnQgSW5kZXhlZERCIGZyb20gJy4uL2JhY2tlbmQvSW5kZXhlZERCJztcbmltcG9ydCBMb2NhbFN0b3JhZ2UgZnJvbSAnLi4vYmFja2VuZC9Mb2NhbFN0b3JhZ2UnO1xuaW1wb3J0IE1vdW50YWJsZUZpbGVTeXN0ZW0gZnJvbSAnLi4vYmFja2VuZC9Nb3VudGFibGVGaWxlU3lzdGVtJztcbmltcG9ydCBPdmVybGF5RlMgZnJvbSAnLi4vYmFja2VuZC9PdmVybGF5RlMnO1xuaW1wb3J0IFdvcmtlckZTIGZyb20gJy4uL2JhY2tlbmQvV29ya2VyRlMnO1xuaW1wb3J0IFhtbEh0dHBSZXF1ZXN0IGZyb20gJy4uL2JhY2tlbmQvWG1sSHR0cFJlcXVlc3QnO1xuaW1wb3J0IFppcEZTIGZyb20gJy4uL2JhY2tlbmQvWmlwRlMnO1xuaW1wb3J0IElzb0ZTIGZyb20gJy4uL2JhY2tlbmQvSXNvRlMnO1xuXG4vLyBNb25rZXktcGF0Y2ggYENyZWF0ZWAgZnVuY3Rpb25zIHRvIGNoZWNrIG9wdGlvbnMgYmVmb3JlIGZpbGUgc3lzdGVtIGluaXRpYWxpemF0aW9uLlxuW0FzeW5jTWlycm9yLCBEcm9wYm94LCBFbXNjcmlwdGVuLCBGb2xkZXJBZGFwdGVyLCBIVE1MNUZTLCBJbk1lbW9yeSwgSW5kZXhlZERCLCBJc29GUywgTG9jYWxTdG9yYWdlLCBNb3VudGFibGVGaWxlU3lzdGVtLCBPdmVybGF5RlMsIFdvcmtlckZTLCBYbWxIdHRwUmVxdWVzdCwgWmlwRlNdLmZvckVhY2goKGZzVHlwZTogRmlsZVN5c3RlbUNvbnN0cnVjdG9yKSA9PiB7XG4gIGNvbnN0IGNyZWF0ZSA9IGZzVHlwZS5DcmVhdGU7XG4gIGZzVHlwZS5DcmVhdGUgPSBmdW5jdGlvbihvcHRzPzogYW55LCBjYj86IEJGU0NhbGxiYWNrPEZpbGVTeXN0ZW0+KTogdm9pZCB7XG4gICAgY29uc3Qgb25lQXJnID0gdHlwZW9mKG9wdHMpID09PSBcImZ1bmN0aW9uXCI7XG4gICAgY29uc3Qgbm9ybWFsaXplZENiID0gb25lQXJnID8gb3B0cyA6IGNiO1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRPcHRzID0gb25lQXJnID8ge30gOiBvcHRzO1xuXG4gICAgZnVuY3Rpb24gd3JhcHBlZENiKGU/OiBBcGlFcnJvcik6IHZvaWQge1xuICAgICAgaWYgKGUpIHtcbiAgICAgICAgbm9ybWFsaXplZENiKGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3JlYXRlLmNhbGwoZnNUeXBlLCBub3JtYWxpemVkT3B0cywgbm9ybWFsaXplZENiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjaGVja09wdGlvbnMoZnNUeXBlLCBub3JtYWxpemVkT3B0cywgd3JhcHBlZENiKTtcbiAgfTtcbn0pO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgQmFja2VuZHMgPSB7IEFzeW5jTWlycm9yLCBEcm9wYm94LCBFbXNjcmlwdGVuLCBGb2xkZXJBZGFwdGVyLCBIVE1MNUZTLCBJbk1lbW9yeSwgSW5kZXhlZERCLCBJc29GUywgTG9jYWxTdG9yYWdlLCBNb3VudGFibGVGaWxlU3lzdGVtLCBPdmVybGF5RlMsIFdvcmtlckZTLCBYbWxIdHRwUmVxdWVzdCwgWmlwRlMgfTtcbi8vIE1ha2Ugc3VyZSBhbGwgYmFja2VuZHMgY2FzdCB0byBGaWxlU3lzdGVtQ29uc3RydWN0b3IgKGZvciB0eXBlIGNoZWNraW5nKVxuY29uc3QgXzoge1tuYW1lOiBzdHJpbmddOiBGaWxlU3lzdGVtQ29uc3RydWN0b3J9ID0gQmFja2VuZHM7XG4vLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tdW51c2VkLWV4cHJlc3Npb25cbl87XG4vLyB0c2xpbnQ6ZW5hYmxlLW5leHQtbGluZTpuby11bnVzZWQtZXhwcmVzc2lvblxuZXhwb3J0IGRlZmF1bHQgQmFja2VuZHM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vLi4vLi4vLi4vc3JjL2NvcmUvYmFja2VuZHMudHMiLCIvKipcbiAqIEJyb3dzZXJGUydzIG1haW4gbW9kdWxlLiBUaGlzIGlzIGV4cG9zZWQgaW4gdGhlIGJyb3dzZXIgdmlhIHRoZSBCcm93c2VyRlMgZ2xvYmFsLlxuICogRHVlIHRvIGxpbWl0YXRpb25zIGluIHR5cGVkb2MsIHdlIGRvY3VtZW50IHRoZXNlIGZ1bmN0aW9ucyBpbiAuL3R5cGVkb2MudHMuXG4gKi9cblxuaW1wb3J0ICogYXMgYnVmZmVyIGZyb20gJ2J1ZmZlcic7XG5pbXBvcnQgZnMgZnJvbSAnLi9ub2RlX2ZzJztcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQge0ZpbGVTeXN0ZW1Db25zdHJ1Y3RvciwgRmlsZVN5c3RlbSwgQkZTT25lQXJnQ2FsbGJhY2ssIEJGU0NhbGxiYWNrfSBmcm9tICcuL2ZpbGVfc3lzdGVtJztcbmltcG9ydCBFbXNjcmlwdGVuRlMgZnJvbSAnLi4vZ2VuZXJpYy9lbXNjcmlwdGVuX2ZzJztcbmltcG9ydCBCYWNrZW5kcyBmcm9tICcuL2JhY2tlbmRzJztcbmltcG9ydCAqIGFzIEJGU1V0aWxzIGZyb20gJy4vdXRpbCc7XG5pbXBvcnQgKiBhcyBFcnJvcnMgZnJvbSAnLi9hcGlfZXJyb3InO1xuaW1wb3J0IHNldEltbWVkaWF0ZSBmcm9tICcuLi9nZW5lcmljL3NldEltbWVkaWF0ZSc7XG5cbmlmICgoPGFueT4gcHJvY2VzcylbJ2luaXRpYWxpemVUVFlzJ10pIHtcbiAgKDxhbnk+IHByb2Nlc3MpWydpbml0aWFsaXplVFRZcyddKCk7XG59XG5cbi8qKlxuICogSW5zdGFsbHMgQkZTUmVxdWlyZSBhcyBnbG9iYWwgYHJlcXVpcmVgLCBhIE5vZGUgQnVmZmVyIHBvbHlmaWxsIGFzIHRoZSBnbG9iYWwgYEJ1ZmZlcmAgdmFyaWFibGUsXG4gKiBhbmQgYSBOb2RlIHByb2Nlc3MgcG9seWZpbGwgYXMgdGhlIGdsb2JhbCBgcHJvY2Vzc2AgdmFyaWFibGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnN0YWxsKG9iajogYW55KSB7XG4gIG9iai5CdWZmZXIgPSBCdWZmZXI7XG4gIG9iai5wcm9jZXNzID0gcHJvY2VzcztcbiAgY29uc3Qgb2xkUmVxdWlyZSA9IG9iai5yZXF1aXJlID8gb2JqLnJlcXVpcmUgOiBudWxsO1xuICAvLyBNb25rZXktcGF0Y2ggcmVxdWlyZSBmb3IgTm9kZS1zdHlsZSBjb2RlLlxuICBvYmoucmVxdWlyZSA9IGZ1bmN0aW9uKGFyZzogc3RyaW5nKSB7XG4gICAgY29uc3QgcnYgPSBCRlNSZXF1aXJlKGFyZyk7XG4gICAgaWYgKCFydikge1xuICAgICAgcmV0dXJuIG9sZFJlcXVpcmUuYXBwbHkobnVsbCwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBydjtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJGaWxlU3lzdGVtKG5hbWU6IHN0cmluZywgZnM6IEZpbGVTeXN0ZW1Db25zdHJ1Y3Rvcikge1xuICAoPGFueT4gQmFja2VuZHMpW25hbWVdID0gZnM7XG59XG5cbi8qKlxuICogUG9seWZpbGwgZm9yIENvbW1vbkpTIGByZXF1aXJlKClgLiBGb3IgZXhhbXBsZSwgY2FuIGNhbGwgYEJGU1JlcXVpcmUoJ2ZzJylgIHRvIGdldCBhICdmcycgbW9kdWxlIHBvbHlmaWxsLlxuICovXG5leHBvcnQgZnVuY3Rpb24gQkZTUmVxdWlyZShtb2R1bGU6ICdmcycpOiB0eXBlb2YgZnM7XG5leHBvcnQgZnVuY3Rpb24gQkZTUmVxdWlyZShtb2R1bGU6ICdwYXRoJyk6IHR5cGVvZiBwYXRoO1xuZXhwb3J0IGZ1bmN0aW9uIEJGU1JlcXVpcmUobW9kdWxlOiAnYnVmZmVyJyk6IHR5cGVvZiBidWZmZXI7XG5leHBvcnQgZnVuY3Rpb24gQkZTUmVxdWlyZShtb2R1bGU6ICdwcm9jZXNzJyk6IHR5cGVvZiBwcm9jZXNzO1xuZXhwb3J0IGZ1bmN0aW9uIEJGU1JlcXVpcmUobW9kdWxlOiAnYmZzX3V0aWxzJyk6IHR5cGVvZiBCRlNVdGlscztcbmV4cG9ydCBmdW5jdGlvbiBCRlNSZXF1aXJlKG1vZHVsZTogc3RyaW5nKTogYW55O1xuZXhwb3J0IGZ1bmN0aW9uIEJGU1JlcXVpcmUobW9kdWxlOiBzdHJpbmcpOiBhbnkge1xuICBzd2l0Y2ggKG1vZHVsZSkge1xuICAgIGNhc2UgJ2ZzJzpcbiAgICAgIHJldHVybiBmcztcbiAgICBjYXNlICdwYXRoJzpcbiAgICAgIHJldHVybiBwYXRoO1xuICAgIGNhc2UgJ2J1ZmZlcic6XG4gICAgICAvLyBUaGUgJ2J1ZmZlcicgbW9kdWxlIGhhcyAnQnVmZmVyJyBhcyBhIHByb3BlcnR5LlxuICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICBjYXNlICdwcm9jZXNzJzpcbiAgICAgIHJldHVybiBwcm9jZXNzO1xuICAgIGNhc2UgJ2Jmc191dGlscyc6XG4gICAgICByZXR1cm4gQkZTVXRpbHM7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAoPGFueT4gQmFja2VuZHMpW21vZHVsZV07XG4gIH1cbn1cblxuLyoqXG4gKiBJbml0aWFsaXplcyBCcm93c2VyRlMgd2l0aCB0aGUgZ2l2ZW4gcm9vdCBmaWxlIHN5c3RlbS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluaXRpYWxpemUocm9vdGZzOiBGaWxlU3lzdGVtKSB7XG4gIHJldHVybiBmcy5pbml0aWFsaXplKHJvb3Rmcyk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZpbGUgc3lzdGVtIHdpdGggdGhlIGdpdmVuIGNvbmZpZ3VyYXRpb24sIGFuZCBpbml0aWFsaXplcyBCcm93c2VyRlMgd2l0aCBpdC5cbiAqIFNlZSB0aGUgRmlsZVN5c3RlbUNvbmZpZ3VyYXRpb24gdHlwZSBmb3IgbW9yZSBpbmZvIG9uIHRoZSBjb25maWd1cmF0aW9uIG9iamVjdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbmZpZ3VyZShjb25maWc6IEZpbGVTeXN0ZW1Db25maWd1cmF0aW9uLCBjYjogQkZTT25lQXJnQ2FsbGJhY2spOiB2b2lkIHtcbiAgZ2V0RmlsZVN5c3RlbShjb25maWcsIChlLCBmcz8pID0+IHtcbiAgICBpZiAoZnMpIHtcbiAgICAgIGluaXRpYWxpemUoZnMpO1xuICAgICAgY2IoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2IoZSk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBTcGVjaWZpZXMgYSBmaWxlIHN5c3RlbSBiYWNrZW5kIHR5cGUgYW5kIGl0cyBvcHRpb25zLlxuICpcbiAqIEluZGl2aWR1YWwgb3B0aW9ucyBjYW4gcmVjdXJzaXZlbHkgY29udGFpbiBGaWxlU3lzdGVtQ29uZmlndXJhdGlvbiBvYmplY3RzIGZvclxuICogb3B0aW9uIHZhbHVlcyB0aGF0IHJlcXVpcmUgZmlsZSBzeXN0ZW1zLlxuICpcbiAqIEZvciBleGFtcGxlLCB0byBtaXJyb3IgRHJvcGJveCB0byBMb2NhbFN0b3JhZ2Ugd2l0aCBBc3luY01pcnJvciwgdXNlIHRoZSBmb2xsb3dpbmdcbiAqIG9iamVjdDpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgY29uZmlnID0ge1xuICogICBmczogXCJBc3luY01pcnJvclwiLFxuICogICBvcHRpb25zOiB7XG4gKiAgICAgc3luYzoge2ZzOiBcIkxvY2FsU3RvcmFnZVwifSxcbiAqICAgICBhc3luYzoge2ZzOiBcIkRyb3Bib3hcIiwgb3B0aW9uczoge2NsaWVudDogYW5BdXRoZW50aWNhdGVkRHJvcGJveFNES0NsaWVudCB9fVxuICogICB9XG4gKiB9O1xuICogYGBgXG4gKlxuICogVGhlIG9wdGlvbiBvYmplY3QgZm9yIGVhY2ggZmlsZSBzeXN0ZW0gY29ycmVzcG9uZHMgdG8gdGhhdCBmaWxlIHN5c3RlbSdzIG9wdGlvbiBvYmplY3QgcGFzc2VkIHRvIGl0cyBgQ3JlYXRlKClgIG1ldGhvZC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBGaWxlU3lzdGVtQ29uZmlndXJhdGlvbiB7XG4gIGZzOiBzdHJpbmc7XG4gIG9wdGlvbnM6IGFueTtcbn1cblxuLyoqXG4gKiBSZXRyaWV2ZSBhIGZpbGUgc3lzdGVtIHdpdGggdGhlIGdpdmVuIGNvbmZpZ3VyYXRpb24uXG4gKiBAcGFyYW0gY29uZmlnIEEgRmlsZVN5c3RlbUNvbmZpZ3VyYXRpb24gb2JqZWN0LiBTZWUgRmlsZVN5c3RlbUNvbmZpZ3VyYXRpb24gZm9yIGRldGFpbHMuXG4gKiBAcGFyYW0gY2IgQ2FsbGVkIHdoZW4gdGhlIGZpbGUgc3lzdGVtIGlzIGNvbnN0cnVjdGVkLCBvciB3aGVuIGFuIGVycm9yIG9jY3Vycy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEZpbGVTeXN0ZW0oY29uZmlnOiBGaWxlU3lzdGVtQ29uZmlndXJhdGlvbiwgY2I6IEJGU0NhbGxiYWNrPEZpbGVTeXN0ZW0+KTogdm9pZCB7XG4gIGNvbnN0IGZzTmFtZSA9IGNvbmZpZ1snZnMnXTtcbiAgaWYgKCFmc05hbWUpIHtcbiAgICByZXR1cm4gY2IobmV3IEVycm9ycy5BcGlFcnJvcihFcnJvcnMuRXJyb3JDb2RlLkVQRVJNLCAnTWlzc2luZyBcImZzXCIgcHJvcGVydHkgb24gY29uZmlndXJhdGlvbiBvYmplY3QuJykpO1xuICB9XG4gIGNvbnN0IG9wdGlvbnMgPSBjb25maWdbJ29wdGlvbnMnXTtcbiAgbGV0IHdhaXRDb3VudCA9IDA7XG4gIGxldCBjYWxsZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZmluaXNoKCkge1xuICAgIGlmICghY2FsbGVkKSB7XG4gICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgY29uc3QgZnNjID0gPEZpbGVTeXN0ZW1Db25zdHJ1Y3RvciB8IHVuZGVmaW5lZD4gKDxhbnk+IEJhY2tlbmRzKVtmc05hbWVdO1xuICAgICAgaWYgKCFmc2MpIHtcbiAgICAgICAgY2IobmV3IEVycm9ycy5BcGlFcnJvcihFcnJvcnMuRXJyb3JDb2RlLkVQRVJNLCBgRmlsZSBzeXN0ZW0gJHtmc05hbWV9IGlzIG5vdCBhdmFpbGFibGUgaW4gQnJvd3NlckZTLmApKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZzYy5DcmVhdGUob3B0aW9ucywgY2IpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChvcHRpb25zICE9PSBudWxsICYmIHR5cGVvZihvcHRpb25zKSA9PT0gXCJvYmplY3RcIikge1xuICAgIGxldCBmaW5pc2hlZEl0ZXJhdGluZyA9IGZhbHNlO1xuICAgIGNvbnN0IHByb3BzID0gT2JqZWN0LmtleXMob3B0aW9ucykuZmlsdGVyKChrKSA9PiBrICE9PSAnZnMnKTtcblxuICAgIC8vIENoZWNrIHJlY3Vyc2l2ZWx5IGlmIG90aGVyIGZpZWxkcyBoYXZlICdmcycgcHJvcGVydGllcy5cbiAgICBwcm9wcy5mb3JFYWNoKChwKSA9PiB7XG4gICAgICBjb25zdCBkID0gb3B0aW9uc1twXTtcbiAgICAgIGlmIChkICE9PSBudWxsICYmIHR5cGVvZihkKSA9PT0gXCJvYmplY3RcIiAmJiBkWydmcyddKSB7XG4gICAgICAgIHdhaXRDb3VudCsrO1xuICAgICAgICBnZXRGaWxlU3lzdGVtKGQsIGZ1bmN0aW9uKGUsIGZzPykge1xuICAgICAgICAgIHdhaXRDb3VudC0tO1xuICAgICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICBpZiAoY2FsbGVkKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICAgICAgICBjYihlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3B0aW9uc1twXSA9IGZzO1xuICAgICAgICAgICAgaWYgKHdhaXRDb3VudCA9PT0gMCAmJiBmaW5pc2hlZEl0ZXJhdGluZykge1xuICAgICAgICAgICAgICBmaW5pc2goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGZpbmlzaGVkSXRlcmF0aW5nID0gdHJ1ZTtcbiAgfVxuICBpZiAod2FpdENvdW50ID09PSAwKSB7XG4gICAgZmluaXNoKCk7XG4gIH1cbn1cblxuZXhwb3J0IHtFbXNjcmlwdGVuRlMsIEJhY2tlbmRzIGFzIEZpbGVTeXN0ZW0sIEVycm9ycywgc2V0SW1tZWRpYXRlfTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi8uLi8uLi8uLi9zcmMvY29yZS9icm93c2VyZnMudHMiLCIvKipcbiAqIEJyb3dzZXJGUydzIG1haW4gZW50cnkgcG9pbnQuXG4gKiBJdCBpbnN0YWxscyBhbGwgb2YgdGhlIG5lZWRlZCBwb2x5ZmlsbHMsIGFuZCByZXF1aXJlcygpIHRoZSBtYWluIG1vZHVsZS5cbiAqL1xuXG4vLyBJRSBzdWJzdHIgZG9lcyBub3Qgc3VwcG9ydCBuZWdhdGl2ZSBpbmRpY2VzXG5pZiAoJ2FiJy5zdWJzdHIoLTEpICE9PSAnYicpIHtcbiAgU3RyaW5nLnByb3RvdHlwZS5zdWJzdHIgPSBmdW5jdGlvbihzdWJzdHI6IChzdGFydDogbnVtYmVyLCBsZW5ndGg/OiBudW1iZXIpID0+IHN0cmluZykge1xuICAgIHJldHVybiBmdW5jdGlvbih0aGlzOiBzdHJpbmcsIHN0YXJ0OiBudW1iZXIsIGxlbmd0aD86IG51bWJlcik6IHN0cmluZyB7XG4gICAgICAvLyBkaWQgd2UgZ2V0IGEgbmVnYXRpdmUgc3RhcnQsIGNhbGN1bGF0ZSBob3cgbXVjaCBpdCBpcyBmcm9tIHRoZVxuICAgICAgLy8gYmVnaW5uaW5nIG9mIHRoZSBzdHJpbmdcbiAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgc3RhcnQgPSB0aGlzLmxlbmd0aCArIHN0YXJ0O1xuICAgICAgfVxuICAgICAgLy8gY2FsbCB0aGUgb3JpZ2luYWwgZnVuY3Rpb25cbiAgICAgIHJldHVybiBzdWJzdHIuY2FsbCh0aGlzLCBzdGFydCwgbGVuZ3RoKTtcbiAgICB9O1xuICB9KFN0cmluZy5wcm90b3R5cGUuc3Vic3RyKTtcbn1cblxuLy8gUG9seWZpbGwgZm9yIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNsaWNlLlxuLy8gU2FmYXJpIGFuZCBzb21lIG90aGVyIGJyb3dzZXJzIGRvIG5vdCBkZWZpbmUgaXQuXG5pZiAodHlwZW9mKEFycmF5QnVmZmVyKSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mKFVpbnQ4QXJyYXkpICE9PSAndW5kZWZpbmVkJykge1xuICBpZiAoIVVpbnQ4QXJyYXkucHJvdG90eXBlWydzbGljZSddKSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbih0aGlzOiBVaW50OEFycmF5LCBzdGFydDogbnVtYmVyID0gMCwgZW5kOiBudW1iZXIgPSB0aGlzLmxlbmd0aCk6IFVpbnQ4QXJyYXkge1xuICAgICAgY29uc3Qgc2VsZjogVWludDhBcnJheSA9IHRoaXM7XG4gICAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICAgIHN0YXJ0ID0gdGhpcy5sZW5ndGggKyBzdGFydDtcbiAgICAgICAgaWYgKHN0YXJ0IDwgMCkge1xuICAgICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGVuZCA8IDApIHtcbiAgICAgICAgZW5kID0gdGhpcy5sZW5ndGggKyBlbmQ7XG4gICAgICAgIGlmIChlbmQgPCAwKSB7XG4gICAgICAgICAgZW5kID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGVuZCA8IHN0YXJ0KSB7XG4gICAgICAgIGVuZCA9IHN0YXJ0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHNlbGYuYnVmZmVyLCBzZWxmLmJ5dGVPZmZzZXQgKyBzdGFydCwgZW5kIC0gc3RhcnQpO1xuICAgIH07XG4gIH1cbn1cblxuZXhwb3J0ICogZnJvbSAnLi9jb3JlL2Jyb3dzZXJmcyc7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vLi4vLi4vLi4vc3JjL2luZGV4LnRzIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2J1aWxkL3RlbXAvbGlicmFyeS93ZWJwYWNrL0JGU0J1ZmZlci5qc1xuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxmZXJvc3NAZmVyb3NzLm9yZz4gPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG4ndXNlIHN0cmljdCdcblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5cbnZhciBLX01BWF9MRU5HVEggPSAweDdmZmZmZmZmXG5leHBvcnRzLmtNYXhMZW5ndGggPSBLX01BWF9MRU5HVEhcblxuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgUHJpbnQgd2FybmluZyBhbmQgcmVjb21tZW5kIHVzaW5nIGBidWZmZXJgIHY0Lnggd2hpY2ggaGFzIGFuIE9iamVjdFxuICogICAgICAgICAgICAgICBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogV2UgcmVwb3J0IHRoYXQgdGhlIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCB0eXBlZCBhcnJheXMgaWYgdGhlIGFyZSBub3Qgc3ViY2xhc3NhYmxlXG4gKiB1c2luZyBfX3Byb3RvX18uIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgXG4gKiAoU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzgpLiBJRSAxMCBsYWNrcyBzdXBwb3J0XG4gKiBmb3IgX19wcm90b19fIGFuZCBoYXMgYSBidWdneSB0eXBlZCBhcnJheSBpbXBsZW1lbnRhdGlvbi5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSB0eXBlZEFycmF5U3VwcG9ydCgpXG5cbmlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIGNvbnNvbGUuZXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgY29uc29sZS5lcnJvcihcbiAgICAnVGhpcyBicm93c2VyIGxhY2tzIHR5cGVkIGFycmF5IChVaW50OEFycmF5KSBzdXBwb3J0IHdoaWNoIGlzIHJlcXVpcmVkIGJ5ICcgK1xuICAgICdgYnVmZmVyYCB2NS54LiBVc2UgYGJ1ZmZlcmAgdjQueCBpZiB5b3UgcmVxdWlyZSBvbGQgYnJvd3NlciBzdXBwb3J0LidcbiAgKVxufVxuXG5mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCAoKSB7XG4gIC8vIENhbiB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZD9cbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSlcbiAgICBhcnIuX19wcm90b19fID0ge19fcHJvdG9fXzogVWludDhBcnJheS5wcm90b3R5cGUsIGZvbzogZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfX1cbiAgICByZXR1cm4gYXJyLmZvbygpID09PSA0MlxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlQnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKGxlbmd0aCA+IEtfTUFYX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHR5cGVkIGFycmF5IGxlbmd0aCcpXG4gIH1cbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgdmFyIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGxlbmd0aClcbiAgYnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIGJ1ZlxufVxuXG4vKipcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgaGF2ZSB0aGVpclxuICogcHJvdG90eXBlIGNoYW5nZWQgdG8gYEJ1ZmZlci5wcm90b3R5cGVgLiBGdXJ0aGVybW9yZSwgYEJ1ZmZlcmAgaXMgYSBzdWJjbGFzcyBvZlxuICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kc1xuICogYW5kIHRoZSBgVWludDhBcnJheWAgbWV0aG9kcy4gU3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXRcbiAqIHJldHVybnMgYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogVGhlIGBVaW50OEFycmF5YCBwcm90b3R5cGUgcmVtYWlucyB1bm1vZGlmaWVkLlxuICovXG5cbmZ1bmN0aW9uIEJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgLy8gQ29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0lmIGVuY29kaW5nIGlzIHNwZWNpZmllZCB0aGVuIHRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nJ1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gYWxsb2NVbnNhZmUoYXJnKVxuICB9XG4gIHJldHVybiBmcm9tKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG4vLyBGaXggc3ViYXJyYXkoKSBpbiBFUzIwMTYuIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC85N1xuaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC5zcGVjaWVzICYmXG4gICAgQnVmZmVyW1N5bWJvbC5zcGVjaWVzXSA9PT0gQnVmZmVyKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIsIFN5bWJvbC5zcGVjaWVzLCB7XG4gICAgdmFsdWU6IG51bGwsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9KVxufVxuXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxuZnVuY3Rpb24gZnJvbSAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXG4gIH1cblxuICBpZiAoaXNBcnJheUJ1ZmZlcih2YWx1ZSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxuICB9XG5cbiAgcmV0dXJuIGZyb21PYmplY3QodmFsdWUpXG59XG5cbi8qKlxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICogQnVmZmVyLmZyb20oYXJyYXkpXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAqKi9cbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGZyb20odmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuLy8gTm90ZTogQ2hhbmdlIHByb3RvdHlwZSAqYWZ0ZXIqIEJ1ZmZlci5mcm9tIGlzIGRlZmluZWQgdG8gd29ya2Fyb3VuZCBDaHJvbWUgYnVnOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC8xNDhcbkJ1ZmZlci5wcm90b3R5cGUuX19wcm90b19fID0gVWludDhBcnJheS5wcm90b3R5cGVcbkJ1ZmZlci5fX3Byb3RvX18gPSBVaW50OEFycmF5XG5cbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG5lZ2F0aXZlJylcbiAgfVxufVxuXG5mdW5jdGlvbiBhbGxvYyAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICBpZiAoc2l6ZSA8PSAwKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKVxuICB9XG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPbmx5IHBheSBhdHRlbnRpb24gdG8gZW5jb2RpbmcgaWYgaXQncyBhIHN0cmluZy4gVGhpc1xuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWxseSBzZW5kaW5nIGluIGEgbnVtYmVyIHRoYXQgd291bGRcbiAgICAvLyBiZSBpbnRlcnByZXR0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXG4gICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZydcbiAgICAgID8gY3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgICA6IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwpXG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIGFsbG9jKHNpemVbLCBmaWxsWywgZW5jb2RpbmddXSlcbiAqKi9cbkJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICByZXR1cm4gYWxsb2Moc2l6ZSwgZmlsbCwgZW5jb2RpbmcpXG59XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlIChzaXplKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMClcbn1cblxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIEJ1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKVxufVxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIFNsb3dCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKVxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZW5jb2RpbmdcIiBtdXN0IGJlIGEgdmFsaWQgc3RyaW5nIGVuY29kaW5nJylcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMFxuICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aClcblxuICB2YXIgYWN0dWFsID0gYnVmLndyaXRlKHN0cmluZywgZW5jb2RpbmcpXG5cbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbiAgICBidWYgPSBidWYuc2xpY2UoMCwgYWN0dWFsKVxuICB9XG5cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlIChhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHZhciBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgYnVmW2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnb2Zmc2V0XFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdsZW5ndGhcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICB2YXIgYnVmXG4gIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSlcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KVxuICB9IGVsc2Uge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICBidWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKG9iaikge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iaikpIHtcbiAgICB2YXIgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDBcbiAgICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbilcblxuICAgIGlmIChidWYubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gYnVmXG4gICAgfVxuXG4gICAgb2JqLmNvcHkoYnVmLCAwLCAwLCBsZW4pXG4gICAgcmV0dXJuIGJ1ZlxuICB9XG5cbiAgaWYgKG9iaikge1xuICAgIGlmIChpc0FycmF5QnVmZmVyVmlldyhvYmopIHx8ICdsZW5ndGgnIGluIG9iaikge1xuICAgICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBudW1iZXJJc05hTihvYmoubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKDApXG4gICAgICB9XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZShvYmopXG4gICAgfVxuXG4gICAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBBcnJheS5pc0FycmF5KG9iai5kYXRhKSkge1xuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqLmRhdGEpXG4gICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksIG9yIGFycmF5LWxpa2Ugb2JqZWN0LicpXG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBLX01BWF9MRU5HVEhgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0gS19NQVhfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIEtfTUFYX0xFTkdUSC50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgbGVuZ3RoID0gMFxuICB9XG4gIHJldHVybiBCdWZmZXIuYWxsb2MoK2xlbmd0aClcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuIGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlciA9PT0gdHJ1ZVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyBtdXN0IGJlIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgdmFyIHggPSBhLmxlbmd0aFxuICB2YXIgeSA9IGIubGVuZ3RoXG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV1cbiAgICAgIHkgPSBiW2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdsYXRpbjEnOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gIH1cblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApXG4gIH1cblxuICB2YXIgaVxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgIHZhciBidWYgPSBsaXN0W2ldXG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgICB9XG4gICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgcG9zICs9IGJ1Zi5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAoaXNBcnJheUJ1ZmZlclZpZXcoc3RyaW5nKSB8fCBpc0FycmF5QnVmZmVyKHN0cmluZykpIHtcbiAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICBzdHJpbmcgPSAnJyArIHN0cmluZ1xuICB9XG5cbiAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgLy8gTm8gbmVlZCB0byB2ZXJpZnkgdGhhdCBcInRoaXMubGVuZ3RoIDw9IE1BWF9VSU5UMzJcIiBzaW5jZSBpdCdzIGEgcmVhZC1vbmx5XG4gIC8vIHByb3BlcnR5IG9mIGEgdHlwZWQgYXJyYXkuXG5cbiAgLy8gVGhpcyBiZWhhdmVzIG5laXRoZXIgbGlrZSBTdHJpbmcgbm9yIFVpbnQ4QXJyYXkgaW4gdGhhdCB3ZSBzZXQgc3RhcnQvZW5kXG4gIC8vIHRvIHRoZWlyIHVwcGVyL2xvd2VyIGJvdW5kcyBpZiB0aGUgdmFsdWUgcGFzc2VkIGlzIG91dCBvZiByYW5nZS5cbiAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbixcbiAgLy8gU2VjdGlvbiAxMy4zLjMuNyBSdW50aW1lIFNlbWFudGljczogS2V5ZWRCaW5kaW5nSW5pdGlhbGl6YXRpb24uXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKGVuZCA8PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvLyBGb3JjZSBjb2Vyc2lvbiB0byB1aW50MzIuIFRoaXMgd2lsbCBhbHNvIGNvZXJjZSBmYWxzZXkvTmFOIHZhbHVlcyB0byAwLlxuICBlbmQgPj4+PSAwXG4gIHN0YXJ0ID4+Pj0gMFxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG4vLyBUaGlzIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgKGFuZCB0aGUgYGlzLWJ1ZmZlcmAgbnBtIHBhY2thZ2UpXG4vLyB0byBkZXRlY3QgYSBCdWZmZXIgaW5zdGFuY2UuIEl0J3Mgbm90IHBvc3NpYmxlIHRvIHVzZSBgaW5zdGFuY2VvZiBCdWZmZXJgXG4vLyByZWxpYWJseSBpbiBhIGJyb3dzZXJpZnkgY29udGV4dCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG11bHRpcGxlIGRpZmZlcmVudFxuLy8gY29waWVzIG9mIHRoZSAnYnVmZmVyJyBwYWNrYWdlIGluIHVzZS4gVGhpcyBtZXRob2Qgd29ya3MgZXZlbiBmb3IgQnVmZmVyXG4vLyBpbnN0YW5jZXMgdGhhdCB3ZXJlIGNyZWF0ZWQgZnJvbSBhbm90aGVyIGNvcHkgb2YgdGhlIGBidWZmZXJgIHBhY2thZ2UuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8xNTRcbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZVxuXG5mdW5jdGlvbiBzd2FwIChiLCBuLCBtKSB7XG4gIHZhciBpID0gYltuXVxuICBiW25dID0gYlttXVxuICBiW21dID0gaVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDEpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAzKVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA4ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgNylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgNilcbiAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSlcbiAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNClcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcbiAgICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLm1hdGNoKC8uezJ9L2cpLmpvaW4oJyAnKVxuICAgIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlICh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc1N0YXJ0ID0gMFxuICB9XG4gIGlmICh0aGlzRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICBzdGFydCA+Pj49IDBcbiAgZW5kID4+Pj0gMFxuICB0aGlzU3RhcnQgPj4+PSAwXG4gIHRoaXNFbmQgPj4+PSAwXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDBcblxuICB2YXIgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnRcbiAgdmFyIHkgPSBlbmQgLSBzdGFydFxuICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSlcblxuICB2YXIgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZClcbiAgdmFyIHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICB4ID0gdGhpc0NvcHlbaV1cbiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxuLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cbi8vXG4vLyBBcmd1bWVudHM6XG4vLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxuLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxuLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcbi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxuICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0XG4gICAgYnl0ZU9mZnNldCA9IDBcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikge1xuICAgIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XG4gICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwXG4gIH1cbiAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0ICAvLyBDb2VyY2UgdG8gTnVtYmVyLlxuICBpZiAobnVtYmVySXNOYU4oYnl0ZU9mZnNldCkpIHtcbiAgICAvLyBieXRlT2Zmc2V0OiBpdCBpdCdzIHVuZGVmaW5lZCwgbnVsbCwgTmFOLCBcImZvb1wiLCBldGMsIHNlYXJjaCB3aG9sZSBidWZmZXJcbiAgICBieXRlT2Zmc2V0ID0gZGlyID8gMCA6IChidWZmZXIubGVuZ3RoIC0gMSlcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0OiBuZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggKyBieXRlT2Zmc2V0XG4gIGlmIChieXRlT2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICBpZiAoZGlyKSByZXR1cm4gLTFcbiAgICBlbHNlIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoIC0gMVxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7XG4gICAgaWYgKGRpcikgYnl0ZU9mZnNldCA9IDBcbiAgICBlbHNlIHJldHVybiAtMVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIHZhbFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWwgPSBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICB9XG5cbiAgLy8gRmluYWxseSwgc2VhcmNoIGVpdGhlciBpbmRleE9mIChpZiBkaXIgaXMgdHJ1ZSkgb3IgbGFzdEluZGV4T2ZcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcvYnVmZmVyIGFsd2F5cyBmYWlsc1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDB4RkYgLy8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XVxuICAgIGlmICh0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGRpcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbIHZhbCBdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICB2YXIgaW5kZXhTaXplID0gMVxuICB2YXIgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aFxuICB2YXIgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aFxuXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fFxuICAgICAgICBlbmNvZGluZyA9PT0gJ3V0ZjE2bGUnIHx8IGVuY29kaW5nID09PSAndXRmLTE2bGUnKSB7XG4gICAgICBpZiAoYXJyLmxlbmd0aCA8IDIgfHwgdmFsLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG4gICAgICBpbmRleFNpemUgPSAyXG4gICAgICBhcnJMZW5ndGggLz0gMlxuICAgICAgdmFsTGVuZ3RoIC89IDJcbiAgICAgIGJ5dGVPZmZzZXQgLz0gMlxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWQgKGJ1ZiwgaSkge1xuICAgIGlmIChpbmRleFNpemUgPT09IDEpIHtcbiAgICAgIHJldHVybiBidWZbaV1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaSAqIGluZGV4U2l6ZSlcbiAgICB9XG4gIH1cblxuICB2YXIgaVxuICBpZiAoZGlyKSB7XG4gICAgdmFyIGZvdW5kSW5kZXggPSAtMVxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPCBhcnJMZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkgcmV0dXJuIGZvdW5kSW5kZXggKiBpbmRleFNpemVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleFxuICAgICAgICBmb3VuZEluZGV4ID0gLTFcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGhcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGZvdW5kID0gdHJ1ZVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7XG4gICAgICAgICAgZm91bmQgPSBmYWxzZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgLy8gbXVzdCBiZSBhbiBldmVuIG51bWJlciBvZiBkaWdpdHNcbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKHN0ckxlbiAlIDIgIT09IDApIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKG51bWJlcklzTmFOKHBhcnNlZCkpIHJldHVybiBpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBsYXRpbjFXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoID4+PiAwXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuICB2YXIgcmVzID0gW11cblxuICB2YXIgaSA9IHN0YXJ0XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgdmFyIGZpcnN0Qnl0ZSA9IGJ1ZltpXVxuICAgIHZhciBjb2RlUG9pbnQgPSBudWxsXG4gICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRikgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKSA/IDNcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMlxuICAgICAgOiAxXG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG52YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIHZhciBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIHZhciByZXMgPSAnJ1xuICB2YXIgaSA9IDBcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgKGJ5dGVzW2kgKyAxXSAqIDI1NikpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgdmFyIG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZClcbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgbmV3QnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICB2YXIgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGhcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCAoOCAqIGJ5dGVMZW5ndGgpIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSAwXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG4gIHZhciBpXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBzdGFydCA8IHRhcmdldFN0YXJ0ICYmIHRhcmdldFN0YXJ0IDwgZW5kKSB7XG4gICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kXG4gICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2UgaWYgKGxlbiA8IDEwMDApIHtcbiAgICAvLyBhc2NlbmRpbmcgY29weSBmcm9tIHN0YXJ0XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgIHRhcmdldCxcbiAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKSxcbiAgICAgIHRhcmdldFN0YXJ0XG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIGxlblxufVxuXG4vLyBVc2FnZTpcbi8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoYnVmZmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczpcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gc3RhcnRcbiAgICAgIHN0YXJ0ID0gMFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuZFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMClcbiAgICAgIGlmIChjb2RlIDwgMjU2KSB7XG4gICAgICAgIHZhbCA9IGNvZGVcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAyNTVcbiAgfVxuXG4gIC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LlxuICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwXG5cbiAgaWYgKCF2YWwpIHZhbCA9IDBcblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICB0aGlzW2ldID0gdmFsXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IEJ1ZmZlci5pc0J1ZmZlcih2YWwpXG4gICAgICA/IHZhbFxuICAgICAgOiBuZXcgQnVmZmVyKHZhbCwgZW5jb2RpbmcpXG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7XG4gICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teKy8wLTlBLVphLXotX10vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHIudHJpbSgpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICB2YXIgY29kZVBvaW50XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICB2YXIgYnl0ZXMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuLy8gQXJyYXlCdWZmZXJzIGZyb20gYW5vdGhlciBjb250ZXh0IChpLmUuIGFuIGlmcmFtZSkgZG8gbm90IHBhc3MgdGhlIGBpbnN0YW5jZW9mYCBjaGVja1xuLy8gYnV0IHRoZXkgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgdmFsaWQuIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE2NlxuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlciAob2JqKSB7XG4gIHJldHVybiBvYmogaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciB8fFxuICAgIChvYmogIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IgIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IubmFtZSA9PT0gJ0FycmF5QnVmZmVyJyAmJlxuICAgICAgdHlwZW9mIG9iai5ieXRlTGVuZ3RoID09PSAnbnVtYmVyJylcbn1cblxuLy8gTm9kZSAwLjEwIHN1cHBvcnRzIGBBcnJheUJ1ZmZlcmAgYnV0IGxhY2tzIGBBcnJheUJ1ZmZlci5pc1ZpZXdgXG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyVmlldyAob2JqKSB7XG4gIHJldHVybiAodHlwZW9mIEFycmF5QnVmZmVyLmlzVmlldyA9PT0gJ2Z1bmN0aW9uJykgJiYgQXJyYXlCdWZmZXIuaXNWaWV3KG9iailcbn1cblxuZnVuY3Rpb24gbnVtYmVySXNOYU4gKG9iaikge1xuICByZXR1cm4gb2JqICE9PSBvYmogLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9idWZmZXIvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcbmV4cG9ydHMudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheVxuZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheVxuXG52YXIgbG9va3VwID0gW11cbnZhciByZXZMb29rdXAgPSBbXVxudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxuXG52YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ1xuZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgbG9va3VwW2ldID0gY29kZVtpXVxuICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGlcbn1cblxucmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyXG5yZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjNcblxuZnVuY3Rpb24gcGxhY2VIb2xkZXJzQ291bnQgKGI2NCkge1xuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuICBpZiAobGVuICUgNCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuICB9XG5cbiAgLy8gdGhlIG51bWJlciBvZiBlcXVhbCBzaWducyAocGxhY2UgaG9sZGVycylcbiAgLy8gaWYgdGhlcmUgYXJlIHR3byBwbGFjZWhvbGRlcnMsIHRoYW4gdGhlIHR3byBjaGFyYWN0ZXJzIGJlZm9yZSBpdFxuICAvLyByZXByZXNlbnQgb25lIGJ5dGVcbiAgLy8gaWYgdGhlcmUgaXMgb25seSBvbmUsIHRoZW4gdGhlIHRocmVlIGNoYXJhY3RlcnMgYmVmb3JlIGl0IHJlcHJlc2VudCAyIGJ5dGVzXG4gIC8vIHRoaXMgaXMganVzdCBhIGNoZWFwIGhhY2sgdG8gbm90IGRvIGluZGV4T2YgdHdpY2VcbiAgcmV0dXJuIGI2NFtsZW4gLSAyXSA9PT0gJz0nID8gMiA6IGI2NFtsZW4gLSAxXSA9PT0gJz0nID8gMSA6IDBcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoYjY0KSB7XG4gIC8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuICByZXR1cm4gYjY0Lmxlbmd0aCAqIDMgLyA0IC0gcGxhY2VIb2xkZXJzQ291bnQoYjY0KVxufVxuXG5mdW5jdGlvbiB0b0J5dGVBcnJheSAoYjY0KSB7XG4gIHZhciBpLCBqLCBsLCB0bXAsIHBsYWNlSG9sZGVycywgYXJyXG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG4gIHBsYWNlSG9sZGVycyA9IHBsYWNlSG9sZGVyc0NvdW50KGI2NClcblxuICBhcnIgPSBuZXcgQXJyKGxlbiAqIDMgLyA0IC0gcGxhY2VIb2xkZXJzKVxuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgbCA9IHBsYWNlSG9sZGVycyA+IDAgPyBsZW4gLSA0IDogbGVuXG5cbiAgdmFyIEwgPSAwXG5cbiAgZm9yIChpID0gMCwgaiA9IDA7IGkgPCBsOyBpICs9IDQsIGogKz0gMykge1xuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDE4KSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfCByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDMpXVxuICAgIGFycltMKytdID0gKHRtcCA+PiAxNikgJiAweEZGXG4gICAgYXJyW0wrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltMKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVycyA9PT0gMikge1xuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpXG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGXG4gIH0gZWxzZSBpZiAocGxhY2VIb2xkZXJzID09PSAxKSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTApIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpXG4gICAgYXJyW0wrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltMKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICsgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICsgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gKyBsb29rdXBbbnVtICYgMHgzRl1cbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gIHZhciB0bXBcbiAgdmFyIG91dHB1dCA9IFtdXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID0gKHVpbnQ4W2ldIDw8IDE2KSArICh1aW50OFtpICsgMV0gPDwgOCkgKyAodWludDhbaSArIDJdKVxuICAgIG91dHB1dC5wdXNoKHRyaXBsZXRUb0Jhc2U2NCh0bXApKVxuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJylcbn1cblxuZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVuID0gdWludDgubGVuZ3RoXG4gIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuICB2YXIgb3V0cHV0ID0gJydcbiAgdmFyIHBhcnRzID0gW11cbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayh1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpKSlcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxuICAgIG91dHB1dCArPSBsb29rdXBbdG1wID4+IDJdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl1cbiAgICBvdXRwdXQgKz0gJz09J1xuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyAodWludDhbbGVuIC0gMV0pXG4gICAgb3V0cHV0ICs9IGxvb2t1cFt0bXAgPj4gMTBdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl1cbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXVxuICAgIG91dHB1dCArPSAnPSdcbiAgfVxuXG4gIHBhcnRzLnB1c2gob3V0cHV0KVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Jhc2U2NC1qcy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9pZWVlNzU0L2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kdWxlKSB7XHJcblx0aWYoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcclxuXHRcdG1vZHVsZS5kZXByZWNhdGUgPSBmdW5jdGlvbigpIHt9O1xyXG5cdFx0bW9kdWxlLnBhdGhzID0gW107XHJcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcclxuXHRcdG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xyXG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XHJcblx0fVxyXG5cdHJldHVybiBtb2R1bGU7XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzXG4vLyBtb2R1bGUgaWQgPSA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBQcm9jZXNzID0gcmVxdWlyZSgnLi9wcm9jZXNzJyk7XG5pbXBvcnQgVFREID0gcmVxdWlyZSgnLi90dHknKTtcblxudmFyIHByb2Nlc3MgPSBuZXcgUHJvY2VzcygpLFxuICBwcm9jZXNzUHJveHk6IFByb2Nlc3MgPSA8YW55PiB7fTtcblxuZnVuY3Rpb24gZGVmaW5lS2V5KGtleTogc3RyaW5nKSB7XG4gIGlmICgoPGFueT4gcHJvY2Vzc1Byb3h5KVtrZXldKSB7XG4gICAgLy8gUHJvYmFibHkgYSBidWlsdGluIE9iamVjdCBwcm9wZXJ0eSB3ZSBkb24ndCBjYXJlIGFib3V0LlxuICAgIHJldHVybjtcbiAgfVxuICBpZiAodHlwZW9mICg8YW55PiBwcm9jZXNzKVtrZXldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgKDxhbnk+IHByb2Nlc3NQcm94eSlba2V5XSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICg8RnVuY3Rpb24+ICg8YW55PiBwcm9jZXNzKVtrZXldKS5hcHBseShwcm9jZXNzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgKDxhbnk+IHByb2Nlc3NQcm94eSlba2V5XSA9ICg8YW55PiBwcm9jZXNzKVtrZXldO1xuICB9XG59XG5cbmZvciAodmFyIGtleSBpbiBwcm9jZXNzKSB7XG4gIC8vIERvbid0IGNoZWNrIGlmIHByb2Nlc3MuaGFzT3duUHJvcGVydHk7IHdlIHdhbnQgdG8gYWxzbyBleHBvc2Ugb2JqZWN0c1xuICAvLyB1cCB0aGUgcHJvdG90eXBlIGhpZXJhcmNoeS5cbiAgZGVmaW5lS2V5KGtleSk7XG59XG5cbi8vIFNwZWNpYWwga2V5OiBFbnN1cmUgd2UgdXBkYXRlIHB1YmxpYy1mYWNpbmcgdmFsdWVzIG9mIHN0ZGluL3N0ZG91dC9zdGRlcnIuXG5wcm9jZXNzUHJveHkuaW5pdGlhbGl6ZVRUWXMgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHByb2Nlc3Muc3RkaW4gPT09IG51bGwpIHtcbiAgICBwcm9jZXNzLmluaXRpYWxpemVUVFlzKCk7XG4gICAgcHJvY2Vzc1Byb3h5LnN0ZGluID0gcHJvY2Vzcy5zdGRpbjtcbiAgICBwcm9jZXNzUHJveHkuc3Rkb3V0ID0gcHJvY2Vzcy5zdGRvdXQ7XG4gICAgcHJvY2Vzc1Byb3h5LnN0ZGVyciA9IHByb2Nlc3Muc3RkZXJyO1xuICB9XG59O1xuXG5wcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgcHJvY2Vzc1Byb3h5LmluaXRpYWxpemVUVFlzKCk7XG59KTtcblxuZXhwb3J0ID0gcHJvY2Vzc1Byb3h5O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL3RzL2luZGV4LnRzIiwiLy8gVXNlIHBhdGggYW5kIFRUWSBmb3IgdHlwZSBpbmZvcm1hdGlvbiBvbmx5LiBXZSBsYXppbHkgcHVsbCB0aGVtIGluXG4vLyB0byBhdm9pZCBjaXJjdWxhciBkZXBlbmRlbmNpZXMgOihcbi8vIChwYXRoIGRlcGVuZHMgb24gcHJvY2VzcyBmb3IgY3dkKCksIFRUWSBkZXBlbmRzIG9uIHN0cmVhbXMgd2hpY2ggZGVwZW5kc1xuLy8gIG9uIHByb2Nlc3MubmV4dFRpY2svcHJvY2Vzcy5zdGRvdXQvc3RkZXJyL3N0ZGluKS5cbmltcG9ydCBfcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbmltcG9ydCBfVFRZID0gcmVxdWlyZSgnLi90dHknKTtcbmltcG9ydCBldmVudHMgPSByZXF1aXJlKCdldmVudHMnKTtcblxuLy8gUGF0aCBkZXBlbmRzIG9uIHByb2Nlc3MuIEF2b2lkIGEgY2lyY3VsYXIgcmVmZXJlbmNlIGJ5IGR5bmFtaWNhbGx5IGluY2x1ZGluZyBwYXRoIHdoZW4gd2UgbmVlZCBpdC5cbnZhciBwYXRoOiB0eXBlb2YgX3BhdGggPSBudWxsO1xuXG5jbGFzcyBJdGVtIHtcbiAgcHJpdmF0ZSBmdW46IEZ1bmN0aW9uO1xuICBwcml2YXRlIGFycmF5OiBhbnlbXTtcbiAgY29uc3RydWN0b3IoZnVuOiBGdW5jdGlvbiwgYXJyYXk6IGFueVtdKSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xuICB9XG5cbiAgcHVibGljIHJ1bigpOiB2b2lkIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbiAgfVxufVxuXG4vKipcbiAqIENvbnRhaW5zIGEgcXVldWUgb2YgSXRlbXMgZm9yIHByb2Nlc3MubmV4dFRpY2suXG4gKiBJbnNwaXJlZCBieSBub2RlLXByb2Nlc3M6IGh0dHBzOi8vZ2l0aHViLmNvbS9kZWZ1bmN0em9tYmllL25vZGUtcHJvY2Vzc1xuICovXG5jbGFzcyBOZXh0VGlja1F1ZXVlIHtcbiAgcHJpdmF0ZSBfcXVldWU6IEl0ZW1bXSA9IFtdO1xuICBwcml2YXRlIF9kcmFpbmluZyA9IGZhbHNlO1xuICAvLyBVc2VkL2Fzc2lnbmVkIGJ5IHRoZSBkcmFpblF1ZXVlIGZ1bmN0aW9uLlxuICBwcml2YXRlIF9jdXJyZW50UXVldWU6IEl0ZW1bXSA9IG51bGw7XG4gIHByaXZhdGUgX3F1ZXVlSW5kZXggPSAtMTtcblxuICBwdWJsaWMgcHVzaChpdGVtOiBJdGVtKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuX3F1ZXVlLnB1c2goaXRlbSkgPT09IDEgJiYgIXRoaXMuX2RyYWluaW5nKSB7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuX2RyYWluUXVldWUoKSwgMCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBfY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIHRoaXMuX2RyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKHRoaXMuX2N1cnJlbnRRdWV1ZSAmJiB0aGlzLl9jdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICB0aGlzLl9xdWV1ZSA9IHRoaXMuX2N1cnJlbnRRdWV1ZS5jb25jYXQodGhpcy5fcXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9xdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmICh0aGlzLl9xdWV1ZS5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX2RyYWluUXVldWUoKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIF9kcmFpblF1ZXVlKCkge1xuICAgIGlmICh0aGlzLl9kcmFpbmluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBJZiBhbiBJdGVtIHRocm93cyBhbiB1bmhhbmRsZWQgZXhjZXB0aW9uLCB0aGlzIGZ1bmN0aW9uIHdpbGwgY2xlYW4gdGhpbmdzIHVwLlxuICAgIHZhciB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLl9jbGVhblVwTmV4dFRpY2soKSk7XG4gICAgdGhpcy5fZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHRoaXMuX3F1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgIHRoaXMuX2N1cnJlbnRRdWV1ZSA9IHRoaXMuX3F1ZXVlO1xuICAgICAgdGhpcy5fcXVldWUgPSBbXTtcbiAgICAgIHdoaWxlICgrK3RoaXMuX3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgIHRoaXMuX2N1cnJlbnRRdWV1ZVt0aGlzLl9xdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fcXVldWVJbmRleCA9IC0xO1xuICAgICAgbGVuID0gdGhpcy5fcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICB0aGlzLl9jdXJyZW50UXVldWUgPSBudWxsO1xuICAgIHRoaXMuX2RyYWluaW5nID0gZmFsc2U7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICB9XG59XG5cbi8qKlxuICogUGFydGlhbCBpbXBsZW1lbnRhdGlvbiBvZiBOb2RlJ3MgYHByb2Nlc3NgIG1vZHVsZS5cbiAqIFdlIGltcGxlbWVudCB0aGUgcG9ydGlvbnMgdGhhdCBhcmUgcmVsZXZhbnQgZm9yIHRoZSBmaWxlc3lzdGVtLlxuICogQHNlZSBodHRwOi8vbm9kZWpzLm9yZy9hcGkvcHJvY2Vzcy5odG1sXG4gKiBAY2xhc3NcbiAqL1xuY2xhc3MgUHJvY2VzcyBleHRlbmRzIGV2ZW50cy5FdmVudEVtaXR0ZXIgaW1wbGVtZW50cyBOb2RlSlMuUHJvY2VzcyB7XG4gIHByaXZhdGUgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcblxuICBwcml2YXRlIF9jd2Q6IHN0cmluZyA9ICcvJztcbiAgLyoqXG4gICAqIENoYW5nZXMgdGhlIGN1cnJlbnQgd29ya2luZyBkaXJlY3RvcnkuXG4gICAqXG4gICAqICoqTm90ZSoqOiBCcm93c2VyRlMgZG9lcyBub3QgdmFsaWRhdGUgdGhhdCB0aGUgZGlyZWN0b3J5IGFjdHVhbGx5IGV4aXN0cy5cbiAgICpcbiAgICogQGV4YW1wbGUgVXNhZ2UgZXhhbXBsZVxuICAgKiAgIGNvbnNvbGUubG9nKCdTdGFydGluZyBkaXJlY3Rvcnk6ICcgKyBwcm9jZXNzLmN3ZCgpKTtcbiAgICogICBwcm9jZXNzLmNoZGlyKCcvdG1wJyk7XG4gICAqICAgY29uc29sZS5sb2coJ05ldyBkaXJlY3Rvcnk6ICcgKyBwcm9jZXNzLmN3ZCgpKTtcbiAgICogQHBhcmFtIFtTdHJpbmddIGRpciBUaGUgZGlyZWN0b3J5IHRvIGNoYW5nZSB0by5cbiAgICovXG4gIHB1YmxpYyBjaGRpcihkaXI6IHN0cmluZyk6IHZvaWQge1xuICAgIC8vIFhYWDogQ2lyY3VsYXIgZGVwZW5kZW5jeSBoYWNrLlxuICAgIGlmIChwYXRoID09PSBudWxsKSB7XG4gICAgICBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuICAgIH1cbiAgICB0aGlzLl9jd2QgPSBwYXRoLnJlc29sdmUoZGlyKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCB3b3JraW5nIGRpcmVjdG9yeS5cbiAgICogQGV4YW1wbGUgVXNhZ2UgZXhhbXBsZVxuICAgKiAgIGNvbnNvbGUubG9nKCdDdXJyZW50IGRpcmVjdG9yeTogJyArIHByb2Nlc3MuY3dkKCkpO1xuICAgKiBAcmV0dXJuIFtTdHJpbmddIFRoZSBjdXJyZW50IHdvcmtpbmcgZGlyZWN0b3J5LlxuICAgKi9cbiAgcHVibGljIGN3ZCgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl9jd2Q7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgd2hhdCBwbGF0Zm9ybSB5b3UgYXJlIHJ1bm5pbmcgb24uXG4gICAqIEByZXR1cm4gW1N0cmluZ11cbiAgICovXG4gIHB1YmxpYyBwbGF0Zm9ybTogc3RyaW5nID0gJ2Jyb3dzZXInO1xuICAvKipcbiAgICogTnVtYmVyIG9mIHNlY29uZHMgQnJvd3NlckZTIGhhcyBiZWVuIHJ1bm5pbmcuXG4gICAqIEByZXR1cm4gW051bWJlcl1cbiAgICovXG4gIHB1YmxpYyB1cHRpbWUoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gKChEYXRlLm5vdygpIC0gdGhpcy5zdGFydFRpbWUpIC8gMTAwMCkgfCAwO1xuICB9XG5cbiAgcHVibGljIGFyZ3Y6IHN0cmluZ1tdID0gW107XG4gIHB1YmxpYyBleGVjQXJndjogc3RyaW5nW10gPSBbXTtcbiAgcHVibGljIHN0ZG91dDogX1RUWSA9IG51bGw7XG4gIHB1YmxpYyBzdGRlcnI6IF9UVFkgPSBudWxsO1xuICBwdWJsaWMgc3RkaW46IF9UVFkgPSBudWxsO1xuICBwdWJsaWMgZG9tYWluOiBOb2RlSlMuRG9tYWluID0gbnVsbDtcblxuICBwcml2YXRlIF9xdWV1ZTogTmV4dFRpY2tRdWV1ZSA9IG5ldyBOZXh0VGlja1F1ZXVlKCk7XG5cbiAgcHVibGljIG5leHRUaWNrKGZ1bjogYW55LCAuLi5hcmdzOiBhbnlbXSkge1xuICAgIHRoaXMuX3F1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gIH1cblxuICBwdWJsaWMgZXhlY1BhdGggPSBfX2Rpcm5hbWU7XG5cbiAgcHVibGljIGFib3J0KCk6IHZvaWQge1xuICAgIHRoaXMuZW1pdCgnYWJvcnQnKTtcbiAgfVxuXG4gIHB1YmxpYyBlbnY6IHtbbmFtZTogc3RyaW5nXTogc3RyaW5nfSA9IHt9O1xuICBwdWJsaWMgZXhpdENvZGU6IG51bWJlciA9IDA7XG4gIHB1YmxpYyBleGl0KGNvZGU6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMuZXhpdENvZGUgPSBjb2RlO1xuICAgIHRoaXMuZW1pdCgnZXhpdCcsIFtjb2RlXSk7XG4gIH1cblxuICBwcml2YXRlIF9naWQ6IG51bWJlciA9IDE7XG4gIHB1YmxpYyBnZXRnaWQoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fZ2lkO1xuICB9XG4gIHB1YmxpYyBzZXRnaWQoZ2lkOiBudW1iZXIgfCBzdHJpbmcpOiB2b2lkIHtcbiAgICBpZiAodHlwZW9mIGdpZCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRoaXMuX2dpZCA9IGdpZDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZ2lkID0gMTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIF91aWQ6IG51bWJlciA9IDE7XG4gIHB1YmxpYyBnZXR1aWQoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fdWlkO1xuICB9XG4gIHB1YmxpYyBzZXR1aWQodWlkOiBudW1iZXIgfCBzdHJpbmcpOiB2b2lkIHtcbiAgICBpZiAodHlwZW9mIHVpZCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRoaXMuX3VpZCA9IHVpZDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fdWlkID0gMTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgdmVyc2lvbjogc3RyaW5nID0gJ3Y1LjAnO1xuXG4gIHB1YmxpYyB2ZXJzaW9ucyA9IHtcbiAgICBodHRwX3BhcnNlcjogJzAuMCcsXG4gICAgbm9kZTogJzUuMCcsXG4gICAgdjg6ICcwLjAnLFxuICAgIHV2OiAnMC4wJyxcbiAgICB6bGliOiAnMC4wJyxcbiAgICBhcmVzOiAnMC4wJyxcbiAgICBpY3U6ICcwLjAnLFxuICAgIG1vZHVsZXM6ICcwJyxcbiAgICBvcGVuc3NsOiAnMC4wJ1xuICB9O1xuXG4gIHB1YmxpYyBjb25maWcgPSB7XG4gICAgdGFyZ2V0X2RlZmF1bHRzOlxuICAgIHsgY2ZsYWdzOiA8YW55W10+IFtdLFxuICAgICAgZGVmYXVsdF9jb25maWd1cmF0aW9uOiAnUmVsZWFzZScsXG4gICAgICBkZWZpbmVzOiA8c3RyaW5nW10+IFtdLFxuICAgICAgaW5jbHVkZV9kaXJzOiA8c3RyaW5nW10+IFtdLFxuICAgICAgbGlicmFyaWVzOiA8c3RyaW5nW10+IFtdIH0sXG4gICAgdmFyaWFibGVzOlxuICAgIHsgY2xhbmc6IDAsXG4gICAgICBob3N0X2FyY2g6ICd4MzInLFxuICAgICAgbm9kZV9pbnN0YWxsX25wbTogZmFsc2UsXG4gICAgICBub2RlX2luc3RhbGxfd2FmOiBmYWxzZSxcbiAgICAgIG5vZGVfcHJlZml4OiAnJyxcbiAgICAgIG5vZGVfc2hhcmVkX2NhcmVzOiBmYWxzZSxcbiAgICAgIG5vZGVfc2hhcmVkX2h0dHBfcGFyc2VyOiBmYWxzZSxcbiAgICAgIG5vZGVfc2hhcmVkX2xpYnV2OiBmYWxzZSxcbiAgICAgIG5vZGVfc2hhcmVkX3psaWI6IGZhbHNlLFxuICAgICAgbm9kZV9zaGFyZWRfdjg6IGZhbHNlLFxuICAgICAgbm9kZV91c2VfZHRyYWNlOiBmYWxzZSxcbiAgICAgIG5vZGVfdXNlX2V0dzogZmFsc2UsXG4gICAgICBub2RlX3VzZV9vcGVuc3NsOiBmYWxzZSxcbiAgICAgIG5vZGVfc2hhcmVkX29wZW5zc2w6IGZhbHNlLFxuICAgICAgc3RyaWN0X2FsaWFzaW5nOiBmYWxzZSxcbiAgICAgIHRhcmdldF9hcmNoOiAneDMyJyxcbiAgICAgIHY4X3VzZV9zbmFwc2hvdDogZmFsc2UsXG4gICAgICB2OF9ub19zdHJpY3RfYWxpYXNpbmc6IDAsXG4gICAgICB2aXNpYmlsaXR5OiAnJyB9IH07XG5cbiAgcHVibGljIGtpbGwocGlkOiBudW1iZXIsIHNpZ25hbD86IHN0cmluZyk6IHZvaWQge1xuICAgIHRoaXMuZW1pdCgna2lsbCcsIFtwaWQsIHNpZ25hbF0pO1xuICB9XG5cbiAgcHVibGljIHBpZCA9IChNYXRoLnJhbmRvbSgpKjEwMDApfDA7XG5cbiAgcHVibGljIHRpdGxlID0gJ25vZGUnO1xuICBwdWJsaWMgYXJjaCA9ICd4MzInO1xuICBwdWJsaWMgbWVtb3J5VXNhZ2UoKToge3JzczogbnVtYmVyOyBoZWFwVG90YWw6IG51bWJlcjsgaGVhcFVzZWQ6IG51bWJlcjt9IHtcbiAgICByZXR1cm4geyByc3M6IDAsIGhlYXBUb3RhbDogMCwgaGVhcFVzZWQ6IDAgfVxuICB9XG5cbiAgcHJpdmF0ZSBfbWFzayA9IDE4O1xuICBwdWJsaWMgdW1hc2sobWFzazogbnVtYmVyID0gdGhpcy5fbWFzayk6IG51bWJlciB7XG4gICAgbGV0IG9sZE1hc2sgPSB0aGlzLl9tYXNrO1xuICAgIHRoaXMuX21hc2sgPSBtYXNrO1xuICAgIHRoaXMuZW1pdCgndW1hc2snLCBbbWFza10pO1xuICAgIHJldHVybiBvbGRNYXNrO1xuICB9XG5cbiAgcHVibGljIGhydGltZSgpOiBbbnVtYmVyLCBudW1iZXJdIHtcbiAgICBsZXQgdGltZWluZm86IG51bWJlcjtcbiAgICBpZiAodHlwZW9mIHBlcmZvcm1hbmNlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGltZWluZm8gPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICB9IGVsc2UgaWYgKERhdGVbJ25vdyddKSB7XG4gICAgICB0aW1laW5mbyA9IERhdGUubm93KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpbWVpbmZvID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcbiAgICB9XG4gICAgbGV0IHNlY3MgPSAodGltZWluZm8gLyAxMDAwKXwwO1xuICAgIHRpbWVpbmZvIC09IHNlY3MgKiAxMDAwO1xuICAgIHRpbWVpbmZvID0gKHRpbWVpbmZvICogMTAwMDAwMCl8MDtcbiAgICByZXR1cm4gW3NlY3MsIHRpbWVpbmZvXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBbQkZTIG9ubHldIEluaXRpYWxpemUgdGhlIFRUWSBkZXZpY2VzLlxuICAgKi9cbiAgcHVibGljIGluaXRpYWxpemVUVFlzKCk6IHZvaWQge1xuICAgIC8vIEd1YXJkIGFnYWluc3QgbXVsdGlwbGUgaW52b2NhdGlvbnMuXG4gICAgaWYgKHRoaXMuc3Rkb3V0ID09PSBudWxsKSB7XG4gICAgICBsZXQgVFRZOiB0eXBlb2YgX1RUWSA9IHJlcXVpcmUoJy4vdHR5Jyk7XG4gICAgICB0aGlzLnN0ZG91dCA9IG5ldyBUVFkoKTtcbiAgICAgIHRoaXMuc3RkZXJyID0gbmV3IFRUWSgpO1xuICAgICAgdGhpcy5zdGRpbiA9IG5ldyBUVFkoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogV29ya2VyLW9ubHkgZnVuY3Rpb247IGlycmVsZXZhbnQgaGVyZS5cbiAgICovXG4gIHB1YmxpYyBkaXNjb25uZWN0KCk6IHZvaWQge1xuXG4gIH1cbiAgLy8gVW5kZWZpbmVkIGluIG1haW4gdGhyZWFkLiBXb3JrZXItb25seS5cbiAgcHVibGljIGNvbm5lY3RlZDogYm9vbGVhbiA9IHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0ID0gUHJvY2VzcztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vdHMvcHJvY2Vzcy50cyIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxuRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24obikge1xuICBpZiAoIWlzTnVtYmVyKG4pIHx8IG4gPCAwIHx8IGlzTmFOKG4pKVxuICAgIHRocm93IFR5cGVFcnJvcignbiBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgZXIsIGhhbmRsZXIsIGxlbiwgYXJncywgaSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKHR5cGUgPT09ICdlcnJvcicpIHtcbiAgICBpZiAoIXRoaXMuX2V2ZW50cy5lcnJvciB8fFxuICAgICAgICAoaXNPYmplY3QodGhpcy5fZXZlbnRzLmVycm9yKSAmJiAhdGhpcy5fZXZlbnRzLmVycm9yLmxlbmd0aCkpIHtcbiAgICAgIGVyID0gYXJndW1lbnRzWzFdO1xuICAgICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyXG4gICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1VuY2F1Z2h0LCB1bnNwZWNpZmllZCBcImVycm9yXCIgZXZlbnQuICgnICsgZXIgKyAnKScpO1xuICAgICAgICBlcnIuY29udGV4dCA9IGVyO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNVbmRlZmluZWQoaGFuZGxlcikpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGhhbmRsZXIpKSB7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAvLyBmYXN0IGNhc2VzXG4gICAgICBjYXNlIDE6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBzbG93ZXJcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICBoYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdChoYW5kbGVyKSkge1xuICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgIGxpc3RlbmVycyA9IGhhbmRsZXIuc2xpY2UoKTtcbiAgICBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgIGxpc3RlbmVyc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBtO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gIGlmICh0aGlzLl9ldmVudHMubmV3TGlzdGVuZXIpXG4gICAgdGhpcy5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgIGlzRnVuY3Rpb24obGlzdGVuZXIubGlzdGVuZXIpID9cbiAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gIGVsc2UgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5wdXNoKGxpc3RlbmVyKTtcbiAgZWxzZVxuICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IFt0aGlzLl9ldmVudHNbdHlwZV0sIGxpc3RlbmVyXTtcblxuICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSAmJiAhdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCkge1xuICAgIGlmICghaXNVbmRlZmluZWQodGhpcy5fbWF4TGlzdGVuZXJzKSkge1xuICAgICAgbSA9IHRoaXMuX21heExpc3RlbmVycztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICAgIH1cblxuICAgIGlmIChtICYmIG0gPiAwICYmIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGggPiBtKSB7XG4gICAgICB0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkID0gdHJ1ZTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJyhub2RlKSB3YXJuaW5nOiBwb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5ICcgK1xuICAgICAgICAgICAgICAgICAgICAnbGVhayBkZXRlY3RlZC4gJWQgbGlzdGVuZXJzIGFkZGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ1VzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvIGluY3JlYXNlIGxpbWl0LicsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGgpO1xuICAgICAgaWYgKHR5cGVvZiBjb25zb2xlLnRyYWNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIG5vdCBzdXBwb3J0ZWQgaW4gSUUgMTBcbiAgICAgICAgY29uc29sZS50cmFjZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICB2YXIgZmlyZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBnKCkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgZyk7XG5cbiAgICBpZiAoIWZpcmVkKSB7XG4gICAgICBmaXJlZCA9IHRydWU7XG4gICAgICBsaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxuXG4gIGcubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgdGhpcy5vbih0eXBlLCBnKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZmYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIGxpc3QsIHBvc2l0aW9uLCBsZW5ndGgsIGk7XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgbGlzdCA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgbGVuZ3RoID0gbGlzdC5sZW5ndGg7XG4gIHBvc2l0aW9uID0gLTE7XG5cbiAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8XG4gICAgICAoaXNGdW5jdGlvbihsaXN0Lmxpc3RlbmVyKSAmJiBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuXG4gIH0gZWxzZSBpZiAoaXNPYmplY3QobGlzdCkpIHtcbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSA+IDA7KSB7XG4gICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHxcbiAgICAgICAgICAobGlzdFtpXS5saXN0ZW5lciAmJiBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICAgIGxpc3QubGVuZ3RoID0gMDtcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpc3Quc3BsaWNlKHBvc2l0aW9uLCAxKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBrZXksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gIGlmICghdGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICBlbHNlIGlmICh0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgZm9yIChrZXkgaW4gdGhpcy5fZXZlbnRzKSB7XG4gICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgfVxuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGxpc3RlbmVycykpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gIH0gZWxzZSBpZiAobGlzdGVuZXJzKSB7XG4gICAgLy8gTElGTyBvcmRlclxuICAgIHdoaWxlIChsaXN0ZW5lcnMubGVuZ3RoKVxuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbbGlzdGVuZXJzLmxlbmd0aCAtIDFdKTtcbiAgfVxuICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciByZXQ7XG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0ID0gW107XG4gIGVsc2UgaWYgKGlzRnVuY3Rpb24odGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICByZXQgPSBbdGhpcy5fZXZlbnRzW3R5cGVdXTtcbiAgZWxzZVxuICAgIHJldCA9IHRoaXMuX2V2ZW50c1t0eXBlXS5zbGljZSgpO1xuICByZXR1cm4gcmV0O1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24odHlwZSkge1xuICBpZiAodGhpcy5fZXZlbnRzKSB7XG4gICAgdmFyIGV2bGlzdGVuZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgICBpZiAoaXNGdW5jdGlvbihldmxpc3RlbmVyKSlcbiAgICAgIHJldHVybiAxO1xuICAgIGVsc2UgaWYgKGV2bGlzdGVuZXIpXG4gICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XG4gIH1cbiAgcmV0dXJuIDA7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcbn07XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9ldmVudHMvZXZlbnRzLmpzXG4vLyBtb2R1bGUgaWQgPSA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIFR5cGUgaW5mb3JtYXRpb24gb25seS5cbmltcG9ydCBfcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcblxuLy8gU3BsaXQgYSBmaWxlbmFtZSBpbnRvIFtyb290LCBkaXIsIGJhc2VuYW1lLCBleHRdLCB1bml4IHZlcnNpb25cbi8vICdyb290JyBpcyBqdXN0IGEgc2xhc2gsIG9yIG5vdGhpbmcuXG52YXIgc3BsaXRQYXRoUmUgPSAvXihcXC8/fCkoW1xcc1xcU10qPykoKD86XFwuezEsMn18W15cXC9dKz98KShcXC5bXi5cXC9dKnwpKSg/OltcXC9dKikkLztcbmZ1bmN0aW9uIHBvc2l4U3BsaXRQYXRoKGZpbGVuYW1lOiBzdHJpbmcpOiBzdHJpbmdbXSB7XG4gIHZhciBvdXQgPSBzcGxpdFBhdGhSZS5leGVjKGZpbGVuYW1lKTtcbiAgb3V0LnNoaWZ0KCk7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogRW11bGF0ZXMgTm9kZSdzIGBwYXRoYCBtb2R1bGUuIFRoaXMgbW9kdWxlIGNvbnRhaW5zIHV0aWxpdGllcyBmb3IgaGFuZGxpbmcgYW5kXG4gKiB0cmFuc2Zvcm1pbmcgZmlsZSBwYXRocy4gKipBbGwqKiBvZiB0aGVzZSBtZXRob2RzIHBlcmZvcm0gb25seSBzdHJpbmdcbiAqIHRyYW5zZm9ybWF0aW9ucy4gVGhlIGZpbGUgc3lzdGVtIGlzIG5vdCBjb25zdWx0ZWQgdG8gY2hlY2sgd2hldGhlciBwYXRocyBhcmVcbiAqIHZhbGlkLlxuICogQHNlZSBodHRwOi8vbm9kZWpzLm9yZy9hcGkvcGF0aC5odG1sXG4gKiBAY2xhc3NcbiAqL1xuY2xhc3MgcGF0aCB7XG4gIC8qKlxuICAgKiBOb3JtYWxpemUgYSBzdHJpbmcgcGF0aCwgdGFraW5nIGNhcmUgb2YgJy4uJyBhbmQgJy4nIHBhcnRzLlxuICAgKlxuICAgKiBXaGVuIG11bHRpcGxlIHNsYXNoZXMgYXJlIGZvdW5kLCB0aGV5J3JlIHJlcGxhY2VkIGJ5IGEgc2luZ2xlIG9uZTsgd2hlbiB0aGUgcGF0aCBjb250YWlucyBhIHRyYWlsaW5nIHNsYXNoLCBpdCBpcyBwcmVzZXJ2ZWQuIE9uIFdpbmRvd3MgYmFja3NsYXNoZXMgYXJlIHVzZWQuXG4gICAqIEBleGFtcGxlIFVzYWdlIGV4YW1wbGVcbiAgICogICBwYXRoLm5vcm1hbGl6ZSgnL2Zvby9iYXIvL2Jhei9hc2RmL3F1dXgvLi4nKVxuICAgKiAgIC8vIHJldHVybnNcbiAgICogICAnL2Zvby9iYXIvYmF6L2FzZGYnXG4gICAqIEBwYXJhbSBbU3RyaW5nXSBwIFRoZSBwYXRoIHRvIG5vcm1hbGl6ZS5cbiAgICogQHJldHVybiBbU3RyaW5nXVxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBub3JtYWxpemUocDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6ICcnIC0+ICcuJ1xuICAgIGlmIChwID09PSAnJykge1xuICAgICAgcCA9ICcuJztcbiAgICB9XG4gICAgLy8gSXQncyB2ZXJ5IGltcG9ydGFudCB0byBrbm93IGlmIHRoZSBwYXRoIGlzIHJlbGF0aXZlIG9yIG5vdCwgc2luY2UgaXRcbiAgICAvLyBjaGFuZ2VzIGhvdyB3ZSBwcm9jZXNzIC4uIGFuZCByZWNvbnN0cnVjdCB0aGUgc3BsaXQgc3RyaW5nLlxuICAgIHZhciBhYnNvbHV0ZSA9IHAuY2hhckF0KDApID09PSBwYXRoLnNlcDtcbiAgICAvLyBSZW1vdmUgcmVwZWF0ZWQgLy9zXG4gICAgcCA9IHBhdGguX3JlbW92ZUR1cGxpY2F0ZVNlcHMocCk7XG4gICAgLy8gVHJ5IHRvIHJlbW92ZSBhcyBtYW55ICcuLi8nIGFzIHBvc3NpYmxlLCBhbmQgcmVtb3ZlICcuJyBjb21wbGV0ZWx5LlxuICAgIHZhciBjb21wb25lbnRzID0gcC5zcGxpdChwYXRoLnNlcCk7XG4gICAgdmFyIGdvb2RDb21wb25lbnRzOiBzdHJpbmdbXSA9IFtdO1xuICAgIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IGNvbXBvbmVudHMubGVuZ3RoOyBpZHgrKykge1xuICAgICAgdmFyIGMgPSBjb21wb25lbnRzW2lkeF07XG4gICAgICBpZiAoYyA9PT0gJy4nKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIGlmIChjID09PSAnLi4nICYmIChhYnNvbHV0ZSB8fCAoIWFic29sdXRlICYmIGdvb2RDb21wb25lbnRzLmxlbmd0aCA+IDAgJiYgZ29vZENvbXBvbmVudHNbMF0gIT09ICcuLicpKSkge1xuICAgICAgICAvLyBJbiB0aGUgYWJzb2x1dGUgY2FzZTogUGF0aCBpcyByZWxhdGl2ZSB0byByb290LCBzbyB3ZSBtYXkgcG9wIGV2ZW4gaWZcbiAgICAgICAgLy8gZ29vZENvbXBvbmVudHMgaXMgZW1wdHkgKGUuZy4gLy4uLyA9PiAvKVxuICAgICAgICAvLyBJbiB0aGUgcmVsYXRpdmUgY2FzZTogV2UncmUgZ2V0dGluZyByaWQgb2YgYSBkaXJlY3RvcnkgdGhhdCBwcmVjZWRlZFxuICAgICAgICAvLyBpdCAoZS5nLiAvZm9vLy4uL2JhciAtPiAvYmFyKVxuICAgICAgICBnb29kQ29tcG9uZW50cy5wb3AoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdvb2RDb21wb25lbnRzLnB1c2goYyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQWRkIGluICcuJyB3aGVuIGl0J3MgYSByZWxhdGl2ZSBwYXRoIHdpdGggbm8gb3RoZXIgbm9uZW1wdHkgY29tcG9uZW50cy5cbiAgICAvLyBQb3NzaWJsZSByZXN1bHRzOiAnLicgYW5kICcuLycgKGlucHV0OiBbJyddIG9yIFtdKVxuICAgIC8vIEB0b2RvIENhbiBwcm9iYWJseSBzaW1wbGlmeSB0aGlzIGxvZ2ljLlxuICAgIGlmICghYWJzb2x1dGUgJiYgZ29vZENvbXBvbmVudHMubGVuZ3RoIDwgMikge1xuICAgICAgc3dpdGNoIChnb29kQ29tcG9uZW50cy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChnb29kQ29tcG9uZW50c1swXSA9PT0gJycpIHtcbiAgICAgICAgICAgIGdvb2RDb21wb25lbnRzLnVuc2hpZnQoJy4nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgZ29vZENvbXBvbmVudHMucHVzaCgnLicpO1xuICAgICAgfVxuICAgIH1cbiAgICBwID0gZ29vZENvbXBvbmVudHMuam9pbihwYXRoLnNlcCk7XG4gICAgaWYgKGFic29sdXRlICYmIHAuY2hhckF0KDApICE9PSBwYXRoLnNlcCkge1xuICAgICAgcCA9IHBhdGguc2VwICsgcDtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG4gIH1cblxuICAvKipcbiAgICogSm9pbiBhbGwgYXJndW1lbnRzIHRvZ2V0aGVyIGFuZCBub3JtYWxpemUgdGhlIHJlc3VsdGluZyBwYXRoLlxuICAgKlxuICAgKiBBcmd1bWVudHMgbXVzdCBiZSBzdHJpbmdzLlxuICAgKiBAZXhhbXBsZSBVc2FnZVxuICAgKiAgIHBhdGguam9pbignL2ZvbycsICdiYXInLCAnYmF6L2FzZGYnLCAncXV1eCcsICcuLicpXG4gICAqICAgLy8gcmV0dXJuc1xuICAgKiAgICcvZm9vL2Jhci9iYXovYXNkZidcbiAgICpcbiAgICogICBwYXRoLmpvaW4oJ2ZvbycsIHt9LCAnYmFyJylcbiAgICogICAvLyB0aHJvd3MgZXhjZXB0aW9uXG4gICAqICAgVHlwZUVycm9yOiBBcmd1bWVudHMgdG8gcGF0aC5qb2luIG11c3QgYmUgc3RyaW5nc1xuICAgKiBAcGFyYW0gW1N0cmluZywuLi5dIHBhdGhzIEVhY2ggY29tcG9uZW50IG9mIHRoZSBwYXRoXG4gICAqIEByZXR1cm4gW1N0cmluZ11cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgam9pbiguLi5wYXRoczogYW55W10pOiBzdHJpbmcge1xuICAgIC8vIFJlcXVpcmVkOiBQcnVuZSBhbnkgbm9uLXN0cmluZ3MgZnJvbSB0aGUgcGF0aC4gSSBhbHNvIHBydW5lIGVtcHR5IHNlZ21lbnRzXG4gICAgLy8gc28gd2UgY2FuIGRvIGEgc2ltcGxlIGpvaW4gb2YgdGhlIGFycmF5LlxuICAgIHZhciBwcm9jZXNzZWQ6IHN0cmluZ1tdID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRocy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNlZ21lbnQgPSBwYXRoc1tpXTtcbiAgICAgIGlmICh0eXBlb2Ygc2VnbWVudCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXJndW1lbnQgdHlwZSB0byBwYXRoLmpvaW46IFwiICsgKHR5cGVvZiBzZWdtZW50KSk7XG4gICAgICB9IGVsc2UgaWYgKHNlZ21lbnQgIT09ICcnKSB7XG4gICAgICAgIHByb2Nlc3NlZC5wdXNoKHNlZ21lbnQpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGF0aC5ub3JtYWxpemUocHJvY2Vzc2VkLmpvaW4ocGF0aC5zZXApKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNvbHZlcyB0byB0byBhbiBhYnNvbHV0ZSBwYXRoLlxuICAgKlxuICAgKiBJZiB0byBpc24ndCBhbHJlYWR5IGFic29sdXRlIGZyb20gYXJndW1lbnRzIGFyZSBwcmVwZW5kZWQgaW4gcmlnaHQgdG8gbGVmdFxuICAgKiBvcmRlciwgdW50aWwgYW4gYWJzb2x1dGUgcGF0aCBpcyBmb3VuZC4gSWYgYWZ0ZXIgdXNpbmcgYWxsIGZyb20gcGF0aHMgc3RpbGxcbiAgICogbm8gYWJzb2x1dGUgcGF0aCBpcyBmb3VuZCwgdGhlIGN1cnJlbnQgd29ya2luZyBkaXJlY3RvcnkgaXMgdXNlZCBhcyB3ZWxsLlxuICAgKiBUaGUgcmVzdWx0aW5nIHBhdGggaXMgbm9ybWFsaXplZCwgYW5kIHRyYWlsaW5nIHNsYXNoZXMgYXJlIHJlbW92ZWQgdW5sZXNzXG4gICAqIHRoZSBwYXRoIGdldHMgcmVzb2x2ZWQgdG8gdGhlIHJvb3QgZGlyZWN0b3J5LiBOb24tc3RyaW5nIGFyZ3VtZW50cyBhcmVcbiAgICogaWdub3JlZC5cbiAgICpcbiAgICogQW5vdGhlciB3YXkgdG8gdGhpbmsgb2YgaXQgaXMgYXMgYSBzZXF1ZW5jZSBvZiBjZCBjb21tYW5kcyBpbiBhIHNoZWxsLlxuICAgKlxuICAgKiAgICAgcGF0aC5yZXNvbHZlKCdmb28vYmFyJywgJy90bXAvZmlsZS8nLCAnLi4nLCAnYS8uLi9zdWJmaWxlJylcbiAgICpcbiAgICogSXMgc2ltaWxhciB0bzpcbiAgICpcbiAgICogICAgIGNkIGZvby9iYXJcbiAgICogICAgIGNkIC90bXAvZmlsZS9cbiAgICogICAgIGNkIC4uXG4gICAqICAgICBjZCBhLy4uL3N1YmZpbGVcbiAgICogICAgIHB3ZFxuICAgKlxuICAgKiBUaGUgZGlmZmVyZW5jZSBpcyB0aGF0IHRoZSBkaWZmZXJlbnQgcGF0aHMgZG9uJ3QgbmVlZCB0byBleGlzdCBhbmQgbWF5IGFsc29cbiAgICogYmUgZmlsZXMuXG4gICAqIEBleGFtcGxlIFVzYWdlIGV4YW1wbGVcbiAgICogICBwYXRoLnJlc29sdmUoJy9mb28vYmFyJywgJy4vYmF6JylcbiAgICogICAvLyByZXR1cm5zXG4gICAqICAgJy9mb28vYmFyL2JheidcbiAgICpcbiAgICogICBwYXRoLnJlc29sdmUoJy9mb28vYmFyJywgJy90bXAvZmlsZS8nKVxuICAgKiAgIC8vIHJldHVybnNcbiAgICogICAnL3RtcC9maWxlJ1xuICAgKlxuICAgKiAgIHBhdGgucmVzb2x2ZSgnd3d3cm9vdCcsICdzdGF0aWNfZmlsZXMvcG5nLycsICcuLi9naWYvaW1hZ2UuZ2lmJylcbiAgICogICAvLyBpZiBjdXJyZW50bHkgaW4gL2hvbWUvbXlzZWxmL25vZGUsIGl0IHJldHVybnNcbiAgICogICAnL2hvbWUvbXlzZWxmL25vZGUvd3d3cm9vdC9zdGF0aWNfZmlsZXMvZ2lmL2ltYWdlLmdpZidcbiAgICogQHBhcmFtIFtTdHJpbmcsLi4uXSBwYXRoc1xuICAgKiBAcmV0dXJuIFtTdHJpbmddXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlc29sdmUoLi4ucGF0aHM6IHN0cmluZ1tdKTogc3RyaW5nIHtcbiAgICAvLyBNb25pdG9yIGZvciBpbnZhbGlkIHBhdGhzLCB0aHJvdyBvdXQgZW1wdHkgcGF0aHMsIGFuZCBsb29rIGZvciB0aGUgKmxhc3QqXG4gICAgLy8gYWJzb2x1dGUgcGF0aCB0aGF0IHdlIHNlZS5cbiAgICB2YXIgcHJvY2Vzc2VkOiBzdHJpbmdbXSA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwID0gcGF0aHNbaV07XG4gICAgICBpZiAodHlwZW9mIHAgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGFyZ3VtZW50IHR5cGUgdG8gcGF0aC5qb2luOiBcIiArICh0eXBlb2YgcCkpO1xuICAgICAgfSBlbHNlIGlmIChwICE9PSAnJykge1xuICAgICAgICAvLyBSZW1vdmUgYW55dGhpbmcgdGhhdCBoYXMgb2NjdXJyZWQgYmVmb3JlIHRoaXMgYWJzb2x1dGUgcGF0aCwgYXMgaXRcbiAgICAgICAgLy8gZG9lc24ndCBtYXR0ZXIuXG4gICAgICAgIGlmIChwLmNoYXJBdCgwKSA9PT0gcGF0aC5zZXApIHtcbiAgICAgICAgICBwcm9jZXNzZWQgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBwcm9jZXNzZWQucHVzaChwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gU3BlY2lhbDogUmVtb3ZlIHRyYWlsaW5nIHNsYXNoIHVubGVzcyBpdCdzIHRoZSByb290XG4gICAgdmFyIHJlc29sdmVkID0gcGF0aC5ub3JtYWxpemUocHJvY2Vzc2VkLmpvaW4ocGF0aC5zZXApKTtcbiAgICBpZiAocmVzb2x2ZWQubGVuZ3RoID4gMSAmJiByZXNvbHZlZC5jaGFyQXQocmVzb2x2ZWQubGVuZ3RoIC0gMSkgPT09IHBhdGguc2VwKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZWQuc3Vic3RyKDAsIHJlc29sdmVkLmxlbmd0aCAtIDEpO1xuICAgIH1cbiAgICAvLyBTcGVjaWFsOiBJZiBpdCBkb2Vzbid0IHN0YXJ0IHdpdGggJy8nLCBpdCdzIHJlbGF0aXZlIGFuZCB3ZSBuZWVkIHRvIGFwcGVuZFxuICAgIC8vIHRoZSBjdXJyZW50IGRpcmVjdG9yeS5cbiAgICBpZiAocmVzb2x2ZWQuY2hhckF0KDApICE9PSBwYXRoLnNlcCkge1xuICAgICAgLy8gUmVtb3ZlIC4vLCBzaW5jZSB3ZSdyZSBnb2luZyB0byBhcHBlbmQgdGhlIGN1cnJlbnQgZGlyZWN0b3J5LlxuICAgICAgaWYgKHJlc29sdmVkLmNoYXJBdCgwKSA9PT0gJy4nICYmIChyZXNvbHZlZC5sZW5ndGggPT09IDEgfHwgcmVzb2x2ZWQuY2hhckF0KDEpID09PSBwYXRoLnNlcCkpIHtcbiAgICAgICAgcmVzb2x2ZWQgPSByZXNvbHZlZC5sZW5ndGggPT09IDEgPyAnJyA6IHJlc29sdmVkLnN1YnN0cigyKTtcbiAgICAgIH1cbiAgICAgIC8vIEFwcGVuZCB0aGUgY3VycmVudCBkaXJlY3RvcnksIHdoaWNoICptdXN0KiBiZSBhbiBhYnNvbHV0ZSBwYXRoLlxuICAgICAgdmFyIGN3ZCA9IHByb2Nlc3MuY3dkKCk7XG4gICAgICBpZiAocmVzb2x2ZWQgIT09ICcnKSB7XG4gICAgICAgIC8vIGN3ZCB3aWxsIG5ldmVyIGVuZCBpbiBhIC8uLi4gdW5sZXNzIGl0J3MgdGhlIHJvb3QuXG4gICAgICAgIHJlc29sdmVkID0gdGhpcy5ub3JtYWxpemUoY3dkICsgKGN3ZCAhPT0gJy8nID8gcGF0aC5zZXAgOiAnJykgKyByZXNvbHZlZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNvbHZlZCA9IGN3ZDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc29sdmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIFNvbHZlIHRoZSByZWxhdGl2ZSBwYXRoIGZyb20gZnJvbSB0byB0by5cbiAgICpcbiAgICogQXQgdGltZXMgd2UgaGF2ZSB0d28gYWJzb2x1dGUgcGF0aHMsIGFuZCB3ZSBuZWVkIHRvIGRlcml2ZSB0aGUgcmVsYXRpdmUgcGF0aFxuICAgKiBmcm9tIG9uZSB0byB0aGUgb3RoZXIuIFRoaXMgaXMgYWN0dWFsbHkgdGhlIHJldmVyc2UgdHJhbnNmb3JtIG9mXG4gICAqIHBhdGgucmVzb2x2ZSwgd2hpY2ggbWVhbnMgd2Ugc2VlIHRoYXQ6XG4gICAqXG4gICAqICAgIHBhdGgucmVzb2x2ZShmcm9tLCBwYXRoLnJlbGF0aXZlKGZyb20sIHRvKSkgPT0gcGF0aC5yZXNvbHZlKHRvKVxuICAgKlxuICAgKiBAZXhhbXBsZSBVc2FnZSBleGFtcGxlXG4gICAqICAgcGF0aC5yZWxhdGl2ZSgnQzpcXFxcb3JhbmRlYVxcXFx0ZXN0XFxcXGFhYScsICdDOlxcXFxvcmFuZGVhXFxcXGltcGxcXFxcYmJiJylcbiAgICogICAvLyByZXR1cm5zXG4gICAqICAgJy4uXFxcXC4uXFxcXGltcGxcXFxcYmJiJ1xuICAgKlxuICAgKiAgIHBhdGgucmVsYXRpdmUoJy9kYXRhL29yYW5kZWEvdGVzdC9hYWEnLCAnL2RhdGEvb3JhbmRlYS9pbXBsL2JiYicpXG4gICAqICAgLy8gcmV0dXJuc1xuICAgKiAgICcuLi8uLi9pbXBsL2JiYidcbiAgICogQHBhcmFtIFtTdHJpbmddIGZyb21cbiAgICogQHBhcmFtIFtTdHJpbmddIHRvXG4gICAqIEByZXR1cm4gW1N0cmluZ11cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcmVsYXRpdmUoZnJvbTogc3RyaW5nLCB0bzogc3RyaW5nKTogc3RyaW5nIHtcbiAgICB2YXIgaTogbnVtYmVyO1xuICAgIC8vIEFscmlnaHQuIExldCdzIHJlc29sdmUgdGhlc2UgdHdvIHRvIGFic29sdXRlIHBhdGhzIGFuZCByZW1vdmUgYW55XG4gICAgLy8gd2VpcmRuZXNzLlxuICAgIGZyb20gPSBwYXRoLnJlc29sdmUoZnJvbSk7XG4gICAgdG8gPSBwYXRoLnJlc29sdmUodG8pO1xuICAgIHZhciBmcm9tU2VncyA9IGZyb20uc3BsaXQocGF0aC5zZXApO1xuICAgIHZhciB0b1NlZ3MgPSB0by5zcGxpdChwYXRoLnNlcCk7XG4gICAgLy8gUmVtb3ZlIHRoZSBmaXJzdCBzZWdtZW50IG9uIGJvdGgsIGFzIGl0J3MgJycgKGJvdGggYXJlIGFic29sdXRlIHBhdGhzKVxuICAgIHRvU2Vncy5zaGlmdCgpO1xuICAgIGZyb21TZWdzLnNoaWZ0KCk7XG4gICAgLy8gVGhlcmUgYXJlIHR3byBzZWdtZW50cyB0byB0aGlzIHBhdGg6XG4gICAgLy8gKiBHb2luZyAqdXAqIHRoZSBkaXJlY3RvcnkgaGllcmFyY2h5IHdpdGggJy4uJ1xuICAgIC8vICogR29pbmcgKmRvd24qIHRoZSBkaXJlY3RvcnkgaGllcmFyY2h5IHdpdGggZm9vL2Jhei9iYXQuXG4gICAgdmFyIHVwQ291bnQgPSAwO1xuICAgIHZhciBkb3duU2Vnczogc3RyaW5nW10gPSBbXTtcbiAgICAvLyBGaWd1cmUgb3V0IGhvdyBtYW55IHRoaW5ncyBpbiAnZnJvbScgYXJlIHNoYXJlZCB3aXRoICd0bycuXG4gICAgZm9yIChpID0gMDsgaSA8IGZyb21TZWdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc2VnID0gZnJvbVNlZ3NbaV07XG4gICAgICBpZiAoc2VnID09PSB0b1NlZ3NbaV0pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICAvLyBUaGUgcmVzdCBvZiAnZnJvbScsIGluY2x1ZGluZyB0aGUgY3VycmVudCBlbGVtZW50LCBpbmRpY2F0ZXMgaG93IG1hbnlcbiAgICAgIC8vIGRpcmVjdG9yaWVzIHdlIG5lZWQgdG8gZ28gdXAuXG4gICAgICB1cENvdW50ID0gZnJvbVNlZ3MubGVuZ3RoIC0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAvLyBUaGUgcmVzdCBvZiAndG8nIGluZGljYXRlcyB3aGVyZSB3ZSBuZWVkIHRvIGNoYW5nZSB0by4gV2UgcGxhY2UgdGhpc1xuICAgIC8vIG91dHNpZGUgb2YgdGhlIGxvb3AsIGFzIHRvU2Vncy5sZW5ndGggbWF5IGJlIGdyZWF0ZXIgdGhhbiBmcm9tU2Vncy5sZW5ndGguXG4gICAgZG93blNlZ3MgPSB0b1NlZ3Muc2xpY2UoaSk7XG4gICAgLy8gU3BlY2lhbCBjYXNlOiBJZiAnZnJvbScgaXMgJy8nXG4gICAgaWYgKGZyb21TZWdzLmxlbmd0aCA9PT0gMSAmJiBmcm9tU2Vnc1swXSA9PT0gJycpIHtcbiAgICAgIHVwQ291bnQgPSAwO1xuICAgIH1cbiAgICAvLyB1cENvdW50IGNhbid0IGJlIGdyZWF0ZXIgdGhhbiB0aGUgbnVtYmVyIG9mIGZyb21TZWdzXG4gICAgLy8gKGNkIC4uIGZyb20gLyBpcyBzdGlsbCAvKVxuICAgIGlmICh1cENvdW50ID4gZnJvbVNlZ3MubGVuZ3RoKSB7XG4gICAgICB1cENvdW50ID0gZnJvbVNlZ3MubGVuZ3RoO1xuICAgIH1cbiAgICAvLyBDcmVhdGUgdGhlIGZpbmFsIHN0cmluZyFcbiAgICB2YXIgcnYgPSAnJztcbiAgICBmb3IgKGkgPSAwOyBpIDwgdXBDb3VudDsgaSsrKSB7XG4gICAgICBydiArPSAnLi4vJztcbiAgICB9XG4gICAgcnYgKz0gZG93blNlZ3Muam9pbihwYXRoLnNlcCk7XG4gICAgLy8gU3BlY2lhbCBjYXNlOiBSZW1vdmUgdHJhaWxpbmcgJy8nLiBIYXBwZW5zIGlmIGl0J3MgYWxsIHVwIGFuZCBubyBkb3duLlxuICAgIGlmIChydi5sZW5ndGggPiAxICYmIHJ2LmNoYXJBdChydi5sZW5ndGggLSAxKSA9PT0gcGF0aC5zZXApIHtcbiAgICAgIHJ2ID0gcnYuc3Vic3RyKDAsIHJ2Lmxlbmd0aCAtIDEpO1xuICAgIH1cbiAgICByZXR1cm4gcnY7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBkaXJlY3RvcnkgbmFtZSBvZiBhIHBhdGguIFNpbWlsYXIgdG8gdGhlIFVuaXggYGRpcm5hbWVgIGNvbW1hbmQuXG4gICAqXG4gICAqIE5vdGUgdGhhdCBCcm93c2VyRlMgZG9lcyBub3QgdmFsaWRhdGUgaWYgdGhlIHBhdGggaXMgYWN0dWFsbHkgYSB2YWxpZFxuICAgKiBkaXJlY3RvcnkuXG4gICAqIEBleGFtcGxlIFVzYWdlIGV4YW1wbGVcbiAgICogICBwYXRoLmRpcm5hbWUoJy9mb28vYmFyL2Jhei9hc2RmL3F1dXgnKVxuICAgKiAgIC8vIHJldHVybnNcbiAgICogICAnL2Zvby9iYXIvYmF6L2FzZGYnXG4gICAqIEBwYXJhbSBbU3RyaW5nXSBwIFRoZSBwYXRoIHRvIGdldCB0aGUgZGlyZWN0b3J5IG5hbWUgb2YuXG4gICAqIEByZXR1cm4gW1N0cmluZ11cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgZGlybmFtZShwOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIC8vIFdlIGdldCByaWQgb2YgLy8sIGJ1dCB3ZSBkb24ndCBtb2RpZnkgYW55dGhpbmcgZWxzZSAoZS5nLiBhbnkgZXh0cmFuZW91cyAuXG4gICAgLy8gYW5kIC4uLyBhcmUga2VwdCBpbnRhY3QpXG4gICAgcCA9IHBhdGguX3JlbW92ZUR1cGxpY2F0ZVNlcHMocCk7XG4gICAgdmFyIGFic29sdXRlID0gcC5jaGFyQXQoMCkgPT09IHBhdGguc2VwO1xuICAgIHZhciBzZWN0aW9ucyA9IHAuc3BsaXQocGF0aC5zZXApO1xuICAgIC8vIERvIDEgaWYgaXQncyAvZm9vL2JhciwgMiBpZiBpdCdzIC9mb28vYmFyL1xuICAgIGlmIChzZWN0aW9ucy5wb3AoKSA9PT0gJycgJiYgc2VjdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgc2VjdGlvbnMucG9wKCk7XG4gICAgfVxuICAgIC8vICMgb2Ygc2VjdGlvbnMgbmVlZHMgdG8gYmUgPiAxIGlmIGFic29sdXRlLCBzaW5jZSB0aGUgZmlyc3Qgc2VjdGlvbiBpcyAnJyBmb3IgJy8nLlxuICAgIC8vIElmIG5vdCBhYnNvbHV0ZSwgdGhlIGZpcnN0IHNlY3Rpb24gaXMgdGhlIGZpcnN0IHBhcnQgb2YgdGhlIHBhdGgsIGFuZCBpcyBPS1xuICAgIC8vIHRvIHJldHVybi5cbiAgICBpZiAoc2VjdGlvbnMubGVuZ3RoID4gMSB8fCAoc2VjdGlvbnMubGVuZ3RoID09PSAxICYmICFhYnNvbHV0ZSkpIHtcbiAgICAgIHJldHVybiBzZWN0aW9ucy5qb2luKHBhdGguc2VwKTtcbiAgICB9IGVsc2UgaWYgKGFic29sdXRlKSB7XG4gICAgICByZXR1cm4gcGF0aC5zZXA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAnLic7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgbGFzdCBwb3J0aW9uIG9mIGEgcGF0aC4gU2ltaWxhciB0byB0aGUgVW5peCBiYXNlbmFtZSBjb21tYW5kLlxuICAgKiBAZXhhbXBsZSBVc2FnZSBleGFtcGxlXG4gICAqICAgcGF0aC5iYXNlbmFtZSgnL2Zvby9iYXIvYmF6L2FzZGYvcXV1eC5odG1sJylcbiAgICogICAvLyByZXR1cm5zXG4gICAqICAgJ3F1dXguaHRtbCdcbiAgICpcbiAgICogICBwYXRoLmJhc2VuYW1lKCcvZm9vL2Jhci9iYXovYXNkZi9xdXV4Lmh0bWwnLCAnLmh0bWwnKVxuICAgKiAgIC8vIHJldHVybnNcbiAgICogICAncXV1eCdcbiAgICogQHBhcmFtIFtTdHJpbmddIHBcbiAgICogQHBhcmFtIFtTdHJpbmc/XSBleHRcbiAgICogQHJldHVybiBbU3RyaW5nXVxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBiYXNlbmFtZShwOiBzdHJpbmcsIGV4dDogc3RyaW5nID0gXCJcIik6IHN0cmluZyB7XG4gICAgLy8gU3BlY2lhbCBjYXNlOiBOb3JtYWxpemUgd2lsbCBtb2RpZnkgdGhpcyB0byAnLidcbiAgICBpZiAocCA9PT0gJycpIHtcbiAgICAgIHJldHVybiBwO1xuICAgIH1cbiAgICAvLyBOb3JtYWxpemUgdGhlIHN0cmluZyBmaXJzdCB0byByZW1vdmUgYW55IHdlaXJkbmVzcy5cbiAgICBwID0gcGF0aC5ub3JtYWxpemUocCk7XG4gICAgLy8gR2V0IHRoZSBsYXN0IHBhcnQgb2YgdGhlIHN0cmluZy5cbiAgICB2YXIgc2VjdGlvbnMgPSBwLnNwbGl0KHBhdGguc2VwKTtcbiAgICB2YXIgbGFzdFBhcnQgPSBzZWN0aW9uc1tzZWN0aW9ucy5sZW5ndGggLSAxXTtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IElmIGl0J3MgZW1wdHksIHRoZW4gd2UgaGF2ZSBhIHN0cmluZyBsaWtlIHNvOiBmb28vXG4gICAgLy8gTWVhbmluZywgJ2ZvbycgaXMgZ3VhcmFudGVlZCB0byBiZSBhIGRpcmVjdG9yeS5cbiAgICBpZiAobGFzdFBhcnQgPT09ICcnICYmIHNlY3Rpb25zLmxlbmd0aCA+IDEpIHtcbiAgICAgIHJldHVybiBzZWN0aW9uc1tzZWN0aW9ucy5sZW5ndGggLSAyXTtcbiAgICB9XG4gICAgLy8gUmVtb3ZlIHRoZSBleHRlbnNpb24sIGlmIG5lZWQgYmUuXG4gICAgaWYgKGV4dC5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgbGFzdFBhcnRFeHQgPSBsYXN0UGFydC5zdWJzdHIobGFzdFBhcnQubGVuZ3RoIC0gZXh0Lmxlbmd0aCk7XG4gICAgICBpZiAobGFzdFBhcnRFeHQgPT09IGV4dCkge1xuICAgICAgICByZXR1cm4gbGFzdFBhcnQuc3Vic3RyKDAsIGxhc3RQYXJ0Lmxlbmd0aCAtIGV4dC5sZW5ndGgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbGFzdFBhcnQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBleHRlbnNpb24gb2YgdGhlIHBhdGgsIGZyb20gdGhlIGxhc3QgJy4nIHRvIGVuZCBvZiBzdHJpbmcgaW4gdGhlXG4gICAqIGxhc3QgcG9ydGlvbiBvZiB0aGUgcGF0aC4gSWYgdGhlcmUgaXMgbm8gJy4nIGluIHRoZSBsYXN0IHBvcnRpb24gb2YgdGhlIHBhdGhcbiAgICogb3IgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiBpdCBpcyAnLicsIHRoZW4gaXQgcmV0dXJucyBhbiBlbXB0eSBzdHJpbmcuXG4gICAqIEBleGFtcGxlIFVzYWdlIGV4YW1wbGVcbiAgICogICBwYXRoLmV4dG5hbWUoJ2luZGV4Lmh0bWwnKVxuICAgKiAgIC8vIHJldHVybnNcbiAgICogICAnLmh0bWwnXG4gICAqXG4gICAqICAgcGF0aC5leHRuYW1lKCdpbmRleC4nKVxuICAgKiAgIC8vIHJldHVybnNcbiAgICogICAnLidcbiAgICpcbiAgICogICBwYXRoLmV4dG5hbWUoJ2luZGV4JylcbiAgICogICAvLyByZXR1cm5zXG4gICAqICAgJydcbiAgICogQHBhcmFtIFtTdHJpbmddIHBcbiAgICogQHJldHVybiBbU3RyaW5nXVxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBleHRuYW1lKHA6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcCA9IHBhdGgubm9ybWFsaXplKHApO1xuICAgIHZhciBzZWN0aW9ucyA9IHAuc3BsaXQocGF0aC5zZXApO1xuICAgIHAgPSBzZWN0aW9ucy5wb3AoKTtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGZvby9maWxlLmV4dC8gc2hvdWxkIHJldHVybiAnLmV4dCdcbiAgICBpZiAocCA9PT0gJycgJiYgc2VjdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgcCA9IHNlY3Rpb25zLnBvcCgpO1xuICAgIH1cbiAgICBpZiAocCA9PT0gJy4uJykge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICB2YXIgaSA9IHAubGFzdEluZGV4T2YoJy4nKTtcbiAgICBpZiAoaSA9PT0gLTEgfHwgaSA9PT0gMCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICByZXR1cm4gcC5zdWJzdHIoaSk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBwYXRoIGlzIGFuIGFic29sdXRlIHBhdGguXG4gICAqXG4gICAqIERlc3BpdGUgbm90IGJlaW5nIGRvY3VtZW50ZWQsIHRoaXMgaXMgYSB0ZXN0ZWQgcGFydCBvZiBOb2RlJ3MgcGF0aCBBUEkuXG4gICAqIEBwYXJhbSBbU3RyaW5nXSBwXG4gICAqIEByZXR1cm4gW0Jvb2xlYW5dIFRydWUgaWYgdGhlIHBhdGggYXBwZWFycyB0byBiZSBhbiBhYnNvbHV0ZSBwYXRoLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBpc0Fic29sdXRlKHA6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBwLmxlbmd0aCA+IDAgJiYgcC5jaGFyQXQoMCkgPT09IHBhdGguc2VwO1xuICB9XG5cbiAgLyoqXG4gICAqIFVua25vd24uIFVuZG9jdW1lbnRlZC5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgX21ha2VMb25nKHA6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHA7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBvYmplY3QgZnJvbSBhIHBhdGggc3RyaW5nLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBwYXJzZShwOiBzdHJpbmcpOiBfcGF0aC5QYXJzZWRQYXRoIHtcbiAgICB2YXIgYWxsUGFydHMgPSBwb3NpeFNwbGl0UGF0aChwKTtcbiAgICByZXR1cm4ge1xuICAgICAgcm9vdDogYWxsUGFydHNbMF0sXG4gICAgICBkaXI6IGFsbFBhcnRzWzBdICsgYWxsUGFydHNbMV0uc2xpY2UoMCwgLTEpLFxuICAgICAgYmFzZTogYWxsUGFydHNbMl0sXG4gICAgICBleHQ6IGFsbFBhcnRzWzNdLFxuICAgICAgbmFtZTogYWxsUGFydHNbMl0uc2xpY2UoMCwgYWxsUGFydHNbMl0ubGVuZ3RoIC0gYWxsUGFydHNbM10ubGVuZ3RoKVxuICAgIH07XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIGZvcm1hdChwYXRoT2JqZWN0OiBfcGF0aC5QYXJzZWRQYXRoKTogc3RyaW5nIHtcbiAgICBpZiAocGF0aE9iamVjdCA9PT0gbnVsbCB8fCB0eXBlb2YgcGF0aE9iamVjdCAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFBhcmFtZXRlciAncGF0aE9iamVjdCcgbXVzdCBiZSBhbiBvYmplY3QsIG5vdCAke3R5cGVvZiBwYXRoT2JqZWN0fWApO1xuICAgIH1cblxuICAgIHZhciByb290ID0gcGF0aE9iamVjdC5yb290IHx8ICcnO1xuXG4gICAgaWYgKHR5cGVvZiByb290ICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBcIidwYXRoT2JqZWN0LnJvb3QnIG11c3QgYmUgYSBzdHJpbmcgb3IgdW5kZWZpbmVkLCBub3QgXCIgK1xuICAgICAgICAgIHR5cGVvZiBwYXRoT2JqZWN0LnJvb3RcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIGRpciA9IHBhdGhPYmplY3QuZGlyID8gcGF0aE9iamVjdC5kaXIgKyBwYXRoLnNlcCA6ICcnO1xuICAgIHZhciBiYXNlID0gcGF0aE9iamVjdC5iYXNlIHx8ICcnO1xuICAgIHJldHVybiBkaXIgKyBiYXNlO1xuICB9XG5cbiAgLy8gVGhlIHBsYXRmb3JtLXNwZWNpZmljIGZpbGUgc2VwYXJhdG9yLiBCcm93c2VyRlMgdXNlcyBgL2AuXG4gIHB1YmxpYyBzdGF0aWMgc2VwOiBzdHJpbmcgPSAnLyc7XG5cbiAgcHJpdmF0ZSBzdGF0aWMgX3JlcGxhY2VSZWdleCA9IG5ldyBSZWdFeHAoXCIvLytcIiwgJ2cnKTtcblxuICBwcml2YXRlIHN0YXRpYyBfcmVtb3ZlRHVwbGljYXRlU2VwcyhwOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHAgPSBwLnJlcGxhY2UodGhpcy5fcmVwbGFjZVJlZ2V4LCB0aGlzLnNlcCk7XG4gICAgcmV0dXJuIHA7XG4gIH1cblxuICAvLyBUaGUgcGxhdGZvcm0tc3BlY2lmaWMgcGF0aCBkZWxpbWl0ZXIuIEJyb3dzZXJGUyB1c2VzIGA6YC5cbiAgcHVibGljIHN0YXRpYyBkZWxpbWl0ZXIgPSAnOic7XG5cbiAgcHVibGljIHN0YXRpYyBwb3NpeCA9IHBhdGg7XG4gIC8vIFhYWDogVHlwaW5nIGhhY2suIFdlIGRvbid0IGFjdHVhbGx5IHN1cHBvcnQgd2luMzIuXG4gIHB1YmxpYyBzdGF0aWMgd2luMzIgPSBwYXRoO1xufVxuXG52YXIgXzogdHlwZW9mIF9wYXRoID0gcGF0aDtcblxuZXhwb3J0ID0gcGF0aDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi90cy9wYXRoLnRzIiwiaW1wb3J0IHN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuXG5jbGFzcyBUVFkgZXh0ZW5kcyBzdHJlYW0uRHVwbGV4IHtcbiAgcHVibGljIGlzUmF3OiBib29sZWFuID0gZmFsc2U7XG4gIHB1YmxpYyBjb2x1bW5zOiBudW1iZXIgPSA4MDtcbiAgcHVibGljIHJvd3M6IG51bWJlciA9IDEyMDtcbiAgcHVibGljIGlzVFRZOiBib29sZWFuID0gdHJ1ZTtcbiAgcHJpdmF0ZSBfYnVmZmVyZWRXcml0ZXM6IEJ1ZmZlcltdID0gW107XG4gIHByaXZhdGUgX3dhaXRpbmdGb3JXcml0ZXM6IGJvb2xlYW4gPSBmYWxzZTtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRvZ2dsZSByYXcgbW9kZS5cbiAgICovXG4gIHB1YmxpYyBzZXRSYXdNb2RlKG1vZGU6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICBpZiAodGhpcy5pc1JhdyAhPT0gbW9kZSkge1xuICAgICAgdGhpcy5pc1JhdyA9IG1vZGU7XG4gICAgICAvLyBbQkZTXSBUVFkgaW1wbGVtZW50YXRpb25zIGNhbiB1c2UgdGhpcyB0byBjaGFuZ2UgdGhlaXIgZXZlbnQgZW1pdHRpbmdcbiAgICAgIC8vICAgICAgIHBhdHRlcm5zLlxuICAgICAgdGhpcy5lbWl0KCdtb2RlQ2hhbmdlJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFtCRlNdIFVwZGF0ZSB0aGUgbnVtYmVyIG9mIGNvbHVtbnMgYXZhaWxhYmxlIG9uIHRoZSB0ZXJtaW5hbC5cbiAgICovXG4gIHB1YmxpYyBjaGFuZ2VDb2x1bW5zKGNvbHVtbnM6IG51bWJlcik6IHZvaWQge1xuICAgIGlmIChjb2x1bW5zICE9PSB0aGlzLmNvbHVtbnMpIHtcbiAgICAgIHRoaXMuY29sdW1ucyA9IGNvbHVtbnM7XG4gICAgICAvLyBSZXNpemUgZXZlbnQuXG4gICAgICB0aGlzLmVtaXQoJ3Jlc2l6ZScpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBbQkZTXSBVcGRhdGUgdGhlIG51bWJlciBvZiByb3dzIGF2YWlsYWJsZSBvbiB0aGUgdGVybWluYWwuXG4gICAqL1xuICBwdWJsaWMgY2hhbmdlUm93cyhyb3dzOiBudW1iZXIpOiB2b2lkIHtcbiAgICBpZiAocm93cyAhPT0gdGhpcy5yb3dzKSB7XG4gICAgICB0aGlzLnJvd3MgPSByb3dzO1xuICAgICAgLy8gUmVzaXplIGV2ZW50LlxuICAgICAgdGhpcy5lbWl0KCdyZXNpemUnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyAndHJ1ZScgaWYgdGhlIGdpdmVuIG9iamVjdCBpcyBhIFRUWS5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgaXNhdHR5KGZkOiBhbnkpOiBmZCBpcyBUVFkge1xuICAgIHJldHVybiBmZCAmJiBmZCBpbnN0YW5jZW9mIFRUWTtcbiAgfVxuXG4gIHB1YmxpYyBfd3JpdGUoY2h1bms6IGFueSwgZW5jb2Rpbmc6IHN0cmluZywgY2I6IEZ1bmN0aW9uKTogdm9pZCB7XG4gICAgdmFyIGVycm9yOiBhbnk7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBkYXRhOiBCdWZmZXI7XG4gICAgICBpZiAodHlwZW9mKGNodW5rKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZGF0YSA9IG5ldyBCdWZmZXIoY2h1bmssIGVuY29kaW5nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGEgPSBjaHVuaztcbiAgICAgIH1cbiAgICAgIHRoaXMuX2J1ZmZlcmVkV3JpdGVzLnB1c2goZGF0YSk7XG4gICAgICBpZiAodGhpcy5fd2FpdGluZ0ZvcldyaXRlcykge1xuICAgICAgICB0aGlzLl9yZWFkKDEwMjQpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGVycm9yID0gZTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgY2IoZXJyb3IpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBfcmVhZChzaXplOiBudW1iZXIpOiB2b2lkIHtcbiAgICAvLyBTaXplIGlzIGFkdmlzb3J5IC0tIHdlIGNhbiBpZ25vcmUgaXQuXG4gICAgaWYgKHRoaXMuX2J1ZmZlcmVkV3JpdGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5fd2FpdGluZ0ZvcldyaXRlcyA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdoaWxlICh0aGlzLl9idWZmZXJlZFdyaXRlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuX3dhaXRpbmdGb3JXcml0ZXMgPSB0aGlzLnB1c2godGhpcy5fYnVmZmVyZWRXcml0ZXMuc2hpZnQoKSk7XG4gICAgICAgIGlmICghdGhpcy5fd2FpdGluZ0ZvcldyaXRlcykge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCA9IFRUWTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi90cy90dHkudHMiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxubW9kdWxlLmV4cG9ydHMgPSBTdHJlYW07XG5cbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmluaGVyaXRzKFN0cmVhbSwgRUUpO1xuU3RyZWFtLlJlYWRhYmxlID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLmpzJyk7XG5TdHJlYW0uV3JpdGFibGUgPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vd3JpdGFibGUuanMnKTtcblN0cmVhbS5EdXBsZXggPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vZHVwbGV4LmpzJyk7XG5TdHJlYW0uVHJhbnNmb3JtID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3RyYW5zZm9ybS5qcycpO1xuU3RyZWFtLlBhc3NUaHJvdWdoID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3Bhc3N0aHJvdWdoLmpzJyk7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuNC54XG5TdHJlYW0uU3RyZWFtID0gU3RyZWFtO1xuXG5cblxuLy8gb2xkLXN0eWxlIHN0cmVhbXMuICBOb3RlIHRoYXQgdGhlIHBpcGUgbWV0aG9kICh0aGUgb25seSByZWxldmFudFxuLy8gcGFydCBvZiB0aGlzIGNsYXNzKSBpcyBvdmVycmlkZGVuIGluIHRoZSBSZWFkYWJsZSBjbGFzcy5cblxuZnVuY3Rpb24gU3RyZWFtKCkge1xuICBFRS5jYWxsKHRoaXMpO1xufVxuXG5TdHJlYW0ucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbihkZXN0LCBvcHRpb25zKSB7XG4gIHZhciBzb3VyY2UgPSB0aGlzO1xuXG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xuICAgIGlmIChkZXN0LndyaXRhYmxlKSB7XG4gICAgICBpZiAoZmFsc2UgPT09IGRlc3Qud3JpdGUoY2h1bmspICYmIHNvdXJjZS5wYXVzZSkge1xuICAgICAgICBzb3VyY2UucGF1c2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzb3VyY2Uub24oJ2RhdGEnLCBvbmRhdGEpO1xuXG4gIGZ1bmN0aW9uIG9uZHJhaW4oKSB7XG4gICAgaWYgKHNvdXJjZS5yZWFkYWJsZSAmJiBzb3VyY2UucmVzdW1lKSB7XG4gICAgICBzb3VyY2UucmVzdW1lKCk7XG4gICAgfVxuICB9XG5cbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcblxuICAvLyBJZiB0aGUgJ2VuZCcgb3B0aW9uIGlzIG5vdCBzdXBwbGllZCwgZGVzdC5lbmQoKSB3aWxsIGJlIGNhbGxlZCB3aGVuXG4gIC8vIHNvdXJjZSBnZXRzIHRoZSAnZW5kJyBvciAnY2xvc2UnIGV2ZW50cy4gIE9ubHkgZGVzdC5lbmQoKSBvbmNlLlxuICBpZiAoIWRlc3QuX2lzU3RkaW8gJiYgKCFvcHRpb25zIHx8IG9wdGlvbnMuZW5kICE9PSBmYWxzZSkpIHtcbiAgICBzb3VyY2Uub24oJ2VuZCcsIG9uZW5kKTtcbiAgICBzb3VyY2Uub24oJ2Nsb3NlJywgb25jbG9zZSk7XG4gIH1cblxuICB2YXIgZGlkT25FbmQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgaWYgKGRpZE9uRW5kKSByZXR1cm47XG4gICAgZGlkT25FbmQgPSB0cnVlO1xuXG4gICAgZGVzdC5lbmQoKTtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBpZiAoZGlkT25FbmQpIHJldHVybjtcbiAgICBkaWRPbkVuZCA9IHRydWU7XG5cbiAgICBpZiAodHlwZW9mIGRlc3QuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgZGVzdC5kZXN0cm95KCk7XG4gIH1cblxuICAvLyBkb24ndCBsZWF2ZSBkYW5nbGluZyBwaXBlcyB3aGVuIHRoZXJlIGFyZSBlcnJvcnMuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBjbGVhbnVwKCk7XG4gICAgaWYgKEVFLmxpc3RlbmVyQ291bnQodGhpcywgJ2Vycm9yJykgPT09IDApIHtcbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgc3RyZWFtIGVycm9yIGluIHBpcGUuXG4gICAgfVxuICB9XG5cbiAgc291cmNlLm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuICBkZXN0Lm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuXG4gIC8vIHJlbW92ZSBhbGwgdGhlIGV2ZW50IGxpc3RlbmVycyB0aGF0IHdlcmUgYWRkZWQuXG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIGNsZWFudXApO1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBjbGVhbnVwKTtcblxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgY2xlYW51cCk7XG4gIH1cblxuICBzb3VyY2Uub24oJ2VuZCcsIGNsZWFudXApO1xuICBzb3VyY2Uub24oJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgZGVzdC5vbignY2xvc2UnLCBjbGVhbnVwKTtcblxuICBkZXN0LmVtaXQoJ3BpcGUnLCBzb3VyY2UpO1xuXG4gIC8vIEFsbG93IGZvciB1bml4LWxpa2UgdXNhZ2U6IEEucGlwZShCKS5waXBlKEMpXG4gIHJldHVybiBkZXN0O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zdHJlYW0tYnJvd3NlcmlmeS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICB9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qc1xuLy8gbW9kdWxlIGlkID0gMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFN0cmVhbSA9IChmdW5jdGlvbiAoKXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gcmVxdWlyZSgnc3QnICsgJ3JlYW0nKTsgLy8gaGFjayB0byBmaXggYSBjaXJjdWxhciBkZXBlbmRlbmN5IGlzc3VlIHdoZW4gdXNlZCB3aXRoIGJyb3dzZXJpZnlcbiAgfSBjYXRjaChfKXt9XG59KCkpO1xuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcycpO1xuZXhwb3J0cy5TdHJlYW0gPSBTdHJlYW0gfHwgZXhwb3J0cztcbmV4cG9ydHMuUmVhZGFibGUgPSBleHBvcnRzO1xuZXhwb3J0cy5Xcml0YWJsZSA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fd3JpdGFibGUuanMnKTtcbmV4cG9ydHMuRHVwbGV4ID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9kdXBsZXguanMnKTtcbmV4cG9ydHMuVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMnKTtcbmV4cG9ydHMuUGFzc1Rocm91Z2ggPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzJyk7XG5cbmlmICghcHJvY2Vzcy5icm93c2VyICYmIHByb2Nlc3MuZW52LlJFQURBQkxFX1NUUkVBTSA9PT0gJ2Rpc2FibGUnICYmIFN0cmVhbSkge1xuICBtb2R1bGUuZXhwb3J0cyA9IFN0cmVhbTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUuanNcbi8vIG1vZHVsZSBpZCA9IDEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFkYWJsZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBwcm9jZXNzTmV4dFRpY2sgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIER1cGxleDtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5SZWFkYWJsZS5SZWFkYWJsZVN0YXRlID0gUmVhZGFibGVTdGF0ZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcblxudmFyIEVFbGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uIChlbWl0dGVyLCB0eXBlKSB7XG4gIHJldHVybiBlbWl0dGVyLmxpc3RlbmVycyh0eXBlKS5sZW5ndGg7XG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgU3RyZWFtO1xuKGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICBTdHJlYW0gPSByZXF1aXJlKCdzdCcgKyAncmVhbScpO1xuICB9IGNhdGNoIChfKSB7fSBmaW5hbGx5IHtcbiAgICBpZiAoIVN0cmVhbSkgU3RyZWFtID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuICB9XG59KSgpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGJ1ZmZlclNoaW0gPSByZXF1aXJlKCdidWZmZXItc2hpbXMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgZGVidWdVdGlsID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIGRlYnVnID0gdm9pZCAwO1xuaWYgKGRlYnVnVXRpbCAmJiBkZWJ1Z1V0aWwuZGVidWdsb2cpIHtcbiAgZGVidWcgPSBkZWJ1Z1V0aWwuZGVidWdsb2coJ3N0cmVhbScpO1xufSBlbHNlIHtcbiAgZGVidWcgPSBmdW5jdGlvbiAoKSB7fTtcbn1cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyTGlzdCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9CdWZmZXJMaXN0Jyk7XG52YXIgU3RyaW5nRGVjb2RlcjtcblxudXRpbC5pbmhlcml0cyhSZWFkYWJsZSwgU3RyZWFtKTtcblxuZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKGVtaXR0ZXIsIGV2ZW50LCBmbikge1xuICAvLyBTYWRseSB0aGlzIGlzIG5vdCBjYWNoZWFibGUgYXMgc29tZSBsaWJyYXJpZXMgYnVuZGxlIHRoZWlyIG93blxuICAvLyBldmVudCBlbWl0dGVyIGltcGxlbWVudGF0aW9uIHdpdGggdGhlbS5cbiAgaWYgKHR5cGVvZiBlbWl0dGVyLnByZXBlbmRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBlbWl0dGVyLnByZXBlbmRMaXN0ZW5lcihldmVudCwgZm4pO1xuICB9IGVsc2Uge1xuICAgIC8vIFRoaXMgaXMgYSBoYWNrIHRvIG1ha2Ugc3VyZSB0aGF0IG91ciBlcnJvciBoYW5kbGVyIGlzIGF0dGFjaGVkIGJlZm9yZSBhbnlcbiAgICAvLyB1c2VybGFuZCBvbmVzLiAgTkVWRVIgRE8gVEhJUy4gVGhpcyBpcyBoZXJlIG9ubHkgYmVjYXVzZSB0aGlzIGNvZGUgbmVlZHNcbiAgICAvLyB0byBjb250aW51ZSB0byB3b3JrIHdpdGggb2xkZXIgdmVyc2lvbnMgb2YgTm9kZS5qcyB0aGF0IGRvIG5vdCBpbmNsdWRlXG4gICAgLy8gdGhlIHByZXBlbmRMaXN0ZW5lcigpIG1ldGhvZC4gVGhlIGdvYWwgaXMgdG8gZXZlbnR1YWxseSByZW1vdmUgdGhpcyBoYWNrLlxuICAgIGlmICghZW1pdHRlci5fZXZlbnRzIHx8ICFlbWl0dGVyLl9ldmVudHNbZXZlbnRdKSBlbWl0dGVyLm9uKGV2ZW50LCBmbik7ZWxzZSBpZiAoaXNBcnJheShlbWl0dGVyLl9ldmVudHNbZXZlbnRdKSkgZW1pdHRlci5fZXZlbnRzW2V2ZW50XS51bnNoaWZ0KGZuKTtlbHNlIGVtaXR0ZXIuX2V2ZW50c1tldmVudF0gPSBbZm4sIGVtaXR0ZXIuX2V2ZW50c1tldmVudF1dO1xuICB9XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gb2JqZWN0IHN0cmVhbSBmbGFnLiBVc2VkIHRvIG1ha2UgcmVhZChuKSBpZ25vcmUgbiBhbmQgdG9cbiAgLy8gbWFrZSBhbGwgdGhlIGJ1ZmZlciBtZXJnaW5nIGFuZCBsZW5ndGggY2hlY2tzIGdvIGF3YXlcbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG5cbiAgaWYgKHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleCkgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy5yZWFkYWJsZU9iamVjdE1vZGU7XG5cbiAgLy8gdGhlIHBvaW50IGF0IHdoaWNoIGl0IHN0b3BzIGNhbGxpbmcgX3JlYWQoKSB0byBmaWxsIHRoZSBidWZmZXJcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyBcImRvbid0IGNhbGwgX3JlYWQgcHJlZW1wdGl2ZWx5IGV2ZXJcIlxuICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB2YXIgZGVmYXVsdEh3bSA9IHRoaXMub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0O1xuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBod20gfHwgaHdtID09PSAwID8gaHdtIDogZGVmYXVsdEh3bTtcblxuICAvLyBjYXN0IHRvIGludHMuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IH5+dGhpcy5oaWdoV2F0ZXJNYXJrO1xuXG4gIC8vIEEgbGlua2VkIGxpc3QgaXMgdXNlZCB0byBzdG9yZSBkYXRhIGNodW5rcyBpbnN0ZWFkIG9mIGFuIGFycmF5IGJlY2F1c2UgdGhlXG4gIC8vIGxpbmtlZCBsaXN0IGNhbiByZW1vdmUgZWxlbWVudHMgZnJvbSB0aGUgYmVnaW5uaW5nIGZhc3RlciB0aGFuXG4gIC8vIGFycmF5LnNoaWZ0KClcbiAgdGhpcy5idWZmZXIgPSBuZXcgQnVmZmVyTGlzdCgpO1xuICB0aGlzLmxlbmd0aCA9IDA7XG4gIHRoaXMucGlwZXMgPSBudWxsO1xuICB0aGlzLnBpcGVzQ291bnQgPSAwO1xuICB0aGlzLmZsb3dpbmcgPSBudWxsO1xuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIHRoaXMuZW5kRW1pdHRlZCA9IGZhbHNlO1xuICB0aGlzLnJlYWRpbmcgPSBmYWxzZTtcblxuICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBvbndyaXRlIGNiIGlzIGNhbGxlZCBpbW1lZGlhdGVseSxcbiAgLy8gb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZSBhbnlcbiAgLy8gYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3Qgd3JpdGUgY2FsbC5cbiAgdGhpcy5zeW5jID0gdHJ1ZTtcblxuICAvLyB3aGVuZXZlciB3ZSByZXR1cm4gbnVsbCwgdGhlbiB3ZSBzZXQgYSBmbGFnIHRvIHNheVxuICAvLyB0aGF0IHdlJ3JlIGF3YWl0aW5nIGEgJ3JlYWRhYmxlJyBldmVudCBlbWlzc2lvbi5cbiAgdGhpcy5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5yZWFkYWJsZUxpc3RlbmluZyA9IGZhbHNlO1xuICB0aGlzLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIHdoZW4gcGlwaW5nLCB3ZSBvbmx5IGNhcmUgYWJvdXQgJ3JlYWRhYmxlJyBldmVudHMgdGhhdCBoYXBwZW5cbiAgLy8gYWZ0ZXIgcmVhZCgpaW5nIGFsbCB0aGUgYnl0ZXMgYW5kIG5vdCBnZXR0aW5nIGFueSBwdXNoYmFjay5cbiAgdGhpcy5yYW5PdXQgPSBmYWxzZTtcblxuICAvLyB0aGUgbnVtYmVyIG9mIHdyaXRlcnMgdGhhdCBhcmUgYXdhaXRpbmcgYSBkcmFpbiBldmVudCBpbiAucGlwZSgpc1xuICB0aGlzLmF3YWl0RHJhaW4gPSAwO1xuXG4gIC8vIGlmIHRydWUsIGEgbWF5YmVSZWFkTW9yZSBoYXMgYmVlbiBzY2hlZHVsZWRcbiAgdGhpcy5yZWFkaW5nTW9yZSA9IGZhbHNlO1xuXG4gIHRoaXMuZGVjb2RlciA9IG51bGw7XG4gIHRoaXMuZW5jb2RpbmcgPSBudWxsO1xuICBpZiAob3B0aW9ucy5lbmNvZGluZykge1xuICAgIGlmICghU3RyaW5nRGVjb2RlcikgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gICAgdGhpcy5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIob3B0aW9ucy5lbmNvZGluZyk7XG4gICAgdGhpcy5lbmNvZGluZyA9IG9wdGlvbnMuZW5jb2Rpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gUmVhZGFibGUob3B0aW9ucykge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZWFkYWJsZSkpIHJldHVybiBuZXcgUmVhZGFibGUob3B0aW9ucyk7XG5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZSA9IG5ldyBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xuXG4gIC8vIGxlZ2FjeVxuICB0aGlzLnJlYWRhYmxlID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5yZWFkID09PSAnZnVuY3Rpb24nKSB0aGlzLl9yZWFkID0gb3B0aW9ucy5yZWFkO1xuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufVxuXG4vLyBNYW51YWxseSBzaG92ZSBzb21ldGhpbmcgaW50byB0aGUgcmVhZCgpIGJ1ZmZlci5cbi8vIFRoaXMgcmV0dXJucyB0cnVlIGlmIHRoZSBoaWdoV2F0ZXJNYXJrIGhhcyBub3QgYmVlbiBoaXQgeWV0LFxuLy8gc2ltaWxhciB0byBob3cgV3JpdGFibGUud3JpdGUoKSByZXR1cm5zIHRydWUgaWYgeW91IHNob3VsZFxuLy8gd3JpdGUoKSBzb21lIG1vcmUuXG5SZWFkYWJsZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgdHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gZW5jb2RpbmcgfHwgc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuICAgIGlmIChlbmNvZGluZyAhPT0gc3RhdGUuZW5jb2RpbmcpIHtcbiAgICAgIGNodW5rID0gYnVmZmVyU2hpbS5mcm9tKGNodW5rLCBlbmNvZGluZyk7XG4gICAgICBlbmNvZGluZyA9ICcnO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgZW5jb2RpbmcsIGZhbHNlKTtcbn07XG5cbi8vIFVuc2hpZnQgc2hvdWxkICphbHdheXMqIGJlIHNvbWV0aGluZyBkaXJlY3RseSBvdXQgb2YgcmVhZCgpXG5SZWFkYWJsZS5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uIChjaHVuaykge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssICcnLCB0cnVlKTtcbn07XG5cblJlYWRhYmxlLnByb3RvdHlwZS5pc1BhdXNlZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9PT0gZmFsc2U7XG59O1xuXG5mdW5jdGlvbiByZWFkYWJsZUFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBlbmNvZGluZywgYWRkVG9Gcm9udCkge1xuICB2YXIgZXIgPSBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKTtcbiAgaWYgKGVyKSB7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICB9IGVsc2UgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSk7XG4gIH0gZWxzZSBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuayAmJiBjaHVuay5sZW5ndGggPiAwKSB7XG4gICAgaWYgKHN0YXRlLmVuZGVkICYmICFhZGRUb0Zyb250KSB7XG4gICAgICB2YXIgZSA9IG5ldyBFcnJvcignc3RyZWFtLnB1c2goKSBhZnRlciBFT0YnKTtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGUpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUuZW5kRW1pdHRlZCAmJiBhZGRUb0Zyb250KSB7XG4gICAgICB2YXIgX2UgPSBuZXcgRXJyb3IoJ3N0cmVhbS51bnNoaWZ0KCkgYWZ0ZXIgZW5kIGV2ZW50Jyk7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBfZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBza2lwQWRkO1xuICAgICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIWFkZFRvRnJvbnQgJiYgIWVuY29kaW5nKSB7XG4gICAgICAgIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG4gICAgICAgIHNraXBBZGQgPSAhc3RhdGUub2JqZWN0TW9kZSAmJiBjaHVuay5sZW5ndGggPT09IDA7XG4gICAgICB9XG5cbiAgICAgIGlmICghYWRkVG9Gcm9udCkgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuXG4gICAgICAvLyBEb24ndCBhZGQgdG8gdGhlIGJ1ZmZlciBpZiB3ZSd2ZSBkZWNvZGVkIHRvIGFuIGVtcHR5IHN0cmluZyBjaHVuayBhbmRcbiAgICAgIC8vIHdlJ3JlIG5vdCBpbiBvYmplY3QgbW9kZVxuICAgICAgaWYgKCFza2lwQWRkKSB7XG4gICAgICAgIC8vIGlmIHdlIHdhbnQgdGhlIGRhdGEgbm93LCBqdXN0IGVtaXQgaXQuXG4gICAgICAgIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiAhc3RhdGUuc3luYykge1xuICAgICAgICAgIHN0cmVhbS5lbWl0KCdkYXRhJywgY2h1bmspO1xuICAgICAgICAgIHN0cmVhbS5yZWFkKDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgYnVmZmVyIGluZm8uXG4gICAgICAgICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgICAgICAgIGlmIChhZGRUb0Zyb250KSBzdGF0ZS5idWZmZXIudW5zaGlmdChjaHVuayk7ZWxzZSBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG5cbiAgICAgICAgICBpZiAoc3RhdGUubmVlZFJlYWRhYmxlKSBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cbiAgfSBlbHNlIGlmICghYWRkVG9Gcm9udCkge1xuICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBuZWVkTW9yZURhdGEoc3RhdGUpO1xufVxuXG4vLyBpZiBpdCdzIHBhc3QgdGhlIGhpZ2ggd2F0ZXIgbWFyaywgd2UgY2FuIHB1c2ggaW4gc29tZSBtb3JlLlxuLy8gQWxzbywgaWYgd2UgaGF2ZSBubyBkYXRhIHlldCwgd2UgY2FuIHN0YW5kIHNvbWVcbi8vIG1vcmUgYnl0ZXMuICBUaGlzIGlzIHRvIHdvcmsgYXJvdW5kIGNhc2VzIHdoZXJlIGh3bT0wLFxuLy8gc3VjaCBhcyB0aGUgcmVwbC4gIEFsc28sIGlmIHRoZSBwdXNoKCkgdHJpZ2dlcmVkIGFcbi8vIHJlYWRhYmxlIGV2ZW50LCBhbmQgdGhlIHVzZXIgY2FsbGVkIHJlYWQobGFyZ2VOdW1iZXIpIHN1Y2ggdGhhdFxuLy8gbmVlZFJlYWRhYmxlIHdhcyBzZXQsIHRoZW4gd2Ugb3VnaHQgdG8gcHVzaCBtb3JlLCBzbyB0aGF0IGFub3RoZXJcbi8vICdyZWFkYWJsZScgZXZlbnQgd2lsbCBiZSB0cmlnZ2VyZWQuXG5mdW5jdGlvbiBuZWVkTW9yZURhdGEoc3RhdGUpIHtcbiAgcmV0dXJuICFzdGF0ZS5lbmRlZCAmJiAoc3RhdGUubmVlZFJlYWRhYmxlIHx8IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUubGVuZ3RoID09PSAwKTtcbn1cblxuLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG5SZWFkYWJsZS5wcm90b3R5cGUuc2V0RW5jb2RpbmcgPSBmdW5jdGlvbiAoZW5jKSB7XG4gIGlmICghU3RyaW5nRGVjb2RlcikgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKGVuYyk7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5jb2RpbmcgPSBlbmM7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gRG9uJ3QgcmFpc2UgdGhlIGh3bSA+IDhNQlxudmFyIE1BWF9IV00gPSAweDgwMDAwMDtcbmZ1bmN0aW9uIGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pIHtcbiAgaWYgKG4gPj0gTUFYX0hXTSkge1xuICAgIG4gPSBNQVhfSFdNO1xuICB9IGVsc2Uge1xuICAgIC8vIEdldCB0aGUgbmV4dCBoaWdoZXN0IHBvd2VyIG9mIDIgdG8gcHJldmVudCBpbmNyZWFzaW5nIGh3bSBleGNlc3NpdmVseSBpblxuICAgIC8vIHRpbnkgYW1vdW50c1xuICAgIG4tLTtcbiAgICBuIHw9IG4gPj4+IDE7XG4gICAgbiB8PSBuID4+PiAyO1xuICAgIG4gfD0gbiA+Pj4gNDtcbiAgICBuIHw9IG4gPj4+IDg7XG4gICAgbiB8PSBuID4+PiAxNjtcbiAgICBuKys7XG4gIH1cbiAgcmV0dXJuIG47XG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSkge1xuICBpZiAobiA8PSAwIHx8IHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkgcmV0dXJuIDA7XG4gIGlmIChzdGF0ZS5vYmplY3RNb2RlKSByZXR1cm4gMTtcbiAgaWYgKG4gIT09IG4pIHtcbiAgICAvLyBPbmx5IGZsb3cgb25lIGJ1ZmZlciBhdCBhIHRpbWVcbiAgICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGgpIHJldHVybiBzdGF0ZS5idWZmZXIuaGVhZC5kYXRhLmxlbmd0aDtlbHNlIHJldHVybiBzdGF0ZS5sZW5ndGg7XG4gIH1cbiAgLy8gSWYgd2UncmUgYXNraW5nIGZvciBtb3JlIHRoYW4gdGhlIGN1cnJlbnQgaHdtLCB0aGVuIHJhaXNlIHRoZSBod20uXG4gIGlmIChuID4gc3RhdGUuaGlnaFdhdGVyTWFyaykgc3RhdGUuaGlnaFdhdGVyTWFyayA9IGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pO1xuICBpZiAobiA8PSBzdGF0ZS5sZW5ndGgpIHJldHVybiBuO1xuICAvLyBEb24ndCBoYXZlIGVub3VnaFxuICBpZiAoIXN0YXRlLmVuZGVkKSB7XG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICByZXR1cm4gMDtcbiAgfVxuICByZXR1cm4gc3RhdGUubGVuZ3RoO1xufVxuXG4vLyB5b3UgY2FuIG92ZXJyaWRlIGVpdGhlciB0aGlzIG1ldGhvZCwgb3IgdGhlIGFzeW5jIF9yZWFkKG4pIGJlbG93LlxuUmVhZGFibGUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbiAobikge1xuICBkZWJ1ZygncmVhZCcsIG4pO1xuICBuID0gcGFyc2VJbnQobiwgMTApO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgbk9yaWcgPSBuO1xuXG4gIGlmIChuICE9PSAwKSBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcblxuICAvLyBpZiB3ZSdyZSBkb2luZyByZWFkKDApIHRvIHRyaWdnZXIgYSByZWFkYWJsZSBldmVudCwgYnV0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhIGJ1bmNoIG9mIGRhdGEgaW4gdGhlIGJ1ZmZlciwgdGhlbiBqdXN0IHRyaWdnZXJcbiAgLy8gdGhlICdyZWFkYWJsZScgZXZlbnQgYW5kIG1vdmUgb24uXG4gIGlmIChuID09PSAwICYmIHN0YXRlLm5lZWRSZWFkYWJsZSAmJiAoc3RhdGUubGVuZ3RoID49IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUuZW5kZWQpKSB7XG4gICAgZGVidWcoJ3JlYWQ6IGVtaXRSZWFkYWJsZScsIHN0YXRlLmxlbmd0aCwgc3RhdGUuZW5kZWQpO1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpO2Vsc2UgZW1pdFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbiA9IGhvd011Y2hUb1JlYWQobiwgc3RhdGUpO1xuXG4gIC8vIGlmIHdlJ3ZlIGVuZGVkLCBhbmQgd2UncmUgbm93IGNsZWFyLCB0aGVuIGZpbmlzaCBpdCB1cC5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUuZW5kZWQpIHtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIEFsbCB0aGUgYWN0dWFsIGNodW5rIGdlbmVyYXRpb24gbG9naWMgbmVlZHMgdG8gYmVcbiAgLy8gKmJlbG93KiB0aGUgY2FsbCB0byBfcmVhZC4gIFRoZSByZWFzb24gaXMgdGhhdCBpbiBjZXJ0YWluXG4gIC8vIHN5bnRoZXRpYyBzdHJlYW0gY2FzZXMsIHN1Y2ggYXMgcGFzc3Rocm91Z2ggc3RyZWFtcywgX3JlYWRcbiAgLy8gbWF5IGJlIGEgY29tcGxldGVseSBzeW5jaHJvbm91cyBvcGVyYXRpb24gd2hpY2ggbWF5IGNoYW5nZVxuICAvLyB0aGUgc3RhdGUgb2YgdGhlIHJlYWQgYnVmZmVyLCBwcm92aWRpbmcgZW5vdWdoIGRhdGEgd2hlblxuICAvLyBiZWZvcmUgdGhlcmUgd2FzICpub3QqIGVub3VnaC5cbiAgLy9cbiAgLy8gU28sIHRoZSBzdGVwcyBhcmU6XG4gIC8vIDEuIEZpZ3VyZSBvdXQgd2hhdCB0aGUgc3RhdGUgb2YgdGhpbmdzIHdpbGwgYmUgYWZ0ZXIgd2UgZG9cbiAgLy8gYSByZWFkIGZyb20gdGhlIGJ1ZmZlci5cbiAgLy9cbiAgLy8gMi4gSWYgdGhhdCByZXN1bHRpbmcgc3RhdGUgd2lsbCB0cmlnZ2VyIGEgX3JlYWQsIHRoZW4gY2FsbCBfcmVhZC5cbiAgLy8gTm90ZSB0aGF0IHRoaXMgbWF5IGJlIGFzeW5jaHJvbm91cywgb3Igc3luY2hyb25vdXMuICBZZXMsIGl0IGlzXG4gIC8vIGRlZXBseSB1Z2x5IHRvIHdyaXRlIEFQSXMgdGhpcyB3YXksIGJ1dCB0aGF0IHN0aWxsIGRvZXNuJ3QgbWVhblxuICAvLyB0aGF0IHRoZSBSZWFkYWJsZSBjbGFzcyBzaG91bGQgYmVoYXZlIGltcHJvcGVybHksIGFzIHN0cmVhbXMgYXJlXG4gIC8vIGRlc2lnbmVkIHRvIGJlIHN5bmMvYXN5bmMgYWdub3N0aWMuXG4gIC8vIFRha2Ugbm90ZSBpZiB0aGUgX3JlYWQgY2FsbCBpcyBzeW5jIG9yIGFzeW5jIChpZSwgaWYgdGhlIHJlYWQgY2FsbFxuICAvLyBoYXMgcmV0dXJuZWQgeWV0KSwgc28gdGhhdCB3ZSBrbm93IHdoZXRoZXIgb3Igbm90IGl0J3Mgc2FmZSB0byBlbWl0XG4gIC8vICdyZWFkYWJsZScgZXRjLlxuICAvL1xuICAvLyAzLiBBY3R1YWxseSBwdWxsIHRoZSByZXF1ZXN0ZWQgY2h1bmtzIG91dCBvZiB0aGUgYnVmZmVyIGFuZCByZXR1cm4uXG5cbiAgLy8gaWYgd2UgbmVlZCBhIHJlYWRhYmxlIGV2ZW50LCB0aGVuIHdlIG5lZWQgdG8gZG8gc29tZSByZWFkaW5nLlxuICB2YXIgZG9SZWFkID0gc3RhdGUubmVlZFJlYWRhYmxlO1xuICBkZWJ1ZygnbmVlZCByZWFkYWJsZScsIGRvUmVhZCk7XG5cbiAgLy8gaWYgd2UgY3VycmVudGx5IGhhdmUgbGVzcyB0aGFuIHRoZSBoaWdoV2F0ZXJNYXJrLCB0aGVuIGFsc28gcmVhZCBzb21lXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgfHwgc3RhdGUubGVuZ3RoIC0gbiA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBkb1JlYWQgPSB0cnVlO1xuICAgIGRlYnVnKCdsZW5ndGggbGVzcyB0aGFuIHdhdGVybWFyaycsIGRvUmVhZCk7XG4gIH1cblxuICAvLyBob3dldmVyLCBpZiB3ZSd2ZSBlbmRlZCwgdGhlbiB0aGVyZSdzIG5vIHBvaW50LCBhbmQgaWYgd2UncmUgYWxyZWFkeVxuICAvLyByZWFkaW5nLCB0aGVuIGl0J3MgdW5uZWNlc3NhcnkuXG4gIGlmIChzdGF0ZS5lbmRlZCB8fCBzdGF0ZS5yZWFkaW5nKSB7XG4gICAgZG9SZWFkID0gZmFsc2U7XG4gICAgZGVidWcoJ3JlYWRpbmcgb3IgZW5kZWQnLCBkb1JlYWQpO1xuICB9IGVsc2UgaWYgKGRvUmVhZCkge1xuICAgIGRlYnVnKCdkbyByZWFkJyk7XG4gICAgc3RhdGUucmVhZGluZyA9IHRydWU7XG4gICAgc3RhdGUuc3luYyA9IHRydWU7XG4gICAgLy8gaWYgdGhlIGxlbmd0aCBpcyBjdXJyZW50bHkgemVybywgdGhlbiB3ZSAqbmVlZCogYSByZWFkYWJsZSBldmVudC5cbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIC8vIGNhbGwgaW50ZXJuYWwgcmVhZCBtZXRob2RcbiAgICB0aGlzLl9yZWFkKHN0YXRlLmhpZ2hXYXRlck1hcmspO1xuICAgIHN0YXRlLnN5bmMgPSBmYWxzZTtcbiAgICAvLyBJZiBfcmVhZCBwdXNoZWQgZGF0YSBzeW5jaHJvbm91c2x5LCB0aGVuIGByZWFkaW5nYCB3aWxsIGJlIGZhbHNlLFxuICAgIC8vIGFuZCB3ZSBuZWVkIHRvIHJlLWV2YWx1YXRlIGhvdyBtdWNoIGRhdGEgd2UgY2FuIHJldHVybiB0byB0aGUgdXNlci5cbiAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIG4gPSBob3dNdWNoVG9SZWFkKG5PcmlnLCBzdGF0ZSk7XG4gIH1cblxuICB2YXIgcmV0O1xuICBpZiAobiA+IDApIHJldCA9IGZyb21MaXN0KG4sIHN0YXRlKTtlbHNlIHJldCA9IG51bGw7XG5cbiAgaWYgKHJldCA9PT0gbnVsbCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgbiA9IDA7XG4gIH0gZWxzZSB7XG4gICAgc3RhdGUubGVuZ3RoIC09IG47XG4gIH1cblxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgLy8gSWYgd2UgaGF2ZSBub3RoaW5nIGluIHRoZSBidWZmZXIsIHRoZW4gd2Ugd2FudCB0byBrbm93XG4gICAgLy8gYXMgc29vbiBhcyB3ZSAqZG8qIGdldCBzb21ldGhpbmcgaW50byB0aGUgYnVmZmVyLlxuICAgIGlmICghc3RhdGUuZW5kZWQpIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG5cbiAgICAvLyBJZiB3ZSB0cmllZCB0byByZWFkKCkgcGFzdCB0aGUgRU9GLCB0aGVuIGVtaXQgZW5kIG9uIHRoZSBuZXh0IHRpY2suXG4gICAgaWYgKG5PcmlnICE9PSBuICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgfVxuXG4gIGlmIChyZXQgIT09IG51bGwpIHRoaXMuZW1pdCgnZGF0YScsIHJldCk7XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspIHtcbiAgdmFyIGVyID0gbnVsbDtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoY2h1bmspICYmIHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgY2h1bmsgIT09IG51bGwgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVyID0gbmV3IFR5cGVFcnJvcignSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVuaycpO1xuICB9XG4gIHJldHVybiBlcjtcbn1cblxuZnVuY3Rpb24gb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5lbmRlZCkgcmV0dXJuO1xuICBpZiAoc3RhdGUuZGVjb2Rlcikge1xuICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkge1xuICAgICAgc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuICAgICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgIH1cbiAgfVxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG5cbiAgLy8gZW1pdCAncmVhZGFibGUnIG5vdyB0byBtYWtlIHN1cmUgaXQgZ2V0cyBwaWNrZWQgdXAuXG4gIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xufVxuXG4vLyBEb24ndCBlbWl0IHJlYWRhYmxlIHJpZ2h0IGF3YXkgaW4gc3luYyBtb2RlLCBiZWNhdXNlIHRoaXMgY2FuIHRyaWdnZXJcbi8vIGFub3RoZXIgcmVhZCgpIGNhbGwgPT4gc3RhY2sgb3ZlcmZsb3cuICBUaGlzIHdheSwgaXQgbWlnaHQgdHJpZ2dlclxuLy8gYSBuZXh0VGljayByZWN1cnNpb24gd2FybmluZywgYnV0IHRoYXQncyBub3Qgc28gYmFkLlxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIHN0YXRlLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuICBpZiAoIXN0YXRlLmVtaXR0ZWRSZWFkYWJsZSkge1xuICAgIGRlYnVnKCdlbWl0UmVhZGFibGUnLCBzdGF0ZS5mbG93aW5nKTtcbiAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSB0cnVlO1xuICAgIGlmIChzdGF0ZS5zeW5jKSBwcm9jZXNzTmV4dFRpY2soZW1pdFJlYWRhYmxlXywgc3RyZWFtKTtlbHNlIGVtaXRSZWFkYWJsZV8oc3RyZWFtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGVfKHN0cmVhbSkge1xuICBkZWJ1ZygnZW1pdCByZWFkYWJsZScpO1xuICBzdHJlYW0uZW1pdCgncmVhZGFibGUnKTtcbiAgZmxvdyhzdHJlYW0pO1xufVxuXG4vLyBhdCB0aGlzIHBvaW50LCB0aGUgdXNlciBoYXMgcHJlc3VtYWJseSBzZWVuIHRoZSAncmVhZGFibGUnIGV2ZW50LFxuLy8gYW5kIGNhbGxlZCByZWFkKCkgdG8gY29uc3VtZSBzb21lIGRhdGEuICB0aGF0IG1heSBoYXZlIHRyaWdnZXJlZFxuLy8gaW4gdHVybiBhbm90aGVyIF9yZWFkKG4pIGNhbGwsIGluIHdoaWNoIGNhc2UgcmVhZGluZyA9IHRydWUgaWZcbi8vIGl0J3MgaW4gcHJvZ3Jlc3MuXG4vLyBIb3dldmVyLCBpZiB3ZSdyZSBub3QgZW5kZWQsIG9yIHJlYWRpbmcsIGFuZCB0aGUgbGVuZ3RoIDwgaHdtLFxuLy8gdGhlbiBnbyBhaGVhZCBhbmQgdHJ5IHRvIHJlYWQgc29tZSBtb3JlIHByZWVtcHRpdmVseS5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlYWRpbmdNb3JlKSB7XG4gICAgc3RhdGUucmVhZGluZ01vcmUgPSB0cnVlO1xuICAgIHByb2Nlc3NOZXh0VGljayhtYXliZVJlYWRNb3JlXywgc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZV8oc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbGVuID0gc3RhdGUubGVuZ3RoO1xuICB3aGlsZSAoIXN0YXRlLnJlYWRpbmcgJiYgIXN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLmVuZGVkICYmIHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBkZWJ1ZygnbWF5YmVSZWFkTW9yZSByZWFkIDAnKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgICBpZiAobGVuID09PSBzdGF0ZS5sZW5ndGgpXG4gICAgICAvLyBkaWRuJ3QgZ2V0IGFueSBkYXRhLCBzdG9wIHNwaW5uaW5nLlxuICAgICAgYnJlYWs7ZWxzZSBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gIH1cbiAgc3RhdGUucmVhZGluZ01vcmUgPSBmYWxzZTtcbn1cblxuLy8gYWJzdHJhY3QgbWV0aG9kLiAgdG8gYmUgb3ZlcnJpZGRlbiBpbiBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gY2FsbCBjYihlciwgZGF0YSkgd2hlcmUgZGF0YSBpcyA8PSBuIGluIGxlbmd0aC5cbi8vIGZvciB2aXJ0dWFsIChub24tc3RyaW5nLCBub24tYnVmZmVyKSBzdHJlYW1zLCBcImxlbmd0aFwiIGlzIHNvbWV3aGF0XG4vLyBhcmJpdHJhcnksIGFuZCBwZXJoYXBzIG5vdCB2ZXJ5IG1lYW5pbmdmdWwuXG5SZWFkYWJsZS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdfcmVhZCgpIGlzIG5vdCBpbXBsZW1lbnRlZCcpKTtcbn07XG5cblJlYWRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKGRlc3QsIHBpcGVPcHRzKSB7XG4gIHZhciBzcmMgPSB0aGlzO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIHN3aXRjaCAoc3RhdGUucGlwZXNDb3VudCkge1xuICAgIGNhc2UgMDpcbiAgICAgIHN0YXRlLnBpcGVzID0gZGVzdDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTpcbiAgICAgIHN0YXRlLnBpcGVzID0gW3N0YXRlLnBpcGVzLCBkZXN0XTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBzdGF0ZS5waXBlcy5wdXNoKGRlc3QpO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgc3RhdGUucGlwZXNDb3VudCArPSAxO1xuICBkZWJ1ZygncGlwZSBjb3VudD0lZCBvcHRzPSVqJywgc3RhdGUucGlwZXNDb3VudCwgcGlwZU9wdHMpO1xuXG4gIHZhciBkb0VuZCA9ICghcGlwZU9wdHMgfHwgcGlwZU9wdHMuZW5kICE9PSBmYWxzZSkgJiYgZGVzdCAhPT0gcHJvY2Vzcy5zdGRvdXQgJiYgZGVzdCAhPT0gcHJvY2Vzcy5zdGRlcnI7XG5cbiAgdmFyIGVuZEZuID0gZG9FbmQgPyBvbmVuZCA6IGNsZWFudXA7XG4gIGlmIChzdGF0ZS5lbmRFbWl0dGVkKSBwcm9jZXNzTmV4dFRpY2soZW5kRm4pO2Vsc2Ugc3JjLm9uY2UoJ2VuZCcsIGVuZEZuKTtcblxuICBkZXN0Lm9uKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gIGZ1bmN0aW9uIG9udW5waXBlKHJlYWRhYmxlKSB7XG4gICAgZGVidWcoJ29udW5waXBlJyk7XG4gICAgaWYgKHJlYWRhYmxlID09PSBzcmMpIHtcbiAgICAgIGNsZWFudXAoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICBkZWJ1Zygnb25lbmQnKTtcbiAgICBkZXN0LmVuZCgpO1xuICB9XG5cbiAgLy8gd2hlbiB0aGUgZGVzdCBkcmFpbnMsIGl0IHJlZHVjZXMgdGhlIGF3YWl0RHJhaW4gY291bnRlclxuICAvLyBvbiB0aGUgc291cmNlLiAgVGhpcyB3b3VsZCBiZSBtb3JlIGVsZWdhbnQgd2l0aCBhIC5vbmNlKClcbiAgLy8gaGFuZGxlciBpbiBmbG93KCksIGJ1dCBhZGRpbmcgYW5kIHJlbW92aW5nIHJlcGVhdGVkbHkgaXNcbiAgLy8gdG9vIHNsb3cuXG4gIHZhciBvbmRyYWluID0gcGlwZU9uRHJhaW4oc3JjKTtcbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcblxuICB2YXIgY2xlYW5lZFVwID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgZGVidWcoJ2NsZWFudXAnKTtcbiAgICAvLyBjbGVhbnVwIGV2ZW50IGhhbmRsZXJzIG9uY2UgdGhlIHBpcGUgaXMgYnJva2VuXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ3VucGlwZScsIG9udW5waXBlKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIGNsZWFudXApO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uZGF0YSk7XG5cbiAgICBjbGVhbmVkVXAgPSB0cnVlO1xuXG4gICAgLy8gaWYgdGhlIHJlYWRlciBpcyB3YWl0aW5nIGZvciBhIGRyYWluIGV2ZW50IGZyb20gdGhpc1xuICAgIC8vIHNwZWNpZmljIHdyaXRlciwgdGhlbiBpdCB3b3VsZCBjYXVzZSBpdCB0byBuZXZlciBzdGFydFxuICAgIC8vIGZsb3dpbmcgYWdhaW4uXG4gICAgLy8gU28sIGlmIHRoaXMgaXMgYXdhaXRpbmcgYSBkcmFpbiwgdGhlbiB3ZSBqdXN0IGNhbGwgaXQgbm93LlxuICAgIC8vIElmIHdlIGRvbid0IGtub3csIHRoZW4gYXNzdW1lIHRoYXQgd2UgYXJlIHdhaXRpbmcgZm9yIG9uZS5cbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiAmJiAoIWRlc3QuX3dyaXRhYmxlU3RhdGUgfHwgZGVzdC5fd3JpdGFibGVTdGF0ZS5uZWVkRHJhaW4pKSBvbmRyYWluKCk7XG4gIH1cblxuICAvLyBJZiB0aGUgdXNlciBwdXNoZXMgbW9yZSBkYXRhIHdoaWxlIHdlJ3JlIHdyaXRpbmcgdG8gZGVzdCB0aGVuIHdlJ2xsIGVuZCB1cFxuICAvLyBpbiBvbmRhdGEgYWdhaW4uIEhvd2V2ZXIsIHdlIG9ubHkgd2FudCB0byBpbmNyZWFzZSBhd2FpdERyYWluIG9uY2UgYmVjYXVzZVxuICAvLyBkZXN0IHdpbGwgb25seSBlbWl0IG9uZSAnZHJhaW4nIGV2ZW50IGZvciB0aGUgbXVsdGlwbGUgd3JpdGVzLlxuICAvLyA9PiBJbnRyb2R1Y2UgYSBndWFyZCBvbiBpbmNyZWFzaW5nIGF3YWl0RHJhaW4uXG4gIHZhciBpbmNyZWFzZWRBd2FpdERyYWluID0gZmFsc2U7XG4gIHNyYy5vbignZGF0YScsIG9uZGF0YSk7XG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xuICAgIGRlYnVnKCdvbmRhdGEnKTtcbiAgICBpbmNyZWFzZWRBd2FpdERyYWluID0gZmFsc2U7XG4gICAgdmFyIHJldCA9IGRlc3Qud3JpdGUoY2h1bmspO1xuICAgIGlmIChmYWxzZSA9PT0gcmV0ICYmICFpbmNyZWFzZWRBd2FpdERyYWluKSB7XG4gICAgICAvLyBJZiB0aGUgdXNlciB1bnBpcGVkIGR1cmluZyBgZGVzdC53cml0ZSgpYCwgaXQgaXMgcG9zc2libGVcbiAgICAgIC8vIHRvIGdldCBzdHVjayBpbiBhIHBlcm1hbmVudGx5IHBhdXNlZCBzdGF0ZSBpZiB0aGF0IHdyaXRlXG4gICAgICAvLyBhbHNvIHJldHVybmVkIGZhbHNlLlxuICAgICAgLy8gPT4gQ2hlY2sgd2hldGhlciBgZGVzdGAgaXMgc3RpbGwgYSBwaXBpbmcgZGVzdGluYXRpb24uXG4gICAgICBpZiAoKHN0YXRlLnBpcGVzQ291bnQgPT09IDEgJiYgc3RhdGUucGlwZXMgPT09IGRlc3QgfHwgc3RhdGUucGlwZXNDb3VudCA+IDEgJiYgaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCkgIT09IC0xKSAmJiAhY2xlYW5lZFVwKSB7XG4gICAgICAgIGRlYnVnKCdmYWxzZSB3cml0ZSByZXNwb25zZSwgcGF1c2UnLCBzcmMuX3JlYWRhYmxlU3RhdGUuYXdhaXREcmFpbik7XG4gICAgICAgIHNyYy5fcmVhZGFibGVTdGF0ZS5hd2FpdERyYWluKys7XG4gICAgICAgIGluY3JlYXNlZEF3YWl0RHJhaW4gPSB0cnVlO1xuICAgICAgfVxuICAgICAgc3JjLnBhdXNlKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIGRlc3QgaGFzIGFuIGVycm9yLCB0aGVuIHN0b3AgcGlwaW5nIGludG8gaXQuXG4gIC8vIGhvd2V2ZXIsIGRvbid0IHN1cHByZXNzIHRoZSB0aHJvd2luZyBiZWhhdmlvciBmb3IgdGhpcy5cbiAgZnVuY3Rpb24gb25lcnJvcihlcikge1xuICAgIGRlYnVnKCdvbmVycm9yJywgZXIpO1xuICAgIHVucGlwZSgpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgaWYgKEVFbGlzdGVuZXJDb3VudChkZXN0LCAnZXJyb3InKSA9PT0gMCkgZGVzdC5lbWl0KCdlcnJvcicsIGVyKTtcbiAgfVxuXG4gIC8vIE1ha2Ugc3VyZSBvdXIgZXJyb3IgaGFuZGxlciBpcyBhdHRhY2hlZCBiZWZvcmUgdXNlcmxhbmQgb25lcy5cbiAgcHJlcGVuZExpc3RlbmVyKGRlc3QsICdlcnJvcicsIG9uZXJyb3IpO1xuXG4gIC8vIEJvdGggY2xvc2UgYW5kIGZpbmlzaCBzaG91bGQgdHJpZ2dlciB1bnBpcGUsIGJ1dCBvbmx5IG9uY2UuXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIHVucGlwZSgpO1xuICB9XG4gIGRlc3Qub25jZSgnY2xvc2UnLCBvbmNsb3NlKTtcbiAgZnVuY3Rpb24gb25maW5pc2goKSB7XG4gICAgZGVidWcoJ29uZmluaXNoJyk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuICBkZXN0Lm9uY2UoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcblxuICBmdW5jdGlvbiB1bnBpcGUoKSB7XG4gICAgZGVidWcoJ3VucGlwZScpO1xuICAgIHNyYy51bnBpcGUoZGVzdCk7XG4gIH1cblxuICAvLyB0ZWxsIHRoZSBkZXN0IHRoYXQgaXQncyBiZWluZyBwaXBlZCB0b1xuICBkZXN0LmVtaXQoJ3BpcGUnLCBzcmMpO1xuXG4gIC8vIHN0YXJ0IHRoZSBmbG93IGlmIGl0IGhhc24ndCBiZWVuIHN0YXJ0ZWQgYWxyZWFkeS5cbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3BpcGUgcmVzdW1lJyk7XG4gICAgc3JjLnJlc3VtZSgpO1xuICB9XG5cbiAgcmV0dXJuIGRlc3Q7XG59O1xuXG5mdW5jdGlvbiBwaXBlT25EcmFpbihzcmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3RhdGUgPSBzcmMuX3JlYWRhYmxlU3RhdGU7XG4gICAgZGVidWcoJ3BpcGVPbkRyYWluJywgc3RhdGUuYXdhaXREcmFpbik7XG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4pIHN0YXRlLmF3YWl0RHJhaW4tLTtcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiA9PT0gMCAmJiBFRWxpc3RlbmVyQ291bnQoc3JjLCAnZGF0YScpKSB7XG4gICAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcbiAgICAgIGZsb3coc3JjKTtcbiAgICB9XG4gIH07XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS51bnBpcGUgPSBmdW5jdGlvbiAoZGVzdCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIC8vIGlmIHdlJ3JlIG5vdCBwaXBpbmcgYW55d2hlcmUsIHRoZW4gZG8gbm90aGluZy5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDApIHJldHVybiB0aGlzO1xuXG4gIC8vIGp1c3Qgb25lIGRlc3RpbmF0aW9uLiAgbW9zdCBjb21tb24gY2FzZS5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHtcbiAgICAvLyBwYXNzZWQgaW4gb25lLCBidXQgaXQncyBub3QgdGhlIHJpZ2h0IG9uZS5cbiAgICBpZiAoZGVzdCAmJiBkZXN0ICE9PSBzdGF0ZS5waXBlcykgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAoIWRlc3QpIGRlc3QgPSBzdGF0ZS5waXBlcztcblxuICAgIC8vIGdvdCBhIG1hdGNoLlxuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgaWYgKGRlc3QpIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBzbG93IGNhc2UuIG11bHRpcGxlIHBpcGUgZGVzdGluYXRpb25zLlxuXG4gIGlmICghZGVzdCkge1xuICAgIC8vIHJlbW92ZSBhbGwuXG4gICAgdmFyIGRlc3RzID0gc3RhdGUucGlwZXM7XG4gICAgdmFyIGxlbiA9IHN0YXRlLnBpcGVzQ291bnQ7XG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGRlc3RzW2ldLmVtaXQoJ3VucGlwZScsIHRoaXMpO1xuICAgIH1yZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHRyeSB0byBmaW5kIHRoZSByaWdodCBvbmUuXG4gIHZhciBpbmRleCA9IGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpO1xuICBpZiAoaW5kZXggPT09IC0xKSByZXR1cm4gdGhpcztcblxuICBzdGF0ZS5waXBlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICBzdGF0ZS5waXBlc0NvdW50IC09IDE7XG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSBzdGF0ZS5waXBlcyA9IHN0YXRlLnBpcGVzWzBdO1xuXG4gIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBzZXQgdXAgZGF0YSBldmVudHMgaWYgdGhleSBhcmUgYXNrZWQgZm9yXG4vLyBFbnN1cmUgcmVhZGFibGUgbGlzdGVuZXJzIGV2ZW50dWFsbHkgZ2V0IHNvbWV0aGluZ1xuUmVhZGFibGUucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2LCBmbikge1xuICB2YXIgcmVzID0gU3RyZWFtLnByb3RvdHlwZS5vbi5jYWxsKHRoaXMsIGV2LCBmbik7XG5cbiAgaWYgKGV2ID09PSAnZGF0YScpIHtcbiAgICAvLyBTdGFydCBmbG93aW5nIG9uIG5leHQgdGljayBpZiBzdHJlYW0gaXNuJ3QgZXhwbGljaXRseSBwYXVzZWRcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nICE9PSBmYWxzZSkgdGhpcy5yZXN1bWUoKTtcbiAgfSBlbHNlIGlmIChldiA9PT0gJ3JlYWRhYmxlJykge1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmICFzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZykge1xuICAgICAgc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcgPSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gICAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICAgICAgcHJvY2Vzc05leHRUaWNrKG5SZWFkaW5nTmV4dFRpY2ssIHRoaXMpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5sZW5ndGgpIHtcbiAgICAgICAgZW1pdFJlYWRhYmxlKHRoaXMsIHN0YXRlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblJlYWRhYmxlLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IFJlYWRhYmxlLnByb3RvdHlwZS5vbjtcblxuZnVuY3Rpb24gblJlYWRpbmdOZXh0VGljayhzZWxmKSB7XG4gIGRlYnVnKCdyZWFkYWJsZSBuZXh0dGljayByZWFkIDAnKTtcbiAgc2VsZi5yZWFkKDApO1xufVxuXG4vLyBwYXVzZSgpIGFuZCByZXN1bWUoKSBhcmUgcmVtbmFudHMgb2YgdGhlIGxlZ2FjeSByZWFkYWJsZSBzdHJlYW0gQVBJXG4vLyBJZiB0aGUgdXNlciB1c2VzIHRoZW0sIHRoZW4gc3dpdGNoIGludG8gb2xkIG1vZGUuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncmVzdW1lJyk7XG4gICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgcmVzdW1lKHRoaXMsIHN0YXRlKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIHJlc3VtZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVzdW1lU2NoZWR1bGVkKSB7XG4gICAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICBwcm9jZXNzTmV4dFRpY2socmVzdW1lXywgc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzdW1lXyhzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVhZGluZykge1xuICAgIGRlYnVnKCdyZXN1bWUgcmVhZCAwJyk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gIH1cblxuICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgc3RhdGUuYXdhaXREcmFpbiA9IDA7XG4gIHN0cmVhbS5lbWl0KCdyZXN1bWUnKTtcbiAgZmxvdyhzdHJlYW0pO1xuICBpZiAoc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUucmVhZGluZykgc3RyZWFtLnJlYWQoMCk7XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoJ2NhbGwgcGF1c2UgZmxvd2luZz0laicsIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyk7XG4gIGlmIChmYWxzZSAhPT0gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3BhdXNlJyk7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgdGhpcy5lbWl0KCdwYXVzZScpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gZmxvdyhzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBkZWJ1ZygnZmxvdycsIHN0YXRlLmZsb3dpbmcpO1xuICB3aGlsZSAoc3RhdGUuZmxvd2luZyAmJiBzdHJlYW0ucmVhZCgpICE9PSBudWxsKSB7fVxufVxuXG4vLyB3cmFwIGFuIG9sZC1zdHlsZSBzdHJlYW0gYXMgdGhlIGFzeW5jIGRhdGEgc291cmNlLlxuLy8gVGhpcyBpcyAqbm90KiBwYXJ0IG9mIHRoZSByZWFkYWJsZSBzdHJlYW0gaW50ZXJmYWNlLlxuLy8gSXQgaXMgYW4gdWdseSB1bmZvcnR1bmF0ZSBtZXNzIG9mIGhpc3RvcnkuXG5SZWFkYWJsZS5wcm90b3R5cGUud3JhcCA9IGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHBhdXNlZCA9IGZhbHNlO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgc3RyZWFtLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgZW5kJyk7XG4gICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIXN0YXRlLmVuZGVkKSB7XG4gICAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkgc2VsZi5wdXNoKGNodW5rKTtcbiAgICB9XG5cbiAgICBzZWxmLnB1c2gobnVsbCk7XG4gIH0pO1xuXG4gIHN0cmVhbS5vbignZGF0YScsIGZ1bmN0aW9uIChjaHVuaykge1xuICAgIGRlYnVnKCd3cmFwcGVkIGRhdGEnKTtcbiAgICBpZiAoc3RhdGUuZGVjb2RlcikgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcblxuICAgIC8vIGRvbid0IHNraXAgb3ZlciBmYWxzeSB2YWx1ZXMgaW4gb2JqZWN0TW9kZVxuICAgIGlmIChzdGF0ZS5vYmplY3RNb2RlICYmIChjaHVuayA9PT0gbnVsbCB8fCBjaHVuayA9PT0gdW5kZWZpbmVkKSkgcmV0dXJuO2Vsc2UgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmICghY2h1bmsgfHwgIWNodW5rLmxlbmd0aCkpIHJldHVybjtcblxuICAgIHZhciByZXQgPSBzZWxmLnB1c2goY2h1bmspO1xuICAgIGlmICghcmV0KSB7XG4gICAgICBwYXVzZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLnBhdXNlKCk7XG4gICAgfVxuICB9KTtcblxuICAvLyBwcm94eSBhbGwgdGhlIG90aGVyIG1ldGhvZHMuXG4gIC8vIGltcG9ydGFudCB3aGVuIHdyYXBwaW5nIGZpbHRlcnMgYW5kIGR1cGxleGVzLlxuICBmb3IgKHZhciBpIGluIHN0cmVhbSkge1xuICAgIGlmICh0aGlzW2ldID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIHN0cmVhbVtpXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpc1tpXSA9IGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gc3RyZWFtW21ldGhvZF0uYXBwbHkoc3RyZWFtLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgICAgfShpKTtcbiAgICB9XG4gIH1cblxuICAvLyBwcm94eSBjZXJ0YWluIGltcG9ydGFudCBldmVudHMuXG4gIHZhciBldmVudHMgPSBbJ2Vycm9yJywgJ2Nsb3NlJywgJ2Rlc3Ryb3knLCAncGF1c2UnLCAncmVzdW1lJ107XG4gIGZvckVhY2goZXZlbnRzLCBmdW5jdGlvbiAoZXYpIHtcbiAgICBzdHJlYW0ub24oZXYsIHNlbGYuZW1pdC5iaW5kKHNlbGYsIGV2KSk7XG4gIH0pO1xuXG4gIC8vIHdoZW4gd2UgdHJ5IHRvIGNvbnN1bWUgc29tZSBtb3JlIGJ5dGVzLCBzaW1wbHkgdW5wYXVzZSB0aGVcbiAgLy8gdW5kZXJseWluZyBzdHJlYW0uXG4gIHNlbGYuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICAgIGRlYnVnKCd3cmFwcGVkIF9yZWFkJywgbik7XG4gICAgaWYgKHBhdXNlZCkge1xuICAgICAgcGF1c2VkID0gZmFsc2U7XG4gICAgICBzdHJlYW0ucmVzdW1lKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBzZWxmO1xufTtcblxuLy8gZXhwb3NlZCBmb3IgdGVzdGluZyBwdXJwb3NlcyBvbmx5LlxuUmVhZGFibGUuX2Zyb21MaXN0ID0gZnJvbUxpc3Q7XG5cbi8vIFBsdWNrIG9mZiBuIGJ5dGVzIGZyb20gYW4gYXJyYXkgb2YgYnVmZmVycy5cbi8vIExlbmd0aCBpcyB0aGUgY29tYmluZWQgbGVuZ3RocyBvZiBhbGwgdGhlIGJ1ZmZlcnMgaW4gdGhlIGxpc3QuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGZyb21MaXN0KG4sIHN0YXRlKSB7XG4gIC8vIG5vdGhpbmcgYnVmZmVyZWRcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7XG5cbiAgdmFyIHJldDtcbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldCA9IHN0YXRlLmJ1ZmZlci5zaGlmdCgpO2Vsc2UgaWYgKCFuIHx8IG4gPj0gc3RhdGUubGVuZ3RoKSB7XG4gICAgLy8gcmVhZCBpdCBhbGwsIHRydW5jYXRlIHRoZSBsaXN0XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIHJldCA9IHN0YXRlLmJ1ZmZlci5qb2luKCcnKTtlbHNlIGlmIChzdGF0ZS5idWZmZXIubGVuZ3RoID09PSAxKSByZXQgPSBzdGF0ZS5idWZmZXIuaGVhZC5kYXRhO2Vsc2UgcmV0ID0gc3RhdGUuYnVmZmVyLmNvbmNhdChzdGF0ZS5sZW5ndGgpO1xuICAgIHN0YXRlLmJ1ZmZlci5jbGVhcigpO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlYWQgcGFydCBvZiBsaXN0XG4gICAgcmV0ID0gZnJvbUxpc3RQYXJ0aWFsKG4sIHN0YXRlLmJ1ZmZlciwgc3RhdGUuZGVjb2Rlcik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG4vLyBFeHRyYWN0cyBvbmx5IGVub3VnaCBidWZmZXJlZCBkYXRhIHRvIHNhdGlzZnkgdGhlIGFtb3VudCByZXF1ZXN0ZWQuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGZyb21MaXN0UGFydGlhbChuLCBsaXN0LCBoYXNTdHJpbmdzKSB7XG4gIHZhciByZXQ7XG4gIGlmIChuIDwgbGlzdC5oZWFkLmRhdGEubGVuZ3RoKSB7XG4gICAgLy8gc2xpY2UgaXMgdGhlIHNhbWUgZm9yIGJ1ZmZlcnMgYW5kIHN0cmluZ3NcbiAgICByZXQgPSBsaXN0LmhlYWQuZGF0YS5zbGljZSgwLCBuKTtcbiAgICBsaXN0LmhlYWQuZGF0YSA9IGxpc3QuaGVhZC5kYXRhLnNsaWNlKG4pO1xuICB9IGVsc2UgaWYgKG4gPT09IGxpc3QuaGVhZC5kYXRhLmxlbmd0aCkge1xuICAgIC8vIGZpcnN0IGNodW5rIGlzIGEgcGVyZmVjdCBtYXRjaFxuICAgIHJldCA9IGxpc3Quc2hpZnQoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyByZXN1bHQgc3BhbnMgbW9yZSB0aGFuIG9uZSBidWZmZXJcbiAgICByZXQgPSBoYXNTdHJpbmdzID8gY29weUZyb21CdWZmZXJTdHJpbmcobiwgbGlzdCkgOiBjb3B5RnJvbUJ1ZmZlcihuLCBsaXN0KTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG4vLyBDb3BpZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGNoYXJhY3RlcnMgZnJvbSB0aGUgbGlzdCBvZiBidWZmZXJlZCBkYXRhXG4vLyBjaHVua3MuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGNvcHlGcm9tQnVmZmVyU3RyaW5nKG4sIGxpc3QpIHtcbiAgdmFyIHAgPSBsaXN0LmhlYWQ7XG4gIHZhciBjID0gMTtcbiAgdmFyIHJldCA9IHAuZGF0YTtcbiAgbiAtPSByZXQubGVuZ3RoO1xuICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgIHZhciBzdHIgPSBwLmRhdGE7XG4gICAgdmFyIG5iID0gbiA+IHN0ci5sZW5ndGggPyBzdHIubGVuZ3RoIDogbjtcbiAgICBpZiAobmIgPT09IHN0ci5sZW5ndGgpIHJldCArPSBzdHI7ZWxzZSByZXQgKz0gc3RyLnNsaWNlKDAsIG4pO1xuICAgIG4gLT0gbmI7XG4gICAgaWYgKG4gPT09IDApIHtcbiAgICAgIGlmIChuYiA9PT0gc3RyLmxlbmd0aCkge1xuICAgICAgICArK2M7XG4gICAgICAgIGlmIChwLm5leHQpIGxpc3QuaGVhZCA9IHAubmV4dDtlbHNlIGxpc3QuaGVhZCA9IGxpc3QudGFpbCA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaXN0LmhlYWQgPSBwO1xuICAgICAgICBwLmRhdGEgPSBzdHIuc2xpY2UobmIpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgICsrYztcbiAgfVxuICBsaXN0Lmxlbmd0aCAtPSBjO1xuICByZXR1cm4gcmV0O1xufVxuXG4vLyBDb3BpZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGJ5dGVzIGZyb20gdGhlIGxpc3Qgb2YgYnVmZmVyZWQgZGF0YSBjaHVua3MuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGNvcHlGcm9tQnVmZmVyKG4sIGxpc3QpIHtcbiAgdmFyIHJldCA9IGJ1ZmZlclNoaW0uYWxsb2NVbnNhZmUobik7XG4gIHZhciBwID0gbGlzdC5oZWFkO1xuICB2YXIgYyA9IDE7XG4gIHAuZGF0YS5jb3B5KHJldCk7XG4gIG4gLT0gcC5kYXRhLmxlbmd0aDtcbiAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICB2YXIgYnVmID0gcC5kYXRhO1xuICAgIHZhciBuYiA9IG4gPiBidWYubGVuZ3RoID8gYnVmLmxlbmd0aCA6IG47XG4gICAgYnVmLmNvcHkocmV0LCByZXQubGVuZ3RoIC0gbiwgMCwgbmIpO1xuICAgIG4gLT0gbmI7XG4gICAgaWYgKG4gPT09IDApIHtcbiAgICAgIGlmIChuYiA9PT0gYnVmLmxlbmd0aCkge1xuICAgICAgICArK2M7XG4gICAgICAgIGlmIChwLm5leHQpIGxpc3QuaGVhZCA9IHAubmV4dDtlbHNlIGxpc3QuaGVhZCA9IGxpc3QudGFpbCA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaXN0LmhlYWQgPSBwO1xuICAgICAgICBwLmRhdGEgPSBidWYuc2xpY2UobmIpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgICsrYztcbiAgfVxuICBsaXN0Lmxlbmd0aCAtPSBjO1xuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuXG4gIC8vIElmIHdlIGdldCBoZXJlIGJlZm9yZSBjb25zdW1pbmcgYWxsIHRoZSBieXRlcywgdGhlbiB0aGF0IGlzIGFcbiAgLy8gYnVnIGluIG5vZGUuICBTaG91bGQgbmV2ZXIgaGFwcGVuLlxuICBpZiAoc3RhdGUubGVuZ3RoID4gMCkgdGhyb3cgbmV3IEVycm9yKCdcImVuZFJlYWRhYmxlKClcIiBjYWxsZWQgb24gbm9uLWVtcHR5IHN0cmVhbScpO1xuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCkge1xuICAgIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbiAgICBwcm9jZXNzTmV4dFRpY2soZW5kUmVhZGFibGVOVCwgc3RhdGUsIHN0cmVhbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW5kUmVhZGFibGVOVChzdGF0ZSwgc3RyZWFtKSB7XG4gIC8vIENoZWNrIHRoYXQgd2UgZGlkbid0IGdldCBvbmUgbGFzdCB1bnNoaWZ0LlxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgc3RhdGUuZW5kRW1pdHRlZCA9IHRydWU7XG4gICAgc3RyZWFtLnJlYWRhYmxlID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2VuZCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZvckVhY2goeHMsIGYpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBmKHhzW2ldLCBpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbmRleE9mKHhzLCB4KSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKHhzW2ldID09PSB4KSByZXR1cm4gaTtcbiAgfVxuICByZXR1cm4gLTE7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9yZWFkYWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gMTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5pZiAoIXByb2Nlc3MudmVyc2lvbiB8fFxuICAgIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MC4nKSA9PT0gMCB8fFxuICAgIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MS4nKSA9PT0gMCAmJiBwcm9jZXNzLnZlcnNpb24uaW5kZXhPZigndjEuOC4nKSAhPT0gMCkge1xuICBtb2R1bGUuZXhwb3J0cyA9IG5leHRUaWNrO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBwcm9jZXNzLm5leHRUaWNrO1xufVxuXG5mdW5jdGlvbiBuZXh0VGljayhmbiwgYXJnMSwgYXJnMiwgYXJnMykge1xuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJjYWxsYmFja1wiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICB9XG4gIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgYXJncywgaTtcbiAgc3dpdGNoIChsZW4pIHtcbiAgY2FzZSAwOlxuICBjYXNlIDE6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZm4pO1xuICBjYXNlIDI6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrT25lKCkge1xuICAgICAgZm4uY2FsbChudWxsLCBhcmcxKTtcbiAgICB9KTtcbiAgY2FzZSAzOlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGlja1R3bygpIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSwgYXJnMik7XG4gICAgfSk7XG4gIGNhc2UgNDpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2tUaHJlZSgpIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSwgYXJnMiwgYXJnMyk7XG4gICAgfSk7XG4gIGRlZmF1bHQ6XG4gICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTtcbiAgICBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGFyZ3MubGVuZ3RoKSB7XG4gICAgICBhcmdzW2krK10gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGljaygpIHtcbiAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH0pO1xuICB9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcHJvY2Vzcy1uZXh0aWNrLWFyZ3MvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2lzYXJyYXkvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDE2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxudmFyIGJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpO1xudmFyIEJ1ZmZlciA9IGJ1ZmZlci5CdWZmZXI7XG52YXIgU2xvd0J1ZmZlciA9IGJ1ZmZlci5TbG93QnVmZmVyO1xudmFyIE1BWF9MRU4gPSBidWZmZXIua01heExlbmd0aCB8fCAyMTQ3NDgzNjQ3O1xuZXhwb3J0cy5hbGxvYyA9IGZ1bmN0aW9uIGFsbG9jKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgQnVmZmVyLmFsbG9jID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYyhzaXplLCBmaWxsLCBlbmNvZGluZyk7XG4gIH1cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IG5vdCBiZSBudW1iZXInKTtcbiAgfVxuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignc2l6ZSBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gIH1cbiAgaWYgKHNpemUgPiBNQVhfTEVOKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NpemUgaXMgdG9vIGxhcmdlJyk7XG4gIH1cbiAgdmFyIGVuYyA9IGVuY29kaW5nO1xuICB2YXIgX2ZpbGwgPSBmaWxsO1xuICBpZiAoX2ZpbGwgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuYyA9IHVuZGVmaW5lZDtcbiAgICBfZmlsbCA9IDA7XG4gIH1cbiAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIoc2l6ZSk7XG4gIGlmICh0eXBlb2YgX2ZpbGwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIGZpbGxCdWYgPSBuZXcgQnVmZmVyKF9maWxsLCBlbmMpO1xuICAgIHZhciBmbGVuID0gZmlsbEJ1Zi5sZW5ndGg7XG4gICAgdmFyIGkgPSAtMTtcbiAgICB3aGlsZSAoKytpIDwgc2l6ZSkge1xuICAgICAgYnVmW2ldID0gZmlsbEJ1ZltpICUgZmxlbl07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGJ1Zi5maWxsKF9maWxsKTtcbiAgfVxuICByZXR1cm4gYnVmO1xufVxuZXhwb3J0cy5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIGFsbG9jVW5zYWZlKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBCdWZmZXIuYWxsb2NVbnNhZmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jVW5zYWZlKHNpemUpO1xuICB9XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdzaXplIG11c3QgYmUgYSBudW1iZXInKTtcbiAgfVxuICBpZiAoc2l6ZSA+IE1BWF9MRU4pIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc2l6ZSBpcyB0b28gbGFyZ2UnKTtcbiAgfVxuICByZXR1cm4gbmV3IEJ1ZmZlcihzaXplKTtcbn1cbmV4cG9ydHMuZnJvbSA9IGZ1bmN0aW9uIGZyb20odmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIEJ1ZmZlci5mcm9tID09PSAnZnVuY3Rpb24nICYmICghZ2xvYmFsLlVpbnQ4QXJyYXkgfHwgVWludDhBcnJheS5mcm9tICE9PSBCdWZmZXIuZnJvbSkpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20odmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCk7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KTtcbiAgfVxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgdmFyIG9mZnNldCA9IGVuY29kaW5nT3JPZmZzZXQ7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiBuZXcgQnVmZmVyKHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cbiAgICB2YXIgbGVuID0gbGVuZ3RoO1xuICAgIGlmICh0eXBlb2YgbGVuID09PSAndW5kZWZpbmVkJykge1xuICAgICAgbGVuID0gdmFsdWUuYnl0ZUxlbmd0aCAtIG9mZnNldDtcbiAgICB9XG4gICAgaWYgKG9mZnNldCA+PSB2YWx1ZS5ieXRlTGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnb2Zmc2V0XFwnIGlzIG91dCBvZiBib3VuZHMnKTtcbiAgICB9XG4gICAgaWYgKGxlbiA+IHZhbHVlLmJ5dGVMZW5ndGggLSBvZmZzZXQpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdsZW5ndGhcXCcgaXMgb3V0IG9mIGJvdW5kcycpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEJ1ZmZlcih2YWx1ZS5zbGljZShvZmZzZXQsIG9mZnNldCArIGxlbikpO1xuICB9XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgdmFyIG91dCA9IG5ldyBCdWZmZXIodmFsdWUubGVuZ3RoKTtcbiAgICB2YWx1ZS5jb3B5KG91dCwgMCwgMCwgdmFsdWUubGVuZ3RoKTtcbiAgICByZXR1cm4gb3V0O1xuICB9XG4gIGlmICh2YWx1ZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSB8fCAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB2YWx1ZS5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgfHwgJ2xlbmd0aCcgaW4gdmFsdWUpIHtcbiAgICAgIHJldHVybiBuZXcgQnVmZmVyKHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlLnR5cGUgPT09ICdCdWZmZXInICYmIEFycmF5LmlzQXJyYXkodmFsdWUuZGF0YSkpIHtcbiAgICAgIHJldHVybiBuZXcgQnVmZmVyKHZhbHVlLmRhdGEpO1xuICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcsIEJ1ZmZlciwgJyArICdBcnJheUJ1ZmZlciwgQXJyYXksIG9yIGFycmF5LWxpa2Ugb2JqZWN0LicpO1xufVxuZXhwb3J0cy5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiBhbGxvY1Vuc2FmZVNsb3coc2l6ZSkge1xuICBpZiAodHlwZW9mIEJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyhzaXplKTtcbiAgfVxuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignc2l6ZSBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gIH1cbiAgaWYgKHNpemUgPj0gTUFYX0xFTikge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdzaXplIGlzIHRvbyBsYXJnZScpO1xuICB9XG4gIHJldHVybiBuZXcgU2xvd0J1ZmZlcihzaXplKTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9idWZmZXItc2hpbXMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBOT1RFOiBUaGVzZSB0eXBlIGNoZWNraW5nIGZ1bmN0aW9ucyBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBgaW5zdGFuY2VvZmBcbi8vIGJlY2F1c2UgaXQgaXMgZnJhZ2lsZSBhbmQgY2FuIGJlIGVhc2lseSBmYWtlZCB3aXRoIGBPYmplY3QuY3JlYXRlKClgLlxuXG5mdW5jdGlvbiBpc0FycmF5KGFyZykge1xuICBpZiAoQXJyYXkuaXNBcnJheSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KGFyZyk7XG4gIH1cbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKGFyZykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuXG5mdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbic7XG59XG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcblxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGwgPSBpc051bGw7XG5cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XG59XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5cbmZ1bmN0aW9uIGlzU3ltYm9sKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7XG59XG5leHBvcnRzLmlzU3ltYm9sID0gaXNTeW1ib2w7XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5leHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcblxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gIHJldHVybiAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcbn1cbmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGwgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7XG59XG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XG5cbmV4cG9ydHMuaXNCdWZmZXIgPSBCdWZmZXIuaXNCdWZmZXI7XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLXV0aWwtaXMvbGliL3V0aWwuanNcbi8vIG1vZHVsZSBpZCA9IDE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIChpZ25vcmVkKSAqL1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIHV0aWwgKGlnbm9yZWQpXG4vLyBtb2R1bGUgaWQgPSAxOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGJ1ZmZlclNoaW0gPSByZXF1aXJlKCdidWZmZXItc2hpbXMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJ1ZmZlckxpc3Q7XG5cbmZ1bmN0aW9uIEJ1ZmZlckxpc3QoKSB7XG4gIHRoaXMuaGVhZCA9IG51bGw7XG4gIHRoaXMudGFpbCA9IG51bGw7XG4gIHRoaXMubGVuZ3RoID0gMDtcbn1cblxuQnVmZmVyTGlzdC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uICh2KSB7XG4gIHZhciBlbnRyeSA9IHsgZGF0YTogdiwgbmV4dDogbnVsbCB9O1xuICBpZiAodGhpcy5sZW5ndGggPiAwKSB0aGlzLnRhaWwubmV4dCA9IGVudHJ5O2Vsc2UgdGhpcy5oZWFkID0gZW50cnk7XG4gIHRoaXMudGFpbCA9IGVudHJ5O1xuICArK3RoaXMubGVuZ3RoO1xufTtcblxuQnVmZmVyTGlzdC5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uICh2KSB7XG4gIHZhciBlbnRyeSA9IHsgZGF0YTogdiwgbmV4dDogdGhpcy5oZWFkIH07XG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgdGhpcy50YWlsID0gZW50cnk7XG4gIHRoaXMuaGVhZCA9IGVudHJ5O1xuICArK3RoaXMubGVuZ3RoO1xufTtcblxuQnVmZmVyTGlzdC5wcm90b3R5cGUuc2hpZnQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICB2YXIgcmV0ID0gdGhpcy5oZWFkLmRhdGE7XG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMSkgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtlbHNlIHRoaXMuaGVhZCA9IHRoaXMuaGVhZC5uZXh0O1xuICAtLXRoaXMubGVuZ3RoO1xuICByZXR1cm4gcmV0O1xufTtcblxuQnVmZmVyTGlzdC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7XG4gIHRoaXMubGVuZ3RoID0gMDtcbn07XG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLmpvaW4gPSBmdW5jdGlvbiAocykge1xuICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiAnJztcbiAgdmFyIHAgPSB0aGlzLmhlYWQ7XG4gIHZhciByZXQgPSAnJyArIHAuZGF0YTtcbiAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICByZXQgKz0gcyArIHAuZGF0YTtcbiAgfXJldHVybiByZXQ7XG59O1xuXG5CdWZmZXJMaXN0LnByb3RvdHlwZS5jb25jYXQgPSBmdW5jdGlvbiAobikge1xuICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiBidWZmZXJTaGltLmFsbG9jKDApO1xuICBpZiAodGhpcy5sZW5ndGggPT09IDEpIHJldHVybiB0aGlzLmhlYWQuZGF0YTtcbiAgdmFyIHJldCA9IGJ1ZmZlclNoaW0uYWxsb2NVbnNhZmUobiA+Pj4gMCk7XG4gIHZhciBwID0gdGhpcy5oZWFkO1xuICB2YXIgaSA9IDA7XG4gIHdoaWxlIChwKSB7XG4gICAgcC5kYXRhLmNvcHkocmV0LCBpKTtcbiAgICBpICs9IHAuZGF0YS5sZW5ndGg7XG4gICAgcCA9IHAubmV4dDtcbiAgfVxuICByZXR1cm4gcmV0O1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL0J1ZmZlckxpc3QuanNcbi8vIG1vZHVsZSBpZCA9IDIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGEgZHVwbGV4IHN0cmVhbSBpcyBqdXN0IGEgc3RyZWFtIHRoYXQgaXMgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUuXG4vLyBTaW5jZSBKUyBkb2Vzbid0IGhhdmUgbXVsdGlwbGUgcHJvdG90eXBhbCBpbmhlcml0YW5jZSwgdGhpcyBjbGFzc1xuLy8gcHJvdG90eXBhbGx5IGluaGVyaXRzIGZyb20gUmVhZGFibGUsIGFuZCB0aGVuIHBhcmFzaXRpY2FsbHkgZnJvbVxuLy8gV3JpdGFibGUuXG5cbid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBrZXlzLnB1c2goa2V5KTtcbiAgfXJldHVybiBrZXlzO1xufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IER1cGxleDtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBwcm9jZXNzTmV4dFRpY2sgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIFJlYWRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3JlYWRhYmxlJyk7XG52YXIgV3JpdGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fd3JpdGFibGUnKTtcblxudXRpbC5pbmhlcml0cyhEdXBsZXgsIFJlYWRhYmxlKTtcblxudmFyIGtleXMgPSBvYmplY3RLZXlzKFdyaXRhYmxlLnByb3RvdHlwZSk7XG5mb3IgKHZhciB2ID0gMDsgdiA8IGtleXMubGVuZ3RoOyB2KyspIHtcbiAgdmFyIG1ldGhvZCA9IGtleXNbdl07XG4gIGlmICghRHVwbGV4LnByb3RvdHlwZVttZXRob2RdKSBEdXBsZXgucHJvdG90eXBlW21ldGhvZF0gPSBXcml0YWJsZS5wcm90b3R5cGVbbWV0aG9kXTtcbn1cblxuZnVuY3Rpb24gRHVwbGV4KG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpIHJldHVybiBuZXcgRHVwbGV4KG9wdGlvbnMpO1xuXG4gIFJlYWRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIFdyaXRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5yZWFkYWJsZSA9PT0gZmFsc2UpIHRoaXMucmVhZGFibGUgPSBmYWxzZTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLndyaXRhYmxlID09PSBmYWxzZSkgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuXG4gIHRoaXMuYWxsb3dIYWxmT3BlbiA9IHRydWU7XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuYWxsb3dIYWxmT3BlbiA9PT0gZmFsc2UpIHRoaXMuYWxsb3dIYWxmT3BlbiA9IGZhbHNlO1xuXG4gIHRoaXMub25jZSgnZW5kJywgb25lbmQpO1xufVxuXG4vLyB0aGUgbm8taGFsZi1vcGVuIGVuZm9yY2VyXG5mdW5jdGlvbiBvbmVuZCgpIHtcbiAgLy8gaWYgd2UgYWxsb3cgaGFsZi1vcGVuIHN0YXRlLCBvciBpZiB0aGUgd3JpdGFibGUgc2lkZSBlbmRlZCxcbiAgLy8gdGhlbiB3ZSdyZSBvay5cbiAgaWYgKHRoaXMuYWxsb3dIYWxmT3BlbiB8fCB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkKSByZXR1cm47XG5cbiAgLy8gbm8gbW9yZSBkYXRhIGNhbiBiZSB3cml0dGVuLlxuICAvLyBCdXQgYWxsb3cgbW9yZSB3cml0ZXMgdG8gaGFwcGVuIGluIHRoaXMgdGljay5cbiAgcHJvY2Vzc05leHRUaWNrKG9uRW5kTlQsIHRoaXMpO1xufVxuXG5mdW5jdGlvbiBvbkVuZE5UKHNlbGYpIHtcbiAgc2VsZi5lbmQoKTtcbn1cblxuZnVuY3Rpb24gZm9yRWFjaCh4cywgZikge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGYoeHNbaV0sIGkpO1xuICB9XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9kdXBsZXguanNcbi8vIG1vZHVsZSBpZCA9IDIxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIEEgYml0IHNpbXBsZXIgdGhhbiByZWFkYWJsZSBzdHJlYW1zLlxuLy8gSW1wbGVtZW50IGFuIGFzeW5jIC5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYiksIGFuZCBpdCdsbCBoYW5kbGUgYWxsXG4vLyB0aGUgZHJhaW4gZXZlbnQgZW1pc3Npb24gYW5kIGJ1ZmZlcmluZy5cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdyaXRhYmxlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHByb2Nlc3NOZXh0VGljayA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBhc3luY1dyaXRlID0gIXByb2Nlc3MuYnJvd3NlciAmJiBbJ3YwLjEwJywgJ3YwLjkuJ10uaW5kZXhPZihwcm9jZXNzLnZlcnNpb24uc2xpY2UoMCwgNSkpID4gLTEgPyBzZXRJbW1lZGlhdGUgOiBwcm9jZXNzTmV4dFRpY2s7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBEdXBsZXg7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuV3JpdGFibGUuV3JpdGFibGVTdGF0ZSA9IFdyaXRhYmxlU3RhdGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBpbnRlcm5hbFV0aWwgPSB7XG4gIGRlcHJlY2F0ZTogcmVxdWlyZSgndXRpbC1kZXByZWNhdGUnKVxufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIFN0cmVhbTtcbihmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgU3RyZWFtID0gcmVxdWlyZSgnc3QnICsgJ3JlYW0nKTtcbiAgfSBjYXRjaCAoXykge30gZmluYWxseSB7XG4gICAgaWYgKCFTdHJlYW0pIFN0cmVhbSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbiAgfVxufSkoKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBidWZmZXJTaGltID0gcmVxdWlyZSgnYnVmZmVyLXNoaW1zJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudXRpbC5pbmhlcml0cyhXcml0YWJsZSwgU3RyZWFtKTtcblxuZnVuY3Rpb24gbm9wKCkge31cblxuZnVuY3Rpb24gV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aGlzLmNodW5rID0gY2h1bms7XG4gIHRoaXMuZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgdGhpcy5jYWxsYmFjayA9IGNiO1xuICB0aGlzLm5leHQgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZyB0byBpbmRpY2F0ZSB3aGV0aGVyIG9yIG5vdCB0aGlzIHN0cmVhbVxuICAvLyBjb250YWlucyBidWZmZXJzIG9yIG9iamVjdHMuXG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuXG4gIGlmIChzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMud3JpdGFibGVPYmplY3RNb2RlO1xuXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCB3cml0ZSgpIHN0YXJ0cyByZXR1cm5pbmcgZmFsc2VcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyB0aGF0IHdlIGFsd2F5cyByZXR1cm4gZmFsc2UgaWZcbiAgLy8gdGhlIGVudGlyZSBidWZmZXIgaXMgbm90IGZsdXNoZWQgaW1tZWRpYXRlbHkgb24gd3JpdGUoKVxuICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB2YXIgZGVmYXVsdEh3bSA9IHRoaXMub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0O1xuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBod20gfHwgaHdtID09PSAwID8gaHdtIDogZGVmYXVsdEh3bTtcblxuICAvLyBjYXN0IHRvIGludHMuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IH5+dGhpcy5oaWdoV2F0ZXJNYXJrO1xuXG4gIC8vIGRyYWluIGV2ZW50IGZsYWcuXG4gIHRoaXMubmVlZERyYWluID0gZmFsc2U7XG4gIC8vIGF0IHRoZSBzdGFydCBvZiBjYWxsaW5nIGVuZCgpXG4gIHRoaXMuZW5kaW5nID0gZmFsc2U7XG4gIC8vIHdoZW4gZW5kKCkgaGFzIGJlZW4gY2FsbGVkLCBhbmQgcmV0dXJuZWRcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICAvLyB3aGVuICdmaW5pc2gnIGlzIGVtaXR0ZWRcbiAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuXG4gIC8vIHNob3VsZCB3ZSBkZWNvZGUgc3RyaW5ncyBpbnRvIGJ1ZmZlcnMgYmVmb3JlIHBhc3NpbmcgdG8gX3dyaXRlP1xuICAvLyB0aGlzIGlzIGhlcmUgc28gdGhhdCBzb21lIG5vZGUtY29yZSBzdHJlYW1zIGNhbiBvcHRpbWl6ZSBzdHJpbmdcbiAgLy8gaGFuZGxpbmcgYXQgYSBsb3dlciBsZXZlbC5cbiAgdmFyIG5vRGVjb2RlID0gb3B0aW9ucy5kZWNvZGVTdHJpbmdzID09PSBmYWxzZTtcbiAgdGhpcy5kZWNvZGVTdHJpbmdzID0gIW5vRGVjb2RlO1xuXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIG5vdCBhbiBhY3R1YWwgYnVmZmVyIHdlIGtlZXAgdHJhY2sgb2YsIGJ1dCBhIG1lYXN1cmVtZW50XG4gIC8vIG9mIGhvdyBtdWNoIHdlJ3JlIHdhaXRpbmcgdG8gZ2V0IHB1c2hlZCB0byBzb21lIHVuZGVybHlpbmdcbiAgLy8gc29ja2V0IG9yIGZpbGUuXG4gIHRoaXMubGVuZ3RoID0gMDtcblxuICAvLyBhIGZsYWcgdG8gc2VlIHdoZW4gd2UncmUgaW4gdGhlIG1pZGRsZSBvZiBhIHdyaXRlLlxuICB0aGlzLndyaXRpbmcgPSBmYWxzZTtcblxuICAvLyB3aGVuIHRydWUgYWxsIHdyaXRlcyB3aWxsIGJlIGJ1ZmZlcmVkIHVudGlsIC51bmNvcmsoKSBjYWxsXG4gIHRoaXMuY29ya2VkID0gMDtcblxuICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBvbndyaXRlIGNiIGlzIGNhbGxlZCBpbW1lZGlhdGVseSxcbiAgLy8gb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZSBhbnlcbiAgLy8gYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3Qgd3JpdGUgY2FsbC5cbiAgdGhpcy5zeW5jID0gdHJ1ZTtcblxuICAvLyBhIGZsYWcgdG8ga25vdyBpZiB3ZSdyZSBwcm9jZXNzaW5nIHByZXZpb3VzbHkgYnVmZmVyZWQgaXRlbXMsIHdoaWNoXG4gIC8vIG1heSBjYWxsIHRoZSBfd3JpdGUoKSBjYWxsYmFjayBpbiB0aGUgc2FtZSB0aWNrLCBzbyB0aGF0IHdlIGRvbid0XG4gIC8vIGVuZCB1cCBpbiBhbiBvdmVybGFwcGVkIG9ud3JpdGUgc2l0dWF0aW9uLlxuICB0aGlzLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcblxuICAvLyB0aGUgY2FsbGJhY2sgdGhhdCdzIHBhc3NlZCB0byBfd3JpdGUoY2h1bmssY2IpXG4gIHRoaXMub253cml0ZSA9IGZ1bmN0aW9uIChlcikge1xuICAgIG9ud3JpdGUoc3RyZWFtLCBlcik7XG4gIH07XG5cbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQgdGhlIHVzZXIgc3VwcGxpZXMgdG8gd3JpdGUoY2h1bmssZW5jb2RpbmcsY2IpXG4gIHRoaXMud3JpdGVjYiA9IG51bGw7XG5cbiAgLy8gdGhlIGFtb3VudCB0aGF0IGlzIGJlaW5nIHdyaXR0ZW4gd2hlbiBfd3JpdGUgaXMgY2FsbGVkLlxuICB0aGlzLndyaXRlbGVuID0gMDtcblxuICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gIHRoaXMubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG5cbiAgLy8gbnVtYmVyIG9mIHBlbmRpbmcgdXNlci1zdXBwbGllZCB3cml0ZSBjYWxsYmFja3NcbiAgLy8gdGhpcyBtdXN0IGJlIDAgYmVmb3JlICdmaW5pc2gnIGNhbiBiZSBlbWl0dGVkXG4gIHRoaXMucGVuZGluZ2NiID0gMDtcblxuICAvLyBlbWl0IHByZWZpbmlzaCBpZiB0aGUgb25seSB0aGluZyB3ZSdyZSB3YWl0aW5nIGZvciBpcyBfd3JpdGUgY2JzXG4gIC8vIFRoaXMgaXMgcmVsZXZhbnQgZm9yIHN5bmNocm9ub3VzIFRyYW5zZm9ybSBzdHJlYW1zXG4gIHRoaXMucHJlZmluaXNoZWQgPSBmYWxzZTtcblxuICAvLyBUcnVlIGlmIHRoZSBlcnJvciB3YXMgYWxyZWFkeSBlbWl0dGVkIGFuZCBzaG91bGQgbm90IGJlIHRocm93biBhZ2FpblxuICB0aGlzLmVycm9yRW1pdHRlZCA9IGZhbHNlO1xuXG4gIC8vIGNvdW50IGJ1ZmZlcmVkIHJlcXVlc3RzXG4gIHRoaXMuYnVmZmVyZWRSZXF1ZXN0Q291bnQgPSAwO1xuXG4gIC8vIGFsbG9jYXRlIHRoZSBmaXJzdCBDb3JrZWRSZXF1ZXN0LCB0aGVyZSBpcyBhbHdheXNcbiAgLy8gb25lIGFsbG9jYXRlZCBhbmQgZnJlZSB0byB1c2UsIGFuZCB3ZSBtYWludGFpbiBhdCBtb3N0IHR3b1xuICB0aGlzLmNvcmtlZFJlcXVlc3RzRnJlZSA9IG5ldyBDb3JrZWRSZXF1ZXN0KHRoaXMpO1xufVxuXG5Xcml0YWJsZVN0YXRlLnByb3RvdHlwZS5nZXRCdWZmZXIgPSBmdW5jdGlvbiBnZXRCdWZmZXIoKSB7XG4gIHZhciBjdXJyZW50ID0gdGhpcy5idWZmZXJlZFJlcXVlc3Q7XG4gIHZhciBvdXQgPSBbXTtcbiAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICBvdXQucHVzaChjdXJyZW50KTtcbiAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICB9XG4gIHJldHVybiBvdXQ7XG59O1xuXG4oZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZVN0YXRlLnByb3RvdHlwZSwgJ2J1ZmZlcicsIHtcbiAgICAgIGdldDogaW50ZXJuYWxVdGlsLmRlcHJlY2F0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEJ1ZmZlcigpO1xuICAgICAgfSwgJ193cml0YWJsZVN0YXRlLmJ1ZmZlciBpcyBkZXByZWNhdGVkLiBVc2UgX3dyaXRhYmxlU3RhdGUuZ2V0QnVmZmVyICcgKyAnaW5zdGVhZC4nKVxuICAgIH0pO1xuICB9IGNhdGNoIChfKSB7fVxufSkoKTtcblxuLy8gVGVzdCBfd3JpdGFibGVTdGF0ZSBmb3IgaW5oZXJpdGFuY2UgdG8gYWNjb3VudCBmb3IgRHVwbGV4IHN0cmVhbXMsXG4vLyB3aG9zZSBwcm90b3R5cGUgY2hhaW4gb25seSBwb2ludHMgdG8gUmVhZGFibGUuXG52YXIgcmVhbEhhc0luc3RhbmNlO1xuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmhhc0luc3RhbmNlICYmIHR5cGVvZiBGdW5jdGlvbi5wcm90b3R5cGVbU3ltYm9sLmhhc0luc3RhbmNlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICByZWFsSGFzSW5zdGFuY2UgPSBGdW5jdGlvbi5wcm90b3R5cGVbU3ltYm9sLmhhc0luc3RhbmNlXTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLCBTeW1ib2wuaGFzSW5zdGFuY2UsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgaWYgKHJlYWxIYXNJbnN0YW5jZS5jYWxsKHRoaXMsIG9iamVjdCkpIHJldHVybiB0cnVlO1xuXG4gICAgICByZXR1cm4gb2JqZWN0ICYmIG9iamVjdC5fd3JpdGFibGVTdGF0ZSBpbnN0YW5jZW9mIFdyaXRhYmxlU3RhdGU7XG4gICAgfVxuICB9KTtcbn0gZWxzZSB7XG4gIHJlYWxIYXNJbnN0YW5jZSA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0IGluc3RhbmNlb2YgdGhpcztcbiAgfTtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGUob3B0aW9ucykge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIC8vIFdyaXRhYmxlIGN0b3IgaXMgYXBwbGllZCB0byBEdXBsZXhlcywgdG9vLlxuICAvLyBgcmVhbEhhc0luc3RhbmNlYCBpcyBuZWNlc3NhcnkgYmVjYXVzZSB1c2luZyBwbGFpbiBgaW5zdGFuY2VvZmBcbiAgLy8gd291bGQgcmV0dXJuIGZhbHNlLCBhcyBubyBgX3dyaXRhYmxlU3RhdGVgIHByb3BlcnR5IGlzIGF0dGFjaGVkLlxuXG4gIC8vIFRyeWluZyB0byB1c2UgdGhlIGN1c3RvbSBgaW5zdGFuY2VvZmAgZm9yIFdyaXRhYmxlIGhlcmUgd2lsbCBhbHNvIGJyZWFrIHRoZVxuICAvLyBOb2RlLmpzIExhenlUcmFuc2Zvcm0gaW1wbGVtZW50YXRpb24sIHdoaWNoIGhhcyBhIG5vbi10cml2aWFsIGdldHRlciBmb3JcbiAgLy8gYF93cml0YWJsZVN0YXRlYCB0aGF0IHdvdWxkIGxlYWQgdG8gaW5maW5pdGUgcmVjdXJzaW9uLlxuICBpZiAoIXJlYWxIYXNJbnN0YW5jZS5jYWxsKFdyaXRhYmxlLCB0aGlzKSAmJiAhKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKSB7XG4gICAgcmV0dXJuIG5ldyBXcml0YWJsZShvcHRpb25zKTtcbiAgfVxuXG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUgPSBuZXcgV3JpdGFibGVTdGF0ZShvcHRpb25zLCB0aGlzKTtcblxuICAvLyBsZWdhY3kuXG4gIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRlID09PSAnZnVuY3Rpb24nKSB0aGlzLl93cml0ZSA9IG9wdGlvbnMud3JpdGU7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JpdGV2ID09PSAnZnVuY3Rpb24nKSB0aGlzLl93cml0ZXYgPSBvcHRpb25zLndyaXRldjtcbiAgfVxuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufVxuXG4vLyBPdGhlcndpc2UgcGVvcGxlIGNhbiBwaXBlIFdyaXRhYmxlIHN0cmVhbXMsIHdoaWNoIGlzIGp1c3Qgd3JvbmcuXG5Xcml0YWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignQ2Fubm90IHBpcGUsIG5vdCByZWFkYWJsZScpKTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlQWZ0ZXJFbmQoc3RyZWFtLCBjYikge1xuICB2YXIgZXIgPSBuZXcgRXJyb3IoJ3dyaXRlIGFmdGVyIGVuZCcpO1xuICAvLyBUT0RPOiBkZWZlciBlcnJvciBldmVudHMgY29uc2lzdGVudGx5IGV2ZXJ5d2hlcmUsIG5vdCBqdXN0IHRoZSBjYlxuICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gIHByb2Nlc3NOZXh0VGljayhjYiwgZXIpO1xufVxuXG4vLyBDaGVja3MgdGhhdCBhIHVzZXItc3VwcGxpZWQgY2h1bmsgaXMgdmFsaWQsIGVzcGVjaWFsbHkgZm9yIHRoZSBwYXJ0aWN1bGFyXG4vLyBtb2RlIHRoZSBzdHJlYW0gaXMgaW4uIEN1cnJlbnRseSB0aGlzIG1lYW5zIHRoYXQgYG51bGxgIGlzIG5ldmVyIGFjY2VwdGVkXG4vLyBhbmQgdW5kZWZpbmVkL25vbi1zdHJpbmcgdmFsdWVzIGFyZSBvbmx5IGFsbG93ZWQgaW4gb2JqZWN0IG1vZGUuXG5mdW5jdGlvbiB2YWxpZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBjYikge1xuICB2YXIgdmFsaWQgPSB0cnVlO1xuICB2YXIgZXIgPSBmYWxzZTtcblxuICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ01heSBub3Qgd3JpdGUgbnVsbCB2YWx1ZXMgdG8gc3RyZWFtJyk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiBjaHVuayAhPT0gdW5kZWZpbmVkICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XG4gIH1cbiAgaWYgKGVyKSB7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgIHByb2Nlc3NOZXh0VGljayhjYiwgZXIpO1xuICAgIHZhbGlkID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHZhbGlkO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuICB2YXIgcmV0ID0gZmFsc2U7XG4gIHZhciBpc0J1ZiA9IEJ1ZmZlci5pc0J1ZmZlcihjaHVuayk7XG5cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKGlzQnVmKSBlbmNvZGluZyA9ICdidWZmZXInO2Vsc2UgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG5cbiAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykgY2IgPSBub3A7XG5cbiAgaWYgKHN0YXRlLmVuZGVkKSB3cml0ZUFmdGVyRW5kKHRoaXMsIGNiKTtlbHNlIGlmIChpc0J1ZiB8fCB2YWxpZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgY2IpKSB7XG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgcmV0ID0gd3JpdGVPckJ1ZmZlcih0aGlzLCBzdGF0ZSwgaXNCdWYsIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5jb3JrID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIHN0YXRlLmNvcmtlZCsrO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLnVuY29yayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkLS07XG5cbiAgICBpZiAoIXN0YXRlLndyaXRpbmcgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuZmluaXNoZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSBjbGVhckJ1ZmZlcih0aGlzLCBzdGF0ZSk7XG4gIH1cbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5zZXREZWZhdWx0RW5jb2RpbmcgPSBmdW5jdGlvbiBzZXREZWZhdWx0RW5jb2RpbmcoZW5jb2RpbmcpIHtcbiAgLy8gbm9kZTo6UGFyc2VFbmNvZGluZygpIHJlcXVpcmVzIGxvd2VyIGNhc2UuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSBlbmNvZGluZyA9IGVuY29kaW5nLnRvTG93ZXJDYXNlKCk7XG4gIGlmICghKFsnaGV4JywgJ3V0ZjgnLCAndXRmLTgnLCAnYXNjaWknLCAnYmluYXJ5JywgJ2Jhc2U2NCcsICd1Y3MyJywgJ3Vjcy0yJywgJ3V0ZjE2bGUnLCAndXRmLTE2bGUnLCAncmF3J10uaW5kZXhPZigoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKSkgPiAtMSkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZyk7XG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVmYXVsdEVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZykge1xuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgc3RhdGUuZGVjb2RlU3RyaW5ncyAhPT0gZmFsc2UgJiYgdHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgIGNodW5rID0gYnVmZmVyU2hpbS5mcm9tKGNodW5rLCBlbmNvZGluZyk7XG4gIH1cbiAgcmV0dXJuIGNodW5rO1xufVxuXG4vLyBpZiB3ZSdyZSBhbHJlYWR5IHdyaXRpbmcgc29tZXRoaW5nLCB0aGVuIGp1c3QgcHV0IHRoaXNcbi8vIGluIHRoZSBxdWV1ZSwgYW5kIHdhaXQgb3VyIHR1cm4uICBPdGhlcndpc2UsIGNhbGwgX3dyaXRlXG4vLyBJZiB3ZSByZXR1cm4gZmFsc2UsIHRoZW4gd2UgbmVlZCBhIGRyYWluIGV2ZW50LCBzbyBzZXQgdGhhdCBmbGFnLlxuZnVuY3Rpb24gd3JpdGVPckJ1ZmZlcihzdHJlYW0sIHN0YXRlLCBpc0J1ZiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBpZiAoIWlzQnVmKSB7XG4gICAgY2h1bmsgPSBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKTtcbiAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKGNodW5rKSkgZW5jb2RpbmcgPSAnYnVmZmVyJztcbiAgfVxuICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgc3RhdGUubGVuZ3RoICs9IGxlbjtcblxuICB2YXIgcmV0ID0gc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgLy8gd2UgbXVzdCBlbnN1cmUgdGhhdCBwcmV2aW91cyBuZWVkRHJhaW4gd2lsbCBub3QgYmUgcmVzZXQgdG8gZmFsc2UuXG4gIGlmICghcmV0KSBzdGF0ZS5uZWVkRHJhaW4gPSB0cnVlO1xuXG4gIGlmIChzdGF0ZS53cml0aW5nIHx8IHN0YXRlLmNvcmtlZCkge1xuICAgIHZhciBsYXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbmV3IFdyaXRlUmVxKGNodW5rLCBlbmNvZGluZywgY2IpO1xuICAgIGlmIChsYXN0KSB7XG4gICAgICBsYXN0Lm5leHQgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIH1cbiAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudCArPSAxO1xuICB9IGVsc2Uge1xuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHdyaXRldiwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHN0YXRlLndyaXRlbGVuID0gbGVuO1xuICBzdGF0ZS53cml0ZWNiID0gY2I7XG4gIHN0YXRlLndyaXRpbmcgPSB0cnVlO1xuICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgaWYgKHdyaXRldikgc3RyZWFtLl93cml0ZXYoY2h1bmssIHN0YXRlLm9ud3JpdGUpO2Vsc2Ugc3RyZWFtLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIHN0YXRlLm9ud3JpdGUpO1xuICBzdGF0ZS5zeW5jID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpIHtcbiAgLS1zdGF0ZS5wZW5kaW5nY2I7XG4gIGlmIChzeW5jKSBwcm9jZXNzTmV4dFRpY2soY2IsIGVyKTtlbHNlIGNiKGVyKTtcblxuICBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpIHtcbiAgc3RhdGUud3JpdGluZyA9IGZhbHNlO1xuICBzdGF0ZS53cml0ZWNiID0gbnVsbDtcbiAgc3RhdGUubGVuZ3RoIC09IHN0YXRlLndyaXRlbGVuO1xuICBzdGF0ZS53cml0ZWxlbiA9IDA7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGUoc3RyZWFtLCBlcikge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG4gIHZhciBzeW5jID0gc3RhdGUuc3luYztcbiAgdmFyIGNiID0gc3RhdGUud3JpdGVjYjtcblxuICBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpO1xuXG4gIGlmIChlcikgb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYik7ZWxzZSB7XG4gICAgLy8gQ2hlY2sgaWYgd2UncmUgYWN0dWFsbHkgcmVhZHkgdG8gZmluaXNoLCBidXQgZG9uJ3QgZW1pdCB5ZXRcbiAgICB2YXIgZmluaXNoZWQgPSBuZWVkRmluaXNoKHN0YXRlKTtcblxuICAgIGlmICghZmluaXNoZWQgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpIHtcbiAgICAgIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cblxuICAgIGlmIChzeW5jKSB7XG4gICAgICAvKjxyZXBsYWNlbWVudD4qL1xuICAgICAgYXN5bmNXcml0ZShhZnRlcldyaXRlLCBzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgICAgLyo8L3JlcGxhY2VtZW50PiovXG4gICAgfSBlbHNlIHtcbiAgICAgIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpIHtcbiAgaWYgKCFmaW5pc2hlZCkgb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpO1xuICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgY2IoKTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG59XG5cbi8vIE11c3QgZm9yY2UgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIG9uIG5leHRUaWNrLCBzbyB0aGF0IHdlIGRvbid0XG4vLyBlbWl0ICdkcmFpbicgYmVmb3JlIHRoZSB3cml0ZSgpIGNvbnN1bWVyIGdldHMgdGhlICdmYWxzZScgcmV0dXJuXG4vLyB2YWx1ZSwgYW5kIGhhcyBhIGNoYW5jZSB0byBhdHRhY2ggYSAnZHJhaW4nIGxpc3RlbmVyLlxuZnVuY3Rpb24gb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5uZWVkRHJhaW4pIHtcbiAgICBzdGF0ZS5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZHJhaW4nKTtcbiAgfVxufVxuXG4vLyBpZiB0aGVyZSdzIHNvbWV0aGluZyBpbiB0aGUgYnVmZmVyIHdhaXRpbmcsIHRoZW4gcHJvY2VzcyBpdFxuZnVuY3Rpb24gY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSkge1xuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gdHJ1ZTtcbiAgdmFyIGVudHJ5ID0gc3RhdGUuYnVmZmVyZWRSZXF1ZXN0O1xuXG4gIGlmIChzdHJlYW0uX3dyaXRldiAmJiBlbnRyeSAmJiBlbnRyeS5uZXh0KSB7XG4gICAgLy8gRmFzdCBjYXNlLCB3cml0ZSBldmVyeXRoaW5nIHVzaW5nIF93cml0ZXYoKVxuICAgIHZhciBsID0gc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQ7XG4gICAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheShsKTtcbiAgICB2YXIgaG9sZGVyID0gc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlO1xuICAgIGhvbGRlci5lbnRyeSA9IGVudHJ5O1xuXG4gICAgdmFyIGNvdW50ID0gMDtcbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIGJ1ZmZlcltjb3VudF0gPSBlbnRyeTtcbiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICAgIGNvdW50ICs9IDE7XG4gICAgfVxuXG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB0cnVlLCBzdGF0ZS5sZW5ndGgsIGJ1ZmZlciwgJycsIGhvbGRlci5maW5pc2gpO1xuXG4gICAgLy8gZG9Xcml0ZSBpcyBhbG1vc3QgYWx3YXlzIGFzeW5jLCBkZWZlciB0aGVzZSB0byBzYXZlIGEgYml0IG9mIHRpbWVcbiAgICAvLyBhcyB0aGUgaG90IHBhdGggZW5kcyB3aXRoIGRvV3JpdGVcbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgICBpZiAoaG9sZGVyLm5leHQpIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IGhvbGRlci5uZXh0O1xuICAgICAgaG9sZGVyLm5leHQgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBuZXcgQ29ya2VkUmVxdWVzdChzdGF0ZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFNsb3cgY2FzZSwgd3JpdGUgY2h1bmtzIG9uZS1ieS1vbmVcbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIHZhciBjaHVuayA9IGVudHJ5LmNodW5rO1xuICAgICAgdmFyIGVuY29kaW5nID0gZW50cnkuZW5jb2Rpbmc7XG4gICAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjaztcbiAgICAgIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcblxuICAgICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICAgIC8vIGlmIHdlIGRpZG4ndCBjYWxsIHRoZSBvbndyaXRlIGltbWVkaWF0ZWx5LCB0aGVuXG4gICAgICAvLyBpdCBtZWFucyB0aGF0IHdlIG5lZWQgdG8gd2FpdCB1bnRpbCBpdCBkb2VzLlxuICAgICAgLy8gYWxzbywgdGhhdCBtZWFucyB0aGF0IHRoZSBjaHVuayBhbmQgY2IgYXJlIGN1cnJlbnRseVxuICAgICAgLy8gYmVpbmcgcHJvY2Vzc2VkLCBzbyBtb3ZlIHRoZSBidWZmZXIgY291bnRlciBwYXN0IHRoZW0uXG4gICAgICBpZiAoc3RhdGUud3JpdGluZykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZW50cnkgPT09IG51bGwpIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICB9XG5cbiAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQgPSAwO1xuICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBlbnRyeTtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobmV3IEVycm9yKCdfd3JpdGUoKSBpcyBub3QgaW1wbGVtZW50ZWQnKSk7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRldiA9IG51bGw7XG5cbldyaXRhYmxlLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmICh0eXBlb2YgY2h1bmsgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGNodW5rO1xuICAgIGNodW5rID0gbnVsbDtcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAoY2h1bmsgIT09IG51bGwgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCkgdGhpcy53cml0ZShjaHVuaywgZW5jb2RpbmcpO1xuXG4gIC8vIC5lbmQoKSBmdWxseSB1bmNvcmtzXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcbiAgICBzdGF0ZS5jb3JrZWQgPSAxO1xuICAgIHRoaXMudW5jb3JrKCk7XG4gIH1cblxuICAvLyBpZ25vcmUgdW5uZWNlc3NhcnkgZW5kKCkgY2FsbHMuXG4gIGlmICghc3RhdGUuZW5kaW5nICYmICFzdGF0ZS5maW5pc2hlZCkgZW5kV3JpdGFibGUodGhpcywgc3RhdGUsIGNiKTtcbn07XG5cbmZ1bmN0aW9uIG5lZWRGaW5pc2goc3RhdGUpIHtcbiAgcmV0dXJuIHN0YXRlLmVuZGluZyAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID09PSBudWxsICYmICFzdGF0ZS5maW5pc2hlZCAmJiAhc3RhdGUud3JpdGluZztcbn1cblxuZnVuY3Rpb24gcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5wcmVmaW5pc2hlZCkge1xuICAgIHN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0uZW1pdCgncHJlZmluaXNoJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbmVlZCA9IG5lZWRGaW5pc2goc3RhdGUpO1xuICBpZiAobmVlZCkge1xuICAgIGlmIChzdGF0ZS5wZW5kaW5nY2IgPT09IDApIHtcbiAgICAgIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKTtcbiAgICAgIHN0YXRlLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5lbWl0KCdmaW5pc2gnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmVlZDtcbn1cblxuZnVuY3Rpb24gZW5kV3JpdGFibGUoc3RyZWFtLCBzdGF0ZSwgY2IpIHtcbiAgc3RhdGUuZW5kaW5nID0gdHJ1ZTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIGlmIChjYikge1xuICAgIGlmIChzdGF0ZS5maW5pc2hlZCkgcHJvY2Vzc05leHRUaWNrKGNiKTtlbHNlIHN0cmVhbS5vbmNlKCdmaW5pc2gnLCBjYik7XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICBzdHJlYW0ud3JpdGFibGUgPSBmYWxzZTtcbn1cblxuLy8gSXQgc2VlbXMgYSBsaW5rZWQgbGlzdCBidXQgaXQgaXMgbm90XG4vLyB0aGVyZSB3aWxsIGJlIG9ubHkgMiBvZiB0aGVzZSBmb3IgZWFjaCBzdHJlYW1cbmZ1bmN0aW9uIENvcmtlZFJlcXVlc3Qoc3RhdGUpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB0aGlzLm5leHQgPSBudWxsO1xuICB0aGlzLmVudHJ5ID0gbnVsbDtcbiAgdGhpcy5maW5pc2ggPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgdmFyIGVudHJ5ID0gX3RoaXMuZW50cnk7XG4gICAgX3RoaXMuZW50cnkgPSBudWxsO1xuICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgICAgIGNiKGVycik7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUpIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZS5uZXh0ID0gX3RoaXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IF90aGlzO1xuICAgIH1cbiAgfTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSAyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBkZXByZWNhdGU7XG5cbi8qKlxuICogTWFyayB0aGF0IGEgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZC5cbiAqIFJldHVybnMgYSBtb2RpZmllZCBmdW5jdGlvbiB3aGljaCB3YXJucyBvbmNlIGJ5IGRlZmF1bHQuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS5ub0RlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS50aHJvd0RlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGRlcHJlY2F0ZWQgZnVuY3Rpb25zXG4gKiB3aWxsIHRocm93IGFuIEVycm9yIHdoZW4gaW52b2tlZC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLnRyYWNlRGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gZGVwcmVjYXRlZCBmdW5jdGlvbnNcbiAqIHdpbGwgaW52b2tlIGBjb25zb2xlLnRyYWNlKClgIGluc3RlYWQgb2YgYGNvbnNvbGUuZXJyb3IoKWAuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSB0aGUgZnVuY3Rpb24gdG8gZGVwcmVjYXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gbXNnIC0gdGhlIHN0cmluZyB0byBwcmludCB0byB0aGUgY29uc29sZSB3aGVuIGBmbmAgaXMgaW52b2tlZFxuICogQHJldHVybnMge0Z1bmN0aW9ufSBhIG5ldyBcImRlcHJlY2F0ZWRcIiB2ZXJzaW9uIG9mIGBmbmBcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGVwcmVjYXRlIChmbiwgbXNnKSB7XG4gIGlmIChjb25maWcoJ25vRGVwcmVjYXRpb24nKSkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgaWYgKGNvbmZpZygndGhyb3dEZXByZWNhdGlvbicpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfSBlbHNlIGlmIChjb25maWcoJ3RyYWNlRGVwcmVjYXRpb24nKSkge1xuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4obXNnKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGBsb2NhbFN0b3JhZ2VgIGZvciBib29sZWFuIHZhbHVlcyBmb3IgdGhlIGdpdmVuIGBuYW1lYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjb25maWcgKG5hbWUpIHtcbiAgLy8gYWNjZXNzaW5nIGdsb2JhbC5sb2NhbFN0b3JhZ2UgY2FuIHRyaWdnZXIgYSBET01FeGNlcHRpb24gaW4gc2FuZGJveGVkIGlmcmFtZXNcbiAgdHJ5IHtcbiAgICBpZiAoIWdsb2JhbC5sb2NhbFN0b3JhZ2UpIHJldHVybiBmYWxzZTtcbiAgfSBjYXRjaCAoXykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdmFsID0gZ2xvYmFsLmxvY2FsU3RvcmFnZVtuYW1lXTtcbiAgaWYgKG51bGwgPT0gdmFsKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBTdHJpbmcodmFsKS50b0xvd2VyQ2FzZSgpID09PSAndHJ1ZSc7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdXRpbC1kZXByZWNhdGUvYnJvd3Nlci5qc1xuLy8gbW9kdWxlIGlkID0gMjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG5cbnZhciBpc0J1ZmZlckVuY29kaW5nID0gQnVmZmVyLmlzRW5jb2RpbmdcbiAgfHwgZnVuY3Rpb24oZW5jb2RpbmcpIHtcbiAgICAgICBzd2l0Y2ggKGVuY29kaW5nICYmIGVuY29kaW5nLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgIGNhc2UgJ2hleCc6IGNhc2UgJ3V0ZjgnOiBjYXNlICd1dGYtOCc6IGNhc2UgJ2FzY2lpJzogY2FzZSAnYmluYXJ5JzogY2FzZSAnYmFzZTY0JzogY2FzZSAndWNzMic6IGNhc2UgJ3Vjcy0yJzogY2FzZSAndXRmMTZsZSc6IGNhc2UgJ3V0Zi0xNmxlJzogY2FzZSAncmF3JzogcmV0dXJuIHRydWU7XG4gICAgICAgICBkZWZhdWx0OiByZXR1cm4gZmFsc2U7XG4gICAgICAgfVxuICAgICB9XG5cblxuZnVuY3Rpb24gYXNzZXJ0RW5jb2RpbmcoZW5jb2RpbmcpIHtcbiAgaWYgKGVuY29kaW5nICYmICFpc0J1ZmZlckVuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKTtcbiAgfVxufVxuXG4vLyBTdHJpbmdEZWNvZGVyIHByb3ZpZGVzIGFuIGludGVyZmFjZSBmb3IgZWZmaWNpZW50bHkgc3BsaXR0aW5nIGEgc2VyaWVzIG9mXG4vLyBidWZmZXJzIGludG8gYSBzZXJpZXMgb2YgSlMgc3RyaW5ncyB3aXRob3V0IGJyZWFraW5nIGFwYXJ0IG11bHRpLWJ5dGVcbi8vIGNoYXJhY3RlcnMuIENFU1UtOCBpcyBoYW5kbGVkIGFzIHBhcnQgb2YgdGhlIFVURi04IGVuY29kaW5nLlxuLy9cbi8vIEBUT0RPIEhhbmRsaW5nIGFsbCBlbmNvZGluZ3MgaW5zaWRlIGEgc2luZ2xlIG9iamVjdCBtYWtlcyBpdCB2ZXJ5IGRpZmZpY3VsdFxuLy8gdG8gcmVhc29uIGFib3V0IHRoaXMgY29kZSwgc28gaXQgc2hvdWxkIGJlIHNwbGl0IHVwIGluIHRoZSBmdXR1cmUuXG4vLyBAVE9ETyBUaGVyZSBzaG91bGQgYmUgYSB1dGY4LXN0cmljdCBlbmNvZGluZyB0aGF0IHJlamVjdHMgaW52YWxpZCBVVEYtOCBjb2RlXG4vLyBwb2ludHMgYXMgdXNlZCBieSBDRVNVLTguXG52YXIgU3RyaW5nRGVjb2RlciA9IGV4cG9ydHMuU3RyaW5nRGVjb2RlciA9IGZ1bmN0aW9uKGVuY29kaW5nKSB7XG4gIHRoaXMuZW5jb2RpbmcgPSAoZW5jb2RpbmcgfHwgJ3V0ZjgnKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1stX10vLCAnJyk7XG4gIGFzc2VydEVuY29kaW5nKGVuY29kaW5nKTtcbiAgc3dpdGNoICh0aGlzLmVuY29kaW5nKSB7XG4gICAgY2FzZSAndXRmOCc6XG4gICAgICAvLyBDRVNVLTggcmVwcmVzZW50cyBlYWNoIG9mIFN1cnJvZ2F0ZSBQYWlyIGJ5IDMtYnl0ZXNcbiAgICAgIHRoaXMuc3Vycm9nYXRlU2l6ZSA9IDM7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIC8vIFVURi0xNiByZXByZXNlbnRzIGVhY2ggb2YgU3Vycm9nYXRlIFBhaXIgYnkgMi1ieXRlc1xuICAgICAgdGhpcy5zdXJyb2dhdGVTaXplID0gMjtcbiAgICAgIHRoaXMuZGV0ZWN0SW5jb21wbGV0ZUNoYXIgPSB1dGYxNkRldGVjdEluY29tcGxldGVDaGFyO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIC8vIEJhc2UtNjQgc3RvcmVzIDMgYnl0ZXMgaW4gNCBjaGFycywgYW5kIHBhZHMgdGhlIHJlbWFpbmRlci5cbiAgICAgIHRoaXMuc3Vycm9nYXRlU2l6ZSA9IDM7XG4gICAgICB0aGlzLmRldGVjdEluY29tcGxldGVDaGFyID0gYmFzZTY0RGV0ZWN0SW5jb21wbGV0ZUNoYXI7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhpcy53cml0ZSA9IHBhc3NUaHJvdWdoV3JpdGU7XG4gICAgICByZXR1cm47XG4gIH1cblxuICAvLyBFbm91Z2ggc3BhY2UgdG8gc3RvcmUgYWxsIGJ5dGVzIG9mIGEgc2luZ2xlIGNoYXJhY3Rlci4gVVRGLTggbmVlZHMgNFxuICAvLyBieXRlcywgYnV0IENFU1UtOCBtYXkgcmVxdWlyZSB1cCB0byA2ICgzIGJ5dGVzIHBlciBzdXJyb2dhdGUpLlxuICB0aGlzLmNoYXJCdWZmZXIgPSBuZXcgQnVmZmVyKDYpO1xuICAvLyBOdW1iZXIgb2YgYnl0ZXMgcmVjZWl2ZWQgZm9yIHRoZSBjdXJyZW50IGluY29tcGxldGUgbXVsdGktYnl0ZSBjaGFyYWN0ZXIuXG4gIHRoaXMuY2hhclJlY2VpdmVkID0gMDtcbiAgLy8gTnVtYmVyIG9mIGJ5dGVzIGV4cGVjdGVkIGZvciB0aGUgY3VycmVudCBpbmNvbXBsZXRlIG11bHRpLWJ5dGUgY2hhcmFjdGVyLlxuICB0aGlzLmNoYXJMZW5ndGggPSAwO1xufTtcblxuXG4vLyB3cml0ZSBkZWNvZGVzIHRoZSBnaXZlbiBidWZmZXIgYW5kIHJldHVybnMgaXQgYXMgSlMgc3RyaW5nIHRoYXQgaXNcbi8vIGd1YXJhbnRlZWQgdG8gbm90IGNvbnRhaW4gYW55IHBhcnRpYWwgbXVsdGktYnl0ZSBjaGFyYWN0ZXJzLiBBbnkgcGFydGlhbFxuLy8gY2hhcmFjdGVyIGZvdW5kIGF0IHRoZSBlbmQgb2YgdGhlIGJ1ZmZlciBpcyBidWZmZXJlZCB1cCwgYW5kIHdpbGwgYmVcbi8vIHJldHVybmVkIHdoZW4gY2FsbGluZyB3cml0ZSBhZ2FpbiB3aXRoIHRoZSByZW1haW5pbmcgYnl0ZXMuXG4vL1xuLy8gTm90ZTogQ29udmVydGluZyBhIEJ1ZmZlciBjb250YWluaW5nIGFuIG9ycGhhbiBzdXJyb2dhdGUgdG8gYSBTdHJpbmdcbi8vIGN1cnJlbnRseSB3b3JrcywgYnV0IGNvbnZlcnRpbmcgYSBTdHJpbmcgdG8gYSBCdWZmZXIgKHZpYSBgbmV3IEJ1ZmZlcmAsIG9yXG4vLyBCdWZmZXIjd3JpdGUpIHdpbGwgcmVwbGFjZSBpbmNvbXBsZXRlIHN1cnJvZ2F0ZXMgd2l0aCB0aGUgdW5pY29kZVxuLy8gcmVwbGFjZW1lbnQgY2hhcmFjdGVyLiBTZWUgaHR0cHM6Ly9jb2RlcmV2aWV3LmNocm9taXVtLm9yZy8xMjExNzMwMDkvIC5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gIHZhciBjaGFyU3RyID0gJyc7XG4gIC8vIGlmIG91ciBsYXN0IHdyaXRlIGVuZGVkIHdpdGggYW4gaW5jb21wbGV0ZSBtdWx0aWJ5dGUgY2hhcmFjdGVyXG4gIHdoaWxlICh0aGlzLmNoYXJMZW5ndGgpIHtcbiAgICAvLyBkZXRlcm1pbmUgaG93IG1hbnkgcmVtYWluaW5nIGJ5dGVzIHRoaXMgYnVmZmVyIGhhcyB0byBvZmZlciBmb3IgdGhpcyBjaGFyXG4gICAgdmFyIGF2YWlsYWJsZSA9IChidWZmZXIubGVuZ3RoID49IHRoaXMuY2hhckxlbmd0aCAtIHRoaXMuY2hhclJlY2VpdmVkKSA/XG4gICAgICAgIHRoaXMuY2hhckxlbmd0aCAtIHRoaXMuY2hhclJlY2VpdmVkIDpcbiAgICAgICAgYnVmZmVyLmxlbmd0aDtcblxuICAgIC8vIGFkZCB0aGUgbmV3IGJ5dGVzIHRvIHRoZSBjaGFyIGJ1ZmZlclxuICAgIGJ1ZmZlci5jb3B5KHRoaXMuY2hhckJ1ZmZlciwgdGhpcy5jaGFyUmVjZWl2ZWQsIDAsIGF2YWlsYWJsZSk7XG4gICAgdGhpcy5jaGFyUmVjZWl2ZWQgKz0gYXZhaWxhYmxlO1xuXG4gICAgaWYgKHRoaXMuY2hhclJlY2VpdmVkIDwgdGhpcy5jaGFyTGVuZ3RoKSB7XG4gICAgICAvLyBzdGlsbCBub3QgZW5vdWdoIGNoYXJzIGluIHRoaXMgYnVmZmVyPyB3YWl0IGZvciBtb3JlIC4uLlxuICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIC8vIHJlbW92ZSBieXRlcyBiZWxvbmdpbmcgdG8gdGhlIGN1cnJlbnQgY2hhcmFjdGVyIGZyb20gdGhlIGJ1ZmZlclxuICAgIGJ1ZmZlciA9IGJ1ZmZlci5zbGljZShhdmFpbGFibGUsIGJ1ZmZlci5sZW5ndGgpO1xuXG4gICAgLy8gZ2V0IHRoZSBjaGFyYWN0ZXIgdGhhdCB3YXMgc3BsaXRcbiAgICBjaGFyU3RyID0gdGhpcy5jaGFyQnVmZmVyLnNsaWNlKDAsIHRoaXMuY2hhckxlbmd0aCkudG9TdHJpbmcodGhpcy5lbmNvZGluZyk7XG5cbiAgICAvLyBDRVNVLTg6IGxlYWQgc3Vycm9nYXRlIChEODAwLURCRkYpIGlzIGFsc28gdGhlIGluY29tcGxldGUgY2hhcmFjdGVyXG4gICAgdmFyIGNoYXJDb2RlID0gY2hhclN0ci5jaGFyQ29kZUF0KGNoYXJTdHIubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGNoYXJDb2RlID49IDB4RDgwMCAmJiBjaGFyQ29kZSA8PSAweERCRkYpIHtcbiAgICAgIHRoaXMuY2hhckxlbmd0aCArPSB0aGlzLnN1cnJvZ2F0ZVNpemU7XG4gICAgICBjaGFyU3RyID0gJyc7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdGhpcy5jaGFyUmVjZWl2ZWQgPSB0aGlzLmNoYXJMZW5ndGggPSAwO1xuXG4gICAgLy8gaWYgdGhlcmUgYXJlIG5vIG1vcmUgYnl0ZXMgaW4gdGhpcyBidWZmZXIsIGp1c3QgZW1pdCBvdXIgY2hhclxuICAgIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gY2hhclN0cjtcbiAgICB9XG4gICAgYnJlYWs7XG4gIH1cblxuICAvLyBkZXRlcm1pbmUgYW5kIHNldCBjaGFyTGVuZ3RoIC8gY2hhclJlY2VpdmVkXG4gIHRoaXMuZGV0ZWN0SW5jb21wbGV0ZUNoYXIoYnVmZmVyKTtcblxuICB2YXIgZW5kID0gYnVmZmVyLmxlbmd0aDtcbiAgaWYgKHRoaXMuY2hhckxlbmd0aCkge1xuICAgIC8vIGJ1ZmZlciB0aGUgaW5jb21wbGV0ZSBjaGFyYWN0ZXIgYnl0ZXMgd2UgZ290XG4gICAgYnVmZmVyLmNvcHkodGhpcy5jaGFyQnVmZmVyLCAwLCBidWZmZXIubGVuZ3RoIC0gdGhpcy5jaGFyUmVjZWl2ZWQsIGVuZCk7XG4gICAgZW5kIC09IHRoaXMuY2hhclJlY2VpdmVkO1xuICB9XG5cbiAgY2hhclN0ciArPSBidWZmZXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywgMCwgZW5kKTtcblxuICB2YXIgZW5kID0gY2hhclN0ci5sZW5ndGggLSAxO1xuICB2YXIgY2hhckNvZGUgPSBjaGFyU3RyLmNoYXJDb2RlQXQoZW5kKTtcbiAgLy8gQ0VTVS04OiBsZWFkIHN1cnJvZ2F0ZSAoRDgwMC1EQkZGKSBpcyBhbHNvIHRoZSBpbmNvbXBsZXRlIGNoYXJhY3RlclxuICBpZiAoY2hhckNvZGUgPj0gMHhEODAwICYmIGNoYXJDb2RlIDw9IDB4REJGRikge1xuICAgIHZhciBzaXplID0gdGhpcy5zdXJyb2dhdGVTaXplO1xuICAgIHRoaXMuY2hhckxlbmd0aCArPSBzaXplO1xuICAgIHRoaXMuY2hhclJlY2VpdmVkICs9IHNpemU7XG4gICAgdGhpcy5jaGFyQnVmZmVyLmNvcHkodGhpcy5jaGFyQnVmZmVyLCBzaXplLCAwLCBzaXplKTtcbiAgICBidWZmZXIuY29weSh0aGlzLmNoYXJCdWZmZXIsIDAsIDAsIHNpemUpO1xuICAgIHJldHVybiBjaGFyU3RyLnN1YnN0cmluZygwLCBlbmQpO1xuICB9XG5cbiAgLy8gb3IganVzdCBlbWl0IHRoZSBjaGFyU3RyXG4gIHJldHVybiBjaGFyU3RyO1xufTtcblxuLy8gZGV0ZWN0SW5jb21wbGV0ZUNoYXIgZGV0ZXJtaW5lcyBpZiB0aGVyZSBpcyBhbiBpbmNvbXBsZXRlIFVURi04IGNoYXJhY3RlciBhdFxuLy8gdGhlIGVuZCBvZiB0aGUgZ2l2ZW4gYnVmZmVyLiBJZiBzbywgaXQgc2V0cyB0aGlzLmNoYXJMZW5ndGggdG8gdGhlIGJ5dGVcbi8vIGxlbmd0aCB0aGF0IGNoYXJhY3RlciwgYW5kIHNldHMgdGhpcy5jaGFyUmVjZWl2ZWQgdG8gdGhlIG51bWJlciBvZiBieXRlc1xuLy8gdGhhdCBhcmUgYXZhaWxhYmxlIGZvciB0aGlzIGNoYXJhY3Rlci5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmRldGVjdEluY29tcGxldGVDaGFyID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gIC8vIGRldGVybWluZSBob3cgbWFueSBieXRlcyB3ZSBoYXZlIHRvIGNoZWNrIGF0IHRoZSBlbmQgb2YgdGhpcyBidWZmZXJcbiAgdmFyIGkgPSAoYnVmZmVyLmxlbmd0aCA+PSAzKSA/IDMgOiBidWZmZXIubGVuZ3RoO1xuXG4gIC8vIEZpZ3VyZSBvdXQgaWYgb25lIG9mIHRoZSBsYXN0IGkgYnl0ZXMgb2Ygb3VyIGJ1ZmZlciBhbm5vdW5jZXMgYW5cbiAgLy8gaW5jb21wbGV0ZSBjaGFyLlxuICBmb3IgKDsgaSA+IDA7IGktLSkge1xuICAgIHZhciBjID0gYnVmZmVyW2J1ZmZlci5sZW5ndGggLSBpXTtcblxuICAgIC8vIFNlZSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1VURi04I0Rlc2NyaXB0aW9uXG5cbiAgICAvLyAxMTBYWFhYWFxuICAgIGlmIChpID09IDEgJiYgYyA+PiA1ID09IDB4MDYpIHtcbiAgICAgIHRoaXMuY2hhckxlbmd0aCA9IDI7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyAxMTEwWFhYWFxuICAgIGlmIChpIDw9IDIgJiYgYyA+PiA0ID09IDB4MEUpIHtcbiAgICAgIHRoaXMuY2hhckxlbmd0aCA9IDM7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyAxMTExMFhYWFxuICAgIGlmIChpIDw9IDMgJiYgYyA+PiAzID09IDB4MUUpIHtcbiAgICAgIHRoaXMuY2hhckxlbmd0aCA9IDQ7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgdGhpcy5jaGFyUmVjZWl2ZWQgPSBpO1xufTtcblxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gIHZhciByZXMgPSAnJztcbiAgaWYgKGJ1ZmZlciAmJiBidWZmZXIubGVuZ3RoKVxuICAgIHJlcyA9IHRoaXMud3JpdGUoYnVmZmVyKTtcblxuICBpZiAodGhpcy5jaGFyUmVjZWl2ZWQpIHtcbiAgICB2YXIgY3IgPSB0aGlzLmNoYXJSZWNlaXZlZDtcbiAgICB2YXIgYnVmID0gdGhpcy5jaGFyQnVmZmVyO1xuICAgIHZhciBlbmMgPSB0aGlzLmVuY29kaW5nO1xuICAgIHJlcyArPSBidWYuc2xpY2UoMCwgY3IpLnRvU3RyaW5nKGVuYyk7XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblxuZnVuY3Rpb24gcGFzc1Rocm91Z2hXcml0ZShidWZmZXIpIHtcbiAgcmV0dXJuIGJ1ZmZlci50b1N0cmluZyh0aGlzLmVuY29kaW5nKTtcbn1cblxuZnVuY3Rpb24gdXRmMTZEZXRlY3RJbmNvbXBsZXRlQ2hhcihidWZmZXIpIHtcbiAgdGhpcy5jaGFyUmVjZWl2ZWQgPSBidWZmZXIubGVuZ3RoICUgMjtcbiAgdGhpcy5jaGFyTGVuZ3RoID0gdGhpcy5jaGFyUmVjZWl2ZWQgPyAyIDogMDtcbn1cblxuZnVuY3Rpb24gYmFzZTY0RGV0ZWN0SW5jb21wbGV0ZUNoYXIoYnVmZmVyKSB7XG4gIHRoaXMuY2hhclJlY2VpdmVkID0gYnVmZmVyLmxlbmd0aCAlIDM7XG4gIHRoaXMuY2hhckxlbmd0aCA9IHRoaXMuY2hhclJlY2VpdmVkID8gMyA6IDA7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc3RyaW5nX2RlY29kZXIvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGEgdHJhbnNmb3JtIHN0cmVhbSBpcyBhIHJlYWRhYmxlL3dyaXRhYmxlIHN0cmVhbSB3aGVyZSB5b3UgZG9cbi8vIHNvbWV0aGluZyB3aXRoIHRoZSBkYXRhLiAgU29tZXRpbWVzIGl0J3MgY2FsbGVkIGEgXCJmaWx0ZXJcIixcbi8vIGJ1dCB0aGF0J3Mgbm90IGEgZ3JlYXQgbmFtZSBmb3IgaXQsIHNpbmNlIHRoYXQgaW1wbGllcyBhIHRoaW5nIHdoZXJlXG4vLyBzb21lIGJpdHMgcGFzcyB0aHJvdWdoLCBhbmQgb3RoZXJzIGFyZSBzaW1wbHkgaWdub3JlZC4gIChUaGF0IHdvdWxkXG4vLyBiZSBhIHZhbGlkIGV4YW1wbGUgb2YgYSB0cmFuc2Zvcm0sIG9mIGNvdXJzZS4pXG4vL1xuLy8gV2hpbGUgdGhlIG91dHB1dCBpcyBjYXVzYWxseSByZWxhdGVkIHRvIHRoZSBpbnB1dCwgaXQncyBub3QgYVxuLy8gbmVjZXNzYXJpbHkgc3ltbWV0cmljIG9yIHN5bmNocm9ub3VzIHRyYW5zZm9ybWF0aW9uLiAgRm9yIGV4YW1wbGUsXG4vLyBhIHpsaWIgc3RyZWFtIG1pZ2h0IHRha2UgbXVsdGlwbGUgcGxhaW4tdGV4dCB3cml0ZXMoKSwgYW5kIHRoZW5cbi8vIGVtaXQgYSBzaW5nbGUgY29tcHJlc3NlZCBjaHVuayBzb21lIHRpbWUgaW4gdGhlIGZ1dHVyZS5cbi8vXG4vLyBIZXJlJ3MgaG93IHRoaXMgd29ya3M6XG4vL1xuLy8gVGhlIFRyYW5zZm9ybSBzdHJlYW0gaGFzIGFsbCB0aGUgYXNwZWN0cyBvZiB0aGUgcmVhZGFibGUgYW5kIHdyaXRhYmxlXG4vLyBzdHJlYW0gY2xhc3Nlcy4gIFdoZW4geW91IHdyaXRlKGNodW5rKSwgdGhhdCBjYWxscyBfd3JpdGUoY2h1bmssY2IpXG4vLyBpbnRlcm5hbGx5LCBhbmQgcmV0dXJucyBmYWxzZSBpZiB0aGVyZSdzIGEgbG90IG9mIHBlbmRpbmcgd3JpdGVzXG4vLyBidWZmZXJlZCB1cC4gIFdoZW4geW91IGNhbGwgcmVhZCgpLCB0aGF0IGNhbGxzIF9yZWFkKG4pIHVudGlsXG4vLyB0aGVyZSdzIGVub3VnaCBwZW5kaW5nIHJlYWRhYmxlIGRhdGEgYnVmZmVyZWQgdXAuXG4vL1xuLy8gSW4gYSB0cmFuc2Zvcm0gc3RyZWFtLCB0aGUgd3JpdHRlbiBkYXRhIGlzIHBsYWNlZCBpbiBhIGJ1ZmZlci4gIFdoZW5cbi8vIF9yZWFkKG4pIGlzIGNhbGxlZCwgaXQgdHJhbnNmb3JtcyB0aGUgcXVldWVkIHVwIGRhdGEsIGNhbGxpbmcgdGhlXG4vLyBidWZmZXJlZCBfd3JpdGUgY2IncyBhcyBpdCBjb25zdW1lcyBjaHVua3MuICBJZiBjb25zdW1pbmcgYSBzaW5nbGVcbi8vIHdyaXR0ZW4gY2h1bmsgd291bGQgcmVzdWx0IGluIG11bHRpcGxlIG91dHB1dCBjaHVua3MsIHRoZW4gdGhlIGZpcnN0XG4vLyBvdXRwdXR0ZWQgYml0IGNhbGxzIHRoZSByZWFkY2IsIGFuZCBzdWJzZXF1ZW50IGNodW5rcyBqdXN0IGdvIGludG9cbi8vIHRoZSByZWFkIGJ1ZmZlciwgYW5kIHdpbGwgY2F1c2UgaXQgdG8gZW1pdCAncmVhZGFibGUnIGlmIG5lY2Vzc2FyeS5cbi8vXG4vLyBUaGlzIHdheSwgYmFjay1wcmVzc3VyZSBpcyBhY3R1YWxseSBkZXRlcm1pbmVkIGJ5IHRoZSByZWFkaW5nIHNpZGUsXG4vLyBzaW5jZSBfcmVhZCBoYXMgdG8gYmUgY2FsbGVkIHRvIHN0YXJ0IHByb2Nlc3NpbmcgYSBuZXcgY2h1bmsuICBIb3dldmVyLFxuLy8gYSBwYXRob2xvZ2ljYWwgaW5mbGF0ZSB0eXBlIG9mIHRyYW5zZm9ybSBjYW4gY2F1c2UgZXhjZXNzaXZlIGJ1ZmZlcmluZ1xuLy8gaGVyZS4gIEZvciBleGFtcGxlLCBpbWFnaW5lIGEgc3RyZWFtIHdoZXJlIGV2ZXJ5IGJ5dGUgb2YgaW5wdXQgaXNcbi8vIGludGVycHJldGVkIGFzIGFuIGludGVnZXIgZnJvbSAwLTI1NSwgYW5kIHRoZW4gcmVzdWx0cyBpbiB0aGF0IG1hbnlcbi8vIGJ5dGVzIG9mIG91dHB1dC4gIFdyaXRpbmcgdGhlIDQgYnl0ZXMge2ZmLGZmLGZmLGZmfSB3b3VsZCByZXN1bHQgaW5cbi8vIDFrYiBvZiBkYXRhIGJlaW5nIG91dHB1dC4gIEluIHRoaXMgY2FzZSwgeW91IGNvdWxkIHdyaXRlIGEgdmVyeSBzbWFsbFxuLy8gYW1vdW50IG9mIGlucHV0LCBhbmQgZW5kIHVwIHdpdGggYSB2ZXJ5IGxhcmdlIGFtb3VudCBvZiBvdXRwdXQuICBJblxuLy8gc3VjaCBhIHBhdGhvbG9naWNhbCBpbmZsYXRpbmcgbWVjaGFuaXNtLCB0aGVyZSdkIGJlIG5vIHdheSB0byB0ZWxsXG4vLyB0aGUgc3lzdGVtIHRvIHN0b3AgZG9pbmcgdGhlIHRyYW5zZm9ybS4gIEEgc2luZ2xlIDRNQiB3cml0ZSBjb3VsZFxuLy8gY2F1c2UgdGhlIHN5c3RlbSB0byBydW4gb3V0IG9mIG1lbW9yeS5cbi8vXG4vLyBIb3dldmVyLCBldmVuIGluIHN1Y2ggYSBwYXRob2xvZ2ljYWwgY2FzZSwgb25seSBhIHNpbmdsZSB3cml0dGVuIGNodW5rXG4vLyB3b3VsZCBiZSBjb25zdW1lZCwgYW5kIHRoZW4gdGhlIHJlc3Qgd291bGQgd2FpdCAodW4tdHJhbnNmb3JtZWQpIHVudGlsXG4vLyB0aGUgcmVzdWx0cyBvZiB0aGUgcHJldmlvdXMgdHJhbnNmb3JtZWQgY2h1bmsgd2VyZSBjb25zdW1lZC5cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zZm9ybTtcblxudmFyIER1cGxleCA9IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG51dGlsLmluaGVyaXRzKFRyYW5zZm9ybSwgRHVwbGV4KTtcblxuZnVuY3Rpb24gVHJhbnNmb3JtU3RhdGUoc3RyZWFtKSB7XG4gIHRoaXMuYWZ0ZXJUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoZXIsIGRhdGEpIHtcbiAgICByZXR1cm4gYWZ0ZXJUcmFuc2Zvcm0oc3RyZWFtLCBlciwgZGF0YSk7XG4gIH07XG5cbiAgdGhpcy5uZWVkVHJhbnNmb3JtID0gZmFsc2U7XG4gIHRoaXMudHJhbnNmb3JtaW5nID0gZmFsc2U7XG4gIHRoaXMud3JpdGVjYiA9IG51bGw7XG4gIHRoaXMud3JpdGVjaHVuayA9IG51bGw7XG4gIHRoaXMud3JpdGVlbmNvZGluZyA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGFmdGVyVHJhbnNmb3JtKHN0cmVhbSwgZXIsIGRhdGEpIHtcbiAgdmFyIHRzID0gc3RyZWFtLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMudHJhbnNmb3JtaW5nID0gZmFsc2U7XG5cbiAgdmFyIGNiID0gdHMud3JpdGVjYjtcblxuICBpZiAoIWNiKSByZXR1cm4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdubyB3cml0ZWNiIGluIFRyYW5zZm9ybSBjbGFzcycpKTtcblxuICB0cy53cml0ZWNodW5rID0gbnVsbDtcbiAgdHMud3JpdGVjYiA9IG51bGw7XG5cbiAgaWYgKGRhdGEgIT09IG51bGwgJiYgZGF0YSAhPT0gdW5kZWZpbmVkKSBzdHJlYW0ucHVzaChkYXRhKTtcblxuICBjYihlcik7XG5cbiAgdmFyIHJzID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBycy5yZWFkaW5nID0gZmFsc2U7XG4gIGlmIChycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykge1xuICAgIHN0cmVhbS5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBUcmFuc2Zvcm0ob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVHJhbnNmb3JtKSkgcmV0dXJuIG5ldyBUcmFuc2Zvcm0ob3B0aW9ucyk7XG5cbiAgRHVwbGV4LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUgPSBuZXcgVHJhbnNmb3JtU3RhdGUodGhpcyk7XG5cbiAgdmFyIHN0cmVhbSA9IHRoaXM7XG5cbiAgLy8gc3RhcnQgb3V0IGFza2luZyBmb3IgYSByZWFkYWJsZSBldmVudCBvbmNlIGRhdGEgaXMgdHJhbnNmb3JtZWQuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcblxuICAvLyB3ZSBoYXZlIGltcGxlbWVudGVkIHRoZSBfcmVhZCBtZXRob2QsIGFuZCBkb25lIHRoZSBvdGhlciB0aGluZ3NcbiAgLy8gdGhhdCBSZWFkYWJsZSB3YW50cyBiZWZvcmUgdGhlIGZpcnN0IF9yZWFkIGNhbGwsIHNvIHVuc2V0IHRoZVxuICAvLyBzeW5jIGd1YXJkIGZsYWcuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuc3luYyA9IGZhbHNlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fdHJhbnNmb3JtID0gb3B0aW9ucy50cmFuc2Zvcm07XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmx1c2ggPT09ICdmdW5jdGlvbicpIHRoaXMuX2ZsdXNoID0gb3B0aW9ucy5mbHVzaDtcbiAgfVxuXG4gIC8vIFdoZW4gdGhlIHdyaXRhYmxlIHNpZGUgZmluaXNoZXMsIHRoZW4gZmx1c2ggb3V0IGFueXRoaW5nIHJlbWFpbmluZy5cbiAgdGhpcy5vbmNlKCdwcmVmaW5pc2gnLCBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLl9mbHVzaCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmx1c2goZnVuY3Rpb24gKGVyLCBkYXRhKSB7XG4gICAgICBkb25lKHN0cmVhbSwgZXIsIGRhdGEpO1xuICAgIH0pO2Vsc2UgZG9uZShzdHJlYW0pO1xuICB9KTtcbn1cblxuVHJhbnNmb3JtLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZykge1xuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZS5uZWVkVHJhbnNmb3JtID0gZmFsc2U7XG4gIHJldHVybiBEdXBsZXgucHJvdG90eXBlLnB1c2guY2FsbCh0aGlzLCBjaHVuaywgZW5jb2RpbmcpO1xufTtcblxuLy8gVGhpcyBpcyB0aGUgcGFydCB3aGVyZSB5b3UgZG8gc3R1ZmYhXG4vLyBvdmVycmlkZSB0aGlzIGZ1bmN0aW9uIGluIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyAnY2h1bmsnIGlzIGFuIGlucHV0IGNodW5rLlxuLy9cbi8vIENhbGwgYHB1c2gobmV3Q2h1bmspYCB0byBwYXNzIGFsb25nIHRyYW5zZm9ybWVkIG91dHB1dFxuLy8gdG8gdGhlIHJlYWRhYmxlIHNpZGUuICBZb3UgbWF5IGNhbGwgJ3B1c2gnIHplcm8gb3IgbW9yZSB0aW1lcy5cbi8vXG4vLyBDYWxsIGBjYihlcnIpYCB3aGVuIHlvdSBhcmUgZG9uZSB3aXRoIHRoaXMgY2h1bmsuICBJZiB5b3UgcGFzc1xuLy8gYW4gZXJyb3IsIHRoZW4gdGhhdCdsbCBwdXQgdGhlIGh1cnQgb24gdGhlIHdob2xlIG9wZXJhdGlvbi4gIElmIHlvdVxuLy8gbmV2ZXIgY2FsbCBjYigpLCB0aGVuIHlvdSdsbCBuZXZlciBnZXQgYW5vdGhlciBjaHVuay5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRocm93IG5ldyBFcnJvcignX3RyYW5zZm9ybSgpIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMud3JpdGVjYiA9IGNiO1xuICB0cy53cml0ZWNodW5rID0gY2h1bms7XG4gIHRzLndyaXRlZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgaWYgKCF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB2YXIgcnMgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICAgIGlmICh0cy5uZWVkVHJhbnNmb3JtIHx8IHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB0aGlzLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59O1xuXG4vLyBEb2Vzbid0IG1hdHRlciB3aGF0IHRoZSBhcmdzIGFyZSBoZXJlLlxuLy8gX3RyYW5zZm9ybSBkb2VzIGFsbCB0aGUgd29yay5cbi8vIFRoYXQgd2UgZ290IGhlcmUgbWVhbnMgdGhhdCB0aGUgcmVhZGFibGUgc2lkZSB3YW50cyBtb3JlIGRhdGEuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG5cbiAgaWYgKHRzLndyaXRlY2h1bmsgIT09IG51bGwgJiYgdHMud3JpdGVjYiAmJiAhdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdHMudHJhbnNmb3JtaW5nID0gdHJ1ZTtcbiAgICB0aGlzLl90cmFuc2Zvcm0odHMud3JpdGVjaHVuaywgdHMud3JpdGVlbmNvZGluZywgdHMuYWZ0ZXJUcmFuc2Zvcm0pO1xuICB9IGVsc2Uge1xuICAgIC8vIG1hcmsgdGhhdCB3ZSBuZWVkIGEgdHJhbnNmb3JtLCBzbyB0aGF0IGFueSBkYXRhIHRoYXQgY29tZXMgaW5cbiAgICAvLyB3aWxsIGdldCBwcm9jZXNzZWQsIG5vdyB0aGF0IHdlJ3ZlIGFza2VkIGZvciBpdC5cbiAgICB0cy5uZWVkVHJhbnNmb3JtID0gdHJ1ZTtcbiAgfVxufTtcblxuZnVuY3Rpb24gZG9uZShzdHJlYW0sIGVyLCBkYXRhKSB7XG4gIGlmIChlcikgcmV0dXJuIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcblxuICBpZiAoZGF0YSAhPT0gbnVsbCAmJiBkYXRhICE9PSB1bmRlZmluZWQpIHN0cmVhbS5wdXNoKGRhdGEpO1xuXG4gIC8vIGlmIHRoZXJlJ3Mgbm90aGluZyBpbiB0aGUgd3JpdGUgYnVmZmVyLCB0aGVuIHRoYXQgbWVhbnNcbiAgLy8gdGhhdCBub3RoaW5nIG1vcmUgd2lsbCBldmVyIGJlIHByb3ZpZGVkXG4gIHZhciB3cyA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHRzID0gc3RyZWFtLl90cmFuc2Zvcm1TdGF0ZTtcblxuICBpZiAod3MubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiB3cy5sZW5ndGggIT0gMCcpO1xuXG4gIGlmICh0cy50cmFuc2Zvcm1pbmcpIHRocm93IG5ldyBFcnJvcignQ2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHN0aWxsIHRyYW5zZm9ybWluZycpO1xuXG4gIHJldHVybiBzdHJlYW0ucHVzaChudWxsKTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qc1xuLy8gbW9kdWxlIGlkID0gMjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gYSBwYXNzdGhyb3VnaCBzdHJlYW0uXG4vLyBiYXNpY2FsbHkganVzdCB0aGUgbW9zdCBtaW5pbWFsIHNvcnQgb2YgVHJhbnNmb3JtIHN0cmVhbS5cbi8vIEV2ZXJ5IHdyaXR0ZW4gY2h1bmsgZ2V0cyBvdXRwdXQgYXMtaXMuXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBQYXNzVGhyb3VnaDtcblxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vX3N0cmVhbV90cmFuc2Zvcm0nKTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG51dGlsLmluaGVyaXRzKFBhc3NUaHJvdWdoLCBUcmFuc2Zvcm0pO1xuXG5mdW5jdGlvbiBQYXNzVGhyb3VnaChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQYXNzVGhyb3VnaCkpIHJldHVybiBuZXcgUGFzc1Rocm91Z2gob3B0aW9ucyk7XG5cbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgb3B0aW9ucyk7XG59XG5cblBhc3NUaHJvdWdoLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobnVsbCwgY2h1bmspO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzXG4vLyBtb2R1bGUgaWQgPSAyNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzXCIpXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVhZGFibGUtc3RyZWFtL3dyaXRhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSAyN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2xpYi9fc3RyZWFtX2R1cGxleC5qc1wiKVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlYWRhYmxlLXN0cmVhbS9kdXBsZXguanNcbi8vIG1vZHVsZSBpZCA9IDI4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzXCIpXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVhZGFibGUtc3RyZWFtL3RyYW5zZm9ybS5qc1xuLy8gbW9kdWxlIGlkID0gMjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qc1wiKVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlYWRhYmxlLXN0cmVhbS9wYXNzdGhyb3VnaC5qc1xuLy8gbW9kdWxlIGlkID0gMzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciB6bGliX2luZmxhdGUgPSByZXF1aXJlKCcuL3psaWIvaW5mbGF0ZScpO1xudmFyIHV0aWxzICAgICAgICA9IHJlcXVpcmUoJy4vdXRpbHMvY29tbW9uJyk7XG52YXIgc3RyaW5ncyAgICAgID0gcmVxdWlyZSgnLi91dGlscy9zdHJpbmdzJyk7XG52YXIgYyAgICAgICAgICAgID0gcmVxdWlyZSgnLi96bGliL2NvbnN0YW50cycpO1xudmFyIG1zZyAgICAgICAgICA9IHJlcXVpcmUoJy4vemxpYi9tZXNzYWdlcycpO1xudmFyIFpTdHJlYW0gICAgICA9IHJlcXVpcmUoJy4vemxpYi96c3RyZWFtJyk7XG52YXIgR1poZWFkZXIgICAgID0gcmVxdWlyZSgnLi96bGliL2d6aGVhZGVyJyk7XG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKlxuICogY2xhc3MgSW5mbGF0ZVxuICpcbiAqIEdlbmVyaWMgSlMtc3R5bGUgd3JhcHBlciBmb3IgemxpYiBjYWxscy4gSWYgeW91IGRvbid0IG5lZWRcbiAqIHN0cmVhbWluZyBiZWhhdmlvdXIgLSB1c2UgbW9yZSBzaW1wbGUgZnVuY3Rpb25zOiBbW2luZmxhdGVdXVxuICogYW5kIFtbaW5mbGF0ZVJhd11dLlxuICoqL1xuXG4vKiBpbnRlcm5hbFxuICogaW5mbGF0ZS5jaHVua3MgLT4gQXJyYXlcbiAqXG4gKiBDaHVua3Mgb2Ygb3V0cHV0IGRhdGEsIGlmIFtbSW5mbGF0ZSNvbkRhdGFdXSBub3Qgb3ZlcnJpZGVuLlxuICoqL1xuXG4vKipcbiAqIEluZmxhdGUucmVzdWx0IC0+IFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nXG4gKlxuICogVW5jb21wcmVzc2VkIHJlc3VsdCwgZ2VuZXJhdGVkIGJ5IGRlZmF1bHQgW1tJbmZsYXRlI29uRGF0YV1dXG4gKiBhbmQgW1tJbmZsYXRlI29uRW5kXV0gaGFuZGxlcnMuIEZpbGxlZCBhZnRlciB5b3UgcHVzaCBsYXN0IGNodW5rXG4gKiAoY2FsbCBbW0luZmxhdGUjcHVzaF1dIHdpdGggYFpfRklOSVNIYCAvIGB0cnVlYCBwYXJhbSkgb3IgaWYgeW91XG4gKiBwdXNoIGEgY2h1bmsgd2l0aCBleHBsaWNpdCBmbHVzaCAoY2FsbCBbW0luZmxhdGUjcHVzaF1dIHdpdGhcbiAqIGBaX1NZTkNfRkxVU0hgIHBhcmFtKS5cbiAqKi9cblxuLyoqXG4gKiBJbmZsYXRlLmVyciAtPiBOdW1iZXJcbiAqXG4gKiBFcnJvciBjb2RlIGFmdGVyIGluZmxhdGUgZmluaXNoZWQuIDAgKFpfT0spIG9uIHN1Y2Nlc3MuXG4gKiBTaG91bGQgYmUgY2hlY2tlZCBpZiBicm9rZW4gZGF0YSBwb3NzaWJsZS5cbiAqKi9cblxuLyoqXG4gKiBJbmZsYXRlLm1zZyAtPiBTdHJpbmdcbiAqXG4gKiBFcnJvciBtZXNzYWdlLCBpZiBbW0luZmxhdGUuZXJyXV0gIT0gMFxuICoqL1xuXG5cbi8qKlxuICogbmV3IEluZmxhdGUob3B0aW9ucylcbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBpbmZsYXRlIG9wdGlvbnMuXG4gKlxuICogQ3JlYXRlcyBuZXcgaW5mbGF0b3IgaW5zdGFuY2Ugd2l0aCBzcGVjaWZpZWQgcGFyYW1zLiBUaHJvd3MgZXhjZXB0aW9uXG4gKiBvbiBiYWQgcGFyYW1zLiBTdXBwb3J0ZWQgb3B0aW9uczpcbiAqXG4gKiAtIGB3aW5kb3dCaXRzYFxuICogLSBgZGljdGlvbmFyeWBcbiAqXG4gKiBbaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkXShodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWQpXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiB0aGVzZS5cbiAqXG4gKiBBZGRpdGlvbmFsIG9wdGlvbnMsIGZvciBpbnRlcm5hbCBuZWVkczpcbiAqXG4gKiAtIGBjaHVua1NpemVgIC0gc2l6ZSBvZiBnZW5lcmF0ZWQgZGF0YSBjaHVua3MgKDE2SyBieSBkZWZhdWx0KVxuICogLSBgcmF3YCAoQm9vbGVhbikgLSBkbyByYXcgaW5mbGF0ZVxuICogLSBgdG9gIChTdHJpbmcpIC0gaWYgZXF1YWwgdG8gJ3N0cmluZycsIHRoZW4gcmVzdWx0IHdpbGwgYmUgY29udmVydGVkXG4gKiAgIGZyb20gdXRmOCB0byB1dGYxNiAoamF2YXNjcmlwdCkgc3RyaW5nLiBXaGVuIHN0cmluZyBvdXRwdXQgcmVxdWVzdGVkLFxuICogICBjaHVuayBsZW5ndGggY2FuIGRpZmZlciBmcm9tIGBjaHVua1NpemVgLCBkZXBlbmRpbmcgb24gY29udGVudC5cbiAqXG4gKiBCeSBkZWZhdWx0LCB3aGVuIG5vIG9wdGlvbnMgc2V0LCBhdXRvZGV0ZWN0IGRlZmxhdGUvZ3ppcCBkYXRhIGZvcm1hdCB2aWFcbiAqIHdyYXBwZXIgaGVhZGVyLlxuICpcbiAqICMjIyMjIEV4YW1wbGU6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIHBha28gPSByZXF1aXJlKCdwYWtvJylcbiAqICAgLCBjaHVuazEgPSBVaW50OEFycmF5KFsxLDIsMyw0LDUsNiw3LDgsOV0pXG4gKiAgICwgY2h1bmsyID0gVWludDhBcnJheShbMTAsMTEsMTIsMTMsMTQsMTUsMTYsMTcsMTgsMTldKTtcbiAqXG4gKiB2YXIgaW5mbGF0ZSA9IG5ldyBwYWtvLkluZmxhdGUoeyBsZXZlbDogM30pO1xuICpcbiAqIGluZmxhdGUucHVzaChjaHVuazEsIGZhbHNlKTtcbiAqIGluZmxhdGUucHVzaChjaHVuazIsIHRydWUpOyAgLy8gdHJ1ZSAtPiBsYXN0IGNodW5rXG4gKlxuICogaWYgKGluZmxhdGUuZXJyKSB7IHRocm93IG5ldyBFcnJvcihpbmZsYXRlLmVycik7IH1cbiAqXG4gKiBjb25zb2xlLmxvZyhpbmZsYXRlLnJlc3VsdCk7XG4gKiBgYGBcbiAqKi9cbmZ1bmN0aW9uIEluZmxhdGUob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgSW5mbGF0ZSkpIHJldHVybiBuZXcgSW5mbGF0ZShvcHRpb25zKTtcblxuICB0aGlzLm9wdGlvbnMgPSB1dGlscy5hc3NpZ24oe1xuICAgIGNodW5rU2l6ZTogMTYzODQsXG4gICAgd2luZG93Qml0czogMCxcbiAgICB0bzogJydcbiAgfSwgb3B0aW9ucyB8fCB7fSk7XG5cbiAgdmFyIG9wdCA9IHRoaXMub3B0aW9ucztcblxuICAvLyBGb3JjZSB3aW5kb3cgc2l6ZSBmb3IgYHJhd2AgZGF0YSwgaWYgbm90IHNldCBkaXJlY3RseSxcbiAgLy8gYmVjYXVzZSB3ZSBoYXZlIG5vIGhlYWRlciBmb3IgYXV0b2RldGVjdC5cbiAgaWYgKG9wdC5yYXcgJiYgKG9wdC53aW5kb3dCaXRzID49IDApICYmIChvcHQud2luZG93Qml0cyA8IDE2KSkge1xuICAgIG9wdC53aW5kb3dCaXRzID0gLW9wdC53aW5kb3dCaXRzO1xuICAgIGlmIChvcHQud2luZG93Qml0cyA9PT0gMCkgeyBvcHQud2luZG93Qml0cyA9IC0xNTsgfVxuICB9XG5cbiAgLy8gSWYgYHdpbmRvd0JpdHNgIG5vdCBkZWZpbmVkIChhbmQgbW9kZSBub3QgcmF3KSAtIHNldCBhdXRvZGV0ZWN0IGZsYWcgZm9yIGd6aXAvZGVmbGF0ZVxuICBpZiAoKG9wdC53aW5kb3dCaXRzID49IDApICYmIChvcHQud2luZG93Qml0cyA8IDE2KSAmJlxuICAgICAgIShvcHRpb25zICYmIG9wdGlvbnMud2luZG93Qml0cykpIHtcbiAgICBvcHQud2luZG93Qml0cyArPSAzMjtcbiAgfVxuXG4gIC8vIEd6aXAgaGVhZGVyIGhhcyBubyBpbmZvIGFib3V0IHdpbmRvd3Mgc2l6ZSwgd2UgY2FuIGRvIGF1dG9kZXRlY3Qgb25seVxuICAvLyBmb3IgZGVmbGF0ZS4gU28sIGlmIHdpbmRvdyBzaXplIG5vdCBzZXQsIGZvcmNlIGl0IHRvIG1heCB3aGVuIGd6aXAgcG9zc2libGVcbiAgaWYgKChvcHQud2luZG93Qml0cyA+IDE1KSAmJiAob3B0LndpbmRvd0JpdHMgPCA0OCkpIHtcbiAgICAvLyBiaXQgMyAoMTYpIC0+IGd6aXBwZWQgZGF0YVxuICAgIC8vIGJpdCA0ICgzMikgLT4gYXV0b2RldGVjdCBnemlwL2RlZmxhdGVcbiAgICBpZiAoKG9wdC53aW5kb3dCaXRzICYgMTUpID09PSAwKSB7XG4gICAgICBvcHQud2luZG93Qml0cyB8PSAxNTtcbiAgICB9XG4gIH1cblxuICB0aGlzLmVyciAgICA9IDA7ICAgICAgLy8gZXJyb3IgY29kZSwgaWYgaGFwcGVucyAoMCA9IFpfT0spXG4gIHRoaXMubXNnICAgID0gJyc7ICAgICAvLyBlcnJvciBtZXNzYWdlXG4gIHRoaXMuZW5kZWQgID0gZmFsc2U7ICAvLyB1c2VkIHRvIGF2b2lkIG11bHRpcGxlIG9uRW5kKCkgY2FsbHNcbiAgdGhpcy5jaHVua3MgPSBbXTsgICAgIC8vIGNodW5rcyBvZiBjb21wcmVzc2VkIGRhdGFcblxuICB0aGlzLnN0cm0gICA9IG5ldyBaU3RyZWFtKCk7XG4gIHRoaXMuc3RybS5hdmFpbF9vdXQgPSAwO1xuXG4gIHZhciBzdGF0dXMgID0gemxpYl9pbmZsYXRlLmluZmxhdGVJbml0MihcbiAgICB0aGlzLnN0cm0sXG4gICAgb3B0LndpbmRvd0JpdHNcbiAgKTtcblxuICBpZiAoc3RhdHVzICE9PSBjLlpfT0spIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobXNnW3N0YXR1c10pO1xuICB9XG5cbiAgdGhpcy5oZWFkZXIgPSBuZXcgR1poZWFkZXIoKTtcblxuICB6bGliX2luZmxhdGUuaW5mbGF0ZUdldEhlYWRlcih0aGlzLnN0cm0sIHRoaXMuaGVhZGVyKTtcbn1cblxuLyoqXG4gKiBJbmZsYXRlI3B1c2goZGF0YVssIG1vZGVdKSAtPiBCb29sZWFuXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXl8QXJyYXlCdWZmZXJ8U3RyaW5nKTogaW5wdXQgZGF0YVxuICogLSBtb2RlIChOdW1iZXJ8Qm9vbGVhbik6IDAuLjYgZm9yIGNvcnJlc3BvbmRpbmcgWl9OT19GTFVTSC4uWl9UUkVFIG1vZGVzLlxuICogICBTZWUgY29uc3RhbnRzLiBTa2lwcGVkIG9yIGBmYWxzZWAgbWVhbnMgWl9OT19GTFVTSCwgYHRydWVgIG1lYW5zaCBaX0ZJTklTSC5cbiAqXG4gKiBTZW5kcyBpbnB1dCBkYXRhIHRvIGluZmxhdGUgcGlwZSwgZ2VuZXJhdGluZyBbW0luZmxhdGUjb25EYXRhXV0gY2FsbHMgd2l0aFxuICogbmV3IG91dHB1dCBjaHVua3MuIFJldHVybnMgYHRydWVgIG9uIHN1Y2Nlc3MuIFRoZSBsYXN0IGRhdGEgYmxvY2sgbXVzdCBoYXZlXG4gKiBtb2RlIFpfRklOSVNIIChvciBgdHJ1ZWApLiBUaGF0IHdpbGwgZmx1c2ggaW50ZXJuYWwgcGVuZGluZyBidWZmZXJzIGFuZCBjYWxsXG4gKiBbW0luZmxhdGUjb25FbmRdXS4gRm9yIGludGVyaW0gZXhwbGljaXQgZmx1c2hlcyAod2l0aG91dCBlbmRpbmcgdGhlIHN0cmVhbSkgeW91XG4gKiBjYW4gdXNlIG1vZGUgWl9TWU5DX0ZMVVNILCBrZWVwaW5nIHRoZSBkZWNvbXByZXNzaW9uIGNvbnRleHQuXG4gKlxuICogT24gZmFpbCBjYWxsIFtbSW5mbGF0ZSNvbkVuZF1dIHdpdGggZXJyb3IgY29kZSBhbmQgcmV0dXJuIGZhbHNlLlxuICpcbiAqIFdlIHN0cm9uZ2x5IHJlY29tbWVuZCB0byB1c2UgYFVpbnQ4QXJyYXlgIG9uIGlucHV0IGZvciBiZXN0IHNwZWVkIChvdXRwdXRcbiAqIGZvcm1hdCBpcyBkZXRlY3RlZCBhdXRvbWF0aWNhbGx5KS4gQWxzbywgZG9uJ3Qgc2tpcCBsYXN0IHBhcmFtIGFuZCBhbHdheXNcbiAqIHVzZSB0aGUgc2FtZSB0eXBlIGluIHlvdXIgY29kZSAoYm9vbGVhbiBvciBudW1iZXIpLiBUaGF0IHdpbGwgaW1wcm92ZSBKUyBzcGVlZC5cbiAqXG4gKiBGb3IgcmVndWxhciBgQXJyYXlgLXMgbWFrZSBzdXJlIGFsbCBlbGVtZW50cyBhcmUgWzAuLjI1NV0uXG4gKlxuICogIyMjIyMgRXhhbXBsZVxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHB1c2goY2h1bmssIGZhbHNlKTsgLy8gcHVzaCBvbmUgb2YgZGF0YSBjaHVua3NcbiAqIC4uLlxuICogcHVzaChjaHVuaywgdHJ1ZSk7ICAvLyBwdXNoIGxhc3QgY2h1bmtcbiAqIGBgYFxuICoqL1xuSW5mbGF0ZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChkYXRhLCBtb2RlKSB7XG4gIHZhciBzdHJtID0gdGhpcy5zdHJtO1xuICB2YXIgY2h1bmtTaXplID0gdGhpcy5vcHRpb25zLmNodW5rU2l6ZTtcbiAgdmFyIGRpY3Rpb25hcnkgPSB0aGlzLm9wdGlvbnMuZGljdGlvbmFyeTtcbiAgdmFyIHN0YXR1cywgX21vZGU7XG4gIHZhciBuZXh0X291dF91dGY4LCB0YWlsLCB1dGY4c3RyO1xuICB2YXIgZGljdDtcblxuICAvLyBGbGFnIHRvIHByb3Blcmx5IHByb2Nlc3MgWl9CVUZfRVJST1Igb24gdGVzdGluZyBpbmZsYXRlIGNhbGxcbiAgLy8gd2hlbiB3ZSBjaGVjayB0aGF0IGFsbCBvdXRwdXQgZGF0YSB3YXMgZmx1c2hlZC5cbiAgdmFyIGFsbG93QnVmRXJyb3IgPSBmYWxzZTtcblxuICBpZiAodGhpcy5lbmRlZCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgX21vZGUgPSAobW9kZSA9PT0gfn5tb2RlKSA/IG1vZGUgOiAoKG1vZGUgPT09IHRydWUpID8gYy5aX0ZJTklTSCA6IGMuWl9OT19GTFVTSCk7XG5cbiAgLy8gQ29udmVydCBkYXRhIGlmIG5lZWRlZFxuICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gT25seSBiaW5hcnkgc3RyaW5ncyBjYW4gYmUgZGVjb21wcmVzc2VkIG9uIHByYWN0aWNlXG4gICAgc3RybS5pbnB1dCA9IHN0cmluZ3MuYmluc3RyaW5nMmJ1ZihkYXRhKTtcbiAgfSBlbHNlIGlmICh0b1N0cmluZy5jYWxsKGRhdGEpID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nKSB7XG4gICAgc3RybS5pbnB1dCA9IG5ldyBVaW50OEFycmF5KGRhdGEpO1xuICB9IGVsc2Uge1xuICAgIHN0cm0uaW5wdXQgPSBkYXRhO1xuICB9XG5cbiAgc3RybS5uZXh0X2luID0gMDtcbiAgc3RybS5hdmFpbF9pbiA9IHN0cm0uaW5wdXQubGVuZ3RoO1xuXG4gIGRvIHtcbiAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHN0cm0ub3V0cHV0ID0gbmV3IHV0aWxzLkJ1ZjgoY2h1bmtTaXplKTtcbiAgICAgIHN0cm0ubmV4dF9vdXQgPSAwO1xuICAgICAgc3RybS5hdmFpbF9vdXQgPSBjaHVua1NpemU7XG4gICAgfVxuXG4gICAgc3RhdHVzID0gemxpYl9pbmZsYXRlLmluZmxhdGUoc3RybSwgYy5aX05PX0ZMVVNIKTsgICAgLyogbm8gYmFkIHJldHVybiB2YWx1ZSAqL1xuXG4gICAgaWYgKHN0YXR1cyA9PT0gYy5aX05FRURfRElDVCAmJiBkaWN0aW9uYXJ5KSB7XG4gICAgICAvLyBDb252ZXJ0IGRhdGEgaWYgbmVlZGVkXG4gICAgICBpZiAodHlwZW9mIGRpY3Rpb25hcnkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGRpY3QgPSBzdHJpbmdzLnN0cmluZzJidWYoZGljdGlvbmFyeSk7XG4gICAgICB9IGVsc2UgaWYgKHRvU3RyaW5nLmNhbGwoZGljdGlvbmFyeSkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXScpIHtcbiAgICAgICAgZGljdCA9IG5ldyBVaW50OEFycmF5KGRpY3Rpb25hcnkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGljdCA9IGRpY3Rpb25hcnk7XG4gICAgICB9XG5cbiAgICAgIHN0YXR1cyA9IHpsaWJfaW5mbGF0ZS5pbmZsYXRlU2V0RGljdGlvbmFyeSh0aGlzLnN0cm0sIGRpY3QpO1xuXG4gICAgfVxuXG4gICAgaWYgKHN0YXR1cyA9PT0gYy5aX0JVRl9FUlJPUiAmJiBhbGxvd0J1ZkVycm9yID09PSB0cnVlKSB7XG4gICAgICBzdGF0dXMgPSBjLlpfT0s7XG4gICAgICBhbGxvd0J1ZkVycm9yID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHN0YXR1cyAhPT0gYy5aX1NUUkVBTV9FTkQgJiYgc3RhdHVzICE9PSBjLlpfT0spIHtcbiAgICAgIHRoaXMub25FbmQoc3RhdHVzKTtcbiAgICAgIHRoaXMuZW5kZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChzdHJtLm5leHRfb3V0KSB7XG4gICAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDAgfHwgc3RhdHVzID09PSBjLlpfU1RSRUFNX0VORCB8fCAoc3RybS5hdmFpbF9pbiA9PT0gMCAmJiAoX21vZGUgPT09IGMuWl9GSU5JU0ggfHwgX21vZGUgPT09IGMuWl9TWU5DX0ZMVVNIKSkpIHtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnRvID09PSAnc3RyaW5nJykge1xuXG4gICAgICAgICAgbmV4dF9vdXRfdXRmOCA9IHN0cmluZ3MudXRmOGJvcmRlcihzdHJtLm91dHB1dCwgc3RybS5uZXh0X291dCk7XG5cbiAgICAgICAgICB0YWlsID0gc3RybS5uZXh0X291dCAtIG5leHRfb3V0X3V0Zjg7XG4gICAgICAgICAgdXRmOHN0ciA9IHN0cmluZ3MuYnVmMnN0cmluZyhzdHJtLm91dHB1dCwgbmV4dF9vdXRfdXRmOCk7XG5cbiAgICAgICAgICAvLyBtb3ZlIHRhaWxcbiAgICAgICAgICBzdHJtLm5leHRfb3V0ID0gdGFpbDtcbiAgICAgICAgICBzdHJtLmF2YWlsX291dCA9IGNodW5rU2l6ZSAtIHRhaWw7XG4gICAgICAgICAgaWYgKHRhaWwpIHsgdXRpbHMuYXJyYXlTZXQoc3RybS5vdXRwdXQsIHN0cm0ub3V0cHV0LCBuZXh0X291dF91dGY4LCB0YWlsLCAwKTsgfVxuXG4gICAgICAgICAgdGhpcy5vbkRhdGEodXRmOHN0cik7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLm9uRGF0YSh1dGlscy5zaHJpbmtCdWYoc3RybS5vdXRwdXQsIHN0cm0ubmV4dF9vdXQpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFdoZW4gbm8gbW9yZSBpbnB1dCBkYXRhLCB3ZSBzaG91bGQgY2hlY2sgdGhhdCBpbnRlcm5hbCBpbmZsYXRlIGJ1ZmZlcnNcbiAgICAvLyBhcmUgZmx1c2hlZC4gVGhlIG9ubHkgd2F5IHRvIGRvIGl0IHdoZW4gYXZhaWxfb3V0ID0gMCAtIHJ1biBvbmUgbW9yZVxuICAgIC8vIGluZmxhdGUgcGFzcy4gQnV0IGlmIG91dHB1dCBkYXRhIG5vdCBleGlzdHMsIGluZmxhdGUgcmV0dXJuIFpfQlVGX0VSUk9SLlxuICAgIC8vIEhlcmUgd2Ugc2V0IGZsYWcgdG8gcHJvY2VzcyB0aGlzIGVycm9yIHByb3Blcmx5LlxuICAgIC8vXG4gICAgLy8gTk9URS4gRGVmbGF0ZSBkb2VzIG5vdCByZXR1cm4gZXJyb3IgaW4gdGhpcyBjYXNlIGFuZCBkb2VzIG5vdCBuZWVkcyBzdWNoXG4gICAgLy8gbG9naWMuXG4gICAgaWYgKHN0cm0uYXZhaWxfaW4gPT09IDAgJiYgc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIGFsbG93QnVmRXJyb3IgPSB0cnVlO1xuICAgIH1cblxuICB9IHdoaWxlICgoc3RybS5hdmFpbF9pbiA+IDAgfHwgc3RybS5hdmFpbF9vdXQgPT09IDApICYmIHN0YXR1cyAhPT0gYy5aX1NUUkVBTV9FTkQpO1xuXG4gIGlmIChzdGF0dXMgPT09IGMuWl9TVFJFQU1fRU5EKSB7XG4gICAgX21vZGUgPSBjLlpfRklOSVNIO1xuICB9XG5cbiAgLy8gRmluYWxpemUgb24gdGhlIGxhc3QgY2h1bmsuXG4gIGlmIChfbW9kZSA9PT0gYy5aX0ZJTklTSCkge1xuICAgIHN0YXR1cyA9IHpsaWJfaW5mbGF0ZS5pbmZsYXRlRW5kKHRoaXMuc3RybSk7XG4gICAgdGhpcy5vbkVuZChzdGF0dXMpO1xuICAgIHRoaXMuZW5kZWQgPSB0cnVlO1xuICAgIHJldHVybiBzdGF0dXMgPT09IGMuWl9PSztcbiAgfVxuXG4gIC8vIGNhbGxiYWNrIGludGVyaW0gcmVzdWx0cyBpZiBaX1NZTkNfRkxVU0guXG4gIGlmIChfbW9kZSA9PT0gYy5aX1NZTkNfRkxVU0gpIHtcbiAgICB0aGlzLm9uRW5kKGMuWl9PSyk7XG4gICAgc3RybS5hdmFpbF9vdXQgPSAwO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cbi8qKlxuICogSW5mbGF0ZSNvbkRhdGEoY2h1bmspIC0+IFZvaWRcbiAqIC0gY2h1bmsgKFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nKTogb3VwdXQgZGF0YS4gVHlwZSBvZiBhcnJheSBkZXBlbmRzXG4gKiAgIG9uIGpzIGVuZ2luZSBzdXBwb3J0LiBXaGVuIHN0cmluZyBvdXRwdXQgcmVxdWVzdGVkLCBlYWNoIGNodW5rXG4gKiAgIHdpbGwgYmUgc3RyaW5nLlxuICpcbiAqIEJ5IGRlZmF1bHQsIHN0b3JlcyBkYXRhIGJsb2NrcyBpbiBgY2h1bmtzW11gIHByb3BlcnR5IGFuZCBnbHVlXG4gKiB0aG9zZSBpbiBgb25FbmRgLiBPdmVycmlkZSB0aGlzIGhhbmRsZXIsIGlmIHlvdSBuZWVkIGFub3RoZXIgYmVoYXZpb3VyLlxuICoqL1xuSW5mbGF0ZS5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gIHRoaXMuY2h1bmtzLnB1c2goY2h1bmspO1xufTtcblxuXG4vKipcbiAqIEluZmxhdGUjb25FbmQoc3RhdHVzKSAtPiBWb2lkXG4gKiAtIHN0YXR1cyAoTnVtYmVyKTogaW5mbGF0ZSBzdGF0dXMuIDAgKFpfT0spIG9uIHN1Y2Nlc3MsXG4gKiAgIG90aGVyIGlmIG5vdC5cbiAqXG4gKiBDYWxsZWQgZWl0aGVyIGFmdGVyIHlvdSB0ZWxsIGluZmxhdGUgdGhhdCB0aGUgaW5wdXQgc3RyZWFtIGlzXG4gKiBjb21wbGV0ZSAoWl9GSU5JU0gpIG9yIHNob3VsZCBiZSBmbHVzaGVkIChaX1NZTkNfRkxVU0gpXG4gKiBvciBpZiBhbiBlcnJvciBoYXBwZW5lZC4gQnkgZGVmYXVsdCAtIGpvaW4gY29sbGVjdGVkIGNodW5rcyxcbiAqIGZyZWUgbWVtb3J5IGFuZCBmaWxsIGByZXN1bHRzYCAvIGBlcnJgIHByb3BlcnRpZXMuXG4gKiovXG5JbmZsYXRlLnByb3RvdHlwZS5vbkVuZCA9IGZ1bmN0aW9uIChzdGF0dXMpIHtcbiAgLy8gT24gc3VjY2VzcyAtIGpvaW5cbiAgaWYgKHN0YXR1cyA9PT0gYy5aX09LKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy50byA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIEdsdWUgJiBjb252ZXJ0IGhlcmUsIHVudGlsIHdlIHRlYWNoIHBha28gdG8gc2VuZFxuICAgICAgLy8gdXRmOCBhbGxpZ25lZCBzdHJpbmdzIHRvIG9uRGF0YVxuICAgICAgdGhpcy5yZXN1bHQgPSB0aGlzLmNodW5rcy5qb2luKCcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZXN1bHQgPSB1dGlscy5mbGF0dGVuQ2h1bmtzKHRoaXMuY2h1bmtzKTtcbiAgICB9XG4gIH1cbiAgdGhpcy5jaHVua3MgPSBbXTtcbiAgdGhpcy5lcnIgPSBzdGF0dXM7XG4gIHRoaXMubXNnID0gdGhpcy5zdHJtLm1zZztcbn07XG5cblxuLyoqXG4gKiBpbmZsYXRlKGRhdGFbLCBvcHRpb25zXSkgLT4gVWludDhBcnJheXxBcnJheXxTdHJpbmdcbiAqIC0gZGF0YSAoVWludDhBcnJheXxBcnJheXxTdHJpbmcpOiBpbnB1dCBkYXRhIHRvIGRlY29tcHJlc3MuXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgaW5mbGF0ZSBvcHRpb25zLlxuICpcbiAqIERlY29tcHJlc3MgYGRhdGFgIHdpdGggaW5mbGF0ZS91bmd6aXAgYW5kIGBvcHRpb25zYC4gQXV0b2RldGVjdFxuICogZm9ybWF0IHZpYSB3cmFwcGVyIGhlYWRlciBieSBkZWZhdWx0LiBUaGF0J3Mgd2h5IHdlIGRvbid0IHByb3ZpZGVcbiAqIHNlcGFyYXRlIGB1bmd6aXBgIG1ldGhvZC5cbiAqXG4gKiBTdXBwb3J0ZWQgb3B0aW9ucyBhcmU6XG4gKlxuICogLSB3aW5kb3dCaXRzXG4gKlxuICogW2h0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZF0oaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkKVxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogU3VnYXIgKG9wdGlvbnMpOlxuICpcbiAqIC0gYHJhd2AgKEJvb2xlYW4pIC0gc2F5IHRoYXQgd2Ugd29yayB3aXRoIHJhdyBzdHJlYW0sIGlmIHlvdSBkb24ndCB3aXNoIHRvIHNwZWNpZnlcbiAqICAgbmVnYXRpdmUgd2luZG93Qml0cyBpbXBsaWNpdGx5LlxuICogLSBgdG9gIChTdHJpbmcpIC0gaWYgZXF1YWwgdG8gJ3N0cmluZycsIHRoZW4gcmVzdWx0IHdpbGwgYmUgY29udmVydGVkXG4gKiAgIGZyb20gdXRmOCB0byB1dGYxNiAoamF2YXNjcmlwdCkgc3RyaW5nLiBXaGVuIHN0cmluZyBvdXRwdXQgcmVxdWVzdGVkLFxuICogICBjaHVuayBsZW5ndGggY2FuIGRpZmZlciBmcm9tIGBjaHVua1NpemVgLCBkZXBlbmRpbmcgb24gY29udGVudC5cbiAqXG4gKlxuICogIyMjIyMgRXhhbXBsZTpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgcGFrbyA9IHJlcXVpcmUoJ3Bha28nKVxuICogICAsIGlucHV0ID0gcGFrby5kZWZsYXRlKFsxLDIsMyw0LDUsNiw3LDgsOV0pXG4gKiAgICwgb3V0cHV0O1xuICpcbiAqIHRyeSB7XG4gKiAgIG91dHB1dCA9IHBha28uaW5mbGF0ZShpbnB1dCk7XG4gKiB9IGNhdGNoIChlcnIpXG4gKiAgIGNvbnNvbGUubG9nKGVycik7XG4gKiB9XG4gKiBgYGBcbiAqKi9cbmZ1bmN0aW9uIGluZmxhdGUoaW5wdXQsIG9wdGlvbnMpIHtcbiAgdmFyIGluZmxhdG9yID0gbmV3IEluZmxhdGUob3B0aW9ucyk7XG5cbiAgaW5mbGF0b3IucHVzaChpbnB1dCwgdHJ1ZSk7XG5cbiAgLy8gVGhhdCB3aWxsIG5ldmVyIGhhcHBlbnMsIGlmIHlvdSBkb24ndCBjaGVhdCB3aXRoIG9wdGlvbnMgOilcbiAgaWYgKGluZmxhdG9yLmVycikgeyB0aHJvdyBpbmZsYXRvci5tc2cgfHwgbXNnW2luZmxhdG9yLmVycl07IH1cblxuICByZXR1cm4gaW5mbGF0b3IucmVzdWx0O1xufVxuXG5cbi8qKlxuICogaW5mbGF0ZVJhdyhkYXRhWywgb3B0aW9uc10pIC0+IFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nKTogaW5wdXQgZGF0YSB0byBkZWNvbXByZXNzLlxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGluZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBUaGUgc2FtZSBhcyBbW2luZmxhdGVdXSwgYnV0IGNyZWF0ZXMgcmF3IGRhdGEsIHdpdGhvdXQgd3JhcHBlclxuICogKGhlYWRlciBhbmQgYWRsZXIzMiBjcmMpLlxuICoqL1xuZnVuY3Rpb24gaW5mbGF0ZVJhdyhpbnB1dCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgb3B0aW9ucy5yYXcgPSB0cnVlO1xuICByZXR1cm4gaW5mbGF0ZShpbnB1dCwgb3B0aW9ucyk7XG59XG5cblxuLyoqXG4gKiB1bmd6aXAoZGF0YVssIG9wdGlvbnNdKSAtPiBVaW50OEFycmF5fEFycmF5fFN0cmluZ1xuICogLSBkYXRhIChVaW50OEFycmF5fEFycmF5fFN0cmluZyk6IGlucHV0IGRhdGEgdG8gZGVjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBpbmZsYXRlIG9wdGlvbnMuXG4gKlxuICogSnVzdCBzaG9ydGN1dCB0byBbW2luZmxhdGVdXSwgYmVjYXVzZSBpdCBhdXRvZGV0ZWN0cyBmb3JtYXRcbiAqIGJ5IGhlYWRlci5jb250ZW50LiBEb25lIGZvciBjb252ZW5pZW5jZS5cbiAqKi9cblxuXG5leHBvcnRzLkluZmxhdGUgPSBJbmZsYXRlO1xuZXhwb3J0cy5pbmZsYXRlID0gaW5mbGF0ZTtcbmV4cG9ydHMuaW5mbGF0ZVJhdyA9IGluZmxhdGVSYXc7XG5leHBvcnRzLnVuZ3ppcCAgPSBpbmZsYXRlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Bha28vbGliL2luZmxhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDMxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuXG52YXIgdXRpbHMgICAgICAgICA9IHJlcXVpcmUoJy4uL3V0aWxzL2NvbW1vbicpO1xudmFyIGFkbGVyMzIgICAgICAgPSByZXF1aXJlKCcuL2FkbGVyMzInKTtcbnZhciBjcmMzMiAgICAgICAgID0gcmVxdWlyZSgnLi9jcmMzMicpO1xudmFyIGluZmxhdGVfZmFzdCAgPSByZXF1aXJlKCcuL2luZmZhc3QnKTtcbnZhciBpbmZsYXRlX3RhYmxlID0gcmVxdWlyZSgnLi9pbmZ0cmVlcycpO1xuXG52YXIgQ09ERVMgPSAwO1xudmFyIExFTlMgPSAxO1xudmFyIERJU1RTID0gMjtcblxuLyogUHVibGljIGNvbnN0YW50cyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuLyogQWxsb3dlZCBmbHVzaCB2YWx1ZXM7IHNlZSBkZWZsYXRlKCkgYW5kIGluZmxhdGUoKSBiZWxvdyBmb3IgZGV0YWlscyAqL1xuLy92YXIgWl9OT19GTFVTSCAgICAgID0gMDtcbi8vdmFyIFpfUEFSVElBTF9GTFVTSCA9IDE7XG4vL3ZhciBaX1NZTkNfRkxVU0ggICAgPSAyO1xuLy92YXIgWl9GVUxMX0ZMVVNIICAgID0gMztcbnZhciBaX0ZJTklTSCAgICAgICAgPSA0O1xudmFyIFpfQkxPQ0sgICAgICAgICA9IDU7XG52YXIgWl9UUkVFUyAgICAgICAgID0gNjtcblxuXG4vKiBSZXR1cm4gY29kZXMgZm9yIHRoZSBjb21wcmVzc2lvbi9kZWNvbXByZXNzaW9uIGZ1bmN0aW9ucy4gTmVnYXRpdmUgdmFsdWVzXG4gKiBhcmUgZXJyb3JzLCBwb3NpdGl2ZSB2YWx1ZXMgYXJlIHVzZWQgZm9yIHNwZWNpYWwgYnV0IG5vcm1hbCBldmVudHMuXG4gKi9cbnZhciBaX09LICAgICAgICAgICAgPSAwO1xudmFyIFpfU1RSRUFNX0VORCAgICA9IDE7XG52YXIgWl9ORUVEX0RJQ1QgICAgID0gMjtcbi8vdmFyIFpfRVJSTk8gICAgICAgICA9IC0xO1xudmFyIFpfU1RSRUFNX0VSUk9SICA9IC0yO1xudmFyIFpfREFUQV9FUlJPUiAgICA9IC0zO1xudmFyIFpfTUVNX0VSUk9SICAgICA9IC00O1xudmFyIFpfQlVGX0VSUk9SICAgICA9IC01O1xuLy92YXIgWl9WRVJTSU9OX0VSUk9SID0gLTY7XG5cbi8qIFRoZSBkZWZsYXRlIGNvbXByZXNzaW9uIG1ldGhvZCAqL1xudmFyIFpfREVGTEFURUQgID0gODtcblxuXG4vKiBTVEFURVMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG52YXIgICAgSEVBRCA9IDE7ICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIG1hZ2ljIGhlYWRlciAqL1xudmFyICAgIEZMQUdTID0gMjsgICAgICAvKiBpOiB3YWl0aW5nIGZvciBtZXRob2QgYW5kIGZsYWdzIChnemlwKSAqL1xudmFyICAgIFRJTUUgPSAzOyAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBtb2RpZmljYXRpb24gdGltZSAoZ3ppcCkgKi9cbnZhciAgICBPUyA9IDQ7ICAgICAgICAgLyogaTogd2FpdGluZyBmb3IgZXh0cmEgZmxhZ3MgYW5kIG9wZXJhdGluZyBzeXN0ZW0gKGd6aXApICovXG52YXIgICAgRVhMRU4gPSA1OyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGV4dHJhIGxlbmd0aCAoZ3ppcCkgKi9cbnZhciAgICBFWFRSQSA9IDY7ICAgICAgLyogaTogd2FpdGluZyBmb3IgZXh0cmEgYnl0ZXMgKGd6aXApICovXG52YXIgICAgTkFNRSA9IDc7ICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGVuZCBvZiBmaWxlIG5hbWUgKGd6aXApICovXG52YXIgICAgQ09NTUVOVCA9IDg7ICAgIC8qIGk6IHdhaXRpbmcgZm9yIGVuZCBvZiBjb21tZW50IChnemlwKSAqL1xudmFyICAgIEhDUkMgPSA5OyAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBoZWFkZXIgY3JjIChnemlwKSAqL1xudmFyICAgIERJQ1RJRCA9IDEwOyAgICAvKiBpOiB3YWl0aW5nIGZvciBkaWN0aW9uYXJ5IGNoZWNrIHZhbHVlICovXG52YXIgICAgRElDVCA9IDExOyAgICAgIC8qIHdhaXRpbmcgZm9yIGluZmxhdGVTZXREaWN0aW9uYXJ5KCkgY2FsbCAqL1xudmFyICAgICAgICBUWVBFID0gMTI7ICAgICAgLyogaTogd2FpdGluZyBmb3IgdHlwZSBiaXRzLCBpbmNsdWRpbmcgbGFzdC1mbGFnIGJpdCAqL1xudmFyICAgICAgICBUWVBFRE8gPSAxMzsgICAgLyogaTogc2FtZSwgYnV0IHNraXAgY2hlY2sgdG8gZXhpdCBpbmZsYXRlIG9uIG5ldyBibG9jayAqL1xudmFyICAgICAgICBTVE9SRUQgPSAxNDsgICAgLyogaTogd2FpdGluZyBmb3Igc3RvcmVkIHNpemUgKGxlbmd0aCBhbmQgY29tcGxlbWVudCkgKi9cbnZhciAgICAgICAgQ09QWV8gPSAxNTsgICAgIC8qIGkvbzogc2FtZSBhcyBDT1BZIGJlbG93LCBidXQgb25seSBmaXJzdCB0aW1lIGluICovXG52YXIgICAgICAgIENPUFkgPSAxNjsgICAgICAvKiBpL286IHdhaXRpbmcgZm9yIGlucHV0IG9yIG91dHB1dCB0byBjb3B5IHN0b3JlZCBibG9jayAqL1xudmFyICAgICAgICBUQUJMRSA9IDE3OyAgICAgLyogaTogd2FpdGluZyBmb3IgZHluYW1pYyBibG9jayB0YWJsZSBsZW5ndGhzICovXG52YXIgICAgICAgIExFTkxFTlMgPSAxODsgICAvKiBpOiB3YWl0aW5nIGZvciBjb2RlIGxlbmd0aCBjb2RlIGxlbmd0aHMgKi9cbnZhciAgICAgICAgQ09ERUxFTlMgPSAxOTsgIC8qIGk6IHdhaXRpbmcgZm9yIGxlbmd0aC9saXQgYW5kIGRpc3RhbmNlIGNvZGUgbGVuZ3RocyAqL1xudmFyICAgICAgICAgICAgTEVOXyA9IDIwOyAgICAgIC8qIGk6IHNhbWUgYXMgTEVOIGJlbG93LCBidXQgb25seSBmaXJzdCB0aW1lIGluICovXG52YXIgICAgICAgICAgICBMRU4gPSAyMTsgICAgICAgLyogaTogd2FpdGluZyBmb3IgbGVuZ3RoL2xpdC9lb2IgY29kZSAqL1xudmFyICAgICAgICAgICAgTEVORVhUID0gMjI7ICAgIC8qIGk6IHdhaXRpbmcgZm9yIGxlbmd0aCBleHRyYSBiaXRzICovXG52YXIgICAgICAgICAgICBESVNUID0gMjM7ICAgICAgLyogaTogd2FpdGluZyBmb3IgZGlzdGFuY2UgY29kZSAqL1xudmFyICAgICAgICAgICAgRElTVEVYVCA9IDI0OyAgIC8qIGk6IHdhaXRpbmcgZm9yIGRpc3RhbmNlIGV4dHJhIGJpdHMgKi9cbnZhciAgICAgICAgICAgIE1BVENIID0gMjU7ICAgICAvKiBvOiB3YWl0aW5nIGZvciBvdXRwdXQgc3BhY2UgdG8gY29weSBzdHJpbmcgKi9cbnZhciAgICAgICAgICAgIExJVCA9IDI2OyAgICAgICAvKiBvOiB3YWl0aW5nIGZvciBvdXRwdXQgc3BhY2UgdG8gd3JpdGUgbGl0ZXJhbCAqL1xudmFyICAgIENIRUNLID0gMjc7ICAgICAvKiBpOiB3YWl0aW5nIGZvciAzMi1iaXQgY2hlY2sgdmFsdWUgKi9cbnZhciAgICBMRU5HVEggPSAyODsgICAgLyogaTogd2FpdGluZyBmb3IgMzItYml0IGxlbmd0aCAoZ3ppcCkgKi9cbnZhciAgICBET05FID0gMjk7ICAgICAgLyogZmluaXNoZWQgY2hlY2ssIGRvbmUgLS0gcmVtYWluIGhlcmUgdW50aWwgcmVzZXQgKi9cbnZhciAgICBCQUQgPSAzMDsgICAgICAgLyogZ290IGEgZGF0YSBlcnJvciAtLSByZW1haW4gaGVyZSB1bnRpbCByZXNldCAqL1xudmFyICAgIE1FTSA9IDMxOyAgICAgICAvKiBnb3QgYW4gaW5mbGF0ZSgpIG1lbW9yeSBlcnJvciAtLSByZW1haW4gaGVyZSB1bnRpbCByZXNldCAqL1xudmFyICAgIFNZTkMgPSAzMjsgICAgICAvKiBsb29raW5nIGZvciBzeW5jaHJvbml6YXRpb24gYnl0ZXMgdG8gcmVzdGFydCBpbmZsYXRlKCkgKi9cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG5cbnZhciBFTk9VR0hfTEVOUyA9IDg1MjtcbnZhciBFTk9VR0hfRElTVFMgPSA1OTI7XG4vL3ZhciBFTk9VR0ggPSAgKEVOT1VHSF9MRU5TK0VOT1VHSF9ESVNUUyk7XG5cbnZhciBNQVhfV0JJVFMgPSAxNTtcbi8qIDMySyBMWjc3IHdpbmRvdyAqL1xudmFyIERFRl9XQklUUyA9IE1BWF9XQklUUztcblxuXG5mdW5jdGlvbiB6c3dhcDMyKHEpIHtcbiAgcmV0dXJuICAoKChxID4+PiAyNCkgJiAweGZmKSArXG4gICAgICAgICAgKChxID4+PiA4KSAmIDB4ZmYwMCkgK1xuICAgICAgICAgICgocSAmIDB4ZmYwMCkgPDwgOCkgK1xuICAgICAgICAgICgocSAmIDB4ZmYpIDw8IDI0KSk7XG59XG5cblxuZnVuY3Rpb24gSW5mbGF0ZVN0YXRlKCkge1xuICB0aGlzLm1vZGUgPSAwOyAgICAgICAgICAgICAvKiBjdXJyZW50IGluZmxhdGUgbW9kZSAqL1xuICB0aGlzLmxhc3QgPSBmYWxzZTsgICAgICAgICAgLyogdHJ1ZSBpZiBwcm9jZXNzaW5nIGxhc3QgYmxvY2sgKi9cbiAgdGhpcy53cmFwID0gMDsgICAgICAgICAgICAgIC8qIGJpdCAwIHRydWUgZm9yIHpsaWIsIGJpdCAxIHRydWUgZm9yIGd6aXAgKi9cbiAgdGhpcy5oYXZlZGljdCA9IGZhbHNlOyAgICAgIC8qIHRydWUgaWYgZGljdGlvbmFyeSBwcm92aWRlZCAqL1xuICB0aGlzLmZsYWdzID0gMDsgICAgICAgICAgICAgLyogZ3ppcCBoZWFkZXIgbWV0aG9kIGFuZCBmbGFncyAoMCBpZiB6bGliKSAqL1xuICB0aGlzLmRtYXggPSAwOyAgICAgICAgICAgICAgLyogemxpYiBoZWFkZXIgbWF4IGRpc3RhbmNlIChJTkZMQVRFX1NUUklDVCkgKi9cbiAgdGhpcy5jaGVjayA9IDA7ICAgICAgICAgICAgIC8qIHByb3RlY3RlZCBjb3B5IG9mIGNoZWNrIHZhbHVlICovXG4gIHRoaXMudG90YWwgPSAwOyAgICAgICAgICAgICAvKiBwcm90ZWN0ZWQgY29weSBvZiBvdXRwdXQgY291bnQgKi9cbiAgLy8gVE9ETzogbWF5IGJlIHt9XG4gIHRoaXMuaGVhZCA9IG51bGw7ICAgICAgICAgICAvKiB3aGVyZSB0byBzYXZlIGd6aXAgaGVhZGVyIGluZm9ybWF0aW9uICovXG5cbiAgLyogc2xpZGluZyB3aW5kb3cgKi9cbiAgdGhpcy53Yml0cyA9IDA7ICAgICAgICAgICAgIC8qIGxvZyBiYXNlIDIgb2YgcmVxdWVzdGVkIHdpbmRvdyBzaXplICovXG4gIHRoaXMud3NpemUgPSAwOyAgICAgICAgICAgICAvKiB3aW5kb3cgc2l6ZSBvciB6ZXJvIGlmIG5vdCB1c2luZyB3aW5kb3cgKi9cbiAgdGhpcy53aGF2ZSA9IDA7ICAgICAgICAgICAgIC8qIHZhbGlkIGJ5dGVzIGluIHRoZSB3aW5kb3cgKi9cbiAgdGhpcy53bmV4dCA9IDA7ICAgICAgICAgICAgIC8qIHdpbmRvdyB3cml0ZSBpbmRleCAqL1xuICB0aGlzLndpbmRvdyA9IG51bGw7ICAgICAgICAgLyogYWxsb2NhdGVkIHNsaWRpbmcgd2luZG93LCBpZiBuZWVkZWQgKi9cblxuICAvKiBiaXQgYWNjdW11bGF0b3IgKi9cbiAgdGhpcy5ob2xkID0gMDsgICAgICAgICAgICAgIC8qIGlucHV0IGJpdCBhY2N1bXVsYXRvciAqL1xuICB0aGlzLmJpdHMgPSAwOyAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGJpdHMgaW4gXCJpblwiICovXG5cbiAgLyogZm9yIHN0cmluZyBhbmQgc3RvcmVkIGJsb2NrIGNvcHlpbmcgKi9cbiAgdGhpcy5sZW5ndGggPSAwOyAgICAgICAgICAgIC8qIGxpdGVyYWwgb3IgbGVuZ3RoIG9mIGRhdGEgdG8gY29weSAqL1xuICB0aGlzLm9mZnNldCA9IDA7ICAgICAgICAgICAgLyogZGlzdGFuY2UgYmFjayB0byBjb3B5IHN0cmluZyBmcm9tICovXG5cbiAgLyogZm9yIHRhYmxlIGFuZCBjb2RlIGRlY29kaW5nICovXG4gIHRoaXMuZXh0cmEgPSAwOyAgICAgICAgICAgICAvKiBleHRyYSBiaXRzIG5lZWRlZCAqL1xuXG4gIC8qIGZpeGVkIGFuZCBkeW5hbWljIGNvZGUgdGFibGVzICovXG4gIHRoaXMubGVuY29kZSA9IG51bGw7ICAgICAgICAgIC8qIHN0YXJ0aW5nIHRhYmxlIGZvciBsZW5ndGgvbGl0ZXJhbCBjb2RlcyAqL1xuICB0aGlzLmRpc3Rjb2RlID0gbnVsbDsgICAgICAgICAvKiBzdGFydGluZyB0YWJsZSBmb3IgZGlzdGFuY2UgY29kZXMgKi9cbiAgdGhpcy5sZW5iaXRzID0gMDsgICAgICAgICAgIC8qIGluZGV4IGJpdHMgZm9yIGxlbmNvZGUgKi9cbiAgdGhpcy5kaXN0Yml0cyA9IDA7ICAgICAgICAgIC8qIGluZGV4IGJpdHMgZm9yIGRpc3Rjb2RlICovXG5cbiAgLyogZHluYW1pYyB0YWJsZSBidWlsZGluZyAqL1xuICB0aGlzLm5jb2RlID0gMDsgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGNvZGUgbGVuZ3RoIGNvZGUgbGVuZ3RocyAqL1xuICB0aGlzLm5sZW4gPSAwOyAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGxlbmd0aCBjb2RlIGxlbmd0aHMgKi9cbiAgdGhpcy5uZGlzdCA9IDA7ICAgICAgICAgICAgIC8qIG51bWJlciBvZiBkaXN0YW5jZSBjb2RlIGxlbmd0aHMgKi9cbiAgdGhpcy5oYXZlID0gMDsgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBjb2RlIGxlbmd0aHMgaW4gbGVuc1tdICovXG4gIHRoaXMubmV4dCA9IG51bGw7ICAgICAgICAgICAgICAvKiBuZXh0IGF2YWlsYWJsZSBzcGFjZSBpbiBjb2Rlc1tdICovXG5cbiAgdGhpcy5sZW5zID0gbmV3IHV0aWxzLkJ1ZjE2KDMyMCk7IC8qIHRlbXBvcmFyeSBzdG9yYWdlIGZvciBjb2RlIGxlbmd0aHMgKi9cbiAgdGhpcy53b3JrID0gbmV3IHV0aWxzLkJ1ZjE2KDI4OCk7IC8qIHdvcmsgYXJlYSBmb3IgY29kZSB0YWJsZSBidWlsZGluZyAqL1xuXG4gIC8qXG4gICBiZWNhdXNlIHdlIGRvbid0IGhhdmUgcG9pbnRlcnMgaW4ganMsIHdlIHVzZSBsZW5jb2RlIGFuZCBkaXN0Y29kZSBkaXJlY3RseVxuICAgYXMgYnVmZmVycyBzbyB3ZSBkb24ndCBuZWVkIGNvZGVzXG4gICovXG4gIC8vdGhpcy5jb2RlcyA9IG5ldyB1dGlscy5CdWYzMihFTk9VR0gpOyAgICAgICAvKiBzcGFjZSBmb3IgY29kZSB0YWJsZXMgKi9cbiAgdGhpcy5sZW5keW4gPSBudWxsOyAgICAgICAgICAgICAgLyogZHluYW1pYyB0YWJsZSBmb3IgbGVuZ3RoL2xpdGVyYWwgY29kZXMgKEpTIHNwZWNpZmljKSAqL1xuICB0aGlzLmRpc3RkeW4gPSBudWxsOyAgICAgICAgICAgICAvKiBkeW5hbWljIHRhYmxlIGZvciBkaXN0YW5jZSBjb2RlcyAoSlMgc3BlY2lmaWMpICovXG4gIHRoaXMuc2FuZSA9IDA7ICAgICAgICAgICAgICAgICAgIC8qIGlmIGZhbHNlLCBhbGxvdyBpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgKi9cbiAgdGhpcy5iYWNrID0gMDsgICAgICAgICAgICAgICAgICAgLyogYml0cyBiYWNrIG9mIGxhc3QgdW5wcm9jZXNzZWQgbGVuZ3RoL2xpdCAqL1xuICB0aGlzLndhcyA9IDA7ICAgICAgICAgICAgICAgICAgICAvKiBpbml0aWFsIGxlbmd0aCBvZiBtYXRjaCAqL1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlUmVzZXRLZWVwKHN0cm0pIHtcbiAgdmFyIHN0YXRlO1xuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICBzdHJtLnRvdGFsX2luID0gc3RybS50b3RhbF9vdXQgPSBzdGF0ZS50b3RhbCA9IDA7XG4gIHN0cm0ubXNnID0gJyc7IC8qWl9OVUxMKi9cbiAgaWYgKHN0YXRlLndyYXApIHsgICAgICAgLyogdG8gc3VwcG9ydCBpbGwtY29uY2VpdmVkIEphdmEgdGVzdCBzdWl0ZSAqL1xuICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS53cmFwICYgMTtcbiAgfVxuICBzdGF0ZS5tb2RlID0gSEVBRDtcbiAgc3RhdGUubGFzdCA9IDA7XG4gIHN0YXRlLmhhdmVkaWN0ID0gMDtcbiAgc3RhdGUuZG1heCA9IDMyNzY4O1xuICBzdGF0ZS5oZWFkID0gbnVsbC8qWl9OVUxMKi87XG4gIHN0YXRlLmhvbGQgPSAwO1xuICBzdGF0ZS5iaXRzID0gMDtcbiAgLy9zdGF0ZS5sZW5jb2RlID0gc3RhdGUuZGlzdGNvZGUgPSBzdGF0ZS5uZXh0ID0gc3RhdGUuY29kZXM7XG4gIHN0YXRlLmxlbmNvZGUgPSBzdGF0ZS5sZW5keW4gPSBuZXcgdXRpbHMuQnVmMzIoRU5PVUdIX0xFTlMpO1xuICBzdGF0ZS5kaXN0Y29kZSA9IHN0YXRlLmRpc3RkeW4gPSBuZXcgdXRpbHMuQnVmMzIoRU5PVUdIX0RJU1RTKTtcblxuICBzdGF0ZS5zYW5lID0gMTtcbiAgc3RhdGUuYmFjayA9IC0xO1xuICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6IHJlc2V0XFxuXCIpKTtcbiAgcmV0dXJuIFpfT0s7XG59XG5cbmZ1bmN0aW9uIGluZmxhdGVSZXNldChzdHJtKSB7XG4gIHZhciBzdGF0ZTtcblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgc3RhdGUud3NpemUgPSAwO1xuICBzdGF0ZS53aGF2ZSA9IDA7XG4gIHN0YXRlLnduZXh0ID0gMDtcbiAgcmV0dXJuIGluZmxhdGVSZXNldEtlZXAoc3RybSk7XG5cbn1cblxuZnVuY3Rpb24gaW5mbGF0ZVJlc2V0MihzdHJtLCB3aW5kb3dCaXRzKSB7XG4gIHZhciB3cmFwO1xuICB2YXIgc3RhdGU7XG5cbiAgLyogZ2V0IHRoZSBzdGF0ZSAqL1xuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIHN0YXRlID0gc3RybS5zdGF0ZTtcblxuICAvKiBleHRyYWN0IHdyYXAgcmVxdWVzdCBmcm9tIHdpbmRvd0JpdHMgcGFyYW1ldGVyICovXG4gIGlmICh3aW5kb3dCaXRzIDwgMCkge1xuICAgIHdyYXAgPSAwO1xuICAgIHdpbmRvd0JpdHMgPSAtd2luZG93Qml0cztcbiAgfVxuICBlbHNlIHtcbiAgICB3cmFwID0gKHdpbmRvd0JpdHMgPj4gNCkgKyAxO1xuICAgIGlmICh3aW5kb3dCaXRzIDwgNDgpIHtcbiAgICAgIHdpbmRvd0JpdHMgJj0gMTU7XG4gICAgfVxuICB9XG5cbiAgLyogc2V0IG51bWJlciBvZiB3aW5kb3cgYml0cywgZnJlZSB3aW5kb3cgaWYgZGlmZmVyZW50ICovXG4gIGlmICh3aW5kb3dCaXRzICYmICh3aW5kb3dCaXRzIDwgOCB8fCB3aW5kb3dCaXRzID4gMTUpKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG4gIGlmIChzdGF0ZS53aW5kb3cgIT09IG51bGwgJiYgc3RhdGUud2JpdHMgIT09IHdpbmRvd0JpdHMpIHtcbiAgICBzdGF0ZS53aW5kb3cgPSBudWxsO1xuICB9XG5cbiAgLyogdXBkYXRlIHN0YXRlIGFuZCByZXNldCB0aGUgcmVzdCBvZiBpdCAqL1xuICBzdGF0ZS53cmFwID0gd3JhcDtcbiAgc3RhdGUud2JpdHMgPSB3aW5kb3dCaXRzO1xuICByZXR1cm4gaW5mbGF0ZVJlc2V0KHN0cm0pO1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlSW5pdDIoc3RybSwgd2luZG93Qml0cykge1xuICB2YXIgcmV0O1xuICB2YXIgc3RhdGU7XG5cbiAgaWYgKCFzdHJtKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICAvL3N0cm0ubXNnID0gWl9OVUxMOyAgICAgICAgICAgICAgICAgLyogaW4gY2FzZSB3ZSByZXR1cm4gYW4gZXJyb3IgKi9cblxuICBzdGF0ZSA9IG5ldyBJbmZsYXRlU3RhdGUoKTtcblxuICAvL2lmIChzdGF0ZSA9PT0gWl9OVUxMKSByZXR1cm4gWl9NRU1fRVJST1I7XG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogYWxsb2NhdGVkXFxuXCIpKTtcbiAgc3RybS5zdGF0ZSA9IHN0YXRlO1xuICBzdGF0ZS53aW5kb3cgPSBudWxsLypaX05VTEwqLztcbiAgcmV0ID0gaW5mbGF0ZVJlc2V0MihzdHJtLCB3aW5kb3dCaXRzKTtcbiAgaWYgKHJldCAhPT0gWl9PSykge1xuICAgIHN0cm0uc3RhdGUgPSBudWxsLypaX05VTEwqLztcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlSW5pdChzdHJtKSB7XG4gIHJldHVybiBpbmZsYXRlSW5pdDIoc3RybSwgREVGX1dCSVRTKTtcbn1cblxuXG4vKlxuIFJldHVybiBzdGF0ZSB3aXRoIGxlbmd0aCBhbmQgZGlzdGFuY2UgZGVjb2RpbmcgdGFibGVzIGFuZCBpbmRleCBzaXplcyBzZXQgdG9cbiBmaXhlZCBjb2RlIGRlY29kaW5nLiAgTm9ybWFsbHkgdGhpcyByZXR1cm5zIGZpeGVkIHRhYmxlcyBmcm9tIGluZmZpeGVkLmguXG4gSWYgQlVJTERGSVhFRCBpcyBkZWZpbmVkLCB0aGVuIGluc3RlYWQgdGhpcyByb3V0aW5lIGJ1aWxkcyB0aGUgdGFibGVzIHRoZVxuIGZpcnN0IHRpbWUgaXQncyBjYWxsZWQsIGFuZCByZXR1cm5zIHRob3NlIHRhYmxlcyB0aGUgZmlyc3QgdGltZSBhbmRcbiB0aGVyZWFmdGVyLiAgVGhpcyByZWR1Y2VzIHRoZSBzaXplIG9mIHRoZSBjb2RlIGJ5IGFib3V0IDJLIGJ5dGVzLCBpblxuIGV4Y2hhbmdlIGZvciBhIGxpdHRsZSBleGVjdXRpb24gdGltZS4gIEhvd2V2ZXIsIEJVSUxERklYRUQgc2hvdWxkIG5vdCBiZVxuIHVzZWQgZm9yIHRocmVhZGVkIGFwcGxpY2F0aW9ucywgc2luY2UgdGhlIHJld3JpdGluZyBvZiB0aGUgdGFibGVzIGFuZCB2aXJnaW5cbiBtYXkgbm90IGJlIHRocmVhZC1zYWZlLlxuICovXG52YXIgdmlyZ2luID0gdHJ1ZTtcblxudmFyIGxlbmZpeCwgZGlzdGZpeDsgLy8gV2UgaGF2ZSBubyBwb2ludGVycyBpbiBKUywgc28ga2VlcCB0YWJsZXMgc2VwYXJhdGVcblxuZnVuY3Rpb24gZml4ZWR0YWJsZXMoc3RhdGUpIHtcbiAgLyogYnVpbGQgZml4ZWQgaHVmZm1hbiB0YWJsZXMgaWYgZmlyc3QgY2FsbCAobWF5IG5vdCBiZSB0aHJlYWQgc2FmZSkgKi9cbiAgaWYgKHZpcmdpbikge1xuICAgIHZhciBzeW07XG5cbiAgICBsZW5maXggPSBuZXcgdXRpbHMuQnVmMzIoNTEyKTtcbiAgICBkaXN0Zml4ID0gbmV3IHV0aWxzLkJ1ZjMyKDMyKTtcblxuICAgIC8qIGxpdGVyYWwvbGVuZ3RoIHRhYmxlICovXG4gICAgc3ltID0gMDtcbiAgICB3aGlsZSAoc3ltIDwgMTQ0KSB7IHN0YXRlLmxlbnNbc3ltKytdID0gODsgfVxuICAgIHdoaWxlIChzeW0gPCAyNTYpIHsgc3RhdGUubGVuc1tzeW0rK10gPSA5OyB9XG4gICAgd2hpbGUgKHN5bSA8IDI4MCkgeyBzdGF0ZS5sZW5zW3N5bSsrXSA9IDc7IH1cbiAgICB3aGlsZSAoc3ltIDwgMjg4KSB7IHN0YXRlLmxlbnNbc3ltKytdID0gODsgfVxuXG4gICAgaW5mbGF0ZV90YWJsZShMRU5TLCAgc3RhdGUubGVucywgMCwgMjg4LCBsZW5maXgsICAgMCwgc3RhdGUud29yaywgeyBiaXRzOiA5IH0pO1xuXG4gICAgLyogZGlzdGFuY2UgdGFibGUgKi9cbiAgICBzeW0gPSAwO1xuICAgIHdoaWxlIChzeW0gPCAzMikgeyBzdGF0ZS5sZW5zW3N5bSsrXSA9IDU7IH1cblxuICAgIGluZmxhdGVfdGFibGUoRElTVFMsIHN0YXRlLmxlbnMsIDAsIDMyLCAgIGRpc3RmaXgsIDAsIHN0YXRlLndvcmssIHsgYml0czogNSB9KTtcblxuICAgIC8qIGRvIHRoaXMganVzdCBvbmNlICovXG4gICAgdmlyZ2luID0gZmFsc2U7XG4gIH1cblxuICBzdGF0ZS5sZW5jb2RlID0gbGVuZml4O1xuICBzdGF0ZS5sZW5iaXRzID0gOTtcbiAgc3RhdGUuZGlzdGNvZGUgPSBkaXN0Zml4O1xuICBzdGF0ZS5kaXN0Yml0cyA9IDU7XG59XG5cblxuLypcbiBVcGRhdGUgdGhlIHdpbmRvdyB3aXRoIHRoZSBsYXN0IHdzaXplIChub3JtYWxseSAzMkspIGJ5dGVzIHdyaXR0ZW4gYmVmb3JlXG4gcmV0dXJuaW5nLiAgSWYgd2luZG93IGRvZXMgbm90IGV4aXN0IHlldCwgY3JlYXRlIGl0LiAgVGhpcyBpcyBvbmx5IGNhbGxlZFxuIHdoZW4gYSB3aW5kb3cgaXMgYWxyZWFkeSBpbiB1c2UsIG9yIHdoZW4gb3V0cHV0IGhhcyBiZWVuIHdyaXR0ZW4gZHVyaW5nIHRoaXNcbiBpbmZsYXRlIGNhbGwsIGJ1dCB0aGUgZW5kIG9mIHRoZSBkZWZsYXRlIHN0cmVhbSBoYXMgbm90IGJlZW4gcmVhY2hlZCB5ZXQuXG4gSXQgaXMgYWxzbyBjYWxsZWQgdG8gY3JlYXRlIGEgd2luZG93IGZvciBkaWN0aW9uYXJ5IGRhdGEgd2hlbiBhIGRpY3Rpb25hcnlcbiBpcyBsb2FkZWQuXG5cbiBQcm92aWRpbmcgb3V0cHV0IGJ1ZmZlcnMgbGFyZ2VyIHRoYW4gMzJLIHRvIGluZmxhdGUoKSBzaG91bGQgcHJvdmlkZSBhIHNwZWVkXG4gYWR2YW50YWdlLCBzaW5jZSBvbmx5IHRoZSBsYXN0IDMySyBvZiBvdXRwdXQgaXMgY29waWVkIHRvIHRoZSBzbGlkaW5nIHdpbmRvd1xuIHVwb24gcmV0dXJuIGZyb20gaW5mbGF0ZSgpLCBhbmQgc2luY2UgYWxsIGRpc3RhbmNlcyBhZnRlciB0aGUgZmlyc3QgMzJLIG9mXG4gb3V0cHV0IHdpbGwgZmFsbCBpbiB0aGUgb3V0cHV0IGRhdGEsIG1ha2luZyBtYXRjaCBjb3BpZXMgc2ltcGxlciBhbmQgZmFzdGVyLlxuIFRoZSBhZHZhbnRhZ2UgbWF5IGJlIGRlcGVuZGVudCBvbiB0aGUgc2l6ZSBvZiB0aGUgcHJvY2Vzc29yJ3MgZGF0YSBjYWNoZXMuXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZXdpbmRvdyhzdHJtLCBzcmMsIGVuZCwgY29weSkge1xuICB2YXIgZGlzdDtcbiAgdmFyIHN0YXRlID0gc3RybS5zdGF0ZTtcblxuICAvKiBpZiBpdCBoYXNuJ3QgYmVlbiBkb25lIGFscmVhZHksIGFsbG9jYXRlIHNwYWNlIGZvciB0aGUgd2luZG93ICovXG4gIGlmIChzdGF0ZS53aW5kb3cgPT09IG51bGwpIHtcbiAgICBzdGF0ZS53c2l6ZSA9IDEgPDwgc3RhdGUud2JpdHM7XG4gICAgc3RhdGUud25leHQgPSAwO1xuICAgIHN0YXRlLndoYXZlID0gMDtcblxuICAgIHN0YXRlLndpbmRvdyA9IG5ldyB1dGlscy5CdWY4KHN0YXRlLndzaXplKTtcbiAgfVxuXG4gIC8qIGNvcHkgc3RhdGUtPndzaXplIG9yIGxlc3Mgb3V0cHV0IGJ5dGVzIGludG8gdGhlIGNpcmN1bGFyIHdpbmRvdyAqL1xuICBpZiAoY29weSA+PSBzdGF0ZS53c2l6ZSkge1xuICAgIHV0aWxzLmFycmF5U2V0KHN0YXRlLndpbmRvdywgc3JjLCBlbmQgLSBzdGF0ZS53c2l6ZSwgc3RhdGUud3NpemUsIDApO1xuICAgIHN0YXRlLnduZXh0ID0gMDtcbiAgICBzdGF0ZS53aGF2ZSA9IHN0YXRlLndzaXplO1xuICB9XG4gIGVsc2Uge1xuICAgIGRpc3QgPSBzdGF0ZS53c2l6ZSAtIHN0YXRlLnduZXh0O1xuICAgIGlmIChkaXN0ID4gY29weSkge1xuICAgICAgZGlzdCA9IGNvcHk7XG4gICAgfVxuICAgIC8vem1lbWNweShzdGF0ZS0+d2luZG93ICsgc3RhdGUtPnduZXh0LCBlbmQgLSBjb3B5LCBkaXN0KTtcbiAgICB1dGlscy5hcnJheVNldChzdGF0ZS53aW5kb3csIHNyYywgZW5kIC0gY29weSwgZGlzdCwgc3RhdGUud25leHQpO1xuICAgIGNvcHkgLT0gZGlzdDtcbiAgICBpZiAoY29weSkge1xuICAgICAgLy96bWVtY3B5KHN0YXRlLT53aW5kb3csIGVuZCAtIGNvcHksIGNvcHkpO1xuICAgICAgdXRpbHMuYXJyYXlTZXQoc3RhdGUud2luZG93LCBzcmMsIGVuZCAtIGNvcHksIGNvcHksIDApO1xuICAgICAgc3RhdGUud25leHQgPSBjb3B5O1xuICAgICAgc3RhdGUud2hhdmUgPSBzdGF0ZS53c2l6ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzdGF0ZS53bmV4dCArPSBkaXN0O1xuICAgICAgaWYgKHN0YXRlLnduZXh0ID09PSBzdGF0ZS53c2l6ZSkgeyBzdGF0ZS53bmV4dCA9IDA7IH1cbiAgICAgIGlmIChzdGF0ZS53aGF2ZSA8IHN0YXRlLndzaXplKSB7IHN0YXRlLndoYXZlICs9IGRpc3Q7IH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIGluZmxhdGUoc3RybSwgZmx1c2gpIHtcbiAgdmFyIHN0YXRlO1xuICB2YXIgaW5wdXQsIG91dHB1dDsgICAgICAgICAgLy8gaW5wdXQvb3V0cHV0IGJ1ZmZlcnNcbiAgdmFyIG5leHQ7ICAgICAgICAgICAgICAgICAgIC8qIG5leHQgaW5wdXQgSU5ERVggKi9cbiAgdmFyIHB1dDsgICAgICAgICAgICAgICAgICAgIC8qIG5leHQgb3V0cHV0IElOREVYICovXG4gIHZhciBoYXZlLCBsZWZ0OyAgICAgICAgICAgICAvKiBhdmFpbGFibGUgaW5wdXQgYW5kIG91dHB1dCAqL1xuICB2YXIgaG9sZDsgICAgICAgICAgICAgICAgICAgLyogYml0IGJ1ZmZlciAqL1xuICB2YXIgYml0czsgICAgICAgICAgICAgICAgICAgLyogYml0cyBpbiBiaXQgYnVmZmVyICovXG4gIHZhciBfaW4sIF9vdXQ7ICAgICAgICAgICAgICAvKiBzYXZlIHN0YXJ0aW5nIGF2YWlsYWJsZSBpbnB1dCBhbmQgb3V0cHV0ICovXG4gIHZhciBjb3B5OyAgICAgICAgICAgICAgICAgICAvKiBudW1iZXIgb2Ygc3RvcmVkIG9yIG1hdGNoIGJ5dGVzIHRvIGNvcHkgKi9cbiAgdmFyIGZyb207ICAgICAgICAgICAgICAgICAgIC8qIHdoZXJlIHRvIGNvcHkgbWF0Y2ggYnl0ZXMgZnJvbSAqL1xuICB2YXIgZnJvbV9zb3VyY2U7XG4gIHZhciBoZXJlID0gMDsgICAgICAgICAgICAgICAvKiBjdXJyZW50IGRlY29kaW5nIHRhYmxlIGVudHJ5ICovXG4gIHZhciBoZXJlX2JpdHMsIGhlcmVfb3AsIGhlcmVfdmFsOyAvLyBwYWtlZCBcImhlcmVcIiBkZW5vcm1hbGl6ZWQgKEpTIHNwZWNpZmljKVxuICAvL3ZhciBsYXN0OyAgICAgICAgICAgICAgICAgICAvKiBwYXJlbnQgdGFibGUgZW50cnkgKi9cbiAgdmFyIGxhc3RfYml0cywgbGFzdF9vcCwgbGFzdF92YWw7IC8vIHBha2VkIFwibGFzdFwiIGRlbm9ybWFsaXplZCAoSlMgc3BlY2lmaWMpXG4gIHZhciBsZW47ICAgICAgICAgICAgICAgICAgICAvKiBsZW5ndGggdG8gY29weSBmb3IgcmVwZWF0cywgYml0cyB0byBkcm9wICovXG4gIHZhciByZXQ7ICAgICAgICAgICAgICAgICAgICAvKiByZXR1cm4gY29kZSAqL1xuICB2YXIgaGJ1ZiA9IG5ldyB1dGlscy5CdWY4KDQpOyAgICAvKiBidWZmZXIgZm9yIGd6aXAgaGVhZGVyIGNyYyBjYWxjdWxhdGlvbiAqL1xuICB2YXIgb3B0cztcblxuICB2YXIgbjsgLy8gdGVtcG9yYXJ5IHZhciBmb3IgTkVFRF9CSVRTXG5cbiAgdmFyIG9yZGVyID0gLyogcGVybXV0YXRpb24gb2YgY29kZSBsZW5ndGhzICovXG4gICAgWyAxNiwgMTcsIDE4LCAwLCA4LCA3LCA5LCA2LCAxMCwgNSwgMTEsIDQsIDEyLCAzLCAxMywgMiwgMTQsIDEsIDE1IF07XG5cblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUgfHwgIXN0cm0ub3V0cHV0IHx8XG4gICAgICAoIXN0cm0uaW5wdXQgJiYgc3RybS5hdmFpbF9pbiAhPT0gMCkpIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIGlmIChzdGF0ZS5tb2RlID09PSBUWVBFKSB7IHN0YXRlLm1vZGUgPSBUWVBFRE87IH0gICAgLyogc2tpcCBjaGVjayAqL1xuXG5cbiAgLy8tLS0gTE9BRCgpIC0tLVxuICBwdXQgPSBzdHJtLm5leHRfb3V0O1xuICBvdXRwdXQgPSBzdHJtLm91dHB1dDtcbiAgbGVmdCA9IHN0cm0uYXZhaWxfb3V0O1xuICBuZXh0ID0gc3RybS5uZXh0X2luO1xuICBpbnB1dCA9IHN0cm0uaW5wdXQ7XG4gIGhhdmUgPSBzdHJtLmF2YWlsX2luO1xuICBob2xkID0gc3RhdGUuaG9sZDtcbiAgYml0cyA9IHN0YXRlLmJpdHM7XG4gIC8vLS0tXG5cbiAgX2luID0gaGF2ZTtcbiAgX291dCA9IGxlZnQ7XG4gIHJldCA9IFpfT0s7XG5cbiAgaW5mX2xlYXZlOiAvLyBnb3RvIGVtdWxhdGlvblxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChzdGF0ZS5tb2RlKSB7XG4gICAgY2FzZSBIRUFEOlxuICAgICAgaWYgKHN0YXRlLndyYXAgPT09IDApIHtcbiAgICAgICAgc3RhdGUubW9kZSA9IFRZUEVETztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvLz09PSBORUVEQklUUygxNik7XG4gICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICBoYXZlLS07XG4gICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICBiaXRzICs9IDg7XG4gICAgICB9XG4gICAgICAvLz09PS8vXG4gICAgICBpZiAoKHN0YXRlLndyYXAgJiAyKSAmJiBob2xkID09PSAweDhiMWYpIHsgIC8qIGd6aXAgaGVhZGVyICovXG4gICAgICAgIHN0YXRlLmNoZWNrID0gMC8qY3JjMzIoMEwsIFpfTlVMTCwgMCkqLztcbiAgICAgICAgLy89PT0gQ1JDMihzdGF0ZS5jaGVjaywgaG9sZCk7XG4gICAgICAgIGhidWZbMF0gPSBob2xkICYgMHhmZjtcbiAgICAgICAgaGJ1ZlsxXSA9IChob2xkID4+PiA4KSAmIDB4ZmY7XG4gICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGhidWYsIDIsIDApO1xuICAgICAgICAvLz09PS8vXG5cbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLm1vZGUgPSBGTEFHUztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBzdGF0ZS5mbGFncyA9IDA7ICAgICAgICAgICAvKiBleHBlY3QgemxpYiBoZWFkZXIgKi9cbiAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgIHN0YXRlLmhlYWQuZG9uZSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKCEoc3RhdGUud3JhcCAmIDEpIHx8ICAgLyogY2hlY2sgaWYgemxpYiBoZWFkZXIgYWxsb3dlZCAqL1xuICAgICAgICAoKChob2xkICYgMHhmZikvKkJJVFMoOCkqLyA8PCA4KSArIChob2xkID4+IDgpKSAlIDMxKSB7XG4gICAgICAgIHN0cm0ubXNnID0gJ2luY29ycmVjdCBoZWFkZXIgY2hlY2snO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmICgoaG9sZCAmIDB4MGYpLypCSVRTKDQpKi8gIT09IFpfREVGTEFURUQpIHtcbiAgICAgICAgc3RybS5tc2cgPSAndW5rbm93biBjb21wcmVzc2lvbiBtZXRob2QnO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vLS0tIERST1BCSVRTKDQpIC0tLS8vXG4gICAgICBob2xkID4+Pj0gNDtcbiAgICAgIGJpdHMgLT0gNDtcbiAgICAgIC8vLS0tLy9cbiAgICAgIGxlbiA9IChob2xkICYgMHgwZikvKkJJVFMoNCkqLyArIDg7XG4gICAgICBpZiAoc3RhdGUud2JpdHMgPT09IDApIHtcbiAgICAgICAgc3RhdGUud2JpdHMgPSBsZW47XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChsZW4gPiBzdGF0ZS53Yml0cykge1xuICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIHdpbmRvdyBzaXplJztcbiAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBzdGF0ZS5kbWF4ID0gMSA8PCBsZW47XG4gICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgemxpYiBoZWFkZXIgb2tcXG5cIikpO1xuICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gMS8qYWRsZXIzMigwTCwgWl9OVUxMLCAwKSovO1xuICAgICAgc3RhdGUubW9kZSA9IGhvbGQgJiAweDIwMCA/IERJQ1RJRCA6IFRZUEU7XG4gICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgaG9sZCA9IDA7XG4gICAgICBiaXRzID0gMDtcbiAgICAgIC8vPT09Ly9cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgRkxBR1M6XG4gICAgICAvLz09PSBORUVEQklUUygxNik7ICovXG4gICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICBoYXZlLS07XG4gICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICBiaXRzICs9IDg7XG4gICAgICB9XG4gICAgICAvLz09PS8vXG4gICAgICBzdGF0ZS5mbGFncyA9IGhvbGQ7XG4gICAgICBpZiAoKHN0YXRlLmZsYWdzICYgMHhmZikgIT09IFpfREVGTEFURUQpIHtcbiAgICAgICAgc3RybS5tc2cgPSAndW5rbm93biBjb21wcmVzc2lvbiBtZXRob2QnO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4ZTAwMCkge1xuICAgICAgICBzdHJtLm1zZyA9ICd1bmtub3duIGhlYWRlciBmbGFncyBzZXQnO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgIHN0YXRlLmhlYWQudGV4dCA9ICgoaG9sZCA+PiA4KSAmIDEpO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgIC8vPT09IENSQzIoc3RhdGUuY2hlY2ssIGhvbGQpO1xuICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDB4ZmY7XG4gICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmO1xuICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBoYnVmLCAyLCAwKTtcbiAgICAgICAgLy89PT0vL1xuICAgICAgfVxuICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgIGhvbGQgPSAwO1xuICAgICAgYml0cyA9IDA7XG4gICAgICAvLz09PS8vXG4gICAgICBzdGF0ZS5tb2RlID0gVElNRTtcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIFRJTUU6XG4gICAgICAvLz09PSBORUVEQklUUygzMik7ICovXG4gICAgICB3aGlsZSAoYml0cyA8IDMyKSB7XG4gICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICBoYXZlLS07XG4gICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICBiaXRzICs9IDg7XG4gICAgICB9XG4gICAgICAvLz09PS8vXG4gICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICBzdGF0ZS5oZWFkLnRpbWUgPSBob2xkO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgIC8vPT09IENSQzQoc3RhdGUuY2hlY2ssIGhvbGQpXG4gICAgICAgIGhidWZbMF0gPSBob2xkICYgMHhmZjtcbiAgICAgICAgaGJ1ZlsxXSA9IChob2xkID4+PiA4KSAmIDB4ZmY7XG4gICAgICAgIGhidWZbMl0gPSAoaG9sZCA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgaGJ1ZlszXSA9IChob2xkID4+PiAyNCkgJiAweGZmO1xuICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBoYnVmLCA0LCAwKTtcbiAgICAgICAgLy89PT1cbiAgICAgIH1cbiAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICBob2xkID0gMDtcbiAgICAgIGJpdHMgPSAwO1xuICAgICAgLy89PT0vL1xuICAgICAgc3RhdGUubW9kZSA9IE9TO1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgT1M6XG4gICAgICAvLz09PSBORUVEQklUUygxNik7ICovXG4gICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICBoYXZlLS07XG4gICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICBiaXRzICs9IDg7XG4gICAgICB9XG4gICAgICAvLz09PS8vXG4gICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICBzdGF0ZS5oZWFkLnhmbGFncyA9IChob2xkICYgMHhmZik7XG4gICAgICAgIHN0YXRlLmhlYWQub3MgPSAoaG9sZCA+PiA4KTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAvLz09PSBDUkMyKHN0YXRlLmNoZWNrLCBob2xkKTtcbiAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmO1xuICAgICAgICBoYnVmWzFdID0gKGhvbGQgPj4+IDgpICYgMHhmZjtcbiAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaGJ1ZiwgMiwgMCk7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgIH1cbiAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICBob2xkID0gMDtcbiAgICAgIGJpdHMgPSAwO1xuICAgICAgLy89PT0vL1xuICAgICAgc3RhdGUubW9kZSA9IEVYTEVOO1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgRVhMRU46XG4gICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDA0MDApIHtcbiAgICAgICAgLy89PT0gTkVFREJJVFMoMTYpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLmxlbmd0aCA9IGhvbGQ7XG4gICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC5leHRyYV9sZW4gPSBob2xkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgIC8vPT09IENSQzIoc3RhdGUuY2hlY2ssIGhvbGQpO1xuICAgICAgICAgIGhidWZbMF0gPSBob2xkICYgMHhmZjtcbiAgICAgICAgICBoYnVmWzFdID0gKGhvbGQgPj4+IDgpICYgMHhmZjtcbiAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBoYnVmLCAyLCAwKTtcbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgIH1cbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICB9XG4gICAgICBlbHNlIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgIHN0YXRlLmhlYWQuZXh0cmEgPSBudWxsLypaX05VTEwqLztcbiAgICAgIH1cbiAgICAgIHN0YXRlLm1vZGUgPSBFWFRSQTtcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIEVYVFJBOlxuICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwNDAwKSB7XG4gICAgICAgIGNvcHkgPSBzdGF0ZS5sZW5ndGg7XG4gICAgICAgIGlmIChjb3B5ID4gaGF2ZSkgeyBjb3B5ID0gaGF2ZTsgfVxuICAgICAgICBpZiAoY29weSkge1xuICAgICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgICBsZW4gPSBzdGF0ZS5oZWFkLmV4dHJhX2xlbiAtIHN0YXRlLmxlbmd0aDtcbiAgICAgICAgICAgIGlmICghc3RhdGUuaGVhZC5leHRyYSkge1xuICAgICAgICAgICAgICAvLyBVc2UgdW50eXBlZCBhcnJheSBmb3IgbW9yZSBjb252ZW5pZW5kIHByb2Nlc3NpbmcgbGF0ZXJcbiAgICAgICAgICAgICAgc3RhdGUuaGVhZC5leHRyYSA9IG5ldyBBcnJheShzdGF0ZS5oZWFkLmV4dHJhX2xlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1dGlscy5hcnJheVNldChcbiAgICAgICAgICAgICAgc3RhdGUuaGVhZC5leHRyYSxcbiAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgIG5leHQsXG4gICAgICAgICAgICAgIC8vIGV4dHJhIGZpZWxkIGlzIGxpbWl0ZWQgdG8gNjU1MzYgYnl0ZXNcbiAgICAgICAgICAgICAgLy8gLSBubyBuZWVkIGZvciBhZGRpdGlvbmFsIHNpemUgY2hlY2tcbiAgICAgICAgICAgICAgY29weSxcbiAgICAgICAgICAgICAgLypsZW4gKyBjb3B5ID4gc3RhdGUuaGVhZC5leHRyYV9tYXggLSBsZW4gPyBzdGF0ZS5oZWFkLmV4dHJhX21heCA6IGNvcHksKi9cbiAgICAgICAgICAgICAgbGVuXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgLy96bWVtY3B5KHN0YXRlLmhlYWQuZXh0cmEgKyBsZW4sIG5leHQsXG4gICAgICAgICAgICAvLyAgICAgICAgbGVuICsgY29weSA+IHN0YXRlLmhlYWQuZXh0cmFfbWF4ID9cbiAgICAgICAgICAgIC8vICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhX21heCAtIGxlbiA6IGNvcHkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGlucHV0LCBjb3B5LCBuZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaGF2ZSAtPSBjb3B5O1xuICAgICAgICAgIG5leHQgKz0gY29weTtcbiAgICAgICAgICBzdGF0ZS5sZW5ndGggLT0gY29weTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUubGVuZ3RoKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgfVxuICAgICAgc3RhdGUubGVuZ3RoID0gMDtcbiAgICAgIHN0YXRlLm1vZGUgPSBOQU1FO1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgTkFNRTpcbiAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDgwMCkge1xuICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgY29weSA9IDA7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAvLyBUT0RPOiAyIG9yIDEgYnl0ZXM/XG4gICAgICAgICAgbGVuID0gaW5wdXRbbmV4dCArIGNvcHkrK107XG4gICAgICAgICAgLyogdXNlIGNvbnN0YW50IGxpbWl0IGJlY2F1c2UgaW4ganMgd2Ugc2hvdWxkIG5vdCBwcmVhbGxvY2F0ZSBtZW1vcnkgKi9cbiAgICAgICAgICBpZiAoc3RhdGUuaGVhZCAmJiBsZW4gJiZcbiAgICAgICAgICAgICAgKHN0YXRlLmxlbmd0aCA8IDY1NTM2IC8qc3RhdGUuaGVhZC5uYW1lX21heCovKSkge1xuICAgICAgICAgICAgc3RhdGUuaGVhZC5uYW1lICs9IFN0cmluZy5mcm9tQ2hhckNvZGUobGVuKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKGxlbiAmJiBjb3B5IDwgaGF2ZSk7XG5cbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaW5wdXQsIGNvcHksIG5leHQpO1xuICAgICAgICB9XG4gICAgICAgIGhhdmUgLT0gY29weTtcbiAgICAgICAgbmV4dCArPSBjb3B5O1xuICAgICAgICBpZiAobGVuKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICBzdGF0ZS5oZWFkLm5hbWUgPSBudWxsO1xuICAgICAgfVxuICAgICAgc3RhdGUubGVuZ3RoID0gMDtcbiAgICAgIHN0YXRlLm1vZGUgPSBDT01NRU5UO1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgQ09NTUVOVDpcbiAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MTAwMCkge1xuICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgY29weSA9IDA7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICBsZW4gPSBpbnB1dFtuZXh0ICsgY29weSsrXTtcbiAgICAgICAgICAvKiB1c2UgY29uc3RhbnQgbGltaXQgYmVjYXVzZSBpbiBqcyB3ZSBzaG91bGQgbm90IHByZWFsbG9jYXRlIG1lbW9yeSAqL1xuICAgICAgICAgIGlmIChzdGF0ZS5oZWFkICYmIGxlbiAmJlxuICAgICAgICAgICAgICAoc3RhdGUubGVuZ3RoIDwgNjU1MzYgLypzdGF0ZS5oZWFkLmNvbW1fbWF4Ki8pKSB7XG4gICAgICAgICAgICBzdGF0ZS5oZWFkLmNvbW1lbnQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShsZW4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAobGVuICYmIGNvcHkgPCBoYXZlKTtcbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaW5wdXQsIGNvcHksIG5leHQpO1xuICAgICAgICB9XG4gICAgICAgIGhhdmUgLT0gY29weTtcbiAgICAgICAgbmV4dCArPSBjb3B5O1xuICAgICAgICBpZiAobGVuKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICBzdGF0ZS5oZWFkLmNvbW1lbnQgPSBudWxsO1xuICAgICAgfVxuICAgICAgc3RhdGUubW9kZSA9IEhDUkM7XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSBIQ1JDOlxuICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDE2KTsgKi9cbiAgICAgICAgd2hpbGUgKGJpdHMgPCAxNikge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBpZiAoaG9sZCAhPT0gKHN0YXRlLmNoZWNrICYgMHhmZmZmKSkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2hlYWRlciBjcmMgbWlzbWF0Y2gnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICBzdGF0ZS5oZWFkLmhjcmMgPSAoKHN0YXRlLmZsYWdzID4+IDkpICYgMSk7XG4gICAgICAgIHN0YXRlLmhlYWQuZG9uZSA9IHRydWU7XG4gICAgICB9XG4gICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSAwO1xuICAgICAgc3RhdGUubW9kZSA9IFRZUEU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIERJQ1RJRDpcbiAgICAgIC8vPT09IE5FRURCSVRTKDMyKTsgKi9cbiAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIGhhdmUtLTtcbiAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgIGJpdHMgKz0gODtcbiAgICAgIH1cbiAgICAgIC8vPT09Ly9cbiAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IHpzd2FwMzIoaG9sZCk7XG4gICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgaG9sZCA9IDA7XG4gICAgICBiaXRzID0gMDtcbiAgICAgIC8vPT09Ly9cbiAgICAgIHN0YXRlLm1vZGUgPSBESUNUO1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgRElDVDpcbiAgICAgIGlmIChzdGF0ZS5oYXZlZGljdCA9PT0gMCkge1xuICAgICAgICAvLy0tLSBSRVNUT1JFKCkgLS0tXG4gICAgICAgIHN0cm0ubmV4dF9vdXQgPSBwdXQ7XG4gICAgICAgIHN0cm0uYXZhaWxfb3V0ID0gbGVmdDtcbiAgICAgICAgc3RybS5uZXh0X2luID0gbmV4dDtcbiAgICAgICAgc3RybS5hdmFpbF9pbiA9IGhhdmU7XG4gICAgICAgIHN0YXRlLmhvbGQgPSBob2xkO1xuICAgICAgICBzdGF0ZS5iaXRzID0gYml0cztcbiAgICAgICAgLy8tLS1cbiAgICAgICAgcmV0dXJuIFpfTkVFRF9ESUNUO1xuICAgICAgfVxuICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gMS8qYWRsZXIzMigwTCwgWl9OVUxMLCAwKSovO1xuICAgICAgc3RhdGUubW9kZSA9IFRZUEU7XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSBUWVBFOlxuICAgICAgaWYgKGZsdXNoID09PSBaX0JMT0NLIHx8IGZsdXNoID09PSBaX1RSRUVTKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgVFlQRURPOlxuICAgICAgaWYgKHN0YXRlLmxhc3QpIHtcbiAgICAgICAgLy8tLS0gQllURUJJVFMoKSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gYml0cyAmIDc7XG4gICAgICAgIGJpdHMgLT0gYml0cyAmIDc7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgc3RhdGUubW9kZSA9IENIRUNLO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vPT09IE5FRURCSVRTKDMpOyAqL1xuICAgICAgd2hpbGUgKGJpdHMgPCAzKSB7XG4gICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICBoYXZlLS07XG4gICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICBiaXRzICs9IDg7XG4gICAgICB9XG4gICAgICAvLz09PS8vXG4gICAgICBzdGF0ZS5sYXN0ID0gKGhvbGQgJiAweDAxKS8qQklUUygxKSovO1xuICAgICAgLy8tLS0gRFJPUEJJVFMoMSkgLS0tLy9cbiAgICAgIGhvbGQgPj4+PSAxO1xuICAgICAgYml0cyAtPSAxO1xuICAgICAgLy8tLS0vL1xuXG4gICAgICBzd2l0Y2ggKChob2xkICYgMHgwMykvKkJJVFMoMikqLykge1xuICAgICAgY2FzZSAwOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogc3RvcmVkIGJsb2NrICovXG4gICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgIHN0b3JlZCBibG9jayVzXFxuXCIsXG4gICAgICAgIC8vICAgICAgICBzdGF0ZS5sYXN0ID8gXCIgKGxhc3QpXCIgOiBcIlwiKSk7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBTVE9SRUQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogZml4ZWQgYmxvY2sgKi9cbiAgICAgICAgZml4ZWR0YWJsZXMoc3RhdGUpO1xuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICBmaXhlZCBjb2RlcyBibG9jayVzXFxuXCIsXG4gICAgICAgIC8vICAgICAgICBzdGF0ZS5sYXN0ID8gXCIgKGxhc3QpXCIgOiBcIlwiKSk7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBMRU5fOyAgICAgICAgICAgICAvKiBkZWNvZGUgY29kZXMgKi9cbiAgICAgICAgaWYgKGZsdXNoID09PSBaX1RSRUVTKSB7XG4gICAgICAgICAgLy8tLS0gRFJPUEJJVFMoMikgLS0tLy9cbiAgICAgICAgICBob2xkID4+Pj0gMjtcbiAgICAgICAgICBiaXRzIC09IDI7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjogICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGR5bmFtaWMgYmxvY2sgKi9cbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgZHluYW1pYyBjb2RlcyBibG9jayVzXFxuXCIsXG4gICAgICAgIC8vICAgICAgICBzdGF0ZS5sYXN0ID8gXCIgKGxhc3QpXCIgOiBcIlwiKSk7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBUQUJMRTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgYmxvY2sgdHlwZSc7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICB9XG4gICAgICAvLy0tLSBEUk9QQklUUygyKSAtLS0vL1xuICAgICAgaG9sZCA+Pj49IDI7XG4gICAgICBiaXRzIC09IDI7XG4gICAgICAvLy0tLS8vXG4gICAgICBicmVhaztcbiAgICBjYXNlIFNUT1JFRDpcbiAgICAgIC8vLS0tIEJZVEVCSVRTKCkgLS0tLy8gLyogZ28gdG8gYnl0ZSBib3VuZGFyeSAqL1xuICAgICAgaG9sZCA+Pj49IGJpdHMgJiA3O1xuICAgICAgYml0cyAtPSBiaXRzICYgNztcbiAgICAgIC8vLS0tLy9cbiAgICAgIC8vPT09IE5FRURCSVRTKDMyKTsgKi9cbiAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIGhhdmUtLTtcbiAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgIGJpdHMgKz0gODtcbiAgICAgIH1cbiAgICAgIC8vPT09Ly9cbiAgICAgIGlmICgoaG9sZCAmIDB4ZmZmZikgIT09ICgoaG9sZCA+Pj4gMTYpIF4gMHhmZmZmKSkge1xuICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIHN0b3JlZCBibG9jayBsZW5ndGhzJztcbiAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBzdGF0ZS5sZW5ndGggPSBob2xkICYgMHhmZmZmO1xuICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICBzdG9yZWQgbGVuZ3RoICV1XFxuXCIsXG4gICAgICAvLyAgICAgICAgc3RhdGUubGVuZ3RoKSk7XG4gICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgaG9sZCA9IDA7XG4gICAgICBiaXRzID0gMDtcbiAgICAgIC8vPT09Ly9cbiAgICAgIHN0YXRlLm1vZGUgPSBDT1BZXztcbiAgICAgIGlmIChmbHVzaCA9PT0gWl9UUkVFUykgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIENPUFlfOlxuICAgICAgc3RhdGUubW9kZSA9IENPUFk7XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSBDT1BZOlxuICAgICAgY29weSA9IHN0YXRlLmxlbmd0aDtcbiAgICAgIGlmIChjb3B5KSB7XG4gICAgICAgIGlmIChjb3B5ID4gaGF2ZSkgeyBjb3B5ID0gaGF2ZTsgfVxuICAgICAgICBpZiAoY29weSA+IGxlZnQpIHsgY29weSA9IGxlZnQ7IH1cbiAgICAgICAgaWYgKGNvcHkgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIC8vLS0tIHptZW1jcHkocHV0LCBuZXh0LCBjb3B5KTsgLS0tXG4gICAgICAgIHV0aWxzLmFycmF5U2V0KG91dHB1dCwgaW5wdXQsIG5leHQsIGNvcHksIHB1dCk7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgaGF2ZSAtPSBjb3B5O1xuICAgICAgICBuZXh0ICs9IGNvcHk7XG4gICAgICAgIGxlZnQgLT0gY29weTtcbiAgICAgICAgcHV0ICs9IGNvcHk7XG4gICAgICAgIHN0YXRlLmxlbmd0aCAtPSBjb3B5O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgc3RvcmVkIGVuZFxcblwiKSk7XG4gICAgICBzdGF0ZS5tb2RlID0gVFlQRTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgVEFCTEU6XG4gICAgICAvLz09PSBORUVEQklUUygxNCk7ICovXG4gICAgICB3aGlsZSAoYml0cyA8IDE0KSB7XG4gICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICBoYXZlLS07XG4gICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICBiaXRzICs9IDg7XG4gICAgICB9XG4gICAgICAvLz09PS8vXG4gICAgICBzdGF0ZS5ubGVuID0gKGhvbGQgJiAweDFmKS8qQklUUyg1KSovICsgMjU3O1xuICAgICAgLy8tLS0gRFJPUEJJVFMoNSkgLS0tLy9cbiAgICAgIGhvbGQgPj4+PSA1O1xuICAgICAgYml0cyAtPSA1O1xuICAgICAgLy8tLS0vL1xuICAgICAgc3RhdGUubmRpc3QgPSAoaG9sZCAmIDB4MWYpLypCSVRTKDUpKi8gKyAxO1xuICAgICAgLy8tLS0gRFJPUEJJVFMoNSkgLS0tLy9cbiAgICAgIGhvbGQgPj4+PSA1O1xuICAgICAgYml0cyAtPSA1O1xuICAgICAgLy8tLS0vL1xuICAgICAgc3RhdGUubmNvZGUgPSAoaG9sZCAmIDB4MGYpLypCSVRTKDQpKi8gKyA0O1xuICAgICAgLy8tLS0gRFJPUEJJVFMoNCkgLS0tLy9cbiAgICAgIGhvbGQgPj4+PSA0O1xuICAgICAgYml0cyAtPSA0O1xuICAgICAgLy8tLS0vL1xuLy8jaWZuZGVmIFBLWklQX0JVR19XT1JLQVJPVU5EXG4gICAgICBpZiAoc3RhdGUubmxlbiA+IDI4NiB8fCBzdGF0ZS5uZGlzdCA+IDMwKSB7XG4gICAgICAgIHN0cm0ubXNnID0gJ3RvbyBtYW55IGxlbmd0aCBvciBkaXN0YW5jZSBzeW1ib2xzJztcbiAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4vLyNlbmRpZlxuICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICB0YWJsZSBzaXplcyBva1xcblwiKSk7XG4gICAgICBzdGF0ZS5oYXZlID0gMDtcbiAgICAgIHN0YXRlLm1vZGUgPSBMRU5MRU5TO1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgTEVOTEVOUzpcbiAgICAgIHdoaWxlIChzdGF0ZS5oYXZlIDwgc3RhdGUubmNvZGUpIHtcbiAgICAgICAgLy89PT0gTkVFREJJVFMoMyk7XG4gICAgICAgIHdoaWxlIChiaXRzIDwgMykge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5sZW5zW29yZGVyW3N0YXRlLmhhdmUrK11dID0gKGhvbGQgJiAweDA3KTsvL0JJVFMoMyk7XG4gICAgICAgIC8vLS0tIERST1BCSVRTKDMpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSAzO1xuICAgICAgICBiaXRzIC09IDM7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgIH1cbiAgICAgIHdoaWxlIChzdGF0ZS5oYXZlIDwgMTkpIHtcbiAgICAgICAgc3RhdGUubGVuc1tvcmRlcltzdGF0ZS5oYXZlKytdXSA9IDA7XG4gICAgICB9XG4gICAgICAvLyBXZSBoYXZlIHNlcGFyYXRlIHRhYmxlcyAmIG5vIHBvaW50ZXJzLiAyIGNvbW1lbnRlZCBsaW5lcyBiZWxvdyBub3QgbmVlZGVkLlxuICAgICAgLy9zdGF0ZS5uZXh0ID0gc3RhdGUuY29kZXM7XG4gICAgICAvL3N0YXRlLmxlbmNvZGUgPSBzdGF0ZS5uZXh0O1xuICAgICAgLy8gU3dpdGNoIHRvIHVzZSBkeW5hbWljIHRhYmxlXG4gICAgICBzdGF0ZS5sZW5jb2RlID0gc3RhdGUubGVuZHluO1xuICAgICAgc3RhdGUubGVuYml0cyA9IDc7XG5cbiAgICAgIG9wdHMgPSB7IGJpdHM6IHN0YXRlLmxlbmJpdHMgfTtcbiAgICAgIHJldCA9IGluZmxhdGVfdGFibGUoQ09ERVMsIHN0YXRlLmxlbnMsIDAsIDE5LCBzdGF0ZS5sZW5jb2RlLCAwLCBzdGF0ZS53b3JrLCBvcHRzKTtcbiAgICAgIHN0YXRlLmxlbmJpdHMgPSBvcHRzLmJpdHM7XG5cbiAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBjb2RlIGxlbmd0aHMgc2V0JztcbiAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgIGNvZGUgbGVuZ3RocyBva1xcblwiKSk7XG4gICAgICBzdGF0ZS5oYXZlID0gMDtcbiAgICAgIHN0YXRlLm1vZGUgPSBDT0RFTEVOUztcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIENPREVMRU5TOlxuICAgICAgd2hpbGUgKHN0YXRlLmhhdmUgPCBzdGF0ZS5ubGVuICsgc3RhdGUubmRpc3QpIHtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgIGhlcmUgPSBzdGF0ZS5sZW5jb2RlW2hvbGQgJiAoKDEgPDwgc3RhdGUubGVuYml0cykgLSAxKV07LypCSVRTKHN0YXRlLmxlbmJpdHMpKi9cbiAgICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDtcbiAgICAgICAgICBoZXJlX29wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgaGVyZV92YWwgPSBoZXJlICYgMHhmZmZmO1xuXG4gICAgICAgICAgaWYgKChoZXJlX2JpdHMpIDw9IGJpdHMpIHsgYnJlYWs7IH1cbiAgICAgICAgICAvLy0tLSBQVUxMQllURSgpIC0tLS8vXG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhlcmVfdmFsIDwgMTYpIHtcbiAgICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgc3RhdGUubGVuc1tzdGF0ZS5oYXZlKytdID0gaGVyZV92YWw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaWYgKGhlcmVfdmFsID09PSAxNikge1xuICAgICAgICAgICAgLy89PT0gTkVFREJJVFMoaGVyZS5iaXRzICsgMik7XG4gICAgICAgICAgICBuID0gaGVyZV9iaXRzICsgMjtcbiAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikge1xuICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy89PT0vL1xuICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgaWYgKHN0YXRlLmhhdmUgPT09IDApIHtcbiAgICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBiaXQgbGVuZ3RoIHJlcGVhdCc7XG4gICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGVuID0gc3RhdGUubGVuc1tzdGF0ZS5oYXZlIC0gMV07XG4gICAgICAgICAgICBjb3B5ID0gMyArIChob2xkICYgMHgwMyk7Ly9CSVRTKDIpO1xuICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoMikgLS0tLy9cbiAgICAgICAgICAgIGhvbGQgPj4+PSAyO1xuICAgICAgICAgICAgYml0cyAtPSAyO1xuICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChoZXJlX3ZhbCA9PT0gMTcpIHtcbiAgICAgICAgICAgIC8vPT09IE5FRURCSVRTKGhlcmUuYml0cyArIDMpO1xuICAgICAgICAgICAgbiA9IGhlcmVfYml0cyArIDM7XG4gICAgICAgICAgICB3aGlsZSAoYml0cyA8IG4pIHtcbiAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgIGxlbiA9IDA7XG4gICAgICAgICAgICBjb3B5ID0gMyArIChob2xkICYgMHgwNyk7Ly9CSVRTKDMpO1xuICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoMykgLS0tLy9cbiAgICAgICAgICAgIGhvbGQgPj4+PSAzO1xuICAgICAgICAgICAgYml0cyAtPSAzO1xuICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vPT09IE5FRURCSVRTKGhlcmUuYml0cyArIDcpO1xuICAgICAgICAgICAgbiA9IGhlcmVfYml0cyArIDc7XG4gICAgICAgICAgICB3aGlsZSAoYml0cyA8IG4pIHtcbiAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgIGxlbiA9IDA7XG4gICAgICAgICAgICBjb3B5ID0gMTEgKyAoaG9sZCAmIDB4N2YpOy8vQklUUyg3KTtcbiAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKDcpIC0tLS8vXG4gICAgICAgICAgICBob2xkID4+Pj0gNztcbiAgICAgICAgICAgIGJpdHMgLT0gNztcbiAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0YXRlLmhhdmUgKyBjb3B5ID4gc3RhdGUubmxlbiArIHN0YXRlLm5kaXN0KSB7XG4gICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGJpdCBsZW5ndGggcmVwZWF0JztcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgd2hpbGUgKGNvcHktLSkge1xuICAgICAgICAgICAgc3RhdGUubGVuc1tzdGF0ZS5oYXZlKytdID0gbGVuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKiBoYW5kbGUgZXJyb3IgYnJlYWtzIGluIHdoaWxlICovXG4gICAgICBpZiAoc3RhdGUubW9kZSA9PT0gQkFEKSB7IGJyZWFrOyB9XG5cbiAgICAgIC8qIGNoZWNrIGZvciBlbmQtb2YtYmxvY2sgY29kZSAoYmV0dGVyIGhhdmUgb25lKSAqL1xuICAgICAgaWYgKHN0YXRlLmxlbnNbMjU2XSA9PT0gMCkge1xuICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGNvZGUgLS0gbWlzc2luZyBlbmQtb2YtYmxvY2snO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgLyogYnVpbGQgY29kZSB0YWJsZXMgLS0gbm90ZTogZG8gbm90IGNoYW5nZSB0aGUgbGVuYml0cyBvciBkaXN0Yml0c1xuICAgICAgICAgdmFsdWVzIGhlcmUgKDkgYW5kIDYpIHdpdGhvdXQgcmVhZGluZyB0aGUgY29tbWVudHMgaW4gaW5mdHJlZXMuaFxuICAgICAgICAgY29uY2VybmluZyB0aGUgRU5PVUdIIGNvbnN0YW50cywgd2hpY2ggZGVwZW5kIG9uIHRob3NlIHZhbHVlcyAqL1xuICAgICAgc3RhdGUubGVuYml0cyA9IDk7XG5cbiAgICAgIG9wdHMgPSB7IGJpdHM6IHN0YXRlLmxlbmJpdHMgfTtcbiAgICAgIHJldCA9IGluZmxhdGVfdGFibGUoTEVOUywgc3RhdGUubGVucywgMCwgc3RhdGUubmxlbiwgc3RhdGUubGVuY29kZSwgMCwgc3RhdGUud29yaywgb3B0cyk7XG4gICAgICAvLyBXZSBoYXZlIHNlcGFyYXRlIHRhYmxlcyAmIG5vIHBvaW50ZXJzLiAyIGNvbW1lbnRlZCBsaW5lcyBiZWxvdyBub3QgbmVlZGVkLlxuICAgICAgLy8gc3RhdGUubmV4dF9pbmRleCA9IG9wdHMudGFibGVfaW5kZXg7XG4gICAgICBzdGF0ZS5sZW5iaXRzID0gb3B0cy5iaXRzO1xuICAgICAgLy8gc3RhdGUubGVuY29kZSA9IHN0YXRlLm5leHQ7XG5cbiAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBsaXRlcmFsL2xlbmd0aHMgc2V0JztcbiAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHN0YXRlLmRpc3RiaXRzID0gNjtcbiAgICAgIC8vc3RhdGUuZGlzdGNvZGUuY29weShzdGF0ZS5jb2Rlcyk7XG4gICAgICAvLyBTd2l0Y2ggdG8gdXNlIGR5bmFtaWMgdGFibGVcbiAgICAgIHN0YXRlLmRpc3Rjb2RlID0gc3RhdGUuZGlzdGR5bjtcbiAgICAgIG9wdHMgPSB7IGJpdHM6IHN0YXRlLmRpc3RiaXRzIH07XG4gICAgICByZXQgPSBpbmZsYXRlX3RhYmxlKERJU1RTLCBzdGF0ZS5sZW5zLCBzdGF0ZS5ubGVuLCBzdGF0ZS5uZGlzdCwgc3RhdGUuZGlzdGNvZGUsIDAsIHN0YXRlLndvcmssIG9wdHMpO1xuICAgICAgLy8gV2UgaGF2ZSBzZXBhcmF0ZSB0YWJsZXMgJiBubyBwb2ludGVycy4gMiBjb21tZW50ZWQgbGluZXMgYmVsb3cgbm90IG5lZWRlZC5cbiAgICAgIC8vIHN0YXRlLm5leHRfaW5kZXggPSBvcHRzLnRhYmxlX2luZGV4O1xuICAgICAgc3RhdGUuZGlzdGJpdHMgPSBvcHRzLmJpdHM7XG4gICAgICAvLyBzdGF0ZS5kaXN0Y29kZSA9IHN0YXRlLm5leHQ7XG5cbiAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZXMgc2V0JztcbiAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvL1RyYWNldigoc3RkZXJyLCAnaW5mbGF0ZTogICAgICAgY29kZXMgb2tcXG4nKSk7XG4gICAgICBzdGF0ZS5tb2RlID0gTEVOXztcbiAgICAgIGlmIChmbHVzaCA9PT0gWl9UUkVFUykgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIExFTl86XG4gICAgICBzdGF0ZS5tb2RlID0gTEVOO1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgTEVOOlxuICAgICAgaWYgKGhhdmUgPj0gNiAmJiBsZWZ0ID49IDI1OCkge1xuICAgICAgICAvLy0tLSBSRVNUT1JFKCkgLS0tXG4gICAgICAgIHN0cm0ubmV4dF9vdXQgPSBwdXQ7XG4gICAgICAgIHN0cm0uYXZhaWxfb3V0ID0gbGVmdDtcbiAgICAgICAgc3RybS5uZXh0X2luID0gbmV4dDtcbiAgICAgICAgc3RybS5hdmFpbF9pbiA9IGhhdmU7XG4gICAgICAgIHN0YXRlLmhvbGQgPSBob2xkO1xuICAgICAgICBzdGF0ZS5iaXRzID0gYml0cztcbiAgICAgICAgLy8tLS1cbiAgICAgICAgaW5mbGF0ZV9mYXN0KHN0cm0sIF9vdXQpO1xuICAgICAgICAvLy0tLSBMT0FEKCkgLS0tXG4gICAgICAgIHB1dCA9IHN0cm0ubmV4dF9vdXQ7XG4gICAgICAgIG91dHB1dCA9IHN0cm0ub3V0cHV0O1xuICAgICAgICBsZWZ0ID0gc3RybS5hdmFpbF9vdXQ7XG4gICAgICAgIG5leHQgPSBzdHJtLm5leHRfaW47XG4gICAgICAgIGlucHV0ID0gc3RybS5pbnB1dDtcbiAgICAgICAgaGF2ZSA9IHN0cm0uYXZhaWxfaW47XG4gICAgICAgIGhvbGQgPSBzdGF0ZS5ob2xkO1xuICAgICAgICBiaXRzID0gc3RhdGUuYml0cztcbiAgICAgICAgLy8tLS1cblxuICAgICAgICBpZiAoc3RhdGUubW9kZSA9PT0gVFlQRSkge1xuICAgICAgICAgIHN0YXRlLmJhY2sgPSAtMTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHN0YXRlLmJhY2sgPSAwO1xuICAgICAgZm9yICg7Oykge1xuICAgICAgICBoZXJlID0gc3RhdGUubGVuY29kZVtob2xkICYgKCgxIDw8IHN0YXRlLmxlbmJpdHMpIC0gMSldOyAgLypCSVRTKHN0YXRlLmxlbmJpdHMpKi9cbiAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7XG4gICAgICAgIGhlcmVfb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgaGVyZV92YWwgPSBoZXJlICYgMHhmZmZmO1xuXG4gICAgICAgIGlmIChoZXJlX2JpdHMgPD0gYml0cykgeyBicmVhazsgfVxuICAgICAgICAvLy0tLSBQVUxMQllURSgpIC0tLS8vXG4gICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICBoYXZlLS07XG4gICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgIH1cbiAgICAgIGlmIChoZXJlX29wICYmIChoZXJlX29wICYgMHhmMCkgPT09IDApIHtcbiAgICAgICAgbGFzdF9iaXRzID0gaGVyZV9iaXRzO1xuICAgICAgICBsYXN0X29wID0gaGVyZV9vcDtcbiAgICAgICAgbGFzdF92YWwgPSBoZXJlX3ZhbDtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgIGhlcmUgPSBzdGF0ZS5sZW5jb2RlW2xhc3RfdmFsICtcbiAgICAgICAgICAgICAgICAgICgoaG9sZCAmICgoMSA8PCAobGFzdF9iaXRzICsgbGFzdF9vcCkpIC0gMSkpLypCSVRTKGxhc3QuYml0cyArIGxhc3Qub3ApKi8gPj4gbGFzdF9iaXRzKV07XG4gICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7XG4gICAgICAgICAgaGVyZV9vcCA9IChoZXJlID4+PiAxNikgJiAweGZmO1xuICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDB4ZmZmZjtcblxuICAgICAgICAgIGlmICgobGFzdF9iaXRzICsgaGVyZV9iaXRzKSA8PSBiaXRzKSB7IGJyZWFrOyB9XG4gICAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vL1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICB9XG4gICAgICAgIC8vLS0tIERST1BCSVRTKGxhc3QuYml0cykgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IGxhc3RfYml0cztcbiAgICAgICAgYml0cyAtPSBsYXN0X2JpdHM7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgc3RhdGUuYmFjayArPSBsYXN0X2JpdHM7XG4gICAgICB9XG4gICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAvLy0tLS8vXG4gICAgICBzdGF0ZS5iYWNrICs9IGhlcmVfYml0cztcbiAgICAgIHN0YXRlLmxlbmd0aCA9IGhlcmVfdmFsO1xuICAgICAgaWYgKGhlcmVfb3AgPT09IDApIHtcbiAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIGhlcmUudmFsID49IDB4MjAgJiYgaGVyZS52YWwgPCAweDdmID9cbiAgICAgICAgLy8gICAgICAgIFwiaW5mbGF0ZTogICAgICAgICBsaXRlcmFsICclYydcXG5cIiA6XG4gICAgICAgIC8vICAgICAgICBcImluZmxhdGU6ICAgICAgICAgbGl0ZXJhbCAweCUwMnhcXG5cIiwgaGVyZS52YWwpKTtcbiAgICAgICAgc3RhdGUubW9kZSA9IExJVDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoaGVyZV9vcCAmIDMyKSB7XG4gICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgZW5kIG9mIGJsb2NrXFxuXCIpKTtcbiAgICAgICAgc3RhdGUuYmFjayA9IC0xO1xuICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoaGVyZV9vcCAmIDY0KSB7XG4gICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgbGl0ZXJhbC9sZW5ndGggY29kZSc7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgc3RhdGUuZXh0cmEgPSBoZXJlX29wICYgMTU7XG4gICAgICBzdGF0ZS5tb2RlID0gTEVORVhUO1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgTEVORVhUOlxuICAgICAgaWYgKHN0YXRlLmV4dHJhKSB7XG4gICAgICAgIC8vPT09IE5FRURCSVRTKHN0YXRlLmV4dHJhKTtcbiAgICAgICAgbiA9IHN0YXRlLmV4dHJhO1xuICAgICAgICB3aGlsZSAoYml0cyA8IG4pIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubGVuZ3RoICs9IGhvbGQgJiAoKDEgPDwgc3RhdGUuZXh0cmEpIC0gMSkvKkJJVFMoc3RhdGUuZXh0cmEpKi87XG4gICAgICAgIC8vLS0tIERST1BCSVRTKHN0YXRlLmV4dHJhKSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gc3RhdGUuZXh0cmE7XG4gICAgICAgIGJpdHMgLT0gc3RhdGUuZXh0cmE7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgc3RhdGUuYmFjayArPSBzdGF0ZS5leHRyYTtcbiAgICAgIH1cbiAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgbGVuZ3RoICV1XFxuXCIsIHN0YXRlLmxlbmd0aCkpO1xuICAgICAgc3RhdGUud2FzID0gc3RhdGUubGVuZ3RoO1xuICAgICAgc3RhdGUubW9kZSA9IERJU1Q7XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSBESVNUOlxuICAgICAgZm9yICg7Oykge1xuICAgICAgICBoZXJlID0gc3RhdGUuZGlzdGNvZGVbaG9sZCAmICgoMSA8PCBzdGF0ZS5kaXN0Yml0cykgLSAxKV07LypCSVRTKHN0YXRlLmRpc3RiaXRzKSovXG4gICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0O1xuICAgICAgICBoZXJlX29wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDB4ZmZmZjtcblxuICAgICAgICBpZiAoKGhlcmVfYml0cykgPD0gYml0cykgeyBicmVhazsgfVxuICAgICAgICAvLy0tLSBQVUxMQllURSgpIC0tLS8vXG4gICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICBoYXZlLS07XG4gICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgIH1cbiAgICAgIGlmICgoaGVyZV9vcCAmIDB4ZjApID09PSAwKSB7XG4gICAgICAgIGxhc3RfYml0cyA9IGhlcmVfYml0cztcbiAgICAgICAgbGFzdF9vcCA9IGhlcmVfb3A7XG4gICAgICAgIGxhc3RfdmFsID0gaGVyZV92YWw7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICBoZXJlID0gc3RhdGUuZGlzdGNvZGVbbGFzdF92YWwgK1xuICAgICAgICAgICAgICAgICAgKChob2xkICYgKCgxIDw8IChsYXN0X2JpdHMgKyBsYXN0X29wKSkgLSAxKSkvKkJJVFMobGFzdC5iaXRzICsgbGFzdC5vcCkqLyA+PiBsYXN0X2JpdHMpXTtcbiAgICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDtcbiAgICAgICAgICBoZXJlX29wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgaGVyZV92YWwgPSBoZXJlICYgMHhmZmZmO1xuXG4gICAgICAgICAgaWYgKChsYXN0X2JpdHMgKyBoZXJlX2JpdHMpIDw9IGJpdHMpIHsgYnJlYWs7IH1cbiAgICAgICAgICAvLy0tLSBQVUxMQllURSgpIC0tLS8vXG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgIH1cbiAgICAgICAgLy8tLS0gRFJPUEJJVFMobGFzdC5iaXRzKSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gbGFzdF9iaXRzO1xuICAgICAgICBiaXRzIC09IGxhc3RfYml0cztcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBzdGF0ZS5iYWNrICs9IGxhc3RfYml0cztcbiAgICAgIH1cbiAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgIC8vLS0tLy9cbiAgICAgIHN0YXRlLmJhY2sgKz0gaGVyZV9iaXRzO1xuICAgICAgaWYgKGhlcmVfb3AgJiA2NCkge1xuICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIGNvZGUnO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHN0YXRlLm9mZnNldCA9IGhlcmVfdmFsO1xuICAgICAgc3RhdGUuZXh0cmEgPSAoaGVyZV9vcCkgJiAxNTtcbiAgICAgIHN0YXRlLm1vZGUgPSBESVNURVhUO1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgRElTVEVYVDpcbiAgICAgIGlmIChzdGF0ZS5leHRyYSkge1xuICAgICAgICAvLz09PSBORUVEQklUUyhzdGF0ZS5leHRyYSk7XG4gICAgICAgIG4gPSBzdGF0ZS5leHRyYTtcbiAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLm9mZnNldCArPSBob2xkICYgKCgxIDw8IHN0YXRlLmV4dHJhKSAtIDEpLypCSVRTKHN0YXRlLmV4dHJhKSovO1xuICAgICAgICAvLy0tLSBEUk9QQklUUyhzdGF0ZS5leHRyYSkgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IHN0YXRlLmV4dHJhO1xuICAgICAgICBiaXRzIC09IHN0YXRlLmV4dHJhO1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIHN0YXRlLmJhY2sgKz0gc3RhdGUuZXh0cmE7XG4gICAgICB9XG4vLyNpZmRlZiBJTkZMQVRFX1NUUklDVFxuICAgICAgaWYgKHN0YXRlLm9mZnNldCA+IHN0YXRlLmRtYXgpIHtcbiAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2snO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbi8vI2VuZGlmXG4gICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGRpc3RhbmNlICV1XFxuXCIsIHN0YXRlLm9mZnNldCkpO1xuICAgICAgc3RhdGUubW9kZSA9IE1BVENIO1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgTUFUQ0g6XG4gICAgICBpZiAobGVmdCA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgIGNvcHkgPSBfb3V0IC0gbGVmdDtcbiAgICAgIGlmIChzdGF0ZS5vZmZzZXQgPiBjb3B5KSB7ICAgICAgICAgLyogY29weSBmcm9tIHdpbmRvdyAqL1xuICAgICAgICBjb3B5ID0gc3RhdGUub2Zmc2V0IC0gY29weTtcbiAgICAgICAgaWYgKGNvcHkgPiBzdGF0ZS53aGF2ZSkge1xuICAgICAgICAgIGlmIChzdGF0ZS5zYW5lKSB7XG4gICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayc7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuLy8gKCEpIFRoaXMgYmxvY2sgaXMgZGlzYWJsZWQgaW4gemxpYiBkZWZhaWx0cyxcbi8vIGRvbid0IGVuYWJsZSBpdCBmb3IgYmluYXJ5IGNvbXBhdGliaWxpdHlcbi8vI2lmZGVmIElORkxBVEVfQUxMT1dfSU5WQUxJRF9ESVNUQU5DRV9UT09GQVJfQVJSUlxuLy8gICAgICAgICAgVHJhY2UoKHN0ZGVyciwgXCJpbmZsYXRlLmMgdG9vIGZhclxcblwiKSk7XG4vLyAgICAgICAgICBjb3B5IC09IHN0YXRlLndoYXZlO1xuLy8gICAgICAgICAgaWYgKGNvcHkgPiBzdGF0ZS5sZW5ndGgpIHsgY29weSA9IHN0YXRlLmxlbmd0aDsgfVxuLy8gICAgICAgICAgaWYgKGNvcHkgPiBsZWZ0KSB7IGNvcHkgPSBsZWZ0OyB9XG4vLyAgICAgICAgICBsZWZ0IC09IGNvcHk7XG4vLyAgICAgICAgICBzdGF0ZS5sZW5ndGggLT0gY29weTtcbi8vICAgICAgICAgIGRvIHtcbi8vICAgICAgICAgICAgb3V0cHV0W3B1dCsrXSA9IDA7XG4vLyAgICAgICAgICB9IHdoaWxlICgtLWNvcHkpO1xuLy8gICAgICAgICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgeyBzdGF0ZS5tb2RlID0gTEVOOyB9XG4vLyAgICAgICAgICBicmVhaztcbi8vI2VuZGlmXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvcHkgPiBzdGF0ZS53bmV4dCkge1xuICAgICAgICAgIGNvcHkgLT0gc3RhdGUud25leHQ7XG4gICAgICAgICAgZnJvbSA9IHN0YXRlLndzaXplIC0gY29weTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBmcm9tID0gc3RhdGUud25leHQgLSBjb3B5O1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb3B5ID4gc3RhdGUubGVuZ3RoKSB7IGNvcHkgPSBzdGF0ZS5sZW5ndGg7IH1cbiAgICAgICAgZnJvbV9zb3VyY2UgPSBzdGF0ZS53aW5kb3c7XG4gICAgICB9XG4gICAgICBlbHNlIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBjb3B5IGZyb20gb3V0cHV0ICovXG4gICAgICAgIGZyb21fc291cmNlID0gb3V0cHV0O1xuICAgICAgICBmcm9tID0gcHV0IC0gc3RhdGUub2Zmc2V0O1xuICAgICAgICBjb3B5ID0gc3RhdGUubGVuZ3RoO1xuICAgICAgfVxuICAgICAgaWYgKGNvcHkgPiBsZWZ0KSB7IGNvcHkgPSBsZWZ0OyB9XG4gICAgICBsZWZ0IC09IGNvcHk7XG4gICAgICBzdGF0ZS5sZW5ndGggLT0gY29weTtcbiAgICAgIGRvIHtcbiAgICAgICAgb3V0cHV0W3B1dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICB9IHdoaWxlICgtLWNvcHkpO1xuICAgICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgeyBzdGF0ZS5tb2RlID0gTEVOOyB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIExJVDpcbiAgICAgIGlmIChsZWZ0ID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgb3V0cHV0W3B1dCsrXSA9IHN0YXRlLmxlbmd0aDtcbiAgICAgIGxlZnQtLTtcbiAgICAgIHN0YXRlLm1vZGUgPSBMRU47XG4gICAgICBicmVhaztcbiAgICBjYXNlIENIRUNLOlxuICAgICAgaWYgKHN0YXRlLndyYXApIHtcbiAgICAgICAgLy89PT0gTkVFREJJVFMoMzIpO1xuICAgICAgICB3aGlsZSAoYml0cyA8IDMyKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIC8vIFVzZSAnfCcgaW5zZGVhZCBvZiAnKycgdG8gbWFrZSBzdXJlIHRoYXQgcmVzdWx0IGlzIHNpZ25lZFxuICAgICAgICAgIGhvbGQgfD0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIF9vdXQgLT0gbGVmdDtcbiAgICAgICAgc3RybS50b3RhbF9vdXQgKz0gX291dDtcbiAgICAgICAgc3RhdGUudG90YWwgKz0gX291dDtcbiAgICAgICAgaWYgKF9vdXQpIHtcbiAgICAgICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPVxuICAgICAgICAgICAgICAvKlVQREFURShzdGF0ZS5jaGVjaywgcHV0IC0gX291dCwgX291dCk7Ki9cbiAgICAgICAgICAgICAgKHN0YXRlLmZsYWdzID8gY3JjMzIoc3RhdGUuY2hlY2ssIG91dHB1dCwgX291dCwgcHV0IC0gX291dCkgOiBhZGxlcjMyKHN0YXRlLmNoZWNrLCBvdXRwdXQsIF9vdXQsIHB1dCAtIF9vdXQpKTtcblxuICAgICAgICB9XG4gICAgICAgIF9vdXQgPSBsZWZ0O1xuICAgICAgICAvLyBOQjogY3JjMzIgc3RvcmVkIGFzIHNpZ25lZCAzMi1iaXQgaW50LCB6c3dhcDMyIHJldHVybnMgc2lnbmVkIHRvb1xuICAgICAgICBpZiAoKHN0YXRlLmZsYWdzID8gaG9sZCA6IHpzd2FwMzIoaG9sZCkpICE9PSBzdGF0ZS5jaGVjaykge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2luY29ycmVjdCBkYXRhIGNoZWNrJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgY2hlY2sgbWF0Y2hlcyB0cmFpbGVyXFxuXCIpKTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLm1vZGUgPSBMRU5HVEg7XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSBMRU5HVEg6XG4gICAgICBpZiAoc3RhdGUud3JhcCAmJiBzdGF0ZS5mbGFncykge1xuICAgICAgICAvLz09PSBORUVEQklUUygzMik7XG4gICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgaWYgKGhvbGQgIT09IChzdGF0ZS50b3RhbCAmIDB4ZmZmZmZmZmYpKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW5jb3JyZWN0IGxlbmd0aCBjaGVjayc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgIGxlbmd0aCBtYXRjaGVzIHRyYWlsZXJcXG5cIikpO1xuICAgICAgfVxuICAgICAgc3RhdGUubW9kZSA9IERPTkU7XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSBET05FOlxuICAgICAgcmV0ID0gWl9TVFJFQU1fRU5EO1xuICAgICAgYnJlYWsgaW5mX2xlYXZlO1xuICAgIGNhc2UgQkFEOlxuICAgICAgcmV0ID0gWl9EQVRBX0VSUk9SO1xuICAgICAgYnJlYWsgaW5mX2xlYXZlO1xuICAgIGNhc2UgTUVNOlxuICAgICAgcmV0dXJuIFpfTUVNX0VSUk9SO1xuICAgIGNhc2UgU1lOQzpcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICAgIH1cbiAgfVxuXG4gIC8vIGluZl9sZWF2ZSA8LSBoZXJlIGlzIHJlYWwgcGxhY2UgZm9yIFwiZ290byBpbmZfbGVhdmVcIiwgZW11bGF0ZWQgdmlhIFwiYnJlYWsgaW5mX2xlYXZlXCJcblxuICAvKlxuICAgICBSZXR1cm4gZnJvbSBpbmZsYXRlKCksIHVwZGF0aW5nIHRoZSB0b3RhbCBjb3VudHMgYW5kIHRoZSBjaGVjayB2YWx1ZS5cbiAgICAgSWYgdGhlcmUgd2FzIG5vIHByb2dyZXNzIGR1cmluZyB0aGUgaW5mbGF0ZSgpIGNhbGwsIHJldHVybiBhIGJ1ZmZlclxuICAgICBlcnJvci4gIENhbGwgdXBkYXRld2luZG93KCkgdG8gY3JlYXRlIGFuZC9vciB1cGRhdGUgdGhlIHdpbmRvdyBzdGF0ZS5cbiAgICAgTm90ZTogYSBtZW1vcnkgZXJyb3IgZnJvbSBpbmZsYXRlKCkgaXMgbm9uLXJlY292ZXJhYmxlLlxuICAgKi9cblxuICAvLy0tLSBSRVNUT1JFKCkgLS0tXG4gIHN0cm0ubmV4dF9vdXQgPSBwdXQ7XG4gIHN0cm0uYXZhaWxfb3V0ID0gbGVmdDtcbiAgc3RybS5uZXh0X2luID0gbmV4dDtcbiAgc3RybS5hdmFpbF9pbiA9IGhhdmU7XG4gIHN0YXRlLmhvbGQgPSBob2xkO1xuICBzdGF0ZS5iaXRzID0gYml0cztcbiAgLy8tLS1cblxuICBpZiAoc3RhdGUud3NpemUgfHwgKF9vdXQgIT09IHN0cm0uYXZhaWxfb3V0ICYmIHN0YXRlLm1vZGUgPCBCQUQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAoc3RhdGUubW9kZSA8IENIRUNLIHx8IGZsdXNoICE9PSBaX0ZJTklTSCkpKSB7XG4gICAgaWYgKHVwZGF0ZXdpbmRvdyhzdHJtLCBzdHJtLm91dHB1dCwgc3RybS5uZXh0X291dCwgX291dCAtIHN0cm0uYXZhaWxfb3V0KSkge1xuICAgICAgc3RhdGUubW9kZSA9IE1FTTtcbiAgICAgIHJldHVybiBaX01FTV9FUlJPUjtcbiAgICB9XG4gIH1cbiAgX2luIC09IHN0cm0uYXZhaWxfaW47XG4gIF9vdXQgLT0gc3RybS5hdmFpbF9vdXQ7XG4gIHN0cm0udG90YWxfaW4gKz0gX2luO1xuICBzdHJtLnRvdGFsX291dCArPSBfb3V0O1xuICBzdGF0ZS50b3RhbCArPSBfb3V0O1xuICBpZiAoc3RhdGUud3JhcCAmJiBfb3V0KSB7XG4gICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gLypVUERBVEUoc3RhdGUuY2hlY2ssIHN0cm0ubmV4dF9vdXQgLSBfb3V0LCBfb3V0KTsqL1xuICAgICAgKHN0YXRlLmZsYWdzID8gY3JjMzIoc3RhdGUuY2hlY2ssIG91dHB1dCwgX291dCwgc3RybS5uZXh0X291dCAtIF9vdXQpIDogYWRsZXIzMihzdGF0ZS5jaGVjaywgb3V0cHV0LCBfb3V0LCBzdHJtLm5leHRfb3V0IC0gX291dCkpO1xuICB9XG4gIHN0cm0uZGF0YV90eXBlID0gc3RhdGUuYml0cyArIChzdGF0ZS5sYXN0ID8gNjQgOiAwKSArXG4gICAgICAgICAgICAgICAgICAgIChzdGF0ZS5tb2RlID09PSBUWVBFID8gMTI4IDogMCkgK1xuICAgICAgICAgICAgICAgICAgICAoc3RhdGUubW9kZSA9PT0gTEVOXyB8fCBzdGF0ZS5tb2RlID09PSBDT1BZXyA/IDI1NiA6IDApO1xuICBpZiAoKChfaW4gPT09IDAgJiYgX291dCA9PT0gMCkgfHwgZmx1c2ggPT09IFpfRklOSVNIKSAmJiByZXQgPT09IFpfT0spIHtcbiAgICByZXQgPSBaX0JVRl9FUlJPUjtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlRW5kKHN0cm0pIHtcblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUgLyp8fCBzdHJtLT56ZnJlZSA9PSAoZnJlZV9mdW5jKTAqLykge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIHZhciBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIGlmIChzdGF0ZS53aW5kb3cpIHtcbiAgICBzdGF0ZS53aW5kb3cgPSBudWxsO1xuICB9XG4gIHN0cm0uc3RhdGUgPSBudWxsO1xuICByZXR1cm4gWl9PSztcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZUdldEhlYWRlcihzdHJtLCBoZWFkKSB7XG4gIHZhciBzdGF0ZTtcblxuICAvKiBjaGVjayBzdGF0ZSAqL1xuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgaWYgKChzdGF0ZS53cmFwICYgMikgPT09IDApIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG5cbiAgLyogc2F2ZSBoZWFkZXIgc3RydWN0dXJlICovXG4gIHN0YXRlLmhlYWQgPSBoZWFkO1xuICBoZWFkLmRvbmUgPSBmYWxzZTtcbiAgcmV0dXJuIFpfT0s7XG59XG5cbmZ1bmN0aW9uIGluZmxhdGVTZXREaWN0aW9uYXJ5KHN0cm0sIGRpY3Rpb25hcnkpIHtcbiAgdmFyIGRpY3RMZW5ndGggPSBkaWN0aW9uYXJ5Lmxlbmd0aDtcblxuICB2YXIgc3RhdGU7XG4gIHZhciBkaWN0aWQ7XG4gIHZhciByZXQ7XG5cbiAgLyogY2hlY2sgc3RhdGUgKi9cbiAgaWYgKCFzdHJtIC8qID09IFpfTlVMTCAqLyB8fCAhc3RybS5zdGF0ZSAvKiA9PSBaX05VTEwgKi8pIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIHN0YXRlID0gc3RybS5zdGF0ZTtcblxuICBpZiAoc3RhdGUud3JhcCAhPT0gMCAmJiBzdGF0ZS5tb2RlICE9PSBESUNUKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgLyogY2hlY2sgZm9yIGNvcnJlY3QgZGljdGlvbmFyeSBpZGVudGlmaWVyICovXG4gIGlmIChzdGF0ZS5tb2RlID09PSBESUNUKSB7XG4gICAgZGljdGlkID0gMTsgLyogYWRsZXIzMigwLCBudWxsLCAwKSovXG4gICAgLyogZGljdGlkID0gYWRsZXIzMihkaWN0aWQsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgpOyAqL1xuICAgIGRpY3RpZCA9IGFkbGVyMzIoZGljdGlkLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoLCAwKTtcbiAgICBpZiAoZGljdGlkICE9PSBzdGF0ZS5jaGVjaykge1xuICAgICAgcmV0dXJuIFpfREFUQV9FUlJPUjtcbiAgICB9XG4gIH1cbiAgLyogY29weSBkaWN0aW9uYXJ5IHRvIHdpbmRvdyB1c2luZyB1cGRhdGV3aW5kb3coKSwgd2hpY2ggd2lsbCBhbWVuZCB0aGVcbiAgIGV4aXN0aW5nIGRpY3Rpb25hcnkgaWYgYXBwcm9wcmlhdGUgKi9cbiAgcmV0ID0gdXBkYXRld2luZG93KHN0cm0sIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgsIGRpY3RMZW5ndGgpO1xuICBpZiAocmV0KSB7XG4gICAgc3RhdGUubW9kZSA9IE1FTTtcbiAgICByZXR1cm4gWl9NRU1fRVJST1I7XG4gIH1cbiAgc3RhdGUuaGF2ZWRpY3QgPSAxO1xuICAvLyBUcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgIGRpY3Rpb25hcnkgc2V0XFxuXCIpKTtcbiAgcmV0dXJuIFpfT0s7XG59XG5cbmV4cG9ydHMuaW5mbGF0ZVJlc2V0ID0gaW5mbGF0ZVJlc2V0O1xuZXhwb3J0cy5pbmZsYXRlUmVzZXQyID0gaW5mbGF0ZVJlc2V0MjtcbmV4cG9ydHMuaW5mbGF0ZVJlc2V0S2VlcCA9IGluZmxhdGVSZXNldEtlZXA7XG5leHBvcnRzLmluZmxhdGVJbml0ID0gaW5mbGF0ZUluaXQ7XG5leHBvcnRzLmluZmxhdGVJbml0MiA9IGluZmxhdGVJbml0MjtcbmV4cG9ydHMuaW5mbGF0ZSA9IGluZmxhdGU7XG5leHBvcnRzLmluZmxhdGVFbmQgPSBpbmZsYXRlRW5kO1xuZXhwb3J0cy5pbmZsYXRlR2V0SGVhZGVyID0gaW5mbGF0ZUdldEhlYWRlcjtcbmV4cG9ydHMuaW5mbGF0ZVNldERpY3Rpb25hcnkgPSBpbmZsYXRlU2V0RGljdGlvbmFyeTtcbmV4cG9ydHMuaW5mbGF0ZUluZm8gPSAncGFrbyBpbmZsYXRlIChmcm9tIE5vZGVjYSBwcm9qZWN0KSc7XG5cbi8qIE5vdCBpbXBsZW1lbnRlZFxuZXhwb3J0cy5pbmZsYXRlQ29weSA9IGluZmxhdGVDb3B5O1xuZXhwb3J0cy5pbmZsYXRlR2V0RGljdGlvbmFyeSA9IGluZmxhdGVHZXREaWN0aW9uYXJ5O1xuZXhwb3J0cy5pbmZsYXRlTWFyayA9IGluZmxhdGVNYXJrO1xuZXhwb3J0cy5pbmZsYXRlUHJpbWUgPSBpbmZsYXRlUHJpbWU7XG5leHBvcnRzLmluZmxhdGVTeW5jID0gaW5mbGF0ZVN5bmM7XG5leHBvcnRzLmluZmxhdGVTeW5jUG9pbnQgPSBpbmZsYXRlU3luY1BvaW50O1xuZXhwb3J0cy5pbmZsYXRlVW5kZXJtaW5lID0gaW5mbGF0ZVVuZGVybWluZTtcbiovXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcGFrby9saWIvemxpYi9pbmZsYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAzMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cblxudmFyIFRZUEVEX09LID0gICh0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcpICYmXG4gICAgICAgICAgICAgICAgKHR5cGVvZiBVaW50MTZBcnJheSAhPT0gJ3VuZGVmaW5lZCcpICYmXG4gICAgICAgICAgICAgICAgKHR5cGVvZiBJbnQzMkFycmF5ICE9PSAndW5kZWZpbmVkJyk7XG5cblxuZXhwb3J0cy5hc3NpZ24gPSBmdW5jdGlvbiAob2JqIC8qZnJvbTEsIGZyb20yLCBmcm9tMywgLi4uKi8pIHtcbiAgdmFyIHNvdXJjZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICB3aGlsZSAoc291cmNlcy5sZW5ndGgpIHtcbiAgICB2YXIgc291cmNlID0gc291cmNlcy5zaGlmdCgpO1xuICAgIGlmICghc291cmNlKSB7IGNvbnRpbnVlOyB9XG5cbiAgICBpZiAodHlwZW9mIHNvdXJjZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3Ioc291cmNlICsgJ211c3QgYmUgbm9uLW9iamVjdCcpO1xuICAgIH1cblxuICAgIGZvciAodmFyIHAgaW4gc291cmNlKSB7XG4gICAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KHApKSB7XG4gICAgICAgIG9ialtwXSA9IHNvdXJjZVtwXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxuXG4vLyByZWR1Y2UgYnVmZmVyIHNpemUsIGF2b2lkaW5nIG1lbSBjb3B5XG5leHBvcnRzLnNocmlua0J1ZiA9IGZ1bmN0aW9uIChidWYsIHNpemUpIHtcbiAgaWYgKGJ1Zi5sZW5ndGggPT09IHNpemUpIHsgcmV0dXJuIGJ1ZjsgfVxuICBpZiAoYnVmLnN1YmFycmF5KSB7IHJldHVybiBidWYuc3ViYXJyYXkoMCwgc2l6ZSk7IH1cbiAgYnVmLmxlbmd0aCA9IHNpemU7XG4gIHJldHVybiBidWY7XG59O1xuXG5cbnZhciBmblR5cGVkID0ge1xuICBhcnJheVNldDogZnVuY3Rpb24gKGRlc3QsIHNyYywgc3JjX29mZnMsIGxlbiwgZGVzdF9vZmZzKSB7XG4gICAgaWYgKHNyYy5zdWJhcnJheSAmJiBkZXN0LnN1YmFycmF5KSB7XG4gICAgICBkZXN0LnNldChzcmMuc3ViYXJyYXkoc3JjX29mZnMsIHNyY19vZmZzICsgbGVuKSwgZGVzdF9vZmZzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gRmFsbGJhY2sgdG8gb3JkaW5hcnkgYXJyYXlcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBkZXN0W2Rlc3Rfb2ZmcyArIGldID0gc3JjW3NyY19vZmZzICsgaV07XG4gICAgfVxuICB9LFxuICAvLyBKb2luIGFycmF5IG9mIGNodW5rcyB0byBzaW5nbGUgYXJyYXkuXG4gIGZsYXR0ZW5DaHVua3M6IGZ1bmN0aW9uIChjaHVua3MpIHtcbiAgICB2YXIgaSwgbCwgbGVuLCBwb3MsIGNodW5rLCByZXN1bHQ7XG5cbiAgICAvLyBjYWxjdWxhdGUgZGF0YSBsZW5ndGhcbiAgICBsZW4gPSAwO1xuICAgIGZvciAoaSA9IDAsIGwgPSBjaHVua3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBsZW4gKz0gY2h1bmtzW2ldLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvLyBqb2luIGNodW5rc1xuICAgIHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGxlbik7XG4gICAgcG9zID0gMDtcbiAgICBmb3IgKGkgPSAwLCBsID0gY2h1bmtzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgY2h1bmsgPSBjaHVua3NbaV07XG4gICAgICByZXN1bHQuc2V0KGNodW5rLCBwb3MpO1xuICAgICAgcG9zICs9IGNodW5rLmxlbmd0aDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59O1xuXG52YXIgZm5VbnR5cGVkID0ge1xuICBhcnJheVNldDogZnVuY3Rpb24gKGRlc3QsIHNyYywgc3JjX29mZnMsIGxlbiwgZGVzdF9vZmZzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZGVzdFtkZXN0X29mZnMgKyBpXSA9IHNyY1tzcmNfb2ZmcyArIGldO1xuICAgIH1cbiAgfSxcbiAgLy8gSm9pbiBhcnJheSBvZiBjaHVua3MgdG8gc2luZ2xlIGFycmF5LlxuICBmbGF0dGVuQ2h1bmtzOiBmdW5jdGlvbiAoY2h1bmtzKSB7XG4gICAgcmV0dXJuIFtdLmNvbmNhdC5hcHBseShbXSwgY2h1bmtzKTtcbiAgfVxufTtcblxuXG4vLyBFbmFibGUvRGlzYWJsZSB0eXBlZCBhcnJheXMgdXNlLCBmb3IgdGVzdGluZ1xuLy9cbmV4cG9ydHMuc2V0VHlwZWQgPSBmdW5jdGlvbiAob24pIHtcbiAgaWYgKG9uKSB7XG4gICAgZXhwb3J0cy5CdWY4ICA9IFVpbnQ4QXJyYXk7XG4gICAgZXhwb3J0cy5CdWYxNiA9IFVpbnQxNkFycmF5O1xuICAgIGV4cG9ydHMuQnVmMzIgPSBJbnQzMkFycmF5O1xuICAgIGV4cG9ydHMuYXNzaWduKGV4cG9ydHMsIGZuVHlwZWQpO1xuICB9IGVsc2Uge1xuICAgIGV4cG9ydHMuQnVmOCAgPSBBcnJheTtcbiAgICBleHBvcnRzLkJ1ZjE2ID0gQXJyYXk7XG4gICAgZXhwb3J0cy5CdWYzMiA9IEFycmF5O1xuICAgIGV4cG9ydHMuYXNzaWduKGV4cG9ydHMsIGZuVW50eXBlZCk7XG4gIH1cbn07XG5cbmV4cG9ydHMuc2V0VHlwZWQoVFlQRURfT0spO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Bha28vbGliL3V0aWxzL2NvbW1vbi5qc1xuLy8gbW9kdWxlIGlkID0gMzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBOb3RlOiBhZGxlcjMyIHRha2VzIDEyJSBmb3IgbGV2ZWwgMCBhbmQgMiUgZm9yIGxldmVsIDYuXG4vLyBJdCBkb2Vzbid0IHdvcnRoIHRvIG1ha2UgYWRkaXRpb25hbCBvcHRpbWl6YXRpb25hIGFzIGluIG9yaWdpbmFsLlxuLy8gU21hbGwgc2l6ZSBpcyBwcmVmZXJhYmxlLlxuXG5mdW5jdGlvbiBhZGxlcjMyKGFkbGVyLCBidWYsIGxlbiwgcG9zKSB7XG4gIHZhciBzMSA9IChhZGxlciAmIDB4ZmZmZikgfDAsXG4gICAgICBzMiA9ICgoYWRsZXIgPj4+IDE2KSAmIDB4ZmZmZikgfDAsXG4gICAgICBuID0gMDtcblxuICB3aGlsZSAobGVuICE9PSAwKSB7XG4gICAgLy8gU2V0IGxpbWl0IH4gdHdpY2UgbGVzcyB0aGFuIDU1NTIsIHRvIGtlZXBcbiAgICAvLyBzMiBpbiAzMS1iaXRzLCBiZWNhdXNlIHdlIGZvcmNlIHNpZ25lZCBpbnRzLlxuICAgIC8vIGluIG90aGVyIGNhc2UgJT0gd2lsbCBmYWlsLlxuICAgIG4gPSBsZW4gPiAyMDAwID8gMjAwMCA6IGxlbjtcbiAgICBsZW4gLT0gbjtcblxuICAgIGRvIHtcbiAgICAgIHMxID0gKHMxICsgYnVmW3BvcysrXSkgfDA7XG4gICAgICBzMiA9IChzMiArIHMxKSB8MDtcbiAgICB9IHdoaWxlICgtLW4pO1xuXG4gICAgczEgJT0gNjU1MjE7XG4gICAgczIgJT0gNjU1MjE7XG4gIH1cblxuICByZXR1cm4gKHMxIHwgKHMyIDw8IDE2KSkgfDA7XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSBhZGxlcjMyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Bha28vbGliL3psaWIvYWRsZXIzMi5qc1xuLy8gbW9kdWxlIGlkID0gMzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBOb3RlOiB3ZSBjYW4ndCBnZXQgc2lnbmlmaWNhbnQgc3BlZWQgYm9vc3QgaGVyZS5cbi8vIFNvIHdyaXRlIGNvZGUgdG8gbWluaW1pemUgc2l6ZSAtIG5vIHByZWdlbmVyYXRlZCB0YWJsZXNcbi8vIGFuZCBhcnJheSB0b29scyBkZXBlbmRlbmNpZXMuXG5cblxuLy8gVXNlIG9yZGluYXJ5IGFycmF5LCBzaW5jZSB1bnR5cGVkIG1ha2VzIG5vIGJvb3N0IGhlcmVcbmZ1bmN0aW9uIG1ha2VUYWJsZSgpIHtcbiAgdmFyIGMsIHRhYmxlID0gW107XG5cbiAgZm9yICh2YXIgbiA9IDA7IG4gPCAyNTY7IG4rKykge1xuICAgIGMgPSBuO1xuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgODsgaysrKSB7XG4gICAgICBjID0gKChjICYgMSkgPyAoMHhFREI4ODMyMCBeIChjID4+PiAxKSkgOiAoYyA+Pj4gMSkpO1xuICAgIH1cbiAgICB0YWJsZVtuXSA9IGM7XG4gIH1cblxuICByZXR1cm4gdGFibGU7XG59XG5cbi8vIENyZWF0ZSB0YWJsZSBvbiBsb2FkLiBKdXN0IDI1NSBzaWduZWQgbG9uZ3MuIE5vdCBhIHByb2JsZW0uXG52YXIgY3JjVGFibGUgPSBtYWtlVGFibGUoKTtcblxuXG5mdW5jdGlvbiBjcmMzMihjcmMsIGJ1ZiwgbGVuLCBwb3MpIHtcbiAgdmFyIHQgPSBjcmNUYWJsZSxcbiAgICAgIGVuZCA9IHBvcyArIGxlbjtcblxuICBjcmMgXj0gLTE7XG5cbiAgZm9yICh2YXIgaSA9IHBvczsgaSA8IGVuZDsgaSsrKSB7XG4gICAgY3JjID0gKGNyYyA+Pj4gOCkgXiB0WyhjcmMgXiBidWZbaV0pICYgMHhGRl07XG4gIH1cblxuICByZXR1cm4gKGNyYyBeICgtMSkpOyAvLyA+Pj4gMDtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyYzMyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Bha28vbGliL3psaWIvY3JjMzIuanNcbi8vIG1vZHVsZSBpZCA9IDM1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuLy8gU2VlIHN0YXRlIGRlZnMgZnJvbSBpbmZsYXRlLmpzXG52YXIgQkFEID0gMzA7ICAgICAgIC8qIGdvdCBhIGRhdGEgZXJyb3IgLS0gcmVtYWluIGhlcmUgdW50aWwgcmVzZXQgKi9cbnZhciBUWVBFID0gMTI7ICAgICAgLyogaTogd2FpdGluZyBmb3IgdHlwZSBiaXRzLCBpbmNsdWRpbmcgbGFzdC1mbGFnIGJpdCAqL1xuXG4vKlxuICAgRGVjb2RlIGxpdGVyYWwsIGxlbmd0aCwgYW5kIGRpc3RhbmNlIGNvZGVzIGFuZCB3cml0ZSBvdXQgdGhlIHJlc3VsdGluZ1xuICAgbGl0ZXJhbCBhbmQgbWF0Y2ggYnl0ZXMgdW50aWwgZWl0aGVyIG5vdCBlbm91Z2ggaW5wdXQgb3Igb3V0cHV0IGlzXG4gICBhdmFpbGFibGUsIGFuIGVuZC1vZi1ibG9jayBpcyBlbmNvdW50ZXJlZCwgb3IgYSBkYXRhIGVycm9yIGlzIGVuY291bnRlcmVkLlxuICAgV2hlbiBsYXJnZSBlbm91Z2ggaW5wdXQgYW5kIG91dHB1dCBidWZmZXJzIGFyZSBzdXBwbGllZCB0byBpbmZsYXRlKCksIGZvclxuICAgZXhhbXBsZSwgYSAxNksgaW5wdXQgYnVmZmVyIGFuZCBhIDY0SyBvdXRwdXQgYnVmZmVyLCBtb3JlIHRoYW4gOTUlIG9mIHRoZVxuICAgaW5mbGF0ZSBleGVjdXRpb24gdGltZSBpcyBzcGVudCBpbiB0aGlzIHJvdXRpbmUuXG5cbiAgIEVudHJ5IGFzc3VtcHRpb25zOlxuXG4gICAgICAgIHN0YXRlLm1vZGUgPT09IExFTlxuICAgICAgICBzdHJtLmF2YWlsX2luID49IDZcbiAgICAgICAgc3RybS5hdmFpbF9vdXQgPj0gMjU4XG4gICAgICAgIHN0YXJ0ID49IHN0cm0uYXZhaWxfb3V0XG4gICAgICAgIHN0YXRlLmJpdHMgPCA4XG5cbiAgIE9uIHJldHVybiwgc3RhdGUubW9kZSBpcyBvbmUgb2Y6XG5cbiAgICAgICAgTEVOIC0tIHJhbiBvdXQgb2YgZW5vdWdoIG91dHB1dCBzcGFjZSBvciBlbm91Z2ggYXZhaWxhYmxlIGlucHV0XG4gICAgICAgIFRZUEUgLS0gcmVhY2hlZCBlbmQgb2YgYmxvY2sgY29kZSwgaW5mbGF0ZSgpIHRvIGludGVycHJldCBuZXh0IGJsb2NrXG4gICAgICAgIEJBRCAtLSBlcnJvciBpbiBibG9jayBkYXRhXG5cbiAgIE5vdGVzOlxuXG4gICAgLSBUaGUgbWF4aW11bSBpbnB1dCBiaXRzIHVzZWQgYnkgYSBsZW5ndGgvZGlzdGFuY2UgcGFpciBpcyAxNSBiaXRzIGZvciB0aGVcbiAgICAgIGxlbmd0aCBjb2RlLCA1IGJpdHMgZm9yIHRoZSBsZW5ndGggZXh0cmEsIDE1IGJpdHMgZm9yIHRoZSBkaXN0YW5jZSBjb2RlLFxuICAgICAgYW5kIDEzIGJpdHMgZm9yIHRoZSBkaXN0YW5jZSBleHRyYS4gIFRoaXMgdG90YWxzIDQ4IGJpdHMsIG9yIHNpeCBieXRlcy5cbiAgICAgIFRoZXJlZm9yZSBpZiBzdHJtLmF2YWlsX2luID49IDYsIHRoZW4gdGhlcmUgaXMgZW5vdWdoIGlucHV0IHRvIGF2b2lkXG4gICAgICBjaGVja2luZyBmb3IgYXZhaWxhYmxlIGlucHV0IHdoaWxlIGRlY29kaW5nLlxuXG4gICAgLSBUaGUgbWF4aW11bSBieXRlcyB0aGF0IGEgc2luZ2xlIGxlbmd0aC9kaXN0YW5jZSBwYWlyIGNhbiBvdXRwdXQgaXMgMjU4XG4gICAgICBieXRlcywgd2hpY2ggaXMgdGhlIG1heGltdW0gbGVuZ3RoIHRoYXQgY2FuIGJlIGNvZGVkLiAgaW5mbGF0ZV9mYXN0KClcbiAgICAgIHJlcXVpcmVzIHN0cm0uYXZhaWxfb3V0ID49IDI1OCBmb3IgZWFjaCBsb29wIHRvIGF2b2lkIGNoZWNraW5nIGZvclxuICAgICAgb3V0cHV0IHNwYWNlLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluZmxhdGVfZmFzdChzdHJtLCBzdGFydCkge1xuICB2YXIgc3RhdGU7XG4gIHZhciBfaW47ICAgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLmlucHV0ICovXG4gIHZhciBsYXN0OyAgICAgICAgICAgICAgICAgICAvKiBoYXZlIGVub3VnaCBpbnB1dCB3aGlsZSBpbiA8IGxhc3QgKi9cbiAgdmFyIF9vdXQ7ICAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0ub3V0cHV0ICovXG4gIHZhciBiZWc7ICAgICAgICAgICAgICAgICAgICAvKiBpbmZsYXRlKCkncyBpbml0aWFsIHN0cm0ub3V0cHV0ICovXG4gIHZhciBlbmQ7ICAgICAgICAgICAgICAgICAgICAvKiB3aGlsZSBvdXQgPCBlbmQsIGVub3VnaCBzcGFjZSBhdmFpbGFibGUgKi9cbi8vI2lmZGVmIElORkxBVEVfU1RSSUNUXG4gIHZhciBkbWF4OyAgICAgICAgICAgICAgICAgICAvKiBtYXhpbXVtIGRpc3RhbmNlIGZyb20gemxpYiBoZWFkZXIgKi9cbi8vI2VuZGlmXG4gIHZhciB3c2l6ZTsgICAgICAgICAgICAgICAgICAvKiB3aW5kb3cgc2l6ZSBvciB6ZXJvIGlmIG5vdCB1c2luZyB3aW5kb3cgKi9cbiAgdmFyIHdoYXZlOyAgICAgICAgICAgICAgICAgIC8qIHZhbGlkIGJ5dGVzIGluIHRoZSB3aW5kb3cgKi9cbiAgdmFyIHduZXh0OyAgICAgICAgICAgICAgICAgIC8qIHdpbmRvdyB3cml0ZSBpbmRleCAqL1xuICAvLyBVc2UgYHNfd2luZG93YCBpbnN0ZWFkIGB3aW5kb3dgLCBhdm9pZCBjb25mbGljdCB3aXRoIGluc3RydW1lbnRhdGlvbiB0b29sc1xuICB2YXIgc193aW5kb3c7ICAgICAgICAgICAgICAgLyogYWxsb2NhdGVkIHNsaWRpbmcgd2luZG93LCBpZiB3c2l6ZSAhPSAwICovXG4gIHZhciBob2xkOyAgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLmhvbGQgKi9cbiAgdmFyIGJpdHM7ICAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0uYml0cyAqL1xuICB2YXIgbGNvZGU7ICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5sZW5jb2RlICovXG4gIHZhciBkY29kZTsgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLmRpc3Rjb2RlICovXG4gIHZhciBsbWFzazsgICAgICAgICAgICAgICAgICAvKiBtYXNrIGZvciBmaXJzdCBsZXZlbCBvZiBsZW5ndGggY29kZXMgKi9cbiAgdmFyIGRtYXNrOyAgICAgICAgICAgICAgICAgIC8qIG1hc2sgZm9yIGZpcnN0IGxldmVsIG9mIGRpc3RhbmNlIGNvZGVzICovXG4gIHZhciBoZXJlOyAgICAgICAgICAgICAgICAgICAvKiByZXRyaWV2ZWQgdGFibGUgZW50cnkgKi9cbiAgdmFyIG9wOyAgICAgICAgICAgICAgICAgICAgIC8qIGNvZGUgYml0cywgb3BlcmF0aW9uLCBleHRyYSBiaXRzLCBvciAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogIHdpbmRvdyBwb3NpdGlvbiwgd2luZG93IGJ5dGVzIHRvIGNvcHkgKi9cbiAgdmFyIGxlbjsgICAgICAgICAgICAgICAgICAgIC8qIG1hdGNoIGxlbmd0aCwgdW51c2VkIGJ5dGVzICovXG4gIHZhciBkaXN0OyAgICAgICAgICAgICAgICAgICAvKiBtYXRjaCBkaXN0YW5jZSAqL1xuICB2YXIgZnJvbTsgICAgICAgICAgICAgICAgICAgLyogd2hlcmUgdG8gY29weSBtYXRjaCBmcm9tICovXG4gIHZhciBmcm9tX3NvdXJjZTtcblxuXG4gIHZhciBpbnB1dCwgb3V0cHV0OyAvLyBKUyBzcGVjaWZpYywgYmVjYXVzZSB3ZSBoYXZlIG5vIHBvaW50ZXJzXG5cbiAgLyogY29weSBzdGF0ZSB0byBsb2NhbCB2YXJpYWJsZXMgKi9cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICAvL2hlcmUgPSBzdGF0ZS5oZXJlO1xuICBfaW4gPSBzdHJtLm5leHRfaW47XG4gIGlucHV0ID0gc3RybS5pbnB1dDtcbiAgbGFzdCA9IF9pbiArIChzdHJtLmF2YWlsX2luIC0gNSk7XG4gIF9vdXQgPSBzdHJtLm5leHRfb3V0O1xuICBvdXRwdXQgPSBzdHJtLm91dHB1dDtcbiAgYmVnID0gX291dCAtIChzdGFydCAtIHN0cm0uYXZhaWxfb3V0KTtcbiAgZW5kID0gX291dCArIChzdHJtLmF2YWlsX291dCAtIDI1Nyk7XG4vLyNpZmRlZiBJTkZMQVRFX1NUUklDVFxuICBkbWF4ID0gc3RhdGUuZG1heDtcbi8vI2VuZGlmXG4gIHdzaXplID0gc3RhdGUud3NpemU7XG4gIHdoYXZlID0gc3RhdGUud2hhdmU7XG4gIHduZXh0ID0gc3RhdGUud25leHQ7XG4gIHNfd2luZG93ID0gc3RhdGUud2luZG93O1xuICBob2xkID0gc3RhdGUuaG9sZDtcbiAgYml0cyA9IHN0YXRlLmJpdHM7XG4gIGxjb2RlID0gc3RhdGUubGVuY29kZTtcbiAgZGNvZGUgPSBzdGF0ZS5kaXN0Y29kZTtcbiAgbG1hc2sgPSAoMSA8PCBzdGF0ZS5sZW5iaXRzKSAtIDE7XG4gIGRtYXNrID0gKDEgPDwgc3RhdGUuZGlzdGJpdHMpIC0gMTtcblxuXG4gIC8qIGRlY29kZSBsaXRlcmFscyBhbmQgbGVuZ3RoL2Rpc3RhbmNlcyB1bnRpbCBlbmQtb2YtYmxvY2sgb3Igbm90IGVub3VnaFxuICAgICBpbnB1dCBkYXRhIG9yIG91dHB1dCBzcGFjZSAqL1xuXG4gIHRvcDpcbiAgZG8ge1xuICAgIGlmIChiaXRzIDwgMTUpIHtcbiAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICBiaXRzICs9IDg7XG4gICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgYml0cyArPSA4O1xuICAgIH1cblxuICAgIGhlcmUgPSBsY29kZVtob2xkICYgbG1hc2tdO1xuXG4gICAgZG9sZW46XG4gICAgZm9yICg7OykgeyAvLyBHb3RvIGVtdWxhdGlvblxuICAgICAgb3AgPSBoZXJlID4+PiAyNC8qaGVyZS5iaXRzKi87XG4gICAgICBob2xkID4+Pj0gb3A7XG4gICAgICBiaXRzIC09IG9wO1xuICAgICAgb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZi8qaGVyZS5vcCovO1xuICAgICAgaWYgKG9wID09PSAwKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBsaXRlcmFsICovXG4gICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBoZXJlLnZhbCA+PSAweDIwICYmIGhlcmUudmFsIDwgMHg3ZiA/XG4gICAgICAgIC8vICAgICAgICBcImluZmxhdGU6ICAgICAgICAgbGl0ZXJhbCAnJWMnXFxuXCIgOlxuICAgICAgICAvLyAgICAgICAgXCJpbmZsYXRlOiAgICAgICAgIGxpdGVyYWwgMHglMDJ4XFxuXCIsIGhlcmUudmFsKSk7XG4gICAgICAgIG91dHB1dFtfb3V0KytdID0gaGVyZSAmIDB4ZmZmZi8qaGVyZS52YWwqLztcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG9wICYgMTYpIHsgICAgICAgICAgICAgICAgICAgICAvKiBsZW5ndGggYmFzZSAqL1xuICAgICAgICBsZW4gPSBoZXJlICYgMHhmZmZmLypoZXJlLnZhbCovO1xuICAgICAgICBvcCAmPSAxNTsgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgZXh0cmEgYml0cyAqL1xuICAgICAgICBpZiAob3ApIHtcbiAgICAgICAgICBpZiAoYml0cyA8IG9wKSB7XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZW4gKz0gaG9sZCAmICgoMSA8PCBvcCkgLSAxKTtcbiAgICAgICAgICBob2xkID4+Pj0gb3A7XG4gICAgICAgICAgYml0cyAtPSBvcDtcbiAgICAgICAgfVxuICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGxlbmd0aCAldVxcblwiLCBsZW4pKTtcbiAgICAgICAgaWYgKGJpdHMgPCAxNSkge1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIGhlcmUgPSBkY29kZVtob2xkICYgZG1hc2tdO1xuXG4gICAgICAgIGRvZGlzdDpcbiAgICAgICAgZm9yICg7OykgeyAvLyBnb3RvIGVtdWxhdGlvblxuICAgICAgICAgIG9wID0gaGVyZSA+Pj4gMjQvKmhlcmUuYml0cyovO1xuICAgICAgICAgIGhvbGQgPj4+PSBvcDtcbiAgICAgICAgICBiaXRzIC09IG9wO1xuICAgICAgICAgIG9wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmYvKmhlcmUub3AqLztcblxuICAgICAgICAgIGlmIChvcCAmIDE2KSB7ICAgICAgICAgICAgICAgICAgICAgIC8qIGRpc3RhbmNlIGJhc2UgKi9cbiAgICAgICAgICAgIGRpc3QgPSBoZXJlICYgMHhmZmZmLypoZXJlLnZhbCovO1xuICAgICAgICAgICAgb3AgJj0gMTU7ICAgICAgICAgICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgZXh0cmEgYml0cyAqL1xuICAgICAgICAgICAgaWYgKGJpdHMgPCBvcCkge1xuICAgICAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAgIGlmIChiaXRzIDwgb3ApIHtcbiAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGlzdCArPSBob2xkICYgKCgxIDw8IG9wKSAtIDEpO1xuLy8jaWZkZWYgSU5GTEFURV9TVFJJQ1RcbiAgICAgICAgICAgIGlmIChkaXN0ID4gZG1heCkge1xuICAgICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayc7XG4gICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICAgIGJyZWFrIHRvcDtcbiAgICAgICAgICAgIH1cbi8vI2VuZGlmXG4gICAgICAgICAgICBob2xkID4+Pj0gb3A7XG4gICAgICAgICAgICBiaXRzIC09IG9wO1xuICAgICAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBkaXN0YW5jZSAldVxcblwiLCBkaXN0KSk7XG4gICAgICAgICAgICBvcCA9IF9vdXQgLSBiZWc7ICAgICAgICAgICAgICAgIC8qIG1heCBkaXN0YW5jZSBpbiBvdXRwdXQgKi9cbiAgICAgICAgICAgIGlmIChkaXN0ID4gb3ApIHsgICAgICAgICAgICAgICAgLyogc2VlIGlmIGNvcHkgZnJvbSB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgb3AgPSBkaXN0IC0gb3A7ICAgICAgICAgICAgICAgLyogZGlzdGFuY2UgYmFjayBpbiB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgaWYgKG9wID4gd2hhdmUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuc2FuZSkge1xuICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2snO1xuICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIHRvcDtcbiAgICAgICAgICAgICAgICB9XG5cbi8vICghKSBUaGlzIGJsb2NrIGlzIGRpc2FibGVkIGluIHpsaWIgZGVmYWlsdHMsXG4vLyBkb24ndCBlbmFibGUgaXQgZm9yIGJpbmFyeSBjb21wYXRpYmlsaXR5XG4vLyNpZmRlZiBJTkZMQVRFX0FMTE9XX0lOVkFMSURfRElTVEFOQ0VfVE9PRkFSX0FSUlJcbi8vICAgICAgICAgICAgICAgIGlmIChsZW4gPD0gb3AgLSB3aGF2ZSkge1xuLy8gICAgICAgICAgICAgICAgICBkbyB7XG4vLyAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSAwO1xuLy8gICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLWxlbik7XG4vLyAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIHRvcDtcbi8vICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICAgIGxlbiAtPSBvcCAtIHdoYXZlO1xuLy8gICAgICAgICAgICAgICAgZG8ge1xuLy8gICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IDA7XG4vLyAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wID4gd2hhdmUpO1xuLy8gICAgICAgICAgICAgICAgaWYgKG9wID09PSAwKSB7XG4vLyAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDtcbi8vICAgICAgICAgICAgICAgICAgZG8ge1xuLy8gICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4vLyAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tbGVuKTtcbi8vICAgICAgICAgICAgICAgICAgY29udGludWUgdG9wO1xuLy8gICAgICAgICAgICAgICAgfVxuLy8jZW5kaWZcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmcm9tID0gMDsgLy8gd2luZG93IGluZGV4XG4gICAgICAgICAgICAgIGZyb21fc291cmNlID0gc193aW5kb3c7XG4gICAgICAgICAgICAgIGlmICh3bmV4dCA9PT0gMCkgeyAgICAgICAgICAgLyogdmVyeSBjb21tb24gY2FzZSAqL1xuICAgICAgICAgICAgICAgIGZyb20gKz0gd3NpemUgLSBvcDtcbiAgICAgICAgICAgICAgICBpZiAob3AgPCBsZW4pIHsgICAgICAgICAvKiBzb21lIGZyb20gd2luZG93ICovXG4gICAgICAgICAgICAgICAgICBsZW4gLT0gb3A7XG4gICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gc193aW5kb3dbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3ApO1xuICAgICAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0OyAgLyogcmVzdCBmcm9tIG91dHB1dCAqL1xuICAgICAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBvdXRwdXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKHduZXh0IDwgb3ApIHsgICAgICAvKiB3cmFwIGFyb3VuZCB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICBmcm9tICs9IHdzaXplICsgd25leHQgLSBvcDtcbiAgICAgICAgICAgICAgICBvcCAtPSB3bmV4dDtcbiAgICAgICAgICAgICAgICBpZiAob3AgPCBsZW4pIHsgICAgICAgICAvKiBzb21lIGZyb20gZW5kIG9mIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgICAgbGVuIC09IG9wO1xuICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IHNfd2luZG93W2Zyb20rK107XG4gICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wKTtcbiAgICAgICAgICAgICAgICAgIGZyb20gPSAwO1xuICAgICAgICAgICAgICAgICAgaWYgKHduZXh0IDwgbGVuKSB7ICAvKiBzb21lIGZyb20gc3RhcnQgb2Ygd2luZG93ICovXG4gICAgICAgICAgICAgICAgICAgIG9wID0gd25leHQ7XG4gICAgICAgICAgICAgICAgICAgIGxlbiAtPSBvcDtcbiAgICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gc193aW5kb3dbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1vcCk7XG4gICAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDsgICAgICAvKiByZXN0IGZyb20gb3V0cHV0ICovXG4gICAgICAgICAgICAgICAgICAgIGZyb21fc291cmNlID0gb3V0cHV0O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHsgICAgICAgICAgICAgICAgICAgICAgLyogY29udGlndW91cyBpbiB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICBmcm9tICs9IHduZXh0IC0gb3A7XG4gICAgICAgICAgICAgICAgaWYgKG9wIDwgbGVuKSB7ICAgICAgICAgLyogc29tZSBmcm9tIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgICAgbGVuIC09IG9wO1xuICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IHNfd2luZG93W2Zyb20rK107XG4gICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wKTtcbiAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDsgIC8qIHJlc3QgZnJvbSBvdXRwdXQgKi9cbiAgICAgICAgICAgICAgICAgIGZyb21fc291cmNlID0gb3V0cHV0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB3aGlsZSAobGVuID4gMikge1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICAgICAgICAgIGxlbiAtPSAzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChsZW4pIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgICAgICAgICAgaWYgKGxlbiA+IDEpIHtcbiAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7ICAgICAgICAgIC8qIGNvcHkgZGlyZWN0IGZyb20gb3V0cHV0ICovXG4gICAgICAgICAgICAgIGRvIHsgICAgICAgICAgICAgICAgICAgICAgICAvKiBtaW5pbXVtIGxlbmd0aCBpcyB0aHJlZSAqL1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdO1xuICAgICAgICAgICAgICAgIGxlbiAtPSAzO1xuICAgICAgICAgICAgICB9IHdoaWxlIChsZW4gPiAyKTtcbiAgICAgICAgICAgICAgaWYgKGxlbikge1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgaWYgKGxlbiA+IDEpIHtcbiAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKChvcCAmIDY0KSA9PT0gMCkgeyAgICAgICAgICAvKiAybmQgbGV2ZWwgZGlzdGFuY2UgY29kZSAqL1xuICAgICAgICAgICAgaGVyZSA9IGRjb2RlWyhoZXJlICYgMHhmZmZmKS8qaGVyZS52YWwqLyArIChob2xkICYgKCgxIDw8IG9wKSAtIDEpKV07XG4gICAgICAgICAgICBjb250aW51ZSBkb2Rpc3Q7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSBjb2RlJztcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICBicmVhayB0b3A7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7IC8vIG5lZWQgdG8gZW11bGF0ZSBnb3RvIHZpYSBcImNvbnRpbnVlXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoKG9wICYgNjQpID09PSAwKSB7ICAgICAgICAgICAgICAvKiAybmQgbGV2ZWwgbGVuZ3RoIGNvZGUgKi9cbiAgICAgICAgaGVyZSA9IGxjb2RlWyhoZXJlICYgMHhmZmZmKS8qaGVyZS52YWwqLyArIChob2xkICYgKCgxIDw8IG9wKSAtIDEpKV07XG4gICAgICAgIGNvbnRpbnVlIGRvbGVuO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAob3AgJiAzMikgeyAgICAgICAgICAgICAgICAgICAgIC8qIGVuZC1vZi1ibG9jayAqL1xuICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGVuZCBvZiBibG9ja1xcblwiKSk7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFO1xuICAgICAgICBicmVhayB0b3A7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBsaXRlcmFsL2xlbmd0aCBjb2RlJztcbiAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgYnJlYWsgdG9wO1xuICAgICAgfVxuXG4gICAgICBicmVhazsgLy8gbmVlZCB0byBlbXVsYXRlIGdvdG8gdmlhIFwiY29udGludWVcIlxuICAgIH1cbiAgfSB3aGlsZSAoX2luIDwgbGFzdCAmJiBfb3V0IDwgZW5kKTtcblxuICAvKiByZXR1cm4gdW51c2VkIGJ5dGVzIChvbiBlbnRyeSwgYml0cyA8IDgsIHNvIGluIHdvbid0IGdvIHRvbyBmYXIgYmFjaykgKi9cbiAgbGVuID0gYml0cyA+PiAzO1xuICBfaW4gLT0gbGVuO1xuICBiaXRzIC09IGxlbiA8PCAzO1xuICBob2xkICY9ICgxIDw8IGJpdHMpIC0gMTtcblxuICAvKiB1cGRhdGUgc3RhdGUgYW5kIHJldHVybiAqL1xuICBzdHJtLm5leHRfaW4gPSBfaW47XG4gIHN0cm0ubmV4dF9vdXQgPSBfb3V0O1xuICBzdHJtLmF2YWlsX2luID0gKF9pbiA8IGxhc3QgPyA1ICsgKGxhc3QgLSBfaW4pIDogNSAtIChfaW4gLSBsYXN0KSk7XG4gIHN0cm0uYXZhaWxfb3V0ID0gKF9vdXQgPCBlbmQgPyAyNTcgKyAoZW5kIC0gX291dCkgOiAyNTcgLSAoX291dCAtIGVuZCkpO1xuICBzdGF0ZS5ob2xkID0gaG9sZDtcbiAgc3RhdGUuYml0cyA9IGJpdHM7XG4gIHJldHVybjtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcGFrby9saWIvemxpYi9pbmZmYXN0LmpzXG4vLyBtb2R1bGUgaWQgPSAzNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvY29tbW9uJyk7XG5cbnZhciBNQVhCSVRTID0gMTU7XG52YXIgRU5PVUdIX0xFTlMgPSA4NTI7XG52YXIgRU5PVUdIX0RJU1RTID0gNTkyO1xuLy92YXIgRU5PVUdIID0gKEVOT1VHSF9MRU5TK0VOT1VHSF9ESVNUUyk7XG5cbnZhciBDT0RFUyA9IDA7XG52YXIgTEVOUyA9IDE7XG52YXIgRElTVFMgPSAyO1xuXG52YXIgbGJhc2UgPSBbIC8qIExlbmd0aCBjb2RlcyAyNTcuLjI4NSBiYXNlICovXG4gIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwLCAxMSwgMTMsIDE1LCAxNywgMTksIDIzLCAyNywgMzEsXG4gIDM1LCA0MywgNTEsIDU5LCA2NywgODMsIDk5LCAxMTUsIDEzMSwgMTYzLCAxOTUsIDIyNywgMjU4LCAwLCAwXG5dO1xuXG52YXIgbGV4dCA9IFsgLyogTGVuZ3RoIGNvZGVzIDI1Ny4uMjg1IGV4dHJhICovXG4gIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTcsIDE3LCAxNywgMTcsIDE4LCAxOCwgMTgsIDE4LFxuICAxOSwgMTksIDE5LCAxOSwgMjAsIDIwLCAyMCwgMjAsIDIxLCAyMSwgMjEsIDIxLCAxNiwgNzIsIDc4XG5dO1xuXG52YXIgZGJhc2UgPSBbIC8qIERpc3RhbmNlIGNvZGVzIDAuLjI5IGJhc2UgKi9cbiAgMSwgMiwgMywgNCwgNSwgNywgOSwgMTMsIDE3LCAyNSwgMzMsIDQ5LCA2NSwgOTcsIDEyOSwgMTkzLFxuICAyNTcsIDM4NSwgNTEzLCA3NjksIDEwMjUsIDE1MzcsIDIwNDksIDMwNzMsIDQwOTcsIDYxNDUsXG4gIDgxOTMsIDEyMjg5LCAxNjM4NSwgMjQ1NzcsIDAsIDBcbl07XG5cbnZhciBkZXh0ID0gWyAvKiBEaXN0YW5jZSBjb2RlcyAwLi4yOSBleHRyYSAqL1xuICAxNiwgMTYsIDE2LCAxNiwgMTcsIDE3LCAxOCwgMTgsIDE5LCAxOSwgMjAsIDIwLCAyMSwgMjEsIDIyLCAyMixcbiAgMjMsIDIzLCAyNCwgMjQsIDI1LCAyNSwgMjYsIDI2LCAyNywgMjcsXG4gIDI4LCAyOCwgMjksIDI5LCA2NCwgNjRcbl07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5mbGF0ZV90YWJsZSh0eXBlLCBsZW5zLCBsZW5zX2luZGV4LCBjb2RlcywgdGFibGUsIHRhYmxlX2luZGV4LCB3b3JrLCBvcHRzKVxue1xuICB2YXIgYml0cyA9IG9wdHMuYml0cztcbiAgICAgIC8vaGVyZSA9IG9wdHMuaGVyZTsgLyogdGFibGUgZW50cnkgZm9yIGR1cGxpY2F0aW9uICovXG5cbiAgdmFyIGxlbiA9IDA7ICAgICAgICAgICAgICAgLyogYSBjb2RlJ3MgbGVuZ3RoIGluIGJpdHMgKi9cbiAgdmFyIHN5bSA9IDA7ICAgICAgICAgICAgICAgLyogaW5kZXggb2YgY29kZSBzeW1ib2xzICovXG4gIHZhciBtaW4gPSAwLCBtYXggPSAwOyAgICAgICAgICAvKiBtaW5pbXVtIGFuZCBtYXhpbXVtIGNvZGUgbGVuZ3RocyAqL1xuICB2YXIgcm9vdCA9IDA7ICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgaW5kZXggYml0cyBmb3Igcm9vdCB0YWJsZSAqL1xuICB2YXIgY3VyciA9IDA7ICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgaW5kZXggYml0cyBmb3IgY3VycmVudCB0YWJsZSAqL1xuICB2YXIgZHJvcCA9IDA7ICAgICAgICAgICAgICAvKiBjb2RlIGJpdHMgdG8gZHJvcCBmb3Igc3ViLXRhYmxlICovXG4gIHZhciBsZWZ0ID0gMDsgICAgICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIHByZWZpeCBjb2RlcyBhdmFpbGFibGUgKi9cbiAgdmFyIHVzZWQgPSAwOyAgICAgICAgICAgICAgLyogY29kZSBlbnRyaWVzIGluIHRhYmxlIHVzZWQgKi9cbiAgdmFyIGh1ZmYgPSAwOyAgICAgICAgICAgICAgLyogSHVmZm1hbiBjb2RlICovXG4gIHZhciBpbmNyOyAgICAgICAgICAgICAgLyogZm9yIGluY3JlbWVudGluZyBjb2RlLCBpbmRleCAqL1xuICB2YXIgZmlsbDsgICAgICAgICAgICAgIC8qIGluZGV4IGZvciByZXBsaWNhdGluZyBlbnRyaWVzICovXG4gIHZhciBsb3c7ICAgICAgICAgICAgICAgLyogbG93IGJpdHMgZm9yIGN1cnJlbnQgcm9vdCBlbnRyeSAqL1xuICB2YXIgbWFzazsgICAgICAgICAgICAgIC8qIG1hc2sgZm9yIGxvdyByb290IGJpdHMgKi9cbiAgdmFyIG5leHQ7ICAgICAgICAgICAgIC8qIG5leHQgYXZhaWxhYmxlIHNwYWNlIGluIHRhYmxlICovXG4gIHZhciBiYXNlID0gbnVsbDsgICAgIC8qIGJhc2UgdmFsdWUgdGFibGUgdG8gdXNlICovXG4gIHZhciBiYXNlX2luZGV4ID0gMDtcbi8vICB2YXIgc2hvZXh0cmE7ICAgIC8qIGV4dHJhIGJpdHMgdGFibGUgdG8gdXNlICovXG4gIHZhciBlbmQ7ICAgICAgICAgICAgICAgICAgICAvKiB1c2UgYmFzZSBhbmQgZXh0cmEgZm9yIHN5bWJvbCA+IGVuZCAqL1xuICB2YXIgY291bnQgPSBuZXcgdXRpbHMuQnVmMTYoTUFYQklUUyArIDEpOyAvL1tNQVhCSVRTKzFdOyAgICAvKiBudW1iZXIgb2YgY29kZXMgb2YgZWFjaCBsZW5ndGggKi9cbiAgdmFyIG9mZnMgPSBuZXcgdXRpbHMuQnVmMTYoTUFYQklUUyArIDEpOyAvL1tNQVhCSVRTKzFdOyAgICAgLyogb2Zmc2V0cyBpbiB0YWJsZSBmb3IgZWFjaCBsZW5ndGggKi9cbiAgdmFyIGV4dHJhID0gbnVsbDtcbiAgdmFyIGV4dHJhX2luZGV4ID0gMDtcblxuICB2YXIgaGVyZV9iaXRzLCBoZXJlX29wLCBoZXJlX3ZhbDtcblxuICAvKlxuICAgUHJvY2VzcyBhIHNldCBvZiBjb2RlIGxlbmd0aHMgdG8gY3JlYXRlIGEgY2Fub25pY2FsIEh1ZmZtYW4gY29kZS4gIFRoZVxuICAgY29kZSBsZW5ndGhzIGFyZSBsZW5zWzAuLmNvZGVzLTFdLiAgRWFjaCBsZW5ndGggY29ycmVzcG9uZHMgdG8gdGhlXG4gICBzeW1ib2xzIDAuLmNvZGVzLTEuICBUaGUgSHVmZm1hbiBjb2RlIGlzIGdlbmVyYXRlZCBieSBmaXJzdCBzb3J0aW5nIHRoZVxuICAgc3ltYm9scyBieSBsZW5ndGggZnJvbSBzaG9ydCB0byBsb25nLCBhbmQgcmV0YWluaW5nIHRoZSBzeW1ib2wgb3JkZXJcbiAgIGZvciBjb2RlcyB3aXRoIGVxdWFsIGxlbmd0aHMuICBUaGVuIHRoZSBjb2RlIHN0YXJ0cyB3aXRoIGFsbCB6ZXJvIGJpdHNcbiAgIGZvciB0aGUgZmlyc3QgY29kZSBvZiB0aGUgc2hvcnRlc3QgbGVuZ3RoLCBhbmQgdGhlIGNvZGVzIGFyZSBpbnRlZ2VyXG4gICBpbmNyZW1lbnRzIGZvciB0aGUgc2FtZSBsZW5ndGgsIGFuZCB6ZXJvcyBhcmUgYXBwZW5kZWQgYXMgdGhlIGxlbmd0aFxuICAgaW5jcmVhc2VzLiAgRm9yIHRoZSBkZWZsYXRlIGZvcm1hdCwgdGhlc2UgYml0cyBhcmUgc3RvcmVkIGJhY2t3YXJkc1xuICAgZnJvbSB0aGVpciBtb3JlIG5hdHVyYWwgaW50ZWdlciBpbmNyZW1lbnQgb3JkZXJpbmcsIGFuZCBzbyB3aGVuIHRoZVxuICAgZGVjb2RpbmcgdGFibGVzIGFyZSBidWlsdCBpbiB0aGUgbGFyZ2UgbG9vcCBiZWxvdywgdGhlIGludGVnZXIgY29kZXNcbiAgIGFyZSBpbmNyZW1lbnRlZCBiYWNrd2FyZHMuXG5cbiAgIFRoaXMgcm91dGluZSBhc3N1bWVzLCBidXQgZG9lcyBub3QgY2hlY2ssIHRoYXQgYWxsIG9mIHRoZSBlbnRyaWVzIGluXG4gICBsZW5zW10gYXJlIGluIHRoZSByYW5nZSAwLi5NQVhCSVRTLiAgVGhlIGNhbGxlciBtdXN0IGFzc3VyZSB0aGlzLlxuICAgMS4uTUFYQklUUyBpcyBpbnRlcnByZXRlZCBhcyB0aGF0IGNvZGUgbGVuZ3RoLiAgemVybyBtZWFucyB0aGF0IHRoYXRcbiAgIHN5bWJvbCBkb2VzIG5vdCBvY2N1ciBpbiB0aGlzIGNvZGUuXG5cbiAgIFRoZSBjb2RlcyBhcmUgc29ydGVkIGJ5IGNvbXB1dGluZyBhIGNvdW50IG9mIGNvZGVzIGZvciBlYWNoIGxlbmd0aCxcbiAgIGNyZWF0aW5nIGZyb20gdGhhdCBhIHRhYmxlIG9mIHN0YXJ0aW5nIGluZGljZXMgZm9yIGVhY2ggbGVuZ3RoIGluIHRoZVxuICAgc29ydGVkIHRhYmxlLCBhbmQgdGhlbiBlbnRlcmluZyB0aGUgc3ltYm9scyBpbiBvcmRlciBpbiB0aGUgc29ydGVkXG4gICB0YWJsZS4gIFRoZSBzb3J0ZWQgdGFibGUgaXMgd29ya1tdLCB3aXRoIHRoYXQgc3BhY2UgYmVpbmcgcHJvdmlkZWQgYnlcbiAgIHRoZSBjYWxsZXIuXG5cbiAgIFRoZSBsZW5ndGggY291bnRzIGFyZSB1c2VkIGZvciBvdGhlciBwdXJwb3NlcyBhcyB3ZWxsLCBpLmUuIGZpbmRpbmdcbiAgIHRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIGxlbmd0aCBjb2RlcywgZGV0ZXJtaW5pbmcgaWYgdGhlcmUgYXJlIGFueVxuICAgY29kZXMgYXQgYWxsLCBjaGVja2luZyBmb3IgYSB2YWxpZCBzZXQgb2YgbGVuZ3RocywgYW5kIGxvb2tpbmcgYWhlYWRcbiAgIGF0IGxlbmd0aCBjb3VudHMgdG8gZGV0ZXJtaW5lIHN1Yi10YWJsZSBzaXplcyB3aGVuIGJ1aWxkaW5nIHRoZVxuICAgZGVjb2RpbmcgdGFibGVzLlxuICAgKi9cblxuICAvKiBhY2N1bXVsYXRlIGxlbmd0aHMgZm9yIGNvZGVzIChhc3N1bWVzIGxlbnNbXSBhbGwgaW4gMC4uTUFYQklUUykgKi9cbiAgZm9yIChsZW4gPSAwOyBsZW4gPD0gTUFYQklUUzsgbGVuKyspIHtcbiAgICBjb3VudFtsZW5dID0gMDtcbiAgfVxuICBmb3IgKHN5bSA9IDA7IHN5bSA8IGNvZGVzOyBzeW0rKykge1xuICAgIGNvdW50W2xlbnNbbGVuc19pbmRleCArIHN5bV1dKys7XG4gIH1cblxuICAvKiBib3VuZCBjb2RlIGxlbmd0aHMsIGZvcmNlIHJvb3QgdG8gYmUgd2l0aGluIGNvZGUgbGVuZ3RocyAqL1xuICByb290ID0gYml0cztcbiAgZm9yIChtYXggPSBNQVhCSVRTOyBtYXggPj0gMTsgbWF4LS0pIHtcbiAgICBpZiAoY291bnRbbWF4XSAhPT0gMCkgeyBicmVhazsgfVxuICB9XG4gIGlmIChyb290ID4gbWF4KSB7XG4gICAgcm9vdCA9IG1heDtcbiAgfVxuICBpZiAobWF4ID09PSAwKSB7ICAgICAgICAgICAgICAgICAgICAgLyogbm8gc3ltYm9scyB0byBjb2RlIGF0IGFsbCAqL1xuICAgIC8vdGFibGUub3Bbb3B0cy50YWJsZV9pbmRleF0gPSA2NDsgIC8vaGVyZS5vcCA9ICh2YXIgY2hhcik2NDsgICAgLyogaW52YWxpZCBjb2RlIG1hcmtlciAqL1xuICAgIC8vdGFibGUuYml0c1tvcHRzLnRhYmxlX2luZGV4XSA9IDE7ICAgLy9oZXJlLmJpdHMgPSAodmFyIGNoYXIpMTtcbiAgICAvL3RhYmxlLnZhbFtvcHRzLnRhYmxlX2luZGV4KytdID0gMDsgICAvL2hlcmUudmFsID0gKHZhciBzaG9ydCkwO1xuICAgIHRhYmxlW3RhYmxlX2luZGV4KytdID0gKDEgPDwgMjQpIHwgKDY0IDw8IDE2KSB8IDA7XG5cblxuICAgIC8vdGFibGUub3Bbb3B0cy50YWJsZV9pbmRleF0gPSA2NDtcbiAgICAvL3RhYmxlLmJpdHNbb3B0cy50YWJsZV9pbmRleF0gPSAxO1xuICAgIC8vdGFibGUudmFsW29wdHMudGFibGVfaW5kZXgrK10gPSAwO1xuICAgIHRhYmxlW3RhYmxlX2luZGV4KytdID0gKDEgPDwgMjQpIHwgKDY0IDw8IDE2KSB8IDA7XG5cbiAgICBvcHRzLmJpdHMgPSAxO1xuICAgIHJldHVybiAwOyAgICAgLyogbm8gc3ltYm9scywgYnV0IHdhaXQgZm9yIGRlY29kaW5nIHRvIHJlcG9ydCBlcnJvciAqL1xuICB9XG4gIGZvciAobWluID0gMTsgbWluIDwgbWF4OyBtaW4rKykge1xuICAgIGlmIChjb3VudFttaW5dICE9PSAwKSB7IGJyZWFrOyB9XG4gIH1cbiAgaWYgKHJvb3QgPCBtaW4pIHtcbiAgICByb290ID0gbWluO1xuICB9XG5cbiAgLyogY2hlY2sgZm9yIGFuIG92ZXItc3Vic2NyaWJlZCBvciBpbmNvbXBsZXRlIHNldCBvZiBsZW5ndGhzICovXG4gIGxlZnQgPSAxO1xuICBmb3IgKGxlbiA9IDE7IGxlbiA8PSBNQVhCSVRTOyBsZW4rKykge1xuICAgIGxlZnQgPDw9IDE7XG4gICAgbGVmdCAtPSBjb3VudFtsZW5dO1xuICAgIGlmIChsZWZ0IDwgMCkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH0gICAgICAgIC8qIG92ZXItc3Vic2NyaWJlZCAqL1xuICB9XG4gIGlmIChsZWZ0ID4gMCAmJiAodHlwZSA9PT0gQ09ERVMgfHwgbWF4ICE9PSAxKSkge1xuICAgIHJldHVybiAtMTsgICAgICAgICAgICAgICAgICAgICAgLyogaW5jb21wbGV0ZSBzZXQgKi9cbiAgfVxuXG4gIC8qIGdlbmVyYXRlIG9mZnNldHMgaW50byBzeW1ib2wgdGFibGUgZm9yIGVhY2ggbGVuZ3RoIGZvciBzb3J0aW5nICovXG4gIG9mZnNbMV0gPSAwO1xuICBmb3IgKGxlbiA9IDE7IGxlbiA8IE1BWEJJVFM7IGxlbisrKSB7XG4gICAgb2Zmc1tsZW4gKyAxXSA9IG9mZnNbbGVuXSArIGNvdW50W2xlbl07XG4gIH1cblxuICAvKiBzb3J0IHN5bWJvbHMgYnkgbGVuZ3RoLCBieSBzeW1ib2wgb3JkZXIgd2l0aGluIGVhY2ggbGVuZ3RoICovXG4gIGZvciAoc3ltID0gMDsgc3ltIDwgY29kZXM7IHN5bSsrKSB7XG4gICAgaWYgKGxlbnNbbGVuc19pbmRleCArIHN5bV0gIT09IDApIHtcbiAgICAgIHdvcmtbb2Zmc1tsZW5zW2xlbnNfaW5kZXggKyBzeW1dXSsrXSA9IHN5bTtcbiAgICB9XG4gIH1cblxuICAvKlxuICAgQ3JlYXRlIGFuZCBmaWxsIGluIGRlY29kaW5nIHRhYmxlcy4gIEluIHRoaXMgbG9vcCwgdGhlIHRhYmxlIGJlaW5nXG4gICBmaWxsZWQgaXMgYXQgbmV4dCBhbmQgaGFzIGN1cnIgaW5kZXggYml0cy4gIFRoZSBjb2RlIGJlaW5nIHVzZWQgaXMgaHVmZlxuICAgd2l0aCBsZW5ndGggbGVuLiAgVGhhdCBjb2RlIGlzIGNvbnZlcnRlZCB0byBhbiBpbmRleCBieSBkcm9wcGluZyBkcm9wXG4gICBiaXRzIG9mZiBvZiB0aGUgYm90dG9tLiAgRm9yIGNvZGVzIHdoZXJlIGxlbiBpcyBsZXNzIHRoYW4gZHJvcCArIGN1cnIsXG4gICB0aG9zZSB0b3AgZHJvcCArIGN1cnIgLSBsZW4gYml0cyBhcmUgaW5jcmVtZW50ZWQgdGhyb3VnaCBhbGwgdmFsdWVzIHRvXG4gICBmaWxsIHRoZSB0YWJsZSB3aXRoIHJlcGxpY2F0ZWQgZW50cmllcy5cblxuICAgcm9vdCBpcyB0aGUgbnVtYmVyIG9mIGluZGV4IGJpdHMgZm9yIHRoZSByb290IHRhYmxlLiAgV2hlbiBsZW4gZXhjZWVkc1xuICAgcm9vdCwgc3ViLXRhYmxlcyBhcmUgY3JlYXRlZCBwb2ludGVkIHRvIGJ5IHRoZSByb290IGVudHJ5IHdpdGggYW4gaW5kZXhcbiAgIG9mIHRoZSBsb3cgcm9vdCBiaXRzIG9mIGh1ZmYuICBUaGlzIGlzIHNhdmVkIGluIGxvdyB0byBjaGVjayBmb3Igd2hlbiBhXG4gICBuZXcgc3ViLXRhYmxlIHNob3VsZCBiZSBzdGFydGVkLiAgZHJvcCBpcyB6ZXJvIHdoZW4gdGhlIHJvb3QgdGFibGUgaXNcbiAgIGJlaW5nIGZpbGxlZCwgYW5kIGRyb3AgaXMgcm9vdCB3aGVuIHN1Yi10YWJsZXMgYXJlIGJlaW5nIGZpbGxlZC5cblxuICAgV2hlbiBhIG5ldyBzdWItdGFibGUgaXMgbmVlZGVkLCBpdCBpcyBuZWNlc3NhcnkgdG8gbG9vayBhaGVhZCBpbiB0aGVcbiAgIGNvZGUgbGVuZ3RocyB0byBkZXRlcm1pbmUgd2hhdCBzaXplIHN1Yi10YWJsZSBpcyBuZWVkZWQuICBUaGUgbGVuZ3RoXG4gICBjb3VudHMgYXJlIHVzZWQgZm9yIHRoaXMsIGFuZCBzbyBjb3VudFtdIGlzIGRlY3JlbWVudGVkIGFzIGNvZGVzIGFyZVxuICAgZW50ZXJlZCBpbiB0aGUgdGFibGVzLlxuXG4gICB1c2VkIGtlZXBzIHRyYWNrIG9mIGhvdyBtYW55IHRhYmxlIGVudHJpZXMgaGF2ZSBiZWVuIGFsbG9jYXRlZCBmcm9tIHRoZVxuICAgcHJvdmlkZWQgKnRhYmxlIHNwYWNlLiAgSXQgaXMgY2hlY2tlZCBmb3IgTEVOUyBhbmQgRElTVCB0YWJsZXMgYWdhaW5zdFxuICAgdGhlIGNvbnN0YW50cyBFTk9VR0hfTEVOUyBhbmQgRU5PVUdIX0RJU1RTIHRvIGd1YXJkIGFnYWluc3QgY2hhbmdlcyBpblxuICAgdGhlIGluaXRpYWwgcm9vdCB0YWJsZSBzaXplIGNvbnN0YW50cy4gIFNlZSB0aGUgY29tbWVudHMgaW4gaW5mdHJlZXMuaFxuICAgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cbiAgIHN5bSBpbmNyZW1lbnRzIHRocm91Z2ggYWxsIHN5bWJvbHMsIGFuZCB0aGUgbG9vcCB0ZXJtaW5hdGVzIHdoZW5cbiAgIGFsbCBjb2RlcyBvZiBsZW5ndGggbWF4LCBpLmUuIGFsbCBjb2RlcywgaGF2ZSBiZWVuIHByb2Nlc3NlZC4gIFRoaXNcbiAgIHJvdXRpbmUgcGVybWl0cyBpbmNvbXBsZXRlIGNvZGVzLCBzbyBhbm90aGVyIGxvb3AgYWZ0ZXIgdGhpcyBvbmUgZmlsbHNcbiAgIGluIHRoZSByZXN0IG9mIHRoZSBkZWNvZGluZyB0YWJsZXMgd2l0aCBpbnZhbGlkIGNvZGUgbWFya2Vycy5cbiAgICovXG5cbiAgLyogc2V0IHVwIGZvciBjb2RlIHR5cGUgKi9cbiAgLy8gcG9vciBtYW4gb3B0aW1pemF0aW9uIC0gdXNlIGlmLWVsc2UgaW5zdGVhZCBvZiBzd2l0Y2gsXG4gIC8vIHRvIGF2b2lkIGRlb3B0cyBpbiBvbGQgdjhcbiAgaWYgKHR5cGUgPT09IENPREVTKSB7XG4gICAgYmFzZSA9IGV4dHJhID0gd29yazsgICAgLyogZHVtbXkgdmFsdWUtLW5vdCB1c2VkICovXG4gICAgZW5kID0gMTk7XG5cbiAgfSBlbHNlIGlmICh0eXBlID09PSBMRU5TKSB7XG4gICAgYmFzZSA9IGxiYXNlO1xuICAgIGJhc2VfaW5kZXggLT0gMjU3O1xuICAgIGV4dHJhID0gbGV4dDtcbiAgICBleHRyYV9pbmRleCAtPSAyNTc7XG4gICAgZW5kID0gMjU2O1xuXG4gIH0gZWxzZSB7ICAgICAgICAgICAgICAgICAgICAvKiBESVNUUyAqL1xuICAgIGJhc2UgPSBkYmFzZTtcbiAgICBleHRyYSA9IGRleHQ7XG4gICAgZW5kID0gLTE7XG4gIH1cblxuICAvKiBpbml0aWFsaXplIG9wdHMgZm9yIGxvb3AgKi9cbiAgaHVmZiA9IDA7ICAgICAgICAgICAgICAgICAgIC8qIHN0YXJ0aW5nIGNvZGUgKi9cbiAgc3ltID0gMDsgICAgICAgICAgICAgICAgICAgIC8qIHN0YXJ0aW5nIGNvZGUgc3ltYm9sICovXG4gIGxlbiA9IG1pbjsgICAgICAgICAgICAgICAgICAvKiBzdGFydGluZyBjb2RlIGxlbmd0aCAqL1xuICBuZXh0ID0gdGFibGVfaW5kZXg7ICAgICAgICAgICAgICAvKiBjdXJyZW50IHRhYmxlIHRvIGZpbGwgaW4gKi9cbiAgY3VyciA9IHJvb3Q7ICAgICAgICAgICAgICAgIC8qIGN1cnJlbnQgdGFibGUgaW5kZXggYml0cyAqL1xuICBkcm9wID0gMDsgICAgICAgICAgICAgICAgICAgLyogY3VycmVudCBiaXRzIHRvIGRyb3AgZnJvbSBjb2RlIGZvciBpbmRleCAqL1xuICBsb3cgPSAtMTsgICAgICAgICAgICAgICAgICAgLyogdHJpZ2dlciBuZXcgc3ViLXRhYmxlIHdoZW4gbGVuID4gcm9vdCAqL1xuICB1c2VkID0gMSA8PCByb290OyAgICAgICAgICAvKiB1c2Ugcm9vdCB0YWJsZSBlbnRyaWVzICovXG4gIG1hc2sgPSB1c2VkIC0gMTsgICAgICAgICAgICAvKiBtYXNrIGZvciBjb21wYXJpbmcgbG93ICovXG5cbiAgLyogY2hlY2sgYXZhaWxhYmxlIHRhYmxlIHNwYWNlICovXG4gIGlmICgodHlwZSA9PT0gTEVOUyAmJiB1c2VkID4gRU5PVUdIX0xFTlMpIHx8XG4gICAgKHR5cGUgPT09IERJU1RTICYmIHVzZWQgPiBFTk9VR0hfRElTVFMpKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICAvKiBwcm9jZXNzIGFsbCBjb2RlcyBhbmQgbWFrZSB0YWJsZSBlbnRyaWVzICovXG4gIGZvciAoOzspIHtcbiAgICAvKiBjcmVhdGUgdGFibGUgZW50cnkgKi9cbiAgICBoZXJlX2JpdHMgPSBsZW4gLSBkcm9wO1xuICAgIGlmICh3b3JrW3N5bV0gPCBlbmQpIHtcbiAgICAgIGhlcmVfb3AgPSAwO1xuICAgICAgaGVyZV92YWwgPSB3b3JrW3N5bV07XG4gICAgfVxuICAgIGVsc2UgaWYgKHdvcmtbc3ltXSA+IGVuZCkge1xuICAgICAgaGVyZV9vcCA9IGV4dHJhW2V4dHJhX2luZGV4ICsgd29ya1tzeW1dXTtcbiAgICAgIGhlcmVfdmFsID0gYmFzZVtiYXNlX2luZGV4ICsgd29ya1tzeW1dXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBoZXJlX29wID0gMzIgKyA2NDsgICAgICAgICAvKiBlbmQgb2YgYmxvY2sgKi9cbiAgICAgIGhlcmVfdmFsID0gMDtcbiAgICB9XG5cbiAgICAvKiByZXBsaWNhdGUgZm9yIHRob3NlIGluZGljZXMgd2l0aCBsb3cgbGVuIGJpdHMgZXF1YWwgdG8gaHVmZiAqL1xuICAgIGluY3IgPSAxIDw8IChsZW4gLSBkcm9wKTtcbiAgICBmaWxsID0gMSA8PCBjdXJyO1xuICAgIG1pbiA9IGZpbGw7ICAgICAgICAgICAgICAgICAvKiBzYXZlIG9mZnNldCB0byBuZXh0IHRhYmxlICovXG4gICAgZG8ge1xuICAgICAgZmlsbCAtPSBpbmNyO1xuICAgICAgdGFibGVbbmV4dCArIChodWZmID4+IGRyb3ApICsgZmlsbF0gPSAoaGVyZV9iaXRzIDw8IDI0KSB8IChoZXJlX29wIDw8IDE2KSB8IGhlcmVfdmFsIHwwO1xuICAgIH0gd2hpbGUgKGZpbGwgIT09IDApO1xuXG4gICAgLyogYmFja3dhcmRzIGluY3JlbWVudCB0aGUgbGVuLWJpdCBjb2RlIGh1ZmYgKi9cbiAgICBpbmNyID0gMSA8PCAobGVuIC0gMSk7XG4gICAgd2hpbGUgKGh1ZmYgJiBpbmNyKSB7XG4gICAgICBpbmNyID4+PSAxO1xuICAgIH1cbiAgICBpZiAoaW5jciAhPT0gMCkge1xuICAgICAgaHVmZiAmPSBpbmNyIC0gMTtcbiAgICAgIGh1ZmYgKz0gaW5jcjtcbiAgICB9IGVsc2Uge1xuICAgICAgaHVmZiA9IDA7XG4gICAgfVxuXG4gICAgLyogZ28gdG8gbmV4dCBzeW1ib2wsIHVwZGF0ZSBjb3VudCwgbGVuICovXG4gICAgc3ltKys7XG4gICAgaWYgKC0tY291bnRbbGVuXSA9PT0gMCkge1xuICAgICAgaWYgKGxlbiA9PT0gbWF4KSB7IGJyZWFrOyB9XG4gICAgICBsZW4gPSBsZW5zW2xlbnNfaW5kZXggKyB3b3JrW3N5bV1dO1xuICAgIH1cblxuICAgIC8qIGNyZWF0ZSBuZXcgc3ViLXRhYmxlIGlmIG5lZWRlZCAqL1xuICAgIGlmIChsZW4gPiByb290ICYmIChodWZmICYgbWFzaykgIT09IGxvdykge1xuICAgICAgLyogaWYgZmlyc3QgdGltZSwgdHJhbnNpdGlvbiB0byBzdWItdGFibGVzICovXG4gICAgICBpZiAoZHJvcCA9PT0gMCkge1xuICAgICAgICBkcm9wID0gcm9vdDtcbiAgICAgIH1cblxuICAgICAgLyogaW5jcmVtZW50IHBhc3QgbGFzdCB0YWJsZSAqL1xuICAgICAgbmV4dCArPSBtaW47ICAgICAgICAgICAgLyogaGVyZSBtaW4gaXMgMSA8PCBjdXJyICovXG5cbiAgICAgIC8qIGRldGVybWluZSBsZW5ndGggb2YgbmV4dCB0YWJsZSAqL1xuICAgICAgY3VyciA9IGxlbiAtIGRyb3A7XG4gICAgICBsZWZ0ID0gMSA8PCBjdXJyO1xuICAgICAgd2hpbGUgKGN1cnIgKyBkcm9wIDwgbWF4KSB7XG4gICAgICAgIGxlZnQgLT0gY291bnRbY3VyciArIGRyb3BdO1xuICAgICAgICBpZiAobGVmdCA8PSAwKSB7IGJyZWFrOyB9XG4gICAgICAgIGN1cnIrKztcbiAgICAgICAgbGVmdCA8PD0gMTtcbiAgICAgIH1cblxuICAgICAgLyogY2hlY2sgZm9yIGVub3VnaCBzcGFjZSAqL1xuICAgICAgdXNlZCArPSAxIDw8IGN1cnI7XG4gICAgICBpZiAoKHR5cGUgPT09IExFTlMgJiYgdXNlZCA+IEVOT1VHSF9MRU5TKSB8fFxuICAgICAgICAodHlwZSA9PT0gRElTVFMgJiYgdXNlZCA+IEVOT1VHSF9ESVNUUykpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG5cbiAgICAgIC8qIHBvaW50IGVudHJ5IGluIHJvb3QgdGFibGUgdG8gc3ViLXRhYmxlICovXG4gICAgICBsb3cgPSBodWZmICYgbWFzaztcbiAgICAgIC8qdGFibGUub3BbbG93XSA9IGN1cnI7XG4gICAgICB0YWJsZS5iaXRzW2xvd10gPSByb290O1xuICAgICAgdGFibGUudmFsW2xvd10gPSBuZXh0IC0gb3B0cy50YWJsZV9pbmRleDsqL1xuICAgICAgdGFibGVbbG93XSA9IChyb290IDw8IDI0KSB8IChjdXJyIDw8IDE2KSB8IChuZXh0IC0gdGFibGVfaW5kZXgpIHwwO1xuICAgIH1cbiAgfVxuXG4gIC8qIGZpbGwgaW4gcmVtYWluaW5nIHRhYmxlIGVudHJ5IGlmIGNvZGUgaXMgaW5jb21wbGV0ZSAoZ3VhcmFudGVlZCB0byBoYXZlXG4gICBhdCBtb3N0IG9uZSByZW1haW5pbmcgZW50cnksIHNpbmNlIGlmIHRoZSBjb2RlIGlzIGluY29tcGxldGUsIHRoZVxuICAgbWF4aW11bSBjb2RlIGxlbmd0aCB0aGF0IHdhcyBhbGxvd2VkIHRvIGdldCB0aGlzIGZhciBpcyBvbmUgYml0KSAqL1xuICBpZiAoaHVmZiAhPT0gMCkge1xuICAgIC8vdGFibGUub3BbbmV4dCArIGh1ZmZdID0gNjQ7ICAgICAgICAgICAgLyogaW52YWxpZCBjb2RlIG1hcmtlciAqL1xuICAgIC8vdGFibGUuYml0c1tuZXh0ICsgaHVmZl0gPSBsZW4gLSBkcm9wO1xuICAgIC8vdGFibGUudmFsW25leHQgKyBodWZmXSA9IDA7XG4gICAgdGFibGVbbmV4dCArIGh1ZmZdID0gKChsZW4gLSBkcm9wKSA8PCAyNCkgfCAoNjQgPDwgMTYpIHwwO1xuICB9XG5cbiAgLyogc2V0IHJldHVybiBwYXJhbWV0ZXJzICovXG4gIC8vb3B0cy50YWJsZV9pbmRleCArPSB1c2VkO1xuICBvcHRzLmJpdHMgPSByb290O1xuICByZXR1cm4gMDtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcGFrby9saWIvemxpYi9pbmZ0cmVlcy5qc1xuLy8gbW9kdWxlIGlkID0gMzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gU3RyaW5nIGVuY29kZS9kZWNvZGUgaGVscGVyc1xuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5cblxuLy8gUXVpY2sgY2hlY2sgaWYgd2UgY2FuIHVzZSBmYXN0IGFycmF5IHRvIGJpbiBzdHJpbmcgY29udmVyc2lvblxuLy9cbi8vIC0gYXBwbHkoQXJyYXkpIGNhbiBmYWlsIG9uIEFuZHJvaWQgMi4yXG4vLyAtIGFwcGx5KFVpbnQ4QXJyYXkpIGNhbiBmYWlsIG9uIGlPUyA1LjEgU2FmYXJ5XG4vL1xudmFyIFNUUl9BUFBMWV9PSyA9IHRydWU7XG52YXIgU1RSX0FQUExZX1VJQV9PSyA9IHRydWU7XG5cbnRyeSB7IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgWyAwIF0pOyB9IGNhdGNoIChfXykgeyBTVFJfQVBQTFlfT0sgPSBmYWxzZTsgfVxudHJ5IHsgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDhBcnJheSgxKSk7IH0gY2F0Y2ggKF9fKSB7IFNUUl9BUFBMWV9VSUFfT0sgPSBmYWxzZTsgfVxuXG5cbi8vIFRhYmxlIHdpdGggdXRmOCBsZW5ndGhzIChjYWxjdWxhdGVkIGJ5IGZpcnN0IGJ5dGUgb2Ygc2VxdWVuY2UpXG4vLyBOb3RlLCB0aGF0IDUgJiA2LWJ5dGUgdmFsdWVzIGFuZCBzb21lIDQtYnl0ZSB2YWx1ZXMgY2FuIG5vdCBiZSByZXByZXNlbnRlZCBpbiBKUyxcbi8vIGJlY2F1c2UgbWF4IHBvc3NpYmxlIGNvZGVwb2ludCBpcyAweDEwZmZmZlxudmFyIF91dGY4bGVuID0gbmV3IHV0aWxzLkJ1ZjgoMjU2KTtcbmZvciAodmFyIHEgPSAwOyBxIDwgMjU2OyBxKyspIHtcbiAgX3V0ZjhsZW5bcV0gPSAocSA+PSAyNTIgPyA2IDogcSA+PSAyNDggPyA1IDogcSA+PSAyNDAgPyA0IDogcSA+PSAyMjQgPyAzIDogcSA+PSAxOTIgPyAyIDogMSk7XG59XG5fdXRmOGxlblsyNTRdID0gX3V0ZjhsZW5bMjU0XSA9IDE7IC8vIEludmFsaWQgc2VxdWVuY2Ugc3RhcnRcblxuXG4vLyBjb252ZXJ0IHN0cmluZyB0byBhcnJheSAodHlwZWQsIHdoZW4gcG9zc2libGUpXG5leHBvcnRzLnN0cmluZzJidWYgPSBmdW5jdGlvbiAoc3RyKSB7XG4gIHZhciBidWYsIGMsIGMyLCBtX3BvcywgaSwgc3RyX2xlbiA9IHN0ci5sZW5ndGgsIGJ1Zl9sZW4gPSAwO1xuXG4gIC8vIGNvdW50IGJpbmFyeSBzaXplXG4gIGZvciAobV9wb3MgPSAwOyBtX3BvcyA8IHN0cl9sZW47IG1fcG9zKyspIHtcbiAgICBjID0gc3RyLmNoYXJDb2RlQXQobV9wb3MpO1xuICAgIGlmICgoYyAmIDB4ZmMwMCkgPT09IDB4ZDgwMCAmJiAobV9wb3MgKyAxIDwgc3RyX2xlbikpIHtcbiAgICAgIGMyID0gc3RyLmNoYXJDb2RlQXQobV9wb3MgKyAxKTtcbiAgICAgIGlmICgoYzIgJiAweGZjMDApID09PSAweGRjMDApIHtcbiAgICAgICAgYyA9IDB4MTAwMDAgKyAoKGMgLSAweGQ4MDApIDw8IDEwKSArIChjMiAtIDB4ZGMwMCk7XG4gICAgICAgIG1fcG9zKys7XG4gICAgICB9XG4gICAgfVxuICAgIGJ1Zl9sZW4gKz0gYyA8IDB4ODAgPyAxIDogYyA8IDB4ODAwID8gMiA6IGMgPCAweDEwMDAwID8gMyA6IDQ7XG4gIH1cblxuICAvLyBhbGxvY2F0ZSBidWZmZXJcbiAgYnVmID0gbmV3IHV0aWxzLkJ1ZjgoYnVmX2xlbik7XG5cbiAgLy8gY29udmVydFxuICBmb3IgKGkgPSAwLCBtX3BvcyA9IDA7IGkgPCBidWZfbGVuOyBtX3BvcysrKSB7XG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KG1fcG9zKTtcbiAgICBpZiAoKGMgJiAweGZjMDApID09PSAweGQ4MDAgJiYgKG1fcG9zICsgMSA8IHN0cl9sZW4pKSB7XG4gICAgICBjMiA9IHN0ci5jaGFyQ29kZUF0KG1fcG9zICsgMSk7XG4gICAgICBpZiAoKGMyICYgMHhmYzAwKSA9PT0gMHhkYzAwKSB7XG4gICAgICAgIGMgPSAweDEwMDAwICsgKChjIC0gMHhkODAwKSA8PCAxMCkgKyAoYzIgLSAweGRjMDApO1xuICAgICAgICBtX3BvcysrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYyA8IDB4ODApIHtcbiAgICAgIC8qIG9uZSBieXRlICovXG4gICAgICBidWZbaSsrXSA9IGM7XG4gICAgfSBlbHNlIGlmIChjIDwgMHg4MDApIHtcbiAgICAgIC8qIHR3byBieXRlcyAqL1xuICAgICAgYnVmW2krK10gPSAweEMwIHwgKGMgPj4+IDYpO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgJiAweDNmKTtcbiAgICB9IGVsc2UgaWYgKGMgPCAweDEwMDAwKSB7XG4gICAgICAvKiB0aHJlZSBieXRlcyAqL1xuICAgICAgYnVmW2krK10gPSAweEUwIHwgKGMgPj4+IDEyKTtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjID4+PiA2ICYgMHgzZik7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyAmIDB4M2YpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvKiBmb3VyIGJ5dGVzICovXG4gICAgICBidWZbaSsrXSA9IDB4ZjAgfCAoYyA+Pj4gMTgpO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgPj4+IDEyICYgMHgzZik7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyA+Pj4gNiAmIDB4M2YpO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgJiAweDNmKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnVmO1xufTtcblxuLy8gSGVscGVyICh1c2VkIGluIDIgcGxhY2VzKVxuZnVuY3Rpb24gYnVmMmJpbnN0cmluZyhidWYsIGxlbikge1xuICAvLyB1c2UgZmFsbGJhY2sgZm9yIGJpZyBhcnJheXMgdG8gYXZvaWQgc3RhY2sgb3ZlcmZsb3dcbiAgaWYgKGxlbiA8IDY1NTM3KSB7XG4gICAgaWYgKChidWYuc3ViYXJyYXkgJiYgU1RSX0FQUExZX1VJQV9PSykgfHwgKCFidWYuc3ViYXJyYXkgJiYgU1RSX0FQUExZX09LKSkge1xuICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgdXRpbHMuc2hyaW5rQnVmKGJ1ZiwgbGVuKSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHJlc3VsdCA9ICcnO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5cbi8vIENvbnZlcnQgYnl0ZSBhcnJheSB0byBiaW5hcnkgc3RyaW5nXG5leHBvcnRzLmJ1ZjJiaW5zdHJpbmcgPSBmdW5jdGlvbiAoYnVmKSB7XG4gIHJldHVybiBidWYyYmluc3RyaW5nKGJ1ZiwgYnVmLmxlbmd0aCk7XG59O1xuXG5cbi8vIENvbnZlcnQgYmluYXJ5IHN0cmluZyAodHlwZWQsIHdoZW4gcG9zc2libGUpXG5leHBvcnRzLmJpbnN0cmluZzJidWYgPSBmdW5jdGlvbiAoc3RyKSB7XG4gIHZhciBidWYgPSBuZXcgdXRpbHMuQnVmOChzdHIubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGJ1Zi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGJ1ZltpXSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICB9XG4gIHJldHVybiBidWY7XG59O1xuXG5cbi8vIGNvbnZlcnQgYXJyYXkgdG8gc3RyaW5nXG5leHBvcnRzLmJ1ZjJzdHJpbmcgPSBmdW5jdGlvbiAoYnVmLCBtYXgpIHtcbiAgdmFyIGksIG91dCwgYywgY19sZW47XG4gIHZhciBsZW4gPSBtYXggfHwgYnVmLmxlbmd0aDtcblxuICAvLyBSZXNlcnZlIG1heCBwb3NzaWJsZSBsZW5ndGggKDIgd29yZHMgcGVyIGNoYXIpXG4gIC8vIE5COiBieSB1bmtub3duIHJlYXNvbnMsIEFycmF5IGlzIHNpZ25pZmljYW50bHkgZmFzdGVyIGZvclxuICAvLyAgICAgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseSB0aGFuIFVpbnQxNkFycmF5LlxuICB2YXIgdXRmMTZidWYgPSBuZXcgQXJyYXkobGVuICogMik7XG5cbiAgZm9yIChvdXQgPSAwLCBpID0gMDsgaSA8IGxlbjspIHtcbiAgICBjID0gYnVmW2krK107XG4gICAgLy8gcXVpY2sgcHJvY2VzcyBhc2NpaVxuICAgIGlmIChjIDwgMHg4MCkgeyB1dGYxNmJ1ZltvdXQrK10gPSBjOyBjb250aW51ZTsgfVxuXG4gICAgY19sZW4gPSBfdXRmOGxlbltjXTtcbiAgICAvLyBza2lwIDUgJiA2IGJ5dGUgY29kZXNcbiAgICBpZiAoY19sZW4gPiA0KSB7IHV0ZjE2YnVmW291dCsrXSA9IDB4ZmZmZDsgaSArPSBjX2xlbiAtIDE7IGNvbnRpbnVlOyB9XG5cbiAgICAvLyBhcHBseSBtYXNrIG9uIGZpcnN0IGJ5dGVcbiAgICBjICY9IGNfbGVuID09PSAyID8gMHgxZiA6IGNfbGVuID09PSAzID8gMHgwZiA6IDB4MDc7XG4gICAgLy8gam9pbiB0aGUgcmVzdFxuICAgIHdoaWxlIChjX2xlbiA+IDEgJiYgaSA8IGxlbikge1xuICAgICAgYyA9IChjIDw8IDYpIHwgKGJ1ZltpKytdICYgMHgzZik7XG4gICAgICBjX2xlbi0tO1xuICAgIH1cblxuICAgIC8vIHRlcm1pbmF0ZWQgYnkgZW5kIG9mIHN0cmluZz9cbiAgICBpZiAoY19sZW4gPiAxKSB7IHV0ZjE2YnVmW291dCsrXSA9IDB4ZmZmZDsgY29udGludWU7IH1cblxuICAgIGlmIChjIDwgMHgxMDAwMCkge1xuICAgICAgdXRmMTZidWZbb3V0KytdID0gYztcbiAgICB9IGVsc2Uge1xuICAgICAgYyAtPSAweDEwMDAwO1xuICAgICAgdXRmMTZidWZbb3V0KytdID0gMHhkODAwIHwgKChjID4+IDEwKSAmIDB4M2ZmKTtcbiAgICAgIHV0ZjE2YnVmW291dCsrXSA9IDB4ZGMwMCB8IChjICYgMHgzZmYpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBidWYyYmluc3RyaW5nKHV0ZjE2YnVmLCBvdXQpO1xufTtcblxuXG4vLyBDYWxjdWxhdGUgbWF4IHBvc3NpYmxlIHBvc2l0aW9uIGluIHV0ZjggYnVmZmVyLFxuLy8gdGhhdCB3aWxsIG5vdCBicmVhayBzZXF1ZW5jZS4gSWYgdGhhdCdzIG5vdCBwb3NzaWJsZVxuLy8gLSAodmVyeSBzbWFsbCBsaW1pdHMpIHJldHVybiBtYXggc2l6ZSBhcyBpcy5cbi8vXG4vLyBidWZbXSAtIHV0ZjggYnl0ZXMgYXJyYXlcbi8vIG1heCAgIC0gbGVuZ3RoIGxpbWl0IChtYW5kYXRvcnkpO1xuZXhwb3J0cy51dGY4Ym9yZGVyID0gZnVuY3Rpb24gKGJ1ZiwgbWF4KSB7XG4gIHZhciBwb3M7XG5cbiAgbWF4ID0gbWF4IHx8IGJ1Zi5sZW5ndGg7XG4gIGlmIChtYXggPiBidWYubGVuZ3RoKSB7IG1heCA9IGJ1Zi5sZW5ndGg7IH1cblxuICAvLyBnbyBiYWNrIGZyb20gbGFzdCBwb3NpdGlvbiwgdW50aWwgc3RhcnQgb2Ygc2VxdWVuY2UgZm91bmRcbiAgcG9zID0gbWF4IC0gMTtcbiAgd2hpbGUgKHBvcyA+PSAwICYmIChidWZbcG9zXSAmIDB4QzApID09PSAweDgwKSB7IHBvcy0tOyB9XG5cbiAgLy8gRnVja3VwIC0gdmVyeSBzbWFsbCBhbmQgYnJva2VuIHNlcXVlbmNlLFxuICAvLyByZXR1cm4gbWF4LCBiZWNhdXNlIHdlIHNob3VsZCByZXR1cm4gc29tZXRoaW5nIGFueXdheS5cbiAgaWYgKHBvcyA8IDApIHsgcmV0dXJuIG1heDsgfVxuXG4gIC8vIElmIHdlIGNhbWUgdG8gc3RhcnQgb2YgYnVmZmVyIC0gdGhhdCBtZWFucyB2dWZmZXIgaXMgdG9vIHNtYWxsLFxuICAvLyByZXR1cm4gbWF4IHRvby5cbiAgaWYgKHBvcyA9PT0gMCkgeyByZXR1cm4gbWF4OyB9XG5cbiAgcmV0dXJuIChwb3MgKyBfdXRmOGxlbltidWZbcG9zXV0gPiBtYXgpID8gcG9zIDogbWF4O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wYWtvL2xpYi91dGlscy9zdHJpbmdzLmpzXG4vLyBtb2R1bGUgaWQgPSAzOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgLyogQWxsb3dlZCBmbHVzaCB2YWx1ZXM7IHNlZSBkZWZsYXRlKCkgYW5kIGluZmxhdGUoKSBiZWxvdyBmb3IgZGV0YWlscyAqL1xuICBaX05PX0ZMVVNIOiAgICAgICAgIDAsXG4gIFpfUEFSVElBTF9GTFVTSDogICAgMSxcbiAgWl9TWU5DX0ZMVVNIOiAgICAgICAyLFxuICBaX0ZVTExfRkxVU0g6ICAgICAgIDMsXG4gIFpfRklOSVNIOiAgICAgICAgICAgNCxcbiAgWl9CTE9DSzogICAgICAgICAgICA1LFxuICBaX1RSRUVTOiAgICAgICAgICAgIDYsXG5cbiAgLyogUmV0dXJuIGNvZGVzIGZvciB0aGUgY29tcHJlc3Npb24vZGVjb21wcmVzc2lvbiBmdW5jdGlvbnMuIE5lZ2F0aXZlIHZhbHVlc1xuICAqIGFyZSBlcnJvcnMsIHBvc2l0aXZlIHZhbHVlcyBhcmUgdXNlZCBmb3Igc3BlY2lhbCBidXQgbm9ybWFsIGV2ZW50cy5cbiAgKi9cbiAgWl9PSzogICAgICAgICAgICAgICAwLFxuICBaX1NUUkVBTV9FTkQ6ICAgICAgIDEsXG4gIFpfTkVFRF9ESUNUOiAgICAgICAgMixcbiAgWl9FUlJOTzogICAgICAgICAgIC0xLFxuICBaX1NUUkVBTV9FUlJPUjogICAgLTIsXG4gIFpfREFUQV9FUlJPUjogICAgICAtMyxcbiAgLy9aX01FTV9FUlJPUjogICAgIC00LFxuICBaX0JVRl9FUlJPUjogICAgICAgLTUsXG4gIC8vWl9WRVJTSU9OX0VSUk9SOiAtNixcblxuICAvKiBjb21wcmVzc2lvbiBsZXZlbHMgKi9cbiAgWl9OT19DT01QUkVTU0lPTjogICAgICAgICAwLFxuICBaX0JFU1RfU1BFRUQ6ICAgICAgICAgICAgIDEsXG4gIFpfQkVTVF9DT01QUkVTU0lPTjogICAgICAgOSxcbiAgWl9ERUZBVUxUX0NPTVBSRVNTSU9OOiAgIC0xLFxuXG5cbiAgWl9GSUxURVJFRDogICAgICAgICAgICAgICAxLFxuICBaX0hVRkZNQU5fT05MWTogICAgICAgICAgIDIsXG4gIFpfUkxFOiAgICAgICAgICAgICAgICAgICAgMyxcbiAgWl9GSVhFRDogICAgICAgICAgICAgICAgICA0LFxuICBaX0RFRkFVTFRfU1RSQVRFR1k6ICAgICAgIDAsXG5cbiAgLyogUG9zc2libGUgdmFsdWVzIG9mIHRoZSBkYXRhX3R5cGUgZmllbGQgKHRob3VnaCBzZWUgaW5mbGF0ZSgpKSAqL1xuICBaX0JJTkFSWTogICAgICAgICAgICAgICAgIDAsXG4gIFpfVEVYVDogICAgICAgICAgICAgICAgICAgMSxcbiAgLy9aX0FTQ0lJOiAgICAgICAgICAgICAgICAxLCAvLyA9IFpfVEVYVCAoZGVwcmVjYXRlZClcbiAgWl9VTktOT1dOOiAgICAgICAgICAgICAgICAyLFxuXG4gIC8qIFRoZSBkZWZsYXRlIGNvbXByZXNzaW9uIG1ldGhvZCAqL1xuICBaX0RFRkxBVEVEOiAgICAgICAgICAgICAgIDhcbiAgLy9aX05VTEw6ICAgICAgICAgICAgICAgICBudWxsIC8vIFVzZSAtMSBvciBudWxsIGlubGluZSwgZGVwZW5kaW5nIG9uIHZhciB0eXBlXG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Bha28vbGliL3psaWIvY29uc3RhbnRzLmpzXG4vLyBtb2R1bGUgaWQgPSAzOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAyOiAgICAgICduZWVkIGRpY3Rpb25hcnknLCAgICAgLyogWl9ORUVEX0RJQ1QgICAgICAgMiAgKi9cbiAgMTogICAgICAnc3RyZWFtIGVuZCcsICAgICAgICAgIC8qIFpfU1RSRUFNX0VORCAgICAgIDEgICovXG4gIDA6ICAgICAgJycsICAgICAgICAgICAgICAgICAgICAvKiBaX09LICAgICAgICAgICAgICAwICAqL1xuICAnLTEnOiAgICdmaWxlIGVycm9yJywgICAgICAgICAgLyogWl9FUlJOTyAgICAgICAgICgtMSkgKi9cbiAgJy0yJzogICAnc3RyZWFtIGVycm9yJywgICAgICAgIC8qIFpfU1RSRUFNX0VSUk9SICAoLTIpICovXG4gICctMyc6ICAgJ2RhdGEgZXJyb3InLCAgICAgICAgICAvKiBaX0RBVEFfRVJST1IgICAgKC0zKSAqL1xuICAnLTQnOiAgICdpbnN1ZmZpY2llbnQgbWVtb3J5JywgLyogWl9NRU1fRVJST1IgICAgICgtNCkgKi9cbiAgJy01JzogICAnYnVmZmVyIGVycm9yJywgICAgICAgIC8qIFpfQlVGX0VSUk9SICAgICAoLTUpICovXG4gICctNic6ICAgJ2luY29tcGF0aWJsZSB2ZXJzaW9uJyAvKiBaX1ZFUlNJT05fRVJST1IgKC02KSAqL1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wYWtvL2xpYi96bGliL21lc3NhZ2VzLmpzXG4vLyBtb2R1bGUgaWQgPSA0MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cblxuZnVuY3Rpb24gWlN0cmVhbSgpIHtcbiAgLyogbmV4dCBpbnB1dCBieXRlICovXG4gIHRoaXMuaW5wdXQgPSBudWxsOyAvLyBKUyBzcGVjaWZpYywgYmVjYXVzZSB3ZSBoYXZlIG5vIHBvaW50ZXJzXG4gIHRoaXMubmV4dF9pbiA9IDA7XG4gIC8qIG51bWJlciBvZiBieXRlcyBhdmFpbGFibGUgYXQgaW5wdXQgKi9cbiAgdGhpcy5hdmFpbF9pbiA9IDA7XG4gIC8qIHRvdGFsIG51bWJlciBvZiBpbnB1dCBieXRlcyByZWFkIHNvIGZhciAqL1xuICB0aGlzLnRvdGFsX2luID0gMDtcbiAgLyogbmV4dCBvdXRwdXQgYnl0ZSBzaG91bGQgYmUgcHV0IHRoZXJlICovXG4gIHRoaXMub3V0cHV0ID0gbnVsbDsgLy8gSlMgc3BlY2lmaWMsIGJlY2F1c2Ugd2UgaGF2ZSBubyBwb2ludGVyc1xuICB0aGlzLm5leHRfb3V0ID0gMDtcbiAgLyogcmVtYWluaW5nIGZyZWUgc3BhY2UgYXQgb3V0cHV0ICovXG4gIHRoaXMuYXZhaWxfb3V0ID0gMDtcbiAgLyogdG90YWwgbnVtYmVyIG9mIGJ5dGVzIG91dHB1dCBzbyBmYXIgKi9cbiAgdGhpcy50b3RhbF9vdXQgPSAwO1xuICAvKiBsYXN0IGVycm9yIG1lc3NhZ2UsIE5VTEwgaWYgbm8gZXJyb3IgKi9cbiAgdGhpcy5tc2cgPSAnJy8qWl9OVUxMKi87XG4gIC8qIG5vdCB2aXNpYmxlIGJ5IGFwcGxpY2F0aW9ucyAqL1xuICB0aGlzLnN0YXRlID0gbnVsbDtcbiAgLyogYmVzdCBndWVzcyBhYm91dCB0aGUgZGF0YSB0eXBlOiBiaW5hcnkgb3IgdGV4dCAqL1xuICB0aGlzLmRhdGFfdHlwZSA9IDIvKlpfVU5LTk9XTiovO1xuICAvKiBhZGxlcjMyIHZhbHVlIG9mIHRoZSB1bmNvbXByZXNzZWQgZGF0YSAqL1xuICB0aGlzLmFkbGVyID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBaU3RyZWFtO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Bha28vbGliL3psaWIvenN0cmVhbS5qc1xuLy8gbW9kdWxlIGlkID0gNDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbmZ1bmN0aW9uIEdaaGVhZGVyKCkge1xuICAvKiB0cnVlIGlmIGNvbXByZXNzZWQgZGF0YSBiZWxpZXZlZCB0byBiZSB0ZXh0ICovXG4gIHRoaXMudGV4dCAgICAgICA9IDA7XG4gIC8qIG1vZGlmaWNhdGlvbiB0aW1lICovXG4gIHRoaXMudGltZSAgICAgICA9IDA7XG4gIC8qIGV4dHJhIGZsYWdzIChub3QgdXNlZCB3aGVuIHdyaXRpbmcgYSBnemlwIGZpbGUpICovXG4gIHRoaXMueGZsYWdzICAgICA9IDA7XG4gIC8qIG9wZXJhdGluZyBzeXN0ZW0gKi9cbiAgdGhpcy5vcyAgICAgICAgID0gMDtcbiAgLyogcG9pbnRlciB0byBleHRyYSBmaWVsZCBvciBaX05VTEwgaWYgbm9uZSAqL1xuICB0aGlzLmV4dHJhICAgICAgPSBudWxsO1xuICAvKiBleHRyYSBmaWVsZCBsZW5ndGggKHZhbGlkIGlmIGV4dHJhICE9IFpfTlVMTCkgKi9cbiAgdGhpcy5leHRyYV9sZW4gID0gMDsgLy8gQWN0dWFsbHksIHdlIGRvbid0IG5lZWQgaXQgaW4gSlMsXG4gICAgICAgICAgICAgICAgICAgICAgIC8vIGJ1dCBsZWF2ZSBmb3IgZmV3IGNvZGUgbW9kaWZpY2F0aW9uc1xuXG4gIC8vXG4gIC8vIFNldHVwIGxpbWl0cyBpcyBub3QgbmVjZXNzYXJ5IGJlY2F1c2UgaW4ganMgd2Ugc2hvdWxkIG5vdCBwcmVhbGxvY2F0ZSBtZW1vcnlcbiAgLy8gZm9yIGluZmxhdGUgdXNlIGNvbnN0YW50IGxpbWl0IGluIDY1NTM2IGJ5dGVzXG4gIC8vXG5cbiAgLyogc3BhY2UgYXQgZXh0cmEgKG9ubHkgd2hlbiByZWFkaW5nIGhlYWRlcikgKi9cbiAgLy8gdGhpcy5leHRyYV9tYXggID0gMDtcbiAgLyogcG9pbnRlciB0byB6ZXJvLXRlcm1pbmF0ZWQgZmlsZSBuYW1lIG9yIFpfTlVMTCAqL1xuICB0aGlzLm5hbWUgICAgICAgPSAnJztcbiAgLyogc3BhY2UgYXQgbmFtZSAob25seSB3aGVuIHJlYWRpbmcgaGVhZGVyKSAqL1xuICAvLyB0aGlzLm5hbWVfbWF4ICAgPSAwO1xuICAvKiBwb2ludGVyIHRvIHplcm8tdGVybWluYXRlZCBjb21tZW50IG9yIFpfTlVMTCAqL1xuICB0aGlzLmNvbW1lbnQgICAgPSAnJztcbiAgLyogc3BhY2UgYXQgY29tbWVudCAob25seSB3aGVuIHJlYWRpbmcgaGVhZGVyKSAqL1xuICAvLyB0aGlzLmNvbW1fbWF4ICAgPSAwO1xuICAvKiB0cnVlIGlmIHRoZXJlIHdhcyBvciB3aWxsIGJlIGEgaGVhZGVyIGNyYyAqL1xuICB0aGlzLmhjcmMgICAgICAgPSAwO1xuICAvKiB0cnVlIHdoZW4gZG9uZSByZWFkaW5nIGd6aXAgaGVhZGVyIChub3QgdXNlZCB3aGVuIHdyaXRpbmcgYSBnemlwIGZpbGUpICovXG4gIHRoaXMuZG9uZSAgICAgICA9IGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEdaaGVhZGVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Bha28vbGliL3psaWIvZ3poZWFkZXIuanNcbi8vIG1vZHVsZSBpZCA9IDQyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IENvbnRhaW5lciB9IGZyb20gXCJpbnZlcnNpZnlcIjtcbmltcG9ydCB7IEdpdFNlcnZpY2UgfSBmcm9tIFwiLi4vc2VydmljZS9HaXRcIjtcbmltcG9ydCB7IE1lc3NhZ2VzU2VydmljZSB9IGZyb20gXCIuLi9zZXJ2aWNlL01lc3NhZ2VzXCI7XG5pbXBvcnQgeyBGaWxlc3lzdGVtU2VydmljZSB9IGZyb20gXCIuLi9zZXJ2aWNlL0ZpbGVzeXN0ZW1cIjtcbmltcG9ydCBSZWFjdCwgeyB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgU2V0dXAgfSBmcm9tIFwiLi4vY29tcG9uZW50cy9TZXR1cFwiO1xuaW1wb3J0IHsgUm91dGVyUHJvdmlkZXIgfSBmcm9tIFwiLi4vY29udGV4dC9Sb3V0ZXJcIjtcbmltcG9ydCB7IE1lbW9yeVJvdXRlciB9IGZyb20gXCJyZWFjdC1yb3V0ZXJcIjtcbmltcG9ydCB7IFJvdXRlLCBTd2l0Y2ggfSBmcm9tIFwicmVhY3Qtcm91dGVyLWRvbVwiO1xuaW1wb3J0IHsgR2xvYmFsU3RhdGVQcm92aWRlciB9IGZyb20gXCIuLi9jb250ZXh0L0dsb2JhbFN0YXRlXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBQb3B1cFJvb3QoKSB7XG5cdHJldHVybiAoXG5cdFx0PGRpdj5Qb3BVcDwvZGl2PlxuXHQpO1xufVxuIiwiaW1wb3J0IFwicmVmbGVjdC1tZXRhZGF0YVwiO1xuaW1wb3J0IFJlYWN0RE9NIGZyb20gXCJyZWFjdC1kb21cIjtcbmltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcblxuaW1wb3J0IHsgUG9wdXBSb290IH0gZnJvbSBcIi4uL2NvbXBvbmVudHMvUG9wdXBSb290XCI7XG5cblJlYWN0RE9NLnJlbmRlcig8UG9wdXBSb290IC8+LCBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYXBwJykpO1xuXG4iLCJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG4iXSwic291cmNlUm9vdCI6IiJ9